um bloco de disco diferente, de modo que a estimativa de custo (pior caso) √© C S6 a = x + 1 + s . O 1 adicional √© levado em conta para o bloco de disco que cont√©m os ponteiros de registro ap√≥s o √≠ndice ser pesquisado (ver Figura 18.5). Se a condi√ß√£o de compara√ß√£o for &gt; &gt;= &lt; , , ou &lt;= e  metade dos registros de arquivo forem considerados para satisfazer a condi√ß√£o, ent√£o (muito aproximadamente) metade dos blocos de √≠ndice de primeiro n√≠vel s√£o acessados, mais metade dos registros de arquivo por meio do √≠ndice. A estimativa de custo para este caso, de maneira aproximada, √© C S6 b = x + ( b I 1 /2) + ( r /2). O fator  /2 pode ser refinado se existirem r melhores estimativas de seletividade por meio de um histograma. O √∫ltimo m√©todo C S6 b pode ser muito dispendioso.

- ¬Ñ S7 - Sele√ß√£o conjuntiva. Podemos usar S1 ou um dos m√©todos de S2 a S6 j√° discutidos. Nesse √∫ltimo caso, usamos uma condi√ß√£o para recuperar os registros e depois verificamos nos buffers da mem√≥ria principal se cada registro recuperado satisfaz as condi√ß√µes restantes na conjun√ß√£o. Se existirem v√°rios √≠ndices, a pesquisa de cada √≠ndice pode produzir um conjunto de ponteiros de registro (ids de registro) nos buffers da mem√≥ria principal. A interse√ß√£o dos conjuntos de ponteiros de registro (indicados em S9) pode ser calculada na mem√≥ria principal e, ent√£o, os registros resultantes s√£o lidos com base em seus ids de registro.
- ¬Ñ S8  -  Sele√ß√£o  conjuntiva  usando  um  √≠ndice composto. O mesmo que S3 , S5 ou S6 a a , dependendo do tipo de √≠ndice.

Exemplo de uso das fun√ß√µes de custo. Em um otimizador de consulta, √© comum enumerar as diversas estrat√©gias poss√≠veis para execu√ß√£o de uma consulta e  estimar seus custos para diferentes est√°gios. Uma t√©cnica  de  otimiza√ß√£o,  como  a  programa√ß√£o  din√¢mica, pode ser usada para encontrar a estimativa de custo ideal (menor) com efici√™ncia, sem ter de considerar  todas  as  estrat√©gias  de  execu√ß√£o  poss√≠veis. N√£o discutimos  os  algoritmos  de  otimiza√ß√£o  aqui; em vez disso, usamos um exemplo simples para ilustrar como as estimativas de custo podem ser usadas. Suponha que o arquivo FUNCIONARIO da Figura 3.5 tenha r F = 10.000  registros  armazenados  em b F = 2.000 blocos de disco com fator de bloco bfr F = 5 registros/bloco e os seguintes caminhos de acesso:

- 1. Um √≠ndice de agrupamento em Salario, com n√≠veis x Salario = 3  e  cardinalidade  de  sele√ß√£o m√©dia s Salario = 20.  (Isso  corresponde  a  uma seletividade de sl Salario = 0,002).
- 2. Um √≠ndice secund√°rio em um atributo chave Cpf , com x Cpf = 4 ( s Cpf = 1, sl Cpf = 0,0001).
- 3. Um √≠ndice secund√°rio no atributo n√£o chave Dnr , com x Dnr = 2 e blocos de √≠ndice de primeiro n√≠vel b I 1 Dnr = 4. Existem d Dnr = 125 valores distintospara Dnr , de modo que a seletividade de Dnr √© sl Dnr = (1/ d Dnr ) = 0,008, e a cardinalidade de sele√ß√£o √© s Dnr = ( r F * sl Dnr ) = ( r F / d Dnr ) = 80.
- 4. Um √≠ndice secund√°rio em Sexo, com x Sexo = 1. Existem d Sexo = 2  valores  para  o  atributo Sexo , de modo que a cardinalidade de sele√ß√£o m√©dia √© s Sexo = ( r F / d Sexo ) = 5.000. (Observe que, neste caso, um histograma que d√° a porcentagem dos funcion√°rios do sexo masculino e feminino pode ser √∫til, a menos que eles sejam aproximadamente iguais.)

Ilustramos  o  uso  das  fun√ß√µes  de  custo  com  os seguintes exemplos:

<!-- formula-not-decoded -->

O custo da op√ß√£o de for√ßa bruta (pesquisa linear ou varredura de arquivo) S1 ser√° estimado como C S1 a = b F = 2.000 (para uma sele√ß√£o em um atributo n√£o chave) ou C S1 b = ( b F /2) = 1.000 (custo m√©dio para uma sele√ß√£o em um atributo chave). Para OP1 , podemos usar o m√©todo S 1 ou o m√©todo S 6 ; a estimativa a de custo para S 6 a √© C S6 a = x Cpf + 1 = 4 + 1 = 5, e ele √© escolhido em rela√ß√£o ao m√©todo S 1, cujo custo m√©dio √© C S1 b = 1000. Para OP2 , podemos usar ou o m√©todo S 1 (com custo estimado C S1 a = 2.000) ou o m√©todo S6 b (com custo estimado C S6 b = x Dnr + ( b I 1 Dnr /2) + ( r F /2) = 2 + (4/2) + (10.000/2) = 5.004), de modo que escolhemos  a  t√©cnica  de  pesquisa  linear  para OP2 . Para OP3 , podemos utilizar o m√©todo S 1 (com custo estimado C S1 a = 2.000) ou o m√©todo S 6  (com custo a estimado C S6 a = x Dnr + s Dnr = 2 + 80 = 82), de modo que escolhemos o m√©todo S 6 . a

Finalmente, considere OP4, que tem uma condi√ß√£o de sele√ß√£o conjuntiva. Precisamos estimar o custo de usar qualquer um dos tr√™s componentes da condi√ß√£o de sele√ß√£o para recuperar os registros, mais a t√©cnica de pesquisa linear. A √∫ltima gera a estimativa de custo C S1 a = 2.000. O uso da condi√ß√£o ( Dnr = 5) primeiro gera a estimativa de custo C S6 a = 82. O uso da condi√ß√£o ( Salario &gt; 30.000) primeiro gera a estimativa de custo C S4 = x Salario + ( b F /2) = 3 + (2.000/2) = 1.003.  O  uso  da  condi√ß√£o ( Sexo = 'F')  primeiro gera a estimativa de custo C S6a = x Sexo + s Sexo = 1 + 5.000 = 5.001. O otimizador, ent√£o, escolheria o m√©-

todo S 6  no √≠ndice secund√°rio em a Dnr ,  pois ele tem a menor estimativa de custo. A condi√ß√£o ( Dnr = 5) serve para recuperar os registros, e a parte restante da condi√ß√£o conjuntiva ( Salario &gt; 30.000 AND Sexo = 'F') √© verificada para cada registro selecionado depois que ele for recuperado para a mem√≥ria. Apenas os registros que satisfazem essas condi√ß√µes adicionais s√£o inclu√≠dos no resultado da opera√ß√£o.

## 19.8.4 Exemplos de fun√ß√µes de custo para JUN√ß√£o

Para desenvolver fun√ß√µes de custo razoavelmente precisas para opera√ß√µes JUN√á√ÉO , precisamos ter uma estimativa do tamanho (n√∫mero de tuplas) do arquivo resultante ap√≥s a opera√ß√µes JUN√á√ÉO . Isso costuma ser mantido como uma raz√£o entre o tamanho (n√∫mero de tuplas) do arquivo de jun√ß√£o resultante e o tamanho do arquivo de PRODUTO CARTESIANO , se ambos forem aplicados aos mesmos arquivos de entrada, e √© chamado de seletividade de jun√ß√£o ( js ). Se indicarmos o n√∫mero de tuplas de uma rela√ß√£o R como | R |, temos:

<!-- formula-not-decoded -->

Se n√£o houver condi√ß√£o de jun√ß√£o  , ent√£o c js = 1 e a jun√ß√£o √© igual ao PRODUTO CARTESIANO . Se nenhuma tupla das rela√ß√µes satisfizer a condi√ß√£o de jun√ß√£o, ent√£o js = 0.  Em geral, 0 ‚â§ js ‚â§ 1.  Para  uma jun√ß√£o em que a condi√ß√£o c √©  uma  compara√ß√£o de igualdade R.A = S.B , chegamos aos dois casos especiais a seguir:

- 1. Se A √© uma chave de R , ent√£o |( R /triangleleft /triangleright c S )| ‚â§ | S |, de modo que js ‚â§ (1/| R |). Isso porque cada registro no arquivo S ser√° juntado com no m√°ximo um registro no arquivo R , pois A √© uma chave de R . Um caso especial dessa condi√ß√£o √© quando o atributo B √© uma chave estrangeira de S que referencia a chave prim√°ria A de R . Al√©m disso, se a chave estrangeira B tiver a restri√ß√£o NOT NULL, ent√£o js = (1/| R |), e o arquivo de resultado da jun√ß√£o ter√° | S | registros.
- 2. Se B √© uma chave de S , ent√£o |( R /triangleleft /triangleright c S )| ‚â§ | R |, de modo que js ‚â§ (1/| S |).

algoritmos de jun√ß√£o dados na Se√ß√£o 19.3.2. As opera√ß√µes de jun√ß√£o t√™m a forma:

<!-- formula-not-decoded -->

onde A e B s√£o  atributos  compat√≠veis  em  dom√≠nio de R e S , respectivamente. Suponha que R tenha b R blocos e que S tenha b S blocos:

- ¬Ñ J1 - Jun√ß√£o de loop aninhado. Suponha que usemos R para o loop externo; depois obtemos a seguinte fun√ß√£o de custo para estimar o n√∫mero de blocos para este m√©todo, considerando tr√™s buffers de mem√≥ria . Consideramos que o fator de bloco para o arquivo resultante seja bfr RS e que a seletividade de jun√ß√£o seja conhecida:

<!-- formula-not-decoded -->

A √∫ltima parte da f√≥rmula √© o custo de gravar o arquivo resultante em disco. Esta f√≥r19.3.2.  Se n B a f√≥rmula de custo torna-se:

<!-- formula-not-decoded -->

- ¬Ñ J2 - Jun√ß√£o de √∫nico loop (usando uma estrutura de acesso para recuperar os registros que combinam). Se existir um √≠ndice para o atributo de jun√ß√£o B de S com n√≠veis de √≠ndice x B , podemos recuperar cada registro s em R e  depois usar o √≠ndice para recuperar todos os registros que combinam   de t S que satisfa√ßam  [ t B ] = s A [ ]. O custo depende do tipo de √≠ndice. Para um √≠ndice secund√°rio onde s B √© a cardinalidade  de  sele√ß√£o  para  o  atributo  de jun√ß√£o B de S , 21 obtemos:

C J2a = b R + (| R    x | * ( B + 1 + s B )) + (( js * R | | * | S |)/ bfr RS )

Para um √≠ndice de agrupamento onde s B √©  a cardinalidade de sele√ß√£o de B , obtemos

Ter  uma  estimativa  da  seletividade  de  jun√ß√£o para condi√ß√µes de jun√ß√£o que ocorrem normalmente permite  que  o  otimizador  de  consulta  estime  o  tamanho  do  arquivo  resultante  ap√≥s  a  opera√ß√£o  de jun√ß√£o, dados os tamanhos dos dois arquivos de entrada,  usando  a  f√≥rmula  |( R /triangleleft /triangleright c S )| = js * | R | * | S |. Agora, podemos dar alguns exemplos de fun√ß√µes de custo aproximado para estimar o custo de alguns dos

C J2b = b R + (| R    x | * ( B + ( s B / bfr B ))) + (( js * R | | * | S |)/ bfr RS )

Para um √≠ndice prim√°rio, obtemos

C J2c = b R + (| R    x | * ( B + 1)) + (( js * R     S | | * | |)/ bfr RS ) Se  houver  uma  chave  de  hash  para  um  dos dois atributos de jun√ß√£o - digamos, B de S -, obtemos

C J2d = b R + (| R   h | * ) + (( js * R | | * S | |)/ bfr RS )

21 A cardinalidade de sele√ß√£o foi definida como o n√∫mero m√©dio de registros que satisfazem uma condi√ß√£o de igualdade em um atributo, que √© o n√∫mero m√©dio de registros que t√™m o mesmo valor para o atributo e, portanto, ser√£o juntados a um √∫nico registro no outro arquivo.

onde h ‚â• 1 √© o n√∫mero m√©dio de acessos de bloco para recuperar um registro, dado seu valor de chave hash. Normalmente, h √© estimado como sendo 1 para o hashing est√°tico e linear e 2 para o hashing estens√≠vel.

- ¬Ñ J3 - Jun√ß√£o ordena√ß√£o-intercala√ß√£o. Se os arquivos j√° estiverem ordenados nos atributos de jun√ß√£o, a fun√ß√£o de custo para esse m√©todo √©

<!-- formula-not-decoded -->

Se tivermos de ordenar os arquivos, o custo de  ordena√ß√£o  precisa  ser  acrescentado.  Podemos usar as f√≥rmulas da Se√ß√£o 19.2 para estimar esse custo.

Exemplo de uso das fun√ß√µes de custo. Suponha que tenhamos o arquivo FUNCIONARIO descrito no exemplo da se√ß√£o anterior, e suponha que o arquivo DEPARTAMENTO da Figura 3.5 consista em r D = 125 registros armazenados em b D = 13 blocos de disco. Considere as duas opera√ß√µes de jun√ß√£o:

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

Suponha que tenhamos um √≠ndice prim√°rio em Dnumero de DEPARTAMENTO com x Dnumero = 1 n√≠vel e um √≠ndice secund√°rio em Cpf\_ger de DEPARTAMENTO com cardinalidade de sele√ß√£o s Cpf\_ger = 1 e n√≠veis x Cpf\_ger = 2.  Suponha  que  a  seletividade  de  jun√ß√£o para OP6 seja js OP6 = (1/| DEPARTAMENTO |) = 1/125, pois Dnumero √© uma chave de DEPARTAMENTO . Suponha tamb√©m que o fator de bloco para o arquivo de jun√ß√£o resultante seja bfr FD = 4 registros por bloco. Podemos estimar os custos no pior caso para a opera√ß√£o JUN√á√ÉO OP6 usando os m√©todos aplic√°veis J1 e J2, da seguinte forma:

- 1. Usando  o  m√©todo  J1  com FUNCIONARIO como loop externo:
- 2. Usando  o  m√©todo  J1  com DEPARTAMENTO como loop externo:

```
C J1 = b F + ( b F * b D ) + (( js OP6 * r F * r D )/ bfr FD ) = .000 2 + (2.000 * 13) + ((1/125) * 10.000   125)/4) * = 30.500
```

<!-- formula-not-decoded -->

- 3. Usando  o  m√©todo  J2  com FUNCIONARIO como loop externo:

<!-- formula-not-decoded -->

- 4. Usando  o  m√©todo  J2  com DEPARTAMENTO

como loop externo:

<!-- formula-not-decoded -->

O caso 4 tem a menor estimativa de custo e ser√° escolhido.  Observe  que,  no  caso  2,  se  15  buffers de mem√≥ria (ou mais) estivessem dispon√≠veis para executar a jun√ß√£o em vez de apenas tr√™s, 13 deles poderiam ser usados para manter a rela√ß√£o DEPARTAMENTO inteira (rela√ß√£o de loop externo) na mem√≥ria,  um  poderia  ser  usado  como  buffer  para  o resultado e um seria usado para manter um bloco de cada vez do arquivo FUNCIONARIO (arquivo de loop interno),  e  o  custo  para  o  caso  2  seria  drasticamente reduzido para apenas b F + b D + (( js OP6 * r F * r D )/ bfr FD ), ou 4.513, conforme discutimos na Se√ß√£o 19.3.2. Se algum outro n√∫mero de buffers da mem√≥ria principal estivesse dispon√≠vel, digamos, n B = 10, ent√£o o custo para o caso 2 seria calculado da seguinte forma, que tamb√©m daria um desempenho melhor do que o caso 4:

<!-- formula-not-decoded -->

Como um exerc√≠cio, o leitor dever√° realizar uma an√°lise semelhante para OP7 .

## 19.8.5 Consultas de m√∫ltiplas rela√ß√µes e ordena√ß√£o de JUN√ß√£o

As regras de transforma√ß√£o alg√©brica na Se√ß√£o 19.7.2 incluem uma regra comutativa e uma regra associativa  para  a  opera√ß√£o  de  jun√ß√£o.  Com  essas regras, muitas express√µes de jun√ß√£o equivalentes podem ser produzidas. Como resultado, o n√∫mero de √°rvores de consulta alternativas cresce muito rapidamente √† medida que o n√∫mero de jun√ß√µes em uma consulta aumenta. Uma consulta que junta n rela√ß√µes normalmente ter√° n -1 opera√ß√µes de jun√ß√£o e, portanto, pode ter um grande n√∫mero de diferentes ordens de jun√ß√£o. A estimativa do custo de cada √°rvore de jun√ß√£o poss√≠vel para uma consulta com um grande n√∫mero de jun√ß√µes exigir√° um tempo substancial do otimizador de consulta. Logo, √© preciso realizar alguma poda das √°rvores de consulta poss√≠veis. Os otimizadores de consulta em geral limitam a estrutura de uma √°rvore de consulta (jun√ß√£o) √† das √°rvores com profundidade esquerda (ou profundidade direita). Uma √°rvore com profundidade esquerda √©  uma √°rvore bin√°ria em que o filho da direita de

cada n√≥ n√£o folha √© sempre uma rela√ß√£o da base. O otimizador escolheria a √°rvore com profundidade esquerda em particular com o custo estimado mais baixo. Dois exemplos de √°rvores com profundidade esquerda aparecem na Figura 19.7. (Observe que as √°rvores na Figura 19.5 tamb√©m s√£o √°rvores com profundidade esquerda.)

Nas √°rvores com profundidade esquerda, o filho da direita √© considerado a rela√ß√£o interna quando se executa uma jun√ß√£o de loop aninhado, ou a rela√ß√£o de  investiga√ß√£o  quando  se  executa  uma  jun√ß√£o  de √∫nico loop. Uma vantagem das √°rvores com profundidade esquerda (ou direita) √© que elas s√£o receptivas em pipeline, conforme discutimos na Se√ß√£o 19.6. Por exemplo, considere a primeira √°rvore com profundidade esquerda na Figura 19.7 e que o algoritmo de jun√ß√£o √© o m√©todo de √∫nico loop; nesse caso, uma p√°gina de disco de tuplas da rela√ß√£o externa √© usada para investigar a rela√ß√£o interna em busca de tuplas correspondentes. √Ä medida que tuplas (registros) resultantes s√£o produzidas com base na jun√ß√£o de R1 e R2, elas podem ser utilizadas para investigar R3 para localizar seus registros correspondentes para jun√ß√£o. De modo semelhante, √† medida que as tuplas resultantes s√£o produzidas dessa jun√ß√£o, elas poderia ser usadas para investigar R4. Outra vantagem das √°rvores com profundidade esquerda (ou direita) √© que ter uma rela√ß√£o da base como uma das entradas de cada jun√ß√£o permite que o otimizador utilize quaisquer caminhos de acesso nessa rela√ß√£o que possam ser √∫teis na execu√ß√£o da jun√ß√£o.

Se a materializa√ß√£o for usada no lugar de pipeline (ver se√ß√µes 19.6 e 19.7.3), os resultados da jun√ß√£o podem ser materializados e armazenados como rela√ß√µes tempor√°rias. A ideia-chave do ponto de vista do otimizador em rela√ß√£o √† ordena√ß√£o de jun√ß√£o √© encontrar uma ordena√ß√£o que reduza o tamanho dos resultados tempor√°rios, pois estes (pipeline ou mate-



R1

R2

R4

R3

Duas √°rvores de consulta (JUN√á√ÉO) com profundidade

Figura 19.7 esquerda.

rializados) s√£o usados por operadores subsequentes e, portanto, afetam o custo de execu√ß√£o desses operadores.

## 19.8.6 Exemplo para ilustrar a otimiza√ß√£o de consulta baseada em custo

Vamos considerar a consulta C2 e sua √°rvore de consulta mostrada na Figura 19.4(a) para ilustrar a otimiza√ß√£o de consulta baseada em custo:

C2: SELECT Projnumero  Dnum  Unome  Endereco , , , , Data\_nasc FROM PROJETO  DEPARTAMENTO , , FUNCIONARIO WHERE Cpf

Dnum = Dnumero AND Cpf\_ger = AND Projlocal = 'Mau√°';

Suponha que tenhamos a informa√ß√£o sobre as rela√ß√µes  mostradas  na  Figura  19.8.  As  estat√≠sticas de VALOR\_MINIMO e VALOR\_MAXIMO foram  normalizadas por clareza. A √°rvore da Figura 19.4(a) √© considerada para representar o resultado do processo  alg√©brico  de  otimiza√ß√£o  heur√≠stica  e  o  in√≠cio  da otimiza√ß√£o  baseada  em  custo  (neste  exemplo,  consideramos  que  o  otimizador  heur√≠stico  n√£o  leva  as opera√ß√µes de proje√ß√£o para baixo na √°rvore).

A primeira otimiza√ß√£o baseada em custo a considerar √© a ordena√ß√£o de jun√ß√£o. Conforme mencionado anteriormente, pressupomos que o otimizador considera  apenas  √°rvores  com  profundidade  √†  esquerda, de modo que as ordens de jun√ß√£o em potencial - sem PRODUTO CARTESIANO s√£o:

- 1. PROJETO /triangleleft /triangleright DEPARTAMENTO /triangleleft /triangleright FUNCIONARIO
- 2. DEPARTAMENTO /triangleleft /triangleright PROJETO /triangleleft /triangleright FUNCIONARIO
- 3. DEPARTAMENTO /triangleleft /triangleright FUNCIONARIO /triangleleft /triangleright PROJETO
- 4. FUNCIONARIO /triangleleft /triangleright DEPARTAMENTO /triangleleft /triangleright PROJETO

Suponha que a opera√ß√£o de sele√ß√£o j√° tenha sido aplicada √† rela√ß√£o PROJETO . Se considerarmos uma t√©cnica materializada, ent√£o uma nova rela√ß√£o tempor√°ria √© criada ap√≥s cada opera√ß√£o de jun√ß√£o. Para examinar o custo da ordem de jun√ß√£o (1), a primeira jun√ß√£o √© entre PROJETO e DEPARTAMENTO. Tanto o m√©todo de jun√ß√£o quanto os m√©todos de acesso para as  rela√ß√µes  de  entrada  precisam  ser  determinados. Como DEPARTAMENTO n√£o  tem  √≠ndice,  de  acordo com a Figura 19.8, o √∫nico m√©todo de acesso dispon√≠vel √© uma varredura de tabela (ou seja, uma pesquisa linear). A rela√ß√£o PROJETO ter√° a opera√ß√£o de sele√ß√£o realizada antes da jun√ß√£o, de modo que existem duas op√ß√µes: varredura de tabela (pesquisa linear) ou utiliza√ß√£o de seu √≠ndice PROJ\_PLOC ,  de  modo que o otimizador deve comparar seus custos estimados.

## (a)

| Nome_tabela   | Nome_coluna   |   Num_distinto |   Valor_minimo |   Valor_maximo |
|---------------|---------------|----------------|----------------|----------------|
| PROJETO       | Projlocal     |            200 |              1 |            200 |
| PROJETO       | Projnumero    |              2 |              1 |              2 |
| PROJETO       | Dnum          |             50 |              1 |             50 |
| DEPARTAMENTO  | Dnumero       |             50 |              1 |             50 |
| DEPARTAMENTO  | Cpf_ger       |             50 |              1 |             50 |
| FUNCIONARIO   | Cpf           |             10 |              1 |             10 |
| FUNCIONARIO   | Dnr           |             50 |              1 |             50 |
| FUNCIONARIO   | Salario       |            500 |              1 |            500 |

## (b)

| Nome_tabela   |   Num_linhas |   Blocos |
|---------------|--------------|----------|
| PROJETO       |            2 |      100 |
| DEPARTAMENTO  |           50 |        5 |
| FUNCIONARIO   |           10 |        2 |

## (c)

| Nome_indice   | Exclusividade   |   Bn√≠vel* |   Blocos_folha |   Chaves_distintas |
|---------------|-----------------|-----------|----------------|--------------------|
| PROJ_PLOC     | NAO UNICA       |         1 |              4 |                200 |
| CPF_FUNC      | UNICA           |         1 |             50 |                 10 |
| SAL_FUNC      | N√ÉO UNICA       |         1 |             50 |                500 |

*Bn√≠vel √© o n√∫mero de n√≠veis sem o n√≠vel folha.

Figura 19.8

Informa√ß√µes estat√≠sticas de exemplo para as rela√ß√µes em C2. (a) Informa√ß√£o de coluna. (b) Informa√ß√£o de tabela. (c) Informa√ß√£o de √≠ndice.

A informa√ß√£o estat√≠stica no √≠ndice PROJ\_PLOC (ver Figura 19.8) mostra o n√∫mero de n√≠veis de √≠ndice x = 2 (raiz mais n√≠veis folha). O √≠ndice √© n√£o √∫nico (porque Projlocal n√£o √© uma chave de PROJETO) , de modo que o otimizador assume uma distribui√ß√£o de dados uniforme e estima o n√∫mero de ponteiros de registro para cada valor de Projlocal como sendo 10. Isso √© calculado com base nas tabelas da Figura 19.8 ao multiplicar Seletividade * Num\_linhas , em que Seletividade √© estimado por 1/ Num\_distinto. Assim, o custo do uso do √≠ndice e acessos dos registros √© estimado como sendo 12 acessos de bloco (2 para o √≠ndice e 10 para os blocos de dados). O custo de uma varredura de tabela √© estimado como sendo de 100 acessos de bloco, de modo que o acesso ao √≠ndice √© mais eficiente, conforme esperado.

Em uma t√©cnica materializada, um arquivo tempor√°rio TEMP1 com tamanho de 1 bloco √© criado para manter o resultado da opera√ß√£o de sele√ß√£o. O tamanho do arquivo √© calculado ao determinar o fator de bloco, usando a f√≥rmula Num\_linhas/Blocos, que gera 2.000/100 ou 20 linhas por bloco. Portanto, os 10 re- gistros selecionados da rela√ß√£o PROJETO caber√£o em um √∫nico bloco. Agora, podemos calcular o custo estimado da primeira jun√ß√£o. Vamos considerar apenas o m√©todo de jun√ß√£o de loop aninhado, no qual a rela√ß√£o externa √© o arquivo tempor√°rio, TEMP1, e a rela√ß√£o interna √© DEPARTAMENTO. Como o arquivo TEMP1 inteiro cabe no espa√ßo de buffer dispon√≠vel, precisamos ler cada um dos cinco blocos da tabela DEPARTAMENTO apenas uma vez, de modo que o custo da jun√ß√£o √© de seis acessos de bloco mais o custo de gravar o arquivo de  resultado  tempor√°rio, TEMP2. O  otimizador  teria de determinar o tamanho de TEMP2. Como o atributo de jun√ß√£o Dnumero √© a chave para DEPARTAMENTO, qualquer valor de Dnum de TEMP1 se juntar√° com no m√°ximo um registro de DEPARTAMENTO, de modo que o n√∫mero de linhas em TEMP2 ser√° igual ao n√∫mero de linhas em TEMP1, que √© 10. O otimizador determinaria o tamanho do registro para TEMP2 e o n√∫mero de blocos necess√°rios para armazenar essas 10 linhas. Para simplificar, considere que o fator de bloco para TEMP2 seja cinco linhas por bloco, de modo que um total de dois blocos √© necess√°rio para armazenar TEMP2 .

Finalmente, o custo da √∫ltima jun√ß√£o precisa ser estimado. Podemos usar uma jun√ß√£o de √∫nico loop em TEMP2 , pois nesse caso o √≠ndice CPF\_FUNC (ver Figura 19.8) pode ser usado para sondar e localizar registros correspondentes de FUNCIONARIO. Logo, o m√©todo de jun√ß√£o envolveria a leitura em cada bloco de TEMP2 e a pesquisa de cada um dos cinco valores de Cpf\_ger usando o √≠ndice CPF\_FUNC .  Cada pesquisa de √≠ndice exigiria um acesso raiz, um acesso de folha e um acesso de bloco de dados ( x + 1, onde o n√∫mero de n√≠veis x √©  2).  Assim,  10  pesquisas  exigem 30  acessos  de  bloco.  Somando  os  dois  acessos  de bloco  para TEMP2 ,  temos  um  total  de  32  acessos de bloco para essa jun√ß√£o.

Para a proje√ß√£o final, considere que a canaliza√ß√£o seja usada para produzir o resultado final, que n√£o exige acessos de bloco adicionais, de modo que o custo total para a ordem de jun√ß√£o (1) √© estimado como a soma dos custos anteriores. O otimizador, ent√£o,  estimaria  os  custos  de  uma  maneira  semelhante para outras tr√™s ordens de jun√ß√£o e escolheria aquela com a estimativa mais baixa. Deixamos isso como um exerc√≠cio para o leitor.

## 19.9 Vis√£o geral da otimiza√ß√£o da consulta no Oracle

O SGBD Oracle 22  oferece duas t√©cnicas diferentes para otimiza√ß√£o de consulta: baseada em regra e baseada em custo. Com a t√©cnica baseada em regra, o  otimizador  escolhe  planos  de  execu√ß√£o  com  base em opera√ß√µes heuristicamente classificadas. O Oracle mant√©m uma tabela de 15 caminhos de acesso posicionados, em que uma posi√ß√£o mais baixa implica uma t√©cnica mais eficiente. Os caminhos de acesso variam de acesso √† tabela por ROWID (o mais eficiente) - em que ROWID especifica  o  endere√ßo  f√≠sico  do  registro, que inclui o arquivo de dados, bloco de dados e deslocamento de linha dentro do bloco - at√© uma varredura completa da tabela (o menos eficiente) - em que todas as linhas da tabela s√£o pesquisadas ao realizar leituras de m√∫ltiplos blocos. No entanto, a t√©cnica baseada em regra est√° sendo retirada em favor da t√©cnica baseada em custo, na qual o otimizador examina os caminhos de acesso alternativos e os algoritmos de operador, e escolhe o plano de execu√ß√£o com o custo estimado mais baixo. O custo de consulta estimado √© proporcional ao tempo gasto esperado para executar a consulta com o plano de execu√ß√£o indicado.

de CPU e mem√≥ria necess√°ria. O objetivo da otimiza√ß√£o baseada em custo no Oracle √© minimizar o tempo decorrido para processar a consulta inteira.

Um acr√©scimo interessante ao otimizador de consulta do Oracle √© a capacidade para um desenvolvedor de aplica√ß√£o especificar dicas ao otimizador. 23  A ideia √© que um desenvolvedor de aplica√ß√£o possa saber mais informa√ß√µes sobre os dados do que o otimizador. Por exemplo, considere a tabela FUNCIONARIO mostrada na Figura 3.6. A coluna Sexo dessa tabela tem apenas dois valores distintos. Se houver 10.000 funcion√°rios, ent√£o o otimizador estimaria que metade √© do sexo masculino e metade √© do sexo feminino, considerando uma distribui√ß√£o de dados uniforme. Se existir um √≠ndice secund√°rio, ser√° mais do que prov√°vel que n√£o seja usado. Por√©m, se o desenvolvedor da aplica√ß√£o souber que h√° apenas 100 funcion√°rios do sexo masculino, uma dica poderia ser especificada em uma consulta SQL cuja condi√ß√£o da cl√°usula WHERE fosse Sexo = 'M', de modo que o √≠ndice associado seja usado no processamento da consulta. Diversas dicas podem ser especificadas, como:

- ¬Ñ A t√©cnica de otimiza√ß√£o para uma instru√ß√£o SQL.
- ¬Ñ O caminho de acesso para uma tabela acessada pela instru√ß√£o.
- ¬Ñ A  ordem  de  jun√ß√£o  para  uma  instru√ß√£o  de jun√ß√£o.
- ¬Ñ Uma opera√ß√£o  de  jun√ß√£o  em  particular  em uma instru√ß√£o de jun√ß√£o.

A otimiza√ß√£o baseada em custo do Oracle 8 e vers√µes mais recentes s√£o um bom exemplo da t√©cnica sofisticada utilizada para otimizar as consultas SQL em SGBDRs comerciais.

## 19.10 Otimiza√ß√£o de consulta sem√¢ntica

O otimizador do Oracle calcula esse custo com base no uso estimado dos recursos, como E/S, tempo

Uma t√©cnica diferente para a otimiza√ß√£o de consulta,  chamada otimiza√ß√£o  de  consulta  sem√¢ntica , foi sugerida. Essa t√©cnica, que pode ser utilizada em combina√ß√£o com as t√©cnicas discutidas anteriormente, usa restri√ß√µes especificadas no esquema de banco de dados - como atributos exclusivos e outras restri√ß√µes  mais  complexas  -  a  fim  de  modificar  uma consulta para outra que seja mais eficiente de executar. N√£o discutiremos essa t√©cnica com detalhes, mas a ilustraremos com um exemplo simples. Considere a consulta SQL:

22 A discuss√£o nesta se√ß√£o √© baseada principalmente na vers√£o 7 do Oracle. Mais t√©cnicas de otimiza√ß√£o foram acrescentadas a vers√µes subsequentes.

23 Essas dicas tamb√©m s√£o chamadas de anota√ß√µes da consulta.

## SELECT F.Unome  G.Unome , FROM WHERE

FUNCIONARIO AS F  FUNCIONARIO , AS G .Cpf\_supervisor F = G.Cpf AND F.Salario &gt;

G.Salario

Essa  consulta  recupera  os  nomes  dos  funcion√°rios  que  ganham  mais  do  que  seus  supervisores. Suponha que tiv√©ssemos uma restri√ß√£o no esquema de banco de dados que indicasse que nenhum funcion√°rio pode ganhar mais do que seu supervisor direto. Se o otimizador de consulta sem√¢ntica verificar a exist√™ncia  dessa  restri√ß√£o,  ele  n√£o  precisa  executar a  consulta  de  forma  alguma,  pois  sabe  que  seu  resultado  ser√°  vazio.  Isso  pode  economizar  bastante tempo  se  a  verifica√ß√£o  de  restri√ß√£o  puder  ser  feita de modo eficiente. Contudo, a pesquisa por meio de muitas restri√ß√µes para encontrar aquelas que se aplicam a determinada consulta e que podem otimiz√°-la semanticamente tamb√©m pode ser muito demorada. Com a inclus√£o de regras ativas e metadados adicionais  nos  sistemas  de  banco  de  dados  (ver  Cap√≠tulo 26), as t√©cnicas de otimiza√ß√£o sem√¢ntica est√£o sendo gradualmente incorporadas nos SGBDs.

## Resumo

Neste cap√≠tulo, demos uma vis√£o geral das t√©cnicas usadas pelos SGBDs no processamento e otimiza√ß√£o de consultas de alto n√≠vel. Primeiro, discutimos como as consultas SQL s√£o traduzidas em √°lgebra relacional e, depois, como diversas opera√ß√µes da √°lgebra relacional podem ser executadas  por  um  SGBD.  Vimos  que  algumas  opera√ß√µes, particularmente SELE√á√ÉO e JUN√á√ÉO , podem ter muitas op√ß√µes de execu√ß√£o. Tamb√©m abordamos como as opera√ß√µes podem ser combinadas durante o processamento da consulta para criar execu√ß√£o canalizada ou baseada em fluxo, em vez da execu√ß√£o materializada.

Depois  disso,  descrevemos  as  t√©cnicas  heur√≠sticas para a otimiza√ß√£o de consulta, que usam regras heur√≠sticas  e  t√©cnicas  alg√©bricas  para  melhorar  a  efici√™ncia  da execu√ß√£o da consulta. Mostramos como uma √°rvore de consulta que representa uma express√£o da √°lgebra relacional pode ser heuristicamente otimizada ao reorganizar os n√≥s de √°rvore e transform√°-los em outra √°rvore de consulta equivalente, que √© mais eficiente de executar. Tamb√©m demos regras de transforma√ß√£o de preserva√ß√£o da equival√™ncia, que podem ser aplicadas a uma √°rvore de consulta. Ent√£o, introduzimos os planos de execu√ß√£o de consulta para consultas SQL, que acrescentam planos de execu√ß√£o de m√©todo √†s opera√ß√µes da √°rvore de consulta.

Discutimos a t√©cnica baseada em custo para a otimiza√ß√£o da consulta. Mostramos como as fun√ß√µes de custo s√£o desenvolvidas para algoritmos de acesso ao banco de dados e como essas fun√ß√µes de custo s√£o usadas para estimar os custos de diferentes estrat√©gias de execu√ß√£o. Apresentamos uma vis√£o geral do otimizador de consulta do Oracle e mencionamos a t√©cnica da otimiza√ß√£o de consulta sem√¢ntica.

## Perguntas de revis√£o

- 19.1. Discuta  os  motivos  para  converter  consultas SQL  em  consultas  da  √°lgebra  relacional  antes que a otimiza√ß√£o seja feita.
- 19.2. Discuta os diferentes algoritmos para implementa√ß√£o de cada um dos seguintes operadores relacionais  e  as  circunst√¢ncias  sob  as  quais  cada algoritmo pode ser usado: SELE√á√ÉO, JUN√á√ÉO, PROJE√á√ÉO, UNI√ÉO, INTERSEC√á√ÉO, DIFEREN√áA  DE  CONJUNTO, PRODUTO  CARTESIANO.
- 19.3. O que √© um plano de execu√ß√£o de consulta?
- 19.4. O que significa o termo otimiza√ß√£o heur√≠stica ? Discuta as principais heur√≠sticas que s√£o aplicadas durante a otimiza√ß√£o da consulta.
- 19.5. Como uma √°rvore de consulta representa uma express√£o da √°lgebra relacional? O que significa a execu√ß√£o de uma √°rvore de consulta? Discuta as regras para transforma√ß√£o de √°rvores de consulta  e  identifique  quando  cada  regra  deve  ser aplicada durante a otimiza√ß√£o.
- 19.6. Quantas  ordens  de  jun√ß√£o  diferentes  existem para uma consulta que junta 10 rela√ß√µes?
- 19.7. O que significa otimiza√ß√£o de consulta baseada em custo ?
- 19.8. Qual √© a diferen√ßa entre pipelining e materializa√ß√£o ?
- 19.9. Discuta os componentes de custo para uma fun√ß√£o de custo que √© usada para estimar o custo de execu√ß√£o da consulta. Quais componentes de custo s√£o utilizados com mais frequ√™ncia como base para as fun√ß√µes de custo?
- 19.10. Discuta  os  diferentes  tipos  de  par√¢metros  que s√£o usados nas fun√ß√µes de custo. Onde essa informa√ß√£o √© mantida?
- 19.11. Liste as fun√ß√µes de custo para os m√©todos SELE√á√ÉO e JUN√á√ÉO discutidos na Se√ß√£o 19.8.
- 19.12. O que significa otimiza√ß√£o de consulta sem√¢ntica? Como ela difere das outras t√©cnicas de otimiza√ß√£o de consulta?

## Exerc√≠cios

- 19.13. Considere as consultas SQL C1, C8, C1B e C4 do Cap√≠tulo 4 e C27 do Cap√≠tulo 5.
- a. Desenhe pelo menos duas √°rvores de consulta  que  podem  representar cada  uma dessas consultas. Sob que circunst√¢ncias voc√™ usaria cada uma de suas √°rvores de consulta?
- b. Desenhe  a  √°rvore  de  consulta  inicial  para cada  uma  dessas  consultas  e  depois  mostre como a √°rvore de consulta √© otimizada pelo algoritmo esbo√ßado na Se√ß√£o 19.7.
- c. Para cada consulta, compare suas √°rvores de consulta da parte (a) e as √°rvores de consulta inicial e final da parte (b).

19.14. Um arquivo com 4.096 blocos deve ser ordenado  com  um  espa√ßo  de  buffer  dispon√≠vel  de  64 blocos.  Quantas  passadas  ser√£o  necess√°rias  na fase  de  intercala√ß√£o  do  algoritmo  ordena√ß√£o-intercala√ß√£o externo?

19.15.

Desenvolva fun√ß√µes de custo para os algoritmos PROJE√á√ÉO, UNI√ÉO, INTERSEC√á√ÉO, DIFEREN√áA DE CONJUNTO e PRODUTO CARTESIAN discutidos na Se√ß√£o 19.4.

19.16. Desenvolva fun√ß√µes de custo para um algoritmo que consiste em duas SELE√á√ïES , uma JUN√á√ÉO e uma PROJE√á√ÉO final, em rela√ß√£o √†s fun√ß√µes de custo para as opera√ß√µes individuais.

19.17. Um √≠ndice n√£o denso pode ser usado na implementa√ß√£o  de  um  operador  de  agrega√ß√£o?  Por qu√™?

19.18. Calcule as fun√ß√µes de custo para diferentes op√ß√µes  de  execu√ß√£o  da  opera√ß√£o JUN√á√ÉO  OP7 discutida na Se√ß√£o 19.3.2.

19.19. Desenvolva  f√≥rmulas  para  o  algoritmo  jun√ß√£o hash h√≠brido para calcular o tamanho do buffer para o primeiro bucket. Desenvolva f√≥rmulas de estimativa de custo mais precisas para o algoritmo.

19.20. Estime o custo das opera√ß√µes OP6 e OP7 , usando as f√≥rmulas desenvolvidas no Exerc√≠cio 19.9.

19.21. Estenda o algoritmo de jun√ß√£o ordena√ß√£o-intercala√ß√£o para implementar a opera√ß√£o JUN√á√ÉO EXTERNA √Ä ESQUERDA .

19.22. Compare o custo de dois planos de consulta diferentes para a consulta a seguir:

ùõî Salario &gt; 40.000 ( FUNCIONARIO /triangleleft /triangleright Dnr = Dnumero DEPARTAMENTO )

Use as estat√≠sticas de banco de dados da Figura 19.8.

## Bibliografia selecionada

Um algoritmo detalhado para otimiza√ß√£o da √°lgebra relacional √© dado por Smith e Chang (1975). A tese de doutorado de Kooi (1980) oferece uma base para as t√©cnicas  de  processamento  de  consulta.  Um  estudo  de

Jarke e Koch (1984) cont√©m uma taxonomia da otimiza√ß√£o de consulta e inclui uma bibliografia do trabalho nessa √°rea. Um estudo de Graefe (1993) discute a execu√ß√£o da consulta nos sistemas de banco de dados e inclui uma extensa bibliografia.

Whang (1985) discute a otimiza√ß√£o de consulta no OBE (Office-By-Example), que √© um sistema baseado na linguagem QBE. A otimiza√ß√£o baseada em custo foi introduzida no SGBD experimental SYSTEM R e √© discutida em Astrahan et al. (1976). Selinger et al. (1979) √© um artigo cl√°ssico que discutiu a otimiza√ß√£o baseada em custo das jun√ß√µes de m√∫ltiplas vias no SYSTEM R. Algoritmos de jun√ß√£o s√£o discutidos em Gotlieb (1975), Blasgen e Eswaran (1976) e Whang et al. (1982). Os algoritmos de hashing para implementar jun√ß√µes s√£o descritos e analisados em DeWitt et al. (1984), Bratbergsengen (1984), Shapiro (1986), Kitsuregawa et al. (1989), e Blakeley e Martin  (1990),  entre  outros.  T√©cnicas  para  encontrar uma boa ordem de jun√ß√£o s√£o apresentadas em Ioannidis e Kang (1990) e em Swami e Gupta (1989). Uma discuss√£o das implica√ß√µes das √°rvores de jun√ß√£o com profundidade √† esquerda e bushy (frondosas) √© apresentada em Ioannidis e Kang (1991). Kim (1982) discute as transforma√ß√µes de consultas SQL aninhadas para representa√ß√µes can√¥nicas. A otimiza√ß√£o das fun√ß√µes de agrega√ß√£o √© discutida em Klug (1982) e Muralikrishna (1992). Salzberg et al. (1990) descrevem um algoritmo de ordena√ß√£o externa  r√°pida.  A  estimativa  do  tamanho  das  rela√ß√µes tempor√°rias √© crucial para a otimiza√ß√£o de consulta. Os esquemas  de  estimativa  baseados  em  amostragem  s√£o apresentados em Haas et al. (1995) e em Haas e Swami (1995). Lipton et al. (1990) tamb√©m discutem a estimativa de seletividade. Fazer que o sistema de banco de dados armazene e use estat√≠sticas detalhadas na forma de histogramas √© o assunto de Muralikrishna e DeWitt (1988) e Poosala et al. (1996).

Kim  et  al.  (1985)  discutem  t√≥picos  avan√ßados  na otimiza√ß√£o  de  consulta.  A  otimiza√ß√£o  de  consulta  sem√¢ntica √© discutida em King (1981) e Malley e Zdonick (1986). O trabalho sobre otimiza√ß√£o de consulta sem√¢ntica √© relatado em Chakravarthy et al. (1990), Shenoy e Ozsoyoglu (1989) e Siegel et al. (1992).



## Projeto f√≠sico e ajuste de banco de dados

N o cap√≠tulo anterior, discutimos v√°rias t√©cnicas pelas quais as consultas podem ser processadas de modo eficiente pelo SGBD. Essas t√©cnicas s√£o principalmente internas ao SGBD e invis√≠veis para o programador. Neste cap√≠tulo, discutimos quest√µes adicionais que afetam o desempenho de uma aplica√ß√£o que roda em um SGBD. Em particular, discutimos algumas das op√ß√µes dispon√≠veis aos administradores e programadores de banco de dados para armazenar bancos de dados, e algumas das heur√≠sticas, regras e t√©cnicas que eles podem usar para ajustar o banco de dados para melhoria do desempenho. Primeiro, na Se√ß√£o 20.1, abordamos as quest√µes que surgem no projeto de banco de dados f√≠sico que lida com armazenamento e acesso de dados. Depois, na Se√ß√£o 20.2, discutimos como melhorar o desempenho do banco de dados por meio do ajuste, indexa√ß√£o de dados, projeto de banco de dados e as pr√≥prias consultas.

determinado esquema conceitual, existem muitas alternativas de projeto f√≠sico em determinado SGBD. N√£o √© poss√≠vel tomar decis√µes significativas de projeto f√≠sico e an√°lise de desempenho at√© que o projetista de banco de dados conhe√ßa a combina√ß√£o de consultas,  transa√ß√µes e aplica√ß√µes que dever√£o usar o banco de dados. Isso √© chamado de combina√ß√£o de tarefas para determinado conjunto de aplica√ß√µes de sistema  de  banco  de  dados.  Os  administradores/ projetistas  de  banco  de  dados  precisam  analisar essas  aplica√ß√µes,  suas  frequ√™ncias  de  chamada  esperadas,  quaisquer  restri√ß√µes  de  temporiza√ß√£o  em sua velocidade de execu√ß√£o, a frequ√™ncia esperada de opera√ß√µes de atualiza√ß√£o e quaisquer restri√ß√µes exclusivas nos atributos. Discutimos cada um desses fatores a seguir.

## 20.1 Projeto f√≠sico em bancos de dados relacionais

Nesta  se√ß√£o,  come√ßamos  discutindo  os  fatores de projeto f√≠sicos que afetam o desempenho de aplica√ß√µes e transa√ß√µes, e depois comentamos as orienta√ß√µes espec√≠ficas para SGBDRs.

## 20.1.1 atores que influenciam o projeto F f√≠sico do banco de dados

A. Analisando as consultas e transa√ß√µes de banco  de  dados. Antes  de  realizar  o  projeto  f√≠sico de banco de dados, devemos ter uma boa ideia do uso intencionado deste √∫ltimo, definindo em uma forma de alto n√≠vel as consultas e transa√ß√µes que dever√£o usar o banco de dados. Para cada consulta de recupera√ß√£o, as seguintes informa√ß√µes seriam necess√°rias:

- 1. Os arquivos que ser√£o acessados pela consulta. 1
- 2. Os atributos sobre os quais quaisquer condi√ß√µes de sele√ß√£o para a consulta s√£o especificadas.
- 3. Se a condi√ß√£o de sele√ß√£o √© uma condi√ß√£o de igualdade, desigualdade ou intervalo.

O projeto f√≠sico √© uma atividade em que o objetivo √© n√£o apenas criar a estrutura√ß√£o apropriada de dados no armazenamento, mas tamb√©m fazer isso de  modo  que  garanta  um  bom  desempenho.  Para

- 4. Os atributos sobre os quais s√£o especificadas quaisquer  condi√ß√µes  de  jun√ß√£o  ou  condi√ß√µes pa  ra ligar m√∫ltiplas tabelas ou objetos para a consulta.

1 Por simplicidade, usamos o termo arquivos aqui, mas isso tamb√©m pode significar tabelas ou rela√ß√µes.

- 5. Os atributos cujos valores ser√£o recuperados pela consulta.

Os atributos listados nos itens 2 e 4 s√£o candidatos para a defini√ß√£o de estruturas de acesso, como √≠ndices, chaves de hash ou ordena√ß√£o do arquivo.

Para cada opera√ß√£o de atualiza√ß√£o ou transa√ß√£o de atualiza√ß√£o , a informa√ß√£o a seguir seria necess√°ria:

- 1. Os arquivos que ser√£o atualizados.
- 2. O tipo de opera√ß√£o em cada arquivo (inser√ß√£o, atualiza√ß√£o ou exclus√£o).
- 3. Os atributos sobre os quais as condi√ß√µes de sele√ß√£o para uma exclus√£o ou atualiza√ß√£o s√£o especificadas.
- 4. Os  atributos  cujos  valores  ser√£o  alterados por uma opera√ß√£o de atualiza√ß√£o.

Novamente, os atributos listados no item 3 s√£o candidatos  para  estruturas  de  acesso  nos  arquivos, pois eles seriam usados para localizar os registros que ser√£o atualizados ou exclu√≠dos. Por sua vez, os atributos listados no item 4 s√£o candidatos para evitar uma  estrutura  de  acesso ,  pois  modific√°-los  exigir√° atualiza√ß√£o das estruturas de acesso.

- B. Analisando a frequ√™ncia de chamada de consultas e transa√ß√µes esperada. Al√©m de identificar as caracter√≠sticas das consultas de recupera√ß√£o e transa√ß√µes de atualiza√ß√£o esperadas, temos de considerar suas taxas de chamada esperadas. Essa informa√ß√£o de frequ√™ncia, junto com a informa√ß√£o de atributo coletada em cada consulta e transa√ß√£o, √© usada para compilar uma lista cumulativa da frequ√™ncia de uso esperada para todas as consultas e transa√ß√µes. Isso √© expresso como a frequ√™ncia de uso esperada de cada atributo em cada arquivo como um atributo de sele√ß√£o ou um atributo de jun√ß√£o, em todas as consultas e transa√ß√µes. Geralmente, para um volume maior de processamento, a regra dos 80-20 informal pode ser usada: aproximadamente 80 por cento do processamento √© atribu√≠do a apenas 20 por cento das consultas e transa√ß√µes. Portanto, em situa√ß√µes pr√°ticas, raramente √© necess√°rio coletar estat√≠sticas completas e taxas de chamada em todas as consultas e transa√ß√µes; basta determinar 20 por cento ou mais das mais importantes.

tri√ß√µes de tempo colocam ainda mais prioridades nos atributos que s√£o candidatos para caminhos de acesso.  Os  atributos  de  sele√ß√£o  usados  por  consultas  e transa√ß√µes com restri√ß√µes de tempo tornam-se candidatos de maior prioridade para estruturas de acesso prim√°rias para os arquivos, visto que as estruturas de acesso prim√°rias geralmente s√£o as mais eficientes para localizar registros em um arquivo.

- D. Analisando as frequ√™ncias esperadas de opera√ß√µes de atualiza√ß√£o. Um n√∫mero m√≠nimo de caminhos de acesso deve ser especificado para um arquivo que √© frequentemente atualizado, pois a atualiza√ß√£o dos pr√≥prios caminhos de acesso atrasa esse tipo de opera√ß√£o. Por exemplo, se um arquivo que tem inser√ß√µes de registro frequentes possui dez √≠ndices em dez atributos diferentes, cada um desses √≠ndices deve ser atualizado sempre que um novo registro √© inserido. O overhead para atualizar dez √≠ndices pode atrasar as opera√ß√µes de inser√ß√£o.
- E.  Analisando  as  restri√ß√µes  de  exclusividade  em atributos. Os caminhos de acesso devem ser especificados em todos os atributos de chave candidata - ou conjuntos de atributos - que s√£o a chave prim√°ria de um arquivo ou atributos √∫nicos. A exist√™ncia de um √≠ndice (ou outro caminho de acesso) torna suficiente apenas procurar o √≠ndice ao verificar essa restri√ß√£o de exclusividade, pois todos os valores do atributo existir√£o nos n√≥s folha do √≠ndice. Por exemplo, ao inserir um novo registro, se um valor de atributo chave do novo registro j√° existir no √≠ndice, a inser√ß√£o do novo registro deve ser rejeitada, pois ela violaria a restri√ß√£o de exclusividade no atributo.

Quando a informa√ß√£o  anterior  √©  compilada,  √© poss√≠vel resolver as decis√µes de projeto f√≠sico do banco de dados, que consiste principalmente em decidir sobre as estruturas de armazenamento e caminhos de acesso para os arquivos de banco de dados.

## 20.1.2 Decis√µes do projeto f√≠sico do banco de dados

- C. Analisando as restri√ß√µes de tempo de consultas  e  transa√ß√µes. Algumas  consultas  e  transa√ß√µes podem ter rigorosas restri√ß√µes de desempenho. Por exemplo, uma transa√ß√£o pode ter a restri√ß√£o de que deve terminar dentro de cinco segundos em 95 por cento das ocasi√µes em que √© chamada, e que ela nunca deve levar mais do que vinte segundos. Essas res-

A maioria dos sistemas relacionais representa cada rela√ß√£o da base como um arquivo de banco de dados f√≠sico. As op√ß√µes do caminho de acesso incluem a especifica√ß√£o do tipo de organiza√ß√£o de arquivo prim√°rio para cada rela√ß√£o e os atributos dos quais os √≠ndices devem ser definidos. No m√°ximo,  um  dos  √≠ndices  em  cada  arquivo  pode  ser um √≠ndice prim√°rio ou de agrupamento. Qualquer quantidade de √≠ndices secund√°rios adicionais pode ser criada. 2

2 O leitor deve rever os diversos tipos de √≠ndices descritos na Se√ß√£o 18.1. Para um entendimento claro dessa discuss√£o, tamb√©m √© √∫til estar acostumado com os algoritmos para processamento de consulta discutidos no Cap√≠tulo 19.

Decis√µes de projeto sobre indexa√ß√£o. Os atributos cujos valores s√£o exigidos nas condi√ß√µes de igualdade ou intervalo (opera√ß√£o de sele√ß√£o) s√£o os de chave ou que participam nas condi√ß√µes de jun√ß√£o (opera√ß√£o de jun√ß√£o) exigindo caminhos de acesso, como √≠ndices.

O desempenho das consultas depende em grande  parte  de  quais  √≠ndices  ou  esquemas  de  hashing existem para agilizar o processamento de sele√ß√µes e jun√ß√µes. Al√©m disso, durante as opera√ß√µes de inser√ß√£o, exclus√£o ou atualiza√ß√£o, a exist√™ncia de √≠ndices aumenta o overhead. Esse overhead precisa ser justificado em rela√ß√£o ao ganho em efici√™ncia ao agilizar consultas e transa√ß√µes.

As decis√µes de projeto f√≠sico para indexa√ß√£o ficam nas seguintes categorias:

- 1. Se um atributo deve ser indexado. As regras gerais  para  a  cria√ß√£o  de  um  √≠ndice  em  um atributo s√£o que o atributo deve ser uma chave  (√∫nica)  ou  alguma  consulta  que  use  esse atributo em uma condi√ß√£o de sele√ß√£o (igualdade ou intervalo de valores) ou em uma condi√ß√£o de jun√ß√£o. Um motivo para a cria√ß√£o de m√∫ltiplos √≠ndices √© que algumas opera√ß√µes podem  ser  processadas  apenas  varrendo  os √≠ndices, sem ter de acessar o arquivo de dados real (ver Se√ß√£o 19.5).
- 2. Que atributo ou atributos indexar. Um √≠ndice pode  ser  constru√≠do  em  um  √∫nico  atributo, ou em mais de um atributo, se for um √≠ndice composto. Se v√°rios atributos de uma rela√ß√£o estiverem envolvidos juntos em v√°rias consultas (por exemplo, (Cod\_estilo\_roupa, Cor) em um banco de dados de estoque de roupas), um √≠ndice multiatributos (composto) √© garantido. A ordena√ß√£o dos atributos em um √≠ndice multiatributos deve corresponder √†s consultas. Por exemplo, o √≠ndice acima assume que as consultas seriam baseadas em uma ordena√ß√£o de cores em um Cod\_estilo\_roupa , em vez do contr√°rio.
- 3. Se  um  √≠ndice  agrupado  deve  ser  montado. No m√°ximo, um √≠ndice por tabela pode ser um √≠ndice prim√°rio ou de agrupamento, pois isso  implica  que  o  arquivo  seja  fisicamente  ordenado nesse atributo. Na maioria dos SGBDRs,  isso  √©  especificado  pela  palavra chave CLUSTER . (Se o atributo for uma chave , um √≠ndice prim√°rio √© criado, enquanto um √≠ndice de agrupamento √© criado se o atributo n√£o for uma chave - ver Se√ß√£o 18.1.) Se uma tabela  exigir  v√°rios  √≠ndices,  a  decis√£o  sobre qual deve ser o √≠ndice prim√°rio ou de agrupamento depende da necessidade de manter a
- tabela ordenada nesse atributo. As consultas de intervalo se beneficiam muito com o agrupamento. Se v√°rios atributos exigem consultas  de  intervalo,  benef√≠cios  relativos  devem ser  avaliados  antes  de  se  decidir  sobre  qual atributo  agrupar.  Se  uma  consulta  tiver  de ser  respondida  realizando  apenas  uma  consulta  de  √≠ndice  (sem  recuperar  registros  de dados), o √≠ndice correspondente n√£o dever√° ser  agrupado,  pois  o  principal  benef√≠cio  do agrupamento  √©  alcan√ßado  ao  se  recuperar os pr√≥prios registros. Um √≠ndice de agrupamento pode ser configurado como um √≠ndice multiatributos se a recupera√ß√£o de intervalo por essa chave composta for √∫til na cria√ß√£o de relat√≥rio (por exemplo, um √≠ndice em Cep, Id\_loja e Id\_produto pode  ser  um  √≠ndice  de agrupamento para dados de venda).
- 4. Se um √≠ndice de hash deve ser usado em um √≠ndice de √°rvore. Em geral, os SGBDRs usam B + -trees  para  indexa√ß√£o.  Contudo,  o  ISAM e √≠ndices de hash tamb√©m s√£o fornecidos em alguns sistemas (ver Cap√≠tulo 18). As B + -trees admitem consultas de igualdade e de intervalo no atributo usado como chave de pesquisa. Os √≠ndices de hash funcionam bem com condi√ß√µes de igualdade, particularmente durante jun√ß√µes  para  encontrar  registros  correspondentes,  mas  elas  n√£o  admitem  consultas  de intervalo.
- 5. Se  o  hashing  din√¢mico  deve  ser  usado  para o arquivo. Para arquivos que s√£o muito vol√°teis  -  ou  seja,  aqueles  que  aumentam  e diminuem de maneira  cont√≠nua  -,  um  dos esquemas de hashing din√¢mico discutidos na Se√ß√£o 17.9 seria adequado. Atualmente, eles n√£o s√£o oferecidos por muitos SGBDRs comerciais.

Como  criar  um  √≠ndice. Muitos  SGBDRs  t√™m  um tipo  semelhante  de  comando  para  criar  um  √≠ndice, embora ele n√£o fa√ßa parte do padr√£o SQL. A forma geral desse comando √©:

CREATE [ UNIQUE   INDEX ] &lt; nome indice &gt; &gt; ]

ON &lt; nome tabela &gt; ( &lt; nome coluna &gt; [ &lt; ordem { , &lt; nome coluna &gt; [ &lt; ordem &gt; ] } ) [ CLUSTER ] ;

As palavras-chave UNIQUE e CLUSTER s√£o opcionais. A palavra-chave CLUSTER √© usada quando o √≠ndice a ser criado tamb√©m deve classificar os registros do arquivo de dados no atributo de indexa√ß√£o. Assim,  especificar CLUSTER em um atributo chave (√∫nica) criaria alguma varia√ß√£o de um √≠ndice prim√°-

rio, enquanto especificar CLUSTER em um atributo n√£o  chave  (n√£o  √∫nico)  criaria  alguma  varia√ß√£o  de um √≠ndice de agrupamento. O valor para &lt; ordem &gt; pode ser ASC (ascendente) ou DESC (descendente), e especifica se o arquivo de dados deve ser ordenado em valores crescentes ou decrescentes do atributo de indexa√ß√£o. O padr√£o √© ASC. Por exemplo, o seguinte criaria um √≠ndice de agrupamento (crescente) no atributo n√£o chave Dnr do arquivo FUNCIONARIO:

CREATE INDEX Idx\_Dnr ON FUNCIONARIO  Dnr ( ) CLUSTER ;

Desnormaliza√ß√£o  como  uma  decis√£o  de  projeto para agilizar as consultas. O objetivo final durante a normaliza√ß√£o (ver cap√≠tulos 15 e 16) √© separar atributos em tabelas e minimizar a redund√¢ncia, e, portanto, evitar as anomalias de atualiza√ß√£o que levam a um overhead de processamento extra para manter a consist√™ncia no banco de dados. Os ideais que normalmente s√£o seguidos s√£o a terceira forma normal ou Boyce-Codd (ver Cap√≠tulo 15).

Esses  ideais  √†s  vezes  s√£o  sacrificados  em  favor de uma execu√ß√£o mais r√°pida de consultas e transa√ß√µes que ocorrem com frequ√™ncia. Esse processo de armazenar o projeto l√≥gico do banco de dados (que pode estar em FNBC ou 4FN) em uma forma normal mais fraca, digamos 2FN ou 1FN, √© chamado de desnormaliza√ß√£o . Em geral, o projetista inclui certos atributos de uma tabela S em outra tabela R . O motivo √© que os atributos de S que est√£o inclu√≠dos em R s√£o necess√°rios com frequ√™ncia - junto com outros atributos de R - para responder a consultas ou produzir relat√≥rios. Ao incluir esses atributos, uma jun√ß√£o de R com S √© evitada para essas consultas e relat√≥rios que ocorrem com frequ√™ncia. Isso reintroduz a redund√¢ncia nas tabelas da base, incluindo os mesmos atributos nas tabelas R e S .  Agora, existe uma depend√™ncia funcional parcial ou uma depend√™ncia transitiva na tabela R ,  criando  assim os problemas de redund√¢ncia associados (ver Cap√≠tulo 15). Existe um dilema entre a atualiza√ß√£o adicional necess√°ria para manter a consist√™ncia dos atributos redundantes e o esfor√ßo necess√°rio para realizar uma jun√ß√£o para incorporar os atributos adicionais necess√°rios no resultado. Por exemplo, considere a seguinte rela√ß√£o:

AREFA T ( Func\_id , Proj\_id , Nome\_func , Car-go\_func   Porc\_atribuida   Nome\_proj,  Id\_ger\_proj , , , Nome\_ger\_proj ), que corresponde exatamente aos cabe√ßalhos em um relat√≥rio chamado de A lista de tarefas do funcion√°rio .

Esta rela√ß√£o est√° apenas na 1FN, devido √†s seguintes depend√™ncias funcionais:

Nome\_proj  Id\_ger\_proj

Proj\_id ‚Üí ,

Id\_ger\_proj ‚Üí Nome\_ger\_proj

Func\_id ‚Üí Nome\_func  Cargo\_func ,

Esta  rela√ß√£o  pode  ser  preferida  ao  projeto  na 2FN (e 3FN) que consiste nas tr√™s rela√ß√µes a seguir:

FUNC  Func\_id  Nome\_func  Cargo\_func ( , ,

) ) )

PROJ  Proj\_id  Nome\_proj  Id\_ger\_proj ( , ,

FUNC\_PROJ  Func\_id  Proj\_id  Porc\_atribuida ( , ,

Isso porque, para produzir o relat√≥rio A lista de tarefas do funcion√°rio (com todos os campos mostrados em TAREFA , acima), o √∫ltimo projeto de m√∫ltiplas rela√ß√µes requer duas opera√ß√µes JUN√á√ÉO NATURAL (indicadas com  ) (entre * FUNC e FUNC\_PROJ, e entre PROJ e FUNC\_PROJ ), mais um JUN√á√ÉO final entre PROJ e FUNC para recuperar o Nome\_ger\_proj do Id\_ger\_proj. Assim, as seguintes JUN√á√ïES seriam necess√°rias (a jun√ß√£o final tamb√©m exigiria troca de nome (renomea√ß√£o) da √∫ltima tabela FUNC , que n√£o aparece):

<!-- formula-not-decoded -->

Tamb√©m √© poss√≠vel criar uma vis√£o para a tabela TAREFA . Isso n√£o significa que as opera√ß√µes de jun√ß√£o  ser√£o  evitadas,  mas  que  o  usu√°rio  n√£o  precisa especificar as jun√ß√µes. Se a tabela de vis√£o for materializada, as jun√ß√µes seriam evitadas, mas se a tabela da vis√£o virtual n√£o for armazenada como um arquivo materializado, os c√°lculos de jun√ß√£o ainda seriam necess√°rios. Outras formas de desnormaliza√ß√£o consistem em armazenar tabelas extras para manter as depend√™ncias funcionais originais que s√£o perdidas durante a decomposi√ß√£o FNBC. Por exemplo, a Figura 15.14 mostra a rela√ß√£o ENSINA(Aluno, Disciplina, Professor) com  as  depend√™ncias  funcionais  {{ Aluno, Disciplina } ‚Üí Professor, Professor ‚Üí Disciplina }. Uma decomposi√ß√£o sem perdas de ENSINA para E1 Aluno, ( Professor ) e E2 Professor, Disciplina ( ) n√£o permite que consultas da forma que disciplina o aluno Silva realizou com o professor Navathe sejam respondidas sem juntar E1 e E2. Portanto,  armazenar E1, E2 e ENSINA pode  ser  uma  solu√ß√£o  poss√≠vel,  que  reduz o projeto da FNBC para 3FN. Aqui, ENSINA √© uma jun√ß√£o  materializada  das  outras  duas  tabelas,  que representam uma redund√¢ncia extrema. Quaisquer atualiza√ß√µes  em E1 e E2 teriam  de  ser  aplicadas  a ENSINA. Uma estrat√©gia alternativa √© criar E1 e E2 como tabelas  da  base  atualiz√°veis,  e  criar ENSINA como uma vis√£o (tabela virtual) em E1 e E2 que s√≥ pode ser consultada.

## 20.2 Vis√£o geral do ajuste de banco de dados em sistemas relacionais

Ap√≥s  um  banco  de  dados  ser  implementado  e estar em opera√ß√£o, o uso real das aplica√ß√µes, transa√ß√µes, consultas e vis√µes revela fatores e √°reas de problema que podem n√£o ter sido considerados durante o projeto f√≠sico inicial. As entradas do projeto f√≠sico listadas  na  Se√ß√£o  20.1.1  podem  ser  revisadas  ao  se reunir estat√≠sticas reais sobre padr√µes de uso. A utiliza√ß√£o de recursos, bem como o processamento interno do SGBD - como a otimiza√ß√£o de consulta podem ser monitorados para revelar gargalos, como a disputa pelos mesmos dados ou dispositivos. Volumes de atividade e tamanhos de dados podem ser melhor estimados. Portanto, √© necess√°rio monitorar e revisar o projeto f√≠sico do banco de dados constantemente uma atividade  conhecida  como ajuste  do  banco  de dados . Os objetivos do ajuste s√£o os seguintes:

- ¬Ñ Fazer as aplica√ß√µes rodarem mais rapidamente.
- ¬Ñ Melhorar  (reduzir)  o  tempo  de  resposta  de consultas e transa√ß√µes.
- ¬Ñ Melhorar o desempenho geral das transa√ß√µes.

A linha divis√≥ria entre o projeto f√≠sico e o ajuste √©  muito  t√™nue.  As  mesmas  decis√µes  de  projeto  que discutimos na Se√ß√£o 20.1.2 s√£o revisadas durante o ajuste do banco de dados, que √© um ajuste cont√≠nuo do projeto f√≠sico. A seguir, damos uma breve vis√£o geral do processo de ajuste. 3  As entradas para o processo de ajuste incluem estat√≠sticas relacionadas aos mesmos fatores  mencionados  na  Se√ß√£o  20.1.1.  Em particular, os SGBDs podem coletar internamente as seguintes estat√≠sticas:

- ¬Ñ Tamanhos de tabelas individuais.
- ¬Ñ N√∫mero de valores distintos em uma coluna.
- ¬Ñ O n√∫mero de vezes que determinada consulta ou transa√ß√£o √© submetida e executada em um intervalo de tempo.
- ¬Ñ Os tempos exigidos para diferentes fases do processamento de consulta e transa√ß√£o (para determinado conjunto de consultas ou transa√ß√µes).

Essas e outras estat√≠sticas criam um perfil de conte√∫dos e uso do banco de dados. Outras informa√ß√µes obtidas pelo monitoramento das atividades e processos do sistema de banco de dados incluem:

- ¬Ñ Estat√≠sticas de armazenamento. Dados sobre aloca√ß√£o  de  armazenamento  em  espa√ßos  de tabela (tablespaces), espa√ßos de √≠ndice e pools de buffer.
- ¬Ñ Estat√≠sticas de desempenho de E/S e dispositivo. Atividade total de leitura/grava√ß√£o (pagina√ß√£o) em extens√µes de disco e 'hot spots' do disco.
- ¬Ñ Estat√≠sticas  de  processamento  de  consulta/ transa√ß√£o. Tempos de execu√ß√£o de consultas e transa√ß√µes e tempos de otimiza√ß√£o durante a otimiza√ß√£o da consulta.
- ¬Ñ Estat√≠sticas  relacionadas  a  bloqueio/logging. Taxas de emiss√£o de diferentes tipos de bloqueios, taxas de vaz√£o da transa√ß√£o e atividade de registros de log. 4
- ¬Ñ Estat√≠sticas  de  √≠ndice. N√∫mero de n√≠veis em um √≠ndice, n√∫mero de p√°ginas folha n√£o cont√≠guas, e assim por diante.

Algumas dessas estat√≠sticas se relacionam a transa√ß√µes, controle de concorr√™ncia e recupera√ß√£o, que ser√£o discutidos nos cap√≠tulos 21 a 23. O ajuste de um banco de dados envolve lidar com os seguintes tipos de problemas:

- ¬Ñ Como evitar disputa excessiva por bloqueio, aumentando  assim  a  concorr√™ncia  entre  as transa√ß√µes.
- ¬Ñ Como minimizar o overhead do logging e o dumping desnecess√°rio de dados.
- ¬Ñ Como otimizar o tamanho do buffer e o escalonamento de processos.
- ¬Ñ Como alocar recursos como discos, RAM e processos para que a utiliza√ß√£o seja mais eficiente.

A maioria dos problemas que mencionamos anteriormente pode ser resolvida pelo DBA ao definir par√¢metros  f√≠sicos  apropriados  do  SGBD,  alterar configura√ß√µes de dispositivos, mudar par√¢metros do sistema operacional e outras atividades semelhantes. As solu√ß√µes costumam estar bastante ligadas a sistemas espec√≠ficos. Os DBAs normalmente s√£o treinados  para  lidar  com  esses  problemas  de  ajuste  para o  SGBD espec√≠fico.  A  seguir,  discutimos  rapidamente  o ajuste de v√°rias decis√µes a respeito do projeto f√≠sico do banco de dados.

3 Os leitores interessados devem consultar Shasha e Bonnet (2002) para obter uma discuss√£o detalhada do processo de ajuste.

4 O leitor deve examinar os cap√≠tulos 21 a 23 para obter uma explica√ß√£o desses termos.

## 20.2.1 Ajustando √≠ndices

A escolha inicial de √≠ndices pode ter que ser revisada pelos seguintes motivos:

- ¬Ñ Certas  consultas  podem  levar  muito  tempo para serem executadas, por falta de um √≠ndice.
- ¬Ñ Certos √≠ndices podem nem ser utilizados.
- ¬Ñ Certos √≠ndices podem sofrer muita atualiza√ß√£o,  pois  o  √≠ndice  est√°  em  um  atributo  que sofre mudan√ßas frequentes.

A maioria dos SGBDs tem um comando ou facilidade de trace, que pode ser usado pelo DBA para pedir que o sistema mostre como uma consulta foi executada  -  que  opera√ß√µes  foram  realizadas  em que  ordem  e  que  estruturas  de  acesso  secund√°rias (√≠ndices) foram usadas. Ao analisar esses planos de execu√ß√£o,  √©  poss√≠vel  diagnosticar  as  causas  de  tais problemas.  Alguns  √≠ndices  podem  ser  removidos  e outros novos podem ser criados com base na an√°lise de ajuste.

O  objetivo  do  ajuste  √©  avaliar  dinamicamente os requisitos, que √†s vezes flutuam sazonalmente ou durante diferentes √©pocas do m√™s ou da semana, e  reorganizar  os  √≠ndices  e  organiza√ß√µes  de  arquivo para gerar o melhor desempenho geral. A remo√ß√£o e cria√ß√£o de novos √≠ndices √© um overhead que pode ser justificado em rela√ß√£o √†s melhorias no desempenho. A atualiza√ß√£o de uma tabela em geral √© suspensa enquanto um √≠ndice √© descartado ou criado; essa perda de servi√ßo deve ser considerada. Al√©m de remover ou criar  √≠ndices  e  alterar  com  base  em  um  √≠ndice  n√£o agrupado  para  um  √≠ndice  agrupado  e  vice-versa,  a recria√ß√£o do √≠ndice pode melhorar o desempenho. A maioria dos SGBDRs utiliza B + -trees para um √≠ndice.  Se  houver  muitas  exclus√µes  na  chave  de  √≠ndice, as p√°ginas de √≠ndice podem conter espa√ßo desperdi√ßado, que pode ser reivindicado durante a opera√ß√£o de recria√ß√£o. De modo semelhante, muitas inser√ß√µes podem causar estouros em um √≠ndice agrupado, que afetam  o  desempenho.  A  recria√ß√£o  de  um  √≠ndice agrupado significa reorganizar a tabela inteira ordenada nessa chave.

um ponteiro de √≠ndice para cada registro. O Sybase oferece √≠ndices de agrupamento como √≠ndices esparsos na forma de B + -trees, enquanto o INGRES oferece √≠ndices de agrupamento esparsos como arquivos ISAM e √≠ndices de agrupamento densos como B + -trees.  Em  algumas  vers√µes  do  Oracle  e  DB2,  a op√ß√£o  de  configurar  um  √≠ndice  de  agrupamento  √© limitada a um √≠ndice denso (com muito mais entradas de √≠ndice), e o DBA precisa trabalhar com essa limita√ß√£o.

## 20.2.2 Ajustando o projeto do banco de dados

Na  Se√ß√£o  20.1.2,  discutimos  a  necessidade  de uma poss√≠vel desnormaliza√ß√£o, que √© um desvio da manuten√ß√£o de todas as tabelas como rela√ß√µes FNBC. Se determinado projeto f√≠sico de banco de dados n√£o atender aos objetivos esperados, o DBA pode reverter  para o projeto l√≥gico do banco de dados, fazer ajustes  como  desnormaliza√ß√µes  no  esquema  l√≥gico e  mape√°-lo  novamente  para  um  novo  conjunto  de tabelas f√≠sicas e √≠ndices.

Conforme discutimos, o projeto inteiro do banco de dados precisa ser controlado pelos requisitos de  processamento  tanto  quanto  pelos  requisitos  de dados. Se os requisitos de processamento estiverem mudando dinamicamente, o projeto precisa responder fazendo mudan√ßas no esquema conceitual, se necess√°rio, e para refletir essas mudan√ßas no esquema l√≥gico e projeto f√≠sico. As mudan√ßas podem ser da seguinte natureza:

- ¬Ñ As  tabelas  existentes  podem  ser  juntadas (desnormalizadas)  porque  certos  atributos de duas ou mais tabelas s√£o frequentemente necess√°rios juntos: isso reduz o n√≠vel de normaliza√ß√£o de FNBC para 3FN, 2FN ou 1FN. 5
- ¬Ñ Para determinado conjunto de tabelas, pode haver escolhas de projeto alternativas, todas alcan√ßando a 3FN ou FNBC. Ilustramos projetos  equivalentes  alternativos  no  Cap√≠tulo 16. Um projeto normalizado pode ser substitu√≠do por outro.

As op√ß√µes dispon√≠veis para indexa√ß√£o e o modo como elas s√£o definidas, criadas e reorganizadas varia de um sistema para outro. Como exemplo, considere os √≠ndices esparsos e densos do Cap√≠tulo 18. Um √≠ndice esparso, como um √≠ndice prim√°rio (ver Se√ß√£o 18.1), ter√° um ponteiro de √≠ndice para cada p√°gina (bloco de disco) no arquivo de dados; um √≠ndice denso, como um √≠ndice secund√°rio √∫nico, ter√°

- ¬Ñ Uma rela√ß√£o da forma R(Ch , A, B, C, D, ...) -com Ch como um conjunto de atributos de chave - que esteja na FNBC pode ser armazenada em v√°rias tabelas que tamb√©m est√£o na FNBC - por exemplo, R1(Ch, A, B), R2(Ch, C, D, ), R3(Ch , ...) - ao replicar a chave Ch em cada tabela. Tal processo √© conhecido como

5 Observe que 3FN e 2FN resolvem diferentes tipos de depend√™ncias de problema que s√£o independentes um do outro; logo, a ordem de normaliza√ß√£o (ou desnormaliza√ß√£o) entre eles √© arbitr√°ria.

- particionamento vertical . Cada tabela agrupa conjuntos de atributos que s√£o acessados juntos. Por exemplo, a tabela FUNCIONARIO(Cpf, Nome, Telefone, Nota, Salario) pode  ser  dividida em duas: FUNC1(Cpf, Nome, Telefone) e FUNC2(Cpf, Nota, Salario) . Se a tabela original tem um grande n√∫mero (digamos, 100.000) de linhas e consultas sobre n√∫meros de telefone e as informa√ß√µes de sal√°rio s√£o totalmente distintas  e  ocorrem  com  frequ√™ncias  muito diferentes,  ent√£o  essa  separa√ß√£o  de  tabelas pode funcionar melhor.
- ¬Ñ O(s)  atributo(s)  de  uma  tabela  pode(m)  ser repetido(s) em outra, embora isso crie redund√¢ncia e uma anomalia em potencial. Por exemplo, Nome\_peca pode ser replicado nas tabelas sempre  que  a Num\_peca aparece  (como  chave  estrangeira), mas pode haver uma tabela principal chamada PECA\_PRINCIPAL(Num\_peca, Nome\_ peca, ...) onde  se  garante  que  o Nome\_peca √© atualizado.
- ¬Ñ Assim como o particionamento vertical divide uma tabela verticalmente em v√°rias tabelas, o particionamento horizontal pega fatias horizontais  de  uma  tabela  e  as  armazena  como tabelas  distintas.  Por  exemplo,  os  dados  de vendas de produto podem ser separados em dez tabelas com base em dez linhas de produtos. Cada tabela tem o mesmo conjunto de colunas (atributos), mas cont√©m um conjunto distinto de produtos (tuplas). Se uma consulta ou transa√ß√£o se aplica a todos os dados do produto, ela pode ter de ser executada novamente contra todas as tabelas e os resultados podem ter de ser combinados.

Esses tipos de ajustes projetados para atender ao grande volume de consultas ou transa√ß√µes, com ou sem sacrificar as formas normais, s√£o comuns na pr√°tica.

## 20.2.3 Ajustando consultas

J√° discutimos como o desempenho da consulta depende da sele√ß√£o apropriada de √≠ndices, e como os √≠ndices podem ter de ser ajustados ap√≥s analisar as consultas que oferecem desempenho fraco usando os comandos no SGBDR que mostram o plano de execu√ß√£o da consulta. Existem principalmente duas indica√ß√µes que sugerem que o ajuste da consulta pode ser necess√°rio:

- 1. Uma consulta emite muitos acessos ao disco (por  exemplo,  uma  consulta  com  combina√ß√£o exata varre uma tabela inteira).
- 2. O plano de consulta mostra que √≠ndices relevantes n√£o est√£o sendo usados.

Alguns casos t√≠picos de situa√ß√µes que precisam de ajuste de consulta incluem os seguintes:

- 1. Muitos  otimizadores  de  consulta  n√£o  usam √≠ndices na presen√ßa de express√µes aritm√©ticas (como Salario/ 365 &gt; 10,50), compara√ß√µes num√©ricas de atributos de diferentes tamanhos e  precis√£o  (como Aqtd = Bqtd, onde Aqtd √© do tipo INTEGER e Bqtd √© do tipo SMALLINTEGER) , compara√ß√µes NULL (como Datanasc IS NULL ) e compara√ß√µes de substring (como Unome LIKE '%eira').
- 2. √çndices n√£o costumam ser usados para consultas aninhadas usando IN; por  exemplo, a consulta a seguir:

SELECT Cpf WHERE Dnr IN (

FROM FUNCIONARIO

SELECT Dnumero FROM DEPARTA- MENTO WHERE Cpf\_ger = '33344555587' );

pode n√£o usar o √≠ndice em Dnr em FUNCIONARIO, enquanto o uso de Dnr = Dnumero na cl√°usula WHERE com uma consulta de √∫nico bloco pode fazer que o √≠ndice seja utilizado.

- 3. Alguns DISTINCT s podem ser redundantes e ser evitados sem alterar o resultado. Um DISTINCT normalmente causa uma opera√ß√£o de ordena√ß√£o e deve ser evitado ao m√°ximo poss√≠vel.
- 4. O uso desnecess√°rio de tabelas de resultado tempor√°rias  pode  ser  evitado  ao  se  reduzir consultas m√∫ltiplas em uma √∫nica consulta, a menos que a rela√ß√£o tempor√°ria seja necess√°ria para algum processamento intermedi√°rio.
- 5. Em algumas situa√ß√µes envolvendo o uso de consultas correlacionadas, os tempor√°rios s√£o √∫teis. Considere a consulta a seguir, que recupera o funcion√°rio com maior sal√°rio em cada departamento:

SELECT

Cpf

FROM

FUNCIONARIO F

WHERE

Salario = (

SELECT MAX Salario )

FROM FUNCIONARIO AS M

WHERE M.Dnr = F.Dnr ;

Isso tem o potencial perigoso de pesquisar toda a tabela FUNCIONARIO interna M em busca de cada

tupla da tabela FUNCIONARIO externa F. Para tornar a execu√ß√£o mais eficiente, o processo pode ser desmembrando em duas consultas, onde a primeira consulta simplesmente calcula o sal√°rio m√°ximo em cada departamento, da seguinte forma:

SELECT

MAX  Salario ( ) AS Salario\_alto, Dnr INTO TEMP

FROM

FUNCIONARIO

GROUP BY

Dnr;

SELECT

Cpf.FUNCIONARIO

FROM

FUNCIONARIO  TEMP ,

WHERE

FUNCIONARIO.Salario = TEMP . Salario\_alto

AND FUNCIONARIO.Dnr = TEMP.Dnr ;

- 6. Se v√°rias op√ß√µes para uma condi√ß√£o de jun√ß√£o s√£o poss√≠veis, escolha uma que utilize um √≠ndice de agrupamento e evite aquelas que cont√™m compara√ß√µes de string. Por exemplo, supondo que o atributo Nome seja uma chave candidata em FUNCIONARIO e ALUNO, √© melhor usar FUNCIONARIO.Cpf  =  ALUNO.Cpf como  uma condi√ß√£o de jun√ß√£o em vez de FUNCIONARIO. Nome = ALUNO.Nome se Cpf tiver um √≠ndice de agrupamento em uma ou ambas as tabelas.
- 7. Uma  peculiaridade  com  alguns  otimizadores de consulta √© que a ordem das tabelas na cl√°usula FROM pode afetar o processamento da jun√ß√£o. Se isso acontecer, pode ser preciso trocar essa ordem para que a menor das duas rela√ß√µes  seja  varrida  e  a  rela√ß√£o  maior  seja usada com um √≠ndice apropriado.
- 8. Alguns otimizadores de consulta funcionam pior em consultas aninhadas em compara√ß√£o com  seus  correspondentes  n√£o  aninhados. Existem quatro tipos de consultas aninhadas:
- ¬Ñ Subconsultas n√£o correlacionadas com agrega√ß√µes em uma consulta interna.
- ¬Ñ Subconsultas n√£o correlacionadas sem agrega√ß√µes.
- ¬Ñ Subconsultas  correlacionadas  com  agrega√ß√µes em uma consulta interna.
- ¬Ñ Subconsultas correlacionadas sem agrega√ß√µes.

Desses quatro tipos, o primeiro normalmente n√£o apresenta problema, pois a maioria dos otimizadores de consulta avalia a consulta interna primeiro.

Por√©m, para uma consulta do segundo tipo, como o exemplo no item 2, a maioria dos otimizadores de consulta pode n√£o usar um √≠ndice em Dnr em FUNCIONARIO. No  entanto,  os  mesmos  otimizadores podem fazer isso se a consulta for gravada como n√£o aninhada. A transforma√ß√£o de subconsultas correlacionadas pode envolver a configura√ß√£o de tabelas tempor√°rias. Exemplos detalhados est√£o fora de nosso escopo aqui. 6

- 9. Finalmente,  muitas  aplica√ß√µes  s√£o  baseadas em vis√µes que definem os dados de interesse para essas aplica√ß√µes. √Äs vezes, essas vis√µes se  tornam  exageradas  porque  uma consulta pode  ser  proposta  diretamente  contra  uma tabela da base, em vez de passar por uma vis√£o que √© definida por uma JUN√á√ÉO .

## 20.2.4 Orienta√ß√µes adicionais de ajuste de consulta

T√©cnicas adicionais para melhorar as consultas se aplicam a certas situa√ß√µes, como a seguir:

- 1. Uma consulta com m√∫ltiplas condi√ß√µes de sele√ß√£o que s√£o conectadas por OR ou podem n√£o estar pedindo ao otimizador de consulta para usar qualquer √≠ndice. Tal consulta pode ser dividida e expressa como uma uni√£o de consultas, cada qual com uma condi√ß√£o em um atributo que causa o uso de um √≠ndice. Por exemplo,

SELECT

Pnome  Unome  Salario, Idade , , 7 FUNCIONARIO

FROM

WHERE

Idade &gt; 45 OR Salario &lt; 50.000;

pode  ser  executado  usando  varredura  sequencial, gerando  um  desempenho  fraco. Dividindo-o como

SELECT

Pnome  Unome  Salario  Idade , , , FUNCIONARIO

FROM

WHERE

Idade &gt; 45

UNION

SELECT

Pnome  Unome  Salario  Idade , , ,

FROM

FUNCIONARIO

WHERE

Salario &lt; 50.000;

pode utilizar √≠ndices em Idade e  tamb√©m em Salario .

- 2. Para ajudar a agilizar a consulta, as seguintes transforma√ß√µes podem ser experimentadas:

6 Para obter mais detalhes, consulte Shasha e Bonnet (2002).

7 Modificamos o esquema e usamos Idade em FUNCIONARIO em vez de Data\_nasc .

- ¬Ñ A condi√ß√£o NOT pode ser transformada em uma express√£o positiva.
- ¬Ñ Blocos SELECT embutidos usando IN, = ALL, = ANY e = SOME podem ser substitu√≠dos por jun√ß√µes.
- ¬Ñ Se uma jun√ß√£o de igualdade for configurada entre duas tabelas, o predicado de intervalo (condi√ß√£o de sele√ß√£o) no atributo de jun√ß√£o configurado em uma tabela pode ser repetido para a outra tabela.
- ¬Ñ Condi√ß√µes WHERE podem ser reescritas para utilizar os √≠ndices em m√∫ltiplas colunas. Por exemplo,

SELECT

Num\_regiao  Tipo\_prod  Mes, Vendas , , ESTATISTICAS\_VENDAS

FROM

WHERE

Num\_regiao = 3 AND (( Tipo\_prod BETWEEN 1 AND 3) OR ( Tipo\_prod

BETWEEN 8 AND 10));

pode usar um √≠ndice apenas em Num\_regiao e pesquisar todas as p√°ginas folha do √≠ndice para uma combina√ß√£o em Tipo\_prod. Em vez disso, usar

SELECT

Num\_regiao  Tipo\_prod  Mes  Vendas , , , ESTATISTICAS\_VENDAS

FROM

WHERE

Num\_regiao ( = 3 AND ( Tipo\_prod BETWEEN 1 AND 3))

OR ( Num\_regiao = 3 AND ( Tipo\_

prod BETWEEN 8 AND 10));

pode usar um √≠ndice composto em ( Num\_regiao, Tipo\_prod ) e atuar de modo muito mais eficiente.

Nesta  se√ß√£o,  abordamos  muitos  dos  casos  comuns em que a inefici√™ncia de uma consulta pode ser fixada por alguma a√ß√£o corretiva simples, como o uso de  uma tabela tempor√°ria, evitando certos tipos de constru√ß√µes de consulta, ou evitando o uso de vis√µes.

- O objetivo  √©  fazer  que  o  SGBDR  utilize  √≠ndices  de atributo √∫nico ou atributos compostos existentes tanto  quanto  poss√≠vel.  Isso  evita  varreduras  completas dos blocos de dados ou a varredura inteira dos n√≥s folha  do  √≠ndice.  Os  processos  redundantes,  como  a classifica√ß√£o, devem ser evitados a qualquer custo. Os problemas e as solu√ß√µes depender√£o do funcionamento de um otimizador de consulta dentro do SGBDR.

Existe literatura detalhada nos guias de ajuste de banco de dados para a administra√ß√£o de banco de dados pelos  fornecedores  de  SGBDR.  A  maioria  dos  fornecedores de SGBD relacional, como Oracle, IBM e Microsoft, encoraja seus maiores clientes a compartilharem ideias de ajuste nas exposi√ß√µes anuais e outros f√≥runs, de modo que o setor inteiro se beneficia com o uso das t√©cnicas de melhoria de desempenho. Essas t√©cnicas normalmente est√£o dispon√≠veis na literatura do setor e em diversos sites da Web.

## Resumo

Neste cap√≠tulo, discutimos os fatores que afetam as decis√µes de projeto f√≠sico do banco de dados e oferecemos orienta√ß√µes  para  escolher  entre  as  alternativas  do projeto f√≠sico. Discutimos as mudan√ßas no projeto l√≥gico, como a desnormaliza√ß√£o, bem como as modifica√ß√µes de √≠ndices, e mudan√ßas nas consultas para ilustrar diferentes  t√©cnicas  para  o  ajuste  de  desempenho  do  banco de dados. Estas s√£o apenas uma amostra representativa de  um grande n√∫mero de medidas e t√©cnicas adotadas no projeto de grandes aplica√ß√µes comerciais de SGBDs relacionais.

## Perguntas de revis√£o

- 20.1. Quais  s√£o  os  fatores  importantes  que  influen- ciam o projeto f√≠sico do banco de dados?

- 20.2. Discuta as decis√µes tomadas durante o projeto f√≠sico do banco de dados.

- 20.3. Discuta as orienta√ß√µes para o projeto f√≠sico do banco de dados nos SGBDRs.

- 20.4. Discuta os tipos de modifica√ß√µes que podem ser aplicadas ao projeto l√≥gico de um banco de da- dos relacional.

- 20.5 Sob que situa√ß√µes a desnormaliza√ß√£o de um es- quema de banco de dados seria usada? D√™ exem- plos de desnormaliza√ß√£o.

- 20.6. Discuta o ajuste de √≠ndices para bancos de dados relacionais.

- 20.7. Discuta as considera√ß√µes para reavaliar e modifi- car consultas em SQL.

- 20.8. Ilustre os tipos de mudan√ßas nas consultas SQL que precisam ser consideradas para a melhoria do desempenho durante o ajuste do banco de dados.

## Bibliografia selecionada

Wiederhold (1987) aborda quest√µes relacionadas ao projeto f√≠sico. O'Neil e O'Neil (2001) t√™m uma discuss√£o detalhada  do  projeto  f√≠sico  e  quest√µes  de  transa√ß√£o  em refer√™ncia  a  SGBDRs comerciais. Navathe e Kerschberg (1986) discutem todas as fases do projeto de banco de dados e apontam o papel dos dicion√°rios de dados. Rozen e Shasha (1991) e Carlis e March (1984) apresentam diferentes modelos para o problema do projeto f√≠sico do banco de dados. Shasha e Bonnet (2002) t√™m uma discuss√£o elaborada das orienta√ß√µes para ajuste de banco de dados. Niemiec (2008) √© um entre v√°rios livros dispon√≠veis para administra√ß√£o e ajuste de banco de dados Oracle. Schneider (2006) √© voltado para o projeto e o ajuste de bancos de dados MySQL.





Processamento de transa√ß√µes, controle de concorr√™ncia e recupera√ß√£o



## Introdu√ß√£o aos conceitos e teoria de processamento de transa√ß√µes

O conceito de transa√ß√£o oferece um mecanismo para descrever unidades l√≥gicas de processamento de banco  de  dados.  Os sistemas  de  processamento de transa√ß√£o s√£o sistemas com grandes bancos de dados e centenas de usu√°rios simult√¢neos que executam transa√ß√µes de banco de dados. Alguns exemplos desses  sistemas  incluem  reservas  a√©reas,  sistemas  banc√°rios, processamento de cart√£o de cr√©dito, compras on-line, mercados de a√ß√µes, caixas de supermercado e  muitas  outras  aplica√ß√µes.  Esses  sistemas  exigem alta disponibilidade e tempo de resposta r√°pido para centenas  de  usu√°rios  simult√¢neos.  Neste  cap√≠tulo, apresentamos  os  conceitos  necess√°rios  em  sistemas de processamento de transa√ß√£o. Definimos o conceito de uma transa√ß√£o, que √© usado para representar uma unidade l√≥gica de processamento de banco de dados  que  deve  ser  conclu√≠da  por  inteiro  para  garantir a exatid√£o. Uma transa√ß√£o normalmente √© implementada por um programa de computador, que inclui comandos de banco de dados como recupera√ß√µes, inser√ß√µes, exclus√µes e atualiza√ß√µes. Apresentamos algumas das t√©cnicas b√°sicas para programa√ß√£o de banco de dados nos cap√≠tulos 13 e 14.

um sistema de banco de dados. A Se√ß√£o 21.2 define o termo transa√ß√£o e discute conceitos adicionais relacionados ao processamento de transa√ß√£o nos sistemas de banco de dados. A Se√ß√£o 21.3 apresenta as propriedades importantes de atomicidade, a preserva√ß√£o de consist√™ncia, o isolamento e a durabilidade ou perman√™ncia - chamadas propriedades ACID -, que s√£o consideradas desej√°veis nos sistemas de processamento de transa√ß√£o. A Se√ß√£o 21.4 apresenta o conceito  de  schedules  (ou  hist√≥ricos)  de  execu√ß√£o de transa√ß√µes e caracteriza sua recuperabilidade .  A Se√ß√£o 21.5 discute a no√ß√£o de serializa√ß√£o da  execu√ß√£o concorrente da transa√ß√£o, que pode ser usada para definir as sequ√™ncias de execu√ß√£o corretas (ou schedules) de transa√ß√µes simult√¢neas. Na Se√ß√£o 21.6, apresentamos alguns dos comandos que d√£o suporte ao conceito de transa√ß√£o em SQL. No final do cap√≠tulo h√° um resumo.

Neste  cap√≠tulo,  focalizamos  os  conceitos  b√°sicos e a teoria necess√°rios para garantir a execu√ß√£o correta  das  transa√ß√µes.  Discutimos  o  problema  de controle de concorr√™ncia, que ocorre quando v√°rias transa√ß√µes submetidas por diversos usu√°rios interferem umas com as outras de uma maneira que produz  resultados  incorretos.  Tamb√©m  discutimos  os problemas que podem ocorrer quando as transa√ß√µes falham, e como o sistema de banco de dados pode se recuperar de diversos tipos de falhas.

Este cap√≠tulo √© organizado da seguinte forma: a Se√ß√£o 21.1 discute informalmente por que o controle de concorr√™ncia e recupera√ß√£o s√£o necess√°rios em

Os dois cap√≠tulos seguintes fornecem mais detalhes sobre os m√©todos e t√©cnicas reais usadas para dar suporte ao processamento de transa√ß√£o. O Cap√≠tulo 22 oferece uma vis√£o geral dos protocolos b√°sicos de controle de concorr√™ncia e o Cap√≠tulo 23 introduz as t√©cnicas de recupera√ß√£o.

## 21.1 ntrodu√ß√£o ao processamento I de transa√ß√µes

Nesta se√ß√£o, discutimos os conceitos de execu√ß√£o concorrente  de  transa√ß√µes  e  recupera√ß√£o  de  transa√ß√µes  com  falhas.  A  Se√ß√£o  21.1.1  compara  sistemas de banco de dados de monousu√°rio e multiusu√°rios, e demonstra como a execu√ß√£o simult√¢nea de transa√ß√µes pode ocorrer nos sistemas multiusu√°rios. A Se√ß√£o 21.1.2 define o conceito de transa√ß√£o e apresenta um modelo simples de execu√ß√£o de transa√ß√£o base-

ado em opera√ß√µes de leitura e grava√ß√£o de banco de dados. Esse modelo √© usado como base para definir e formalizar os conceitos de controle de concorr√™ncia e  recupera√ß√£o.  A  Se√ß√£o  21.1.3  utiliza  exemplos  informais para mostrar por que as t√©cnicas de controle de concorr√™ncia s√£o necess√°rias em sistemas multiusu√°rios. Por fim, a Se√ß√£o 21.1.4 discute por que s√£o necess√°rias t√©cnicas para lidar com a recupera√ß√£o do sistema e falhas de transa√ß√£o, discutindo as diferentes maneiras como as transa√ß√µes podem falhar quando s√£o executadas.

## 21.1.1 Sistemas de monousu√°rio versus multiusu√°rio

Um crit√©rio para classificar um sistema de banco de dados √© de acordo com o n√∫mero de usu√°rios que  podem  usar  o  sistema simultaneamente . Um SGBD √© monousu√°rio se no m√°ximo um usu√°rio de cada  vez  pode  utilizar  o  sistema,  e  √© multiusu√°rio se  muitos  usu√°rios  puderem  faz√™-lo  -  e,  portanto, acessar  o  banco  de  dados  -  simultaneamente.  Os SGBDs  monousu√°rio  s√£o  principalmente  restritos  a sistemas  de  computador  pessoal;  a  maioria  dos  outros SGBDs √© multiusu√°rio. Por exemplo, um sistema de reservas a√©reas √© acessado por centenas de agentes  de  viagens  e  funcion√°rios  de  reserva  de  maneira simult√¢nea.  Os  sistemas  de  banco  de  dados  usados em bancos,  ag√™ncias  de  seguros,  mercado  de  a√ß√µes, supermercados  e  muitas  outras  aplica√ß√µes  s√£o  de multiusu√°rios. Nesses sistemas, centenas ou milhares de usu√°rios normalmente est√£o operando no banco de dados ao submeter transa√ß√µes ao sistema ao mesmo tempo.

cada  vez.  Por√©m, sistemas  operacionais  de  multiprograma√ß√£o executam alguns comandos de um processo, depois suspendem esse processo e executam alguns comandos do processo seguinte, e assim por diante. Um processo  √©  retomado  no  ponto  em  que  foi  suspenso sempre que chega sua vez de usar a CPU novamente. Assim, a execu√ß√£o simult√¢nea dos processo √©, na realidade, intercalada , conforme ilustrado na Figura 21.1, que mostra dois processos, A e B, executando simultaneamente em um padr√£o intercalado. A intercala√ß√£o mant√©m a  CPU  ocupada  quando  um  processo  exige uma opera√ß√£o de entrada ou sa√≠da (E/S), como a leitura de um bloco do disco. A CPU √© trocada para executar outro processo, em vez de permanecer ociosa durante o tempo da E/S. A intercala√ß√£o tamb√©m impede que um processo longo atrase os demais processos.

Se o sistema de computa√ß√£o tiver m√∫ltiplos processadores de hardware (CPUs), o processamento paralelo de  v√°rios  processos  √©  poss√≠vel,  conforme  ilustrado pelos processos C e D da Figura 21.1. A maior parte da teoria referente ao controle de concorr√™ncia nos bancos de dados √© desenvolvida em rela√ß√£o √† concorr√™ncia  intercalada ,  de  modo  que,  para  o  restante  deste  cap√≠tulo,  assumiremos esse modelo. Em um SGBD multiusu√°rio, os itens de dados armazenados s√£o  os  recursos  principais  que  podem  ser  acessados simultaneamente por usu√°rios ou programas de aplica√ß√£o interativos, que est√£o sempre recuperando informa√ß√µes e modificando o banco de dados.

Multiusu√°rios podem acessar os bancos de dados - e usar sistemas de computa√ß√£o - simultanea  mente devido ao conceito da multiprograma√ß√£o , que permite que o sistema operacional do computador execute v√°rios programas - ou processos - ao mesmo tempo. Uma √∫nica  unidade  central  de  processamento  (CPU) pode executar apenas, e no m√°ximo, um processo de

## 21.1.2 ransa√ß√µes, itens de banco de T dados, opera√ß√µes de leitura e grava√ß√£o e buffers do SGBD

Uma transa√ß√£o √©  um  programa  em  execu√ß√£o que forma uma unidade l√≥gica de processamento de banco de dados. Ela inclui uma ou mais opera√ß√µes de acesso ao banco de dados - estas podem incluir opera√ß√µes  de  inser√ß√£o,  exclus√£o,  modifica√ß√£o  ou recupera√ß√£o.  As  opera√ß√µes  de  banco  de  dados  que



1

2

3

4

Figura 21.1 Processamento intercalado versus processamento paralelo de transa√ß√µes simult√¢neas.

formam uma transa√ß√£o podem ser embutidas em um programa de aplica√ß√£o  ou  podem  ser  especificadas interativamente por meio de uma linguagem de consulta de alto n√≠vel, como a SQL. Um modo de especificar os limites de transa√ß√£o √© determinando pelas instru√ß√µes expl√≠citas begin transaction e end transaction em um programa de aplica√ß√£o; nesse caso, todas as opera√ß√µes de acesso ao banco de dados entre os dois s√£o consideradas formando uma transa√ß√£o. Um √∫nico  programa  de  aplica√ß√£o  pode  conter  mais  de uma transa√ß√£o se tiver v√°rios limites de transa√ß√£o. Se as opera√ß√µes de banco de dados em uma transa√ß√£o n√£o atualizarem o banco de dados, mas apenas recuperarem dados, a transa√ß√£o √© chamada de transa√ß√£o somente de leitura ;  caso  contr√°rio,  ela  √©  conhecida como transa√ß√£o de leitura-grava√ß√£o .

O modelo  de  banco  de  dados utilizado  para apresentar conceitos de processamento de transa√ß√£o √© muito simples em compara√ß√£o com modelos de dados que discutimos anteriormente no livro, como o modelo relacional ou o modelo de objeto. Um banco de dados √© basicamente representado como uma cole√ß√£o  de itens  de  dados  nomeados .  O  tamanho de um item de dados √© chamado de sua granularidade . Um item de dados pode ser um registro de banco de dados ,  mas  tamb√©m  pode  ser  uma  unidade  maior, como  um bloco  de  disco inteiro,  ou  mesmo  uma unidade menor, como um valor de campo  atributo ( ) individual de algum registro no banco de dados. Os conceitos de processamento de transa√ß√£o que discutimos s√£o independentes da granularidade (tamanho) do item de dados e se aplicam a itens de dados em geral. Cada item de dados tem um nome √∫nico , mas esse nome em geral n√£o √© usado pelo programador; em vez disso, ele √© apenas um meio para identificar exclusivamente cada item de dados . Por exemplo, se a granularidade do item de dados for um bloco de disco, ent√£o o endere√ßo do bloco de disco pode ser utilizado como o nome do item de dados. Ao usar esse modelo de banco de dados simplificado, as opera√ß√µes b√°sicas de acesso ao banco de dados que uma transa√ß√£o pode incluir s√£o as seguintes:

- ¬Ñ read\_item ( X ). L√™ um item do banco de dados chamado X para uma vari√°vel do programa. Para simplificar nossa nota√ß√£o, consideramos que a  vari√°vel  de  programa  tamb√©m  √©  chamada X .
- ¬Ñ write\_item ( X ). Grava o valor da vari√°vel de programa X no item de banco de dados chamado X .

de b√°sica de transfer√™ncia de dados do disco para a mem√≥ria principal  √©  um  bloco.  A  execu√ß√£o  de  um comando read\_item ( X ) inclui as seguintes etapas:

- 1. Ache o endere√ßo do bloco de disco que cont√©m o item X .
- 2. Copie esse bloco de disco para um buffer na mem√≥ria principal (se esse bloco de disco ainda n√£o estiver em algum buffer da mem√≥ria principal).
- 3. Copie o item X do buffer para a vari√°vel de programa chamada X .

A execu√ß√£o de um comando write\_item ( X ) inclui as seguintes etapas:

- 1. Ache o endere√ßo do bloco de disco que cont√©m o item X .
- 2. Copie esse bloco de disco para um buffer na mem√≥ria principal (se esse bloco de disco ainda n√£o estiver em algum buffer da mem√≥ria principal).
- 3. Copie o item X da vari√°vel de programa chamada X para o local correto no buffer.
- 4. Armazene  o  bloco  atualizado  do  buffer  de volta no disco (imediatamente ou em algum momento posterior).

√â a etapa 4 que de fato atualiza o banco de dados no disco. Em alguns casos, o buffer n√£o √© imediatamente  armazenado  no  disco,  caso  mudan√ßas adicionais tenham de ser feitas no buffer. Em geral, a decis√£o sobre quando armazenar um bloco de disco modificado cujo conte√∫do est√° em um buffer da mem√≥ria principal √© tratado pelo gerenciador de recupera√ß√£o do SGBD em coopera√ß√£o com o sistema operacional subjacente. O SGBD manter√° na cache do banco de dados uma s√©rie de buffers de dados na mem√≥ria principal.  Cada  buffer  costuma  manter  o conte√∫do de um bloco de disco do banco de dados, que cont√©m alguns dos itens de banco de dados que est√£o sendo processados. Quando esses buffers est√£o todos ocupados, e blocos de disco de banco de dados adicionais devem ser copiados para a mem√≥ria, alguma pol√≠tica de substitui√ß√£o de buffer √© utilizada para escolher quais buffers atuais devem ser substitu√≠  dos. Se um buffer escolhido tiver de ser modificado, ele precisa ser gravado de volta no disco antes de ser reutilizado. 1

Conforme discutimos no Cap√≠tulo 17, a unida-

Uma  transa√ß√£o  inclui  opera√ß√µes read\_item e write\_item para acessar e atualizar o banco de dados. A Figura 21.2 mostra exemplos de duas transa√ß√µes muito simples. O conjunto de leitura de  uma tran-

1 N√£o discutiremos as pol√≠ticas de substitui√ß√£o de buffer aqui, pois elas normalmente s√£o abordadas em livros-texto sobre sistemas operacionais.

Figura 21.2 Duas transa√ß√µes de exemplo. (a) Transa√ß√£o T 1 . (b) T ransa√ß√£o T 2 .



sa√ß√£o √© o conjunto de todos os itens que a transa√ß√£o l√™, e o conjunto de grava√ß√£o √© o conjunto de todos os itens que a transa√ß√£o grava. Por exemplo, o conjunto de leitura de T 1 da Figura 21.2 √© { X Y , } e seu conjunto de grava√ß√£o tamb√©m √© { X Y , }.

Os mecanismos de controle de concorr√™ncia e recupera√ß√£o tratam principalmente dos comandos de  banco  de  dados  em  uma  transa√ß√£o.  As  transa√ß√µes submetidas pelos diversos usu√°rios podem ser  executadas  simultaneamente,  acessar  e  atualizar os mesmos itens de banco de dados. Se essa execu√ß√£o simult√¢nea for descontrolada ,  ela pode ocasionar  problemas,  como  um  banco  de  dados inconsistente.  Na  pr√≥xima  se√ß√£o,  apresentamos de  maneira  informal  alguns  dos  problemas  que podem ocorrer.

## 21.1.3 Por que o controle de concorr√™ncia √© necess√°rio

V√°rios problemas podem acontecer quando transa√ß√µes  simult√¢neas  s√£o  executadas  de  uma  maneira descontrolada. Ilustramos alguns desses problemas ao nos referirmos a um banco de dados de reservas a√©reas muito simplificado, em que um registro √© armazenado para cada voo. Cada registro inclui o n√∫mero de assentos reservados nesse voo como um item de dados nomeado (identific√°vel exclusivamente) ,  entre  outras informa√ß√µes. A Figura 21.2(a) mostra uma transa√ß√£o T 1 que transfere N reservas de um voo cujo n√∫mero de assentos reservados √© armazenado no item de banco de dados chamado X para outro voo cujo n√∫mero de assentos reservados √© armazenado no item de banco de dados chamado Y .  A Figura 21.2(b) mostra uma transa√ß√£o mais simples T 2 que apenas reserva M assentos no primeiro voo ( X ) referenciados na transa√ß√£o T 1 . 2 Para simplificar nosso exemplo, n√£o mostramos partes adicionais das transa√ß√µes, como a verifica√ß√£o de um voo ter assentos suficientes dispon√≠veis antes de reservar assentos adicionais.

Quando um programa de acesso ao banco de dados √© escrito, ele tem o n√∫mero do voo, a data do voo e o n√∫mero de assentos a serem reservados como par√¢metros; logo, o mesmo programa pode ser utilizado para executar muitas transa√ß√µes diferentes , cada uma com um n√∫mero diferente de voo, data e n√∫mero de assentos a serem reservados. Para fins de controle de concorr√™ncia, uma transa√ß√£o √© uma execu√ß√£o em particular de um programa em uma data, voo e n√∫mero de assentos espec√≠ficos. Na Figura 21.2(a) e (b), as transa√ß√µes T 1 e T 2 s√£o execu√ß√µes espec√≠ficas dos programas que se referem aos voos espec√≠ficos cujos n√∫meros de assentos s√£o armazenados nos itens de dados X e Y no banco de dados. Em seguida, discutimos os tipos de problemas que podemos encontrar com essas duas transa√ß√µes simples se elas forem executadas simultaneamente.

O problema da atualiza√ß√£o perdida. Esse  problema ocorre quando duas transa√ß√µes que acessam os mesmos itens do banco de dados t√™m suas opera√ß√µes intercaladas de modo que isso torna o valor de alguns  itens  do  banco  de  dados  incorreto.  Suponha que as transa√ß√µes T 1 e T 2 sejam submetidas aproximadamente ao mesmo tempo, e suponha que suas opera√ß√µes sejam intercaladas, como mostra a Figura  21.3(a);  ent√£o,  o  valor  final  do  item X √©  incorreto porque T 2 l√™ o valor de X antes que T 1 o mude no banco de dados, e, portanto, o valor atualizado resultante de T 1 √© perdido. Por exemplo, se X = 80 no in√≠cio (originalmente, havia 80 reservas no voo), N = 5 ( T 1 transfere cinco reservas de assento do voo correspondente a X para o voo correspondente a Y ), e M = 4 ( T 2 reserva quatro assentos em X ), o resultado final deveria ser X = 79. No entanto, na intercala√ß√£o de opera√ß√µes mostrada na Figura 21.3(a), ele √© X = 84, pois a atualiza√ß√£o em T 1 que removeu os cinco assentos de X foi perdida.

O problema da atualiza√ß√£o tempor√°ria (ou leitura suja). Esse problema ocorre quando uma transa√ß√£o atualiza um item do banco de dados e depois a transa√ß√£o falha por algum motivo (ver Se√ß√£o 21.1.4). Nesse meio-tempo, o item atualizado √© acessado (lido) por outra transa√ß√£o, antes de ser alterado de volta para seu valor original. A Figura 21.3(b) mostra um exemplo em que T 1 atualiza o item X e ent√£o falha antes de terminar, de modo que o sistema deve mudar X de volta para seu valor original. Contudo, antes que ele possa fazer isso, a transa√ß√£o T 2 l√™  o  valor  tempor√°rio de X , que n√£o ser√° gravado permanentemente no

2 Um exemplo semelhante, mais utilizado, considera um banco de dados banc√°rio, com uma transa√ß√£o realizando uma transfer√™ncia de fundos da conta X para a conta Y e outra transa√ß√£o realizando um dep√≥sito na conta X .

Figura 21.3



Alguns problemas que ocorrem quando a execu√ß√£o simult√¢nea n√£o √© controlada. (a) O problema da atualiza√ß√£o perdida. (b) O problema da atualiza√ß√£o tempor√°ria. (c) O problema do resumo incorreto.

banco de dados devido √† falha de T 1 . O valor do item X que foi lido por T 2 √© chamado de dado sujo, pois foi criado por uma transa√ß√£o que n√£o foi conclu√≠da nem confirmada; portanto, esse problema tamb√©m √© conhecido como problema de leitura suja.

O problema do resumo incorreto. Se uma transa√ß√£o est√° calculando uma fun√ß√£o de resumo de agrega√ß√£o em uma s√©rie  de  itens  de  banco  de  dados,  enquanto outras transa√ß√µes est√£o atualizando alguns desses itens, a fun√ß√£o de agrega√ß√£o pode calcular alguns valores antes que eles sejam atualizados e outros, depois que eles forem atualizados. Por exemplo, suponha que uma transa√ß√£o T 3 esteja calculando o n√∫mero total de reservas em todos os voos; enquanto isso, a transa√ß√£o T 1 est√° sendo executada. Se a intercala√ß√£o de opera√ß√µes  mostrada  na  Figura  21.3(c)  acontecer,  o  resultado  de T 3 estar√°  defasado  por  uma  quantidade N , pois T 3 l√™  o  valor  de X ap√≥s N assentos terem sido

subtra√≠dos dele, mas l√™ o valor de Y antes que esses N assentos tenham sido acrescentados.

O problema da leitura n√£o repetitiva. Outro problema que pode acontecer √© chamado de leitura n√£o repetitiva, em que uma transa√ß√£o T l√™ o mesmo item duas vezes e o item √© alterado por outra transa√ß√£o T '  entre  as  duas  leituras.  Logo, T recebe  valores diferentes  para  suas  duas  leituras  do  mesmo  item. Isso pode acontecer, por exemplo, se durante uma transa√ß√£o  de  reserva  a√©rea,  um  cliente  consultar  a disponibilidade de assento em v√°rios voos. Quando o cliente decide sobre um voo em particular, a transa√ß√£o ent√£o l√™ o n√∫mero de assentos nesse voo pela segunda  vez  antes  de  completar  a  reserva,  e  pode acabar lendo um valor diferente para o item.

## 21.1.4 Por que a recupera√ß√£o √© necess√°ria

Sempre que uma transa√ß√£o √© submetida a um SGBD para execu√ß√£o, o sistema √© respons√°vel por garantir que todas as opera√ß√µes na transa√ß√£o sejam conclu√≠das  com  sucesso  e  seu  efeito  seja  registrado permanentemente no banco de dados, ou que a transa√ß√£o  n√£o  tenha  qualquer  efeito  no  banco  de dados ou quaisquer outras transa√ß√µes. No primeiro caso, a transa√ß√£o √© considerada confirmada (committed), ao passo que, no segundo caso, a transa√ß√£o √© abortada .  O  SGBD n√£o deve permitir que algumas opera√ß√µes de uma transa√ß√£o T sejam aplicadas ao  banco  de  dados  enquanto  outras  opera√ß√µes  de T n√£o o s√£o, pois a transa√ß√£o inteira √© uma unidade l√≥gica de processamento de banco de dados. Se a  transa√ß√£o falhar depois  de  executar  algumas  de suas opera√ß√µes, mas antes de executar todas elas, as opera√ß√µes j√° executadas precisam ser desfeitas e n√£o t√™m efeito duradouro.

Tipos  de  falhas. As  falhas  geralmente  s√£o  classificadas  como  falhas  de  transa√ß√£o,  sistema  e  m√≠dia. Existem v√°rios motivos poss√≠veis para uma transa√ß√£o falhar no meio da execu√ß√£o:

- 1. Uma falha do computador (falha do sistema). Um erro de hardware, software ou rede no sistema  de  computa√ß√£o  durante  a  execu√ß√£o da  transa√ß√£o.  Falhas  do  hardware  normalmente s√£o falhas de m√≠dia - por exemplo, uma falha na mem√≥ria principal.
- 2. Um erro de transa√ß√£o ou do sistema. Alguma opera√ß√£o na transa√ß√£o pode fazer que esta falhe,  como um estouro de inteiro ou divis√£o por zero. A falha da transa√ß√£o tamb√©m pode
- ocorrer devido a valores de par√¢metro err√¥neos ou a um erro l√≥gico de programa√ß√£o. 3 Al√©m  disso,  o  usu√°rio  pode  interromper  a transa√ß√£o durante sua execu√ß√£o.
- 3. Erros locais  ou  condi√ß√µes  de  exce√ß√£o  detectadas pela transa√ß√£o. Durante a execu√ß√£o da transa√ß√£o, podem ocorrer certas condi√ß√µes que necessitam de cancelamento da transa√ß√£o.  Por  exemplo,  os  dados  da  transa√ß√£o podem n√£o ser encontrados. Uma condi√ß√£o de  exce√ß√£o, 4   como  um  saldo  de  conta  insuficiente em um banco de dados banc√°rio, pode  fazer  que  uma  transa√ß√£o,  como  um saque,  seja  cancelada.  Essa  exce√ß√£o  poderia ser programada na pr√≥pria transa√ß√£o, e nesse caso n√£o seria considerado uma falha da transa√ß√£o.
- 4. Imposi√ß√£o  de  controle  de  concorr√™ncia. O m√©todo de controle de concorr√™ncia (ver Cap√≠tulo 22) pode decidir abortar uma transa√ß√£o porque ela viola a serializa√ß√£o (ver Se√ß√£o 21.5), ou pode abortar uma ou mais transa√ß√µes para resolver um estado de deadlock entre  v√°rias  transa√ß√µes  (ver  Se√ß√£o  22.1.3).  As transa√ß√µes  abortadas  devido  a  viola√ß√µes  de serializa√ß√£o ou deadlock em geral s√£o reiniciadas automaticamente em outro momento.
- 5. Falha de disco. Alguns blocos de disco podem perder seus dados devido a um defeito de leitura, grava√ß√£o ou por causa de uma falha da cabe√ßa de leitura/grava√ß√£o. Isso pode acontecer durante uma opera√ß√£o de leitura ou grava√ß√£o da transa√ß√£o.
- 6. Problemas f√≠sicos e cat√°strofes. Isso  se  refere a uma lista sem fim de problemas que incluem falha de energia ou de ar-condicionado, inc√™ndio, roubo, sabotagem, regrava√ß√£o de discos ou fitas por engano e montagem da fita errada pelo operador.

As falhas dos tipos 1, 2, 3 e 4 s√£o mais comuns do que aquelas dos tipos 5 ou 6. Sempre que ocorre  uma falha dos tipos de 1 a 4, o sistema precisa manter informa√ß√µes suficientes para recuperar-se rapidamente da falha. A falha de disco ou outras falhas catastr√≥ficas de tipo 5 ou 6 n√£o acontecem com frequ√™ncia; se ocorrerem, a recupera√ß√£o √© uma tarefa importante. Discutiremos sobre a recupera√ß√£o de falhas no Cap√≠tulo 23.

- O  conceito  de  transa√ß√£o  √©  fundamental  para muitas t√©cnicas de controle de concorr√™ncia e recu-

3 Em geral, uma transa√ß√£o deve ser testada completamente para garantir que n√£o tenha quaisquer bugs (erros l√≥gicos de programa√ß√£o).

4 Condi√ß√µes de exce√ß√£o, se programadas corretamente, n√£o constituem falhas de transa√ß√£o.

pera√ß√£o de falhas.

## 21.2 Conceitos de transa√ß√£o e sistema

Nesta  se√ß√£o,  discutimos  conceitos  adicionais relevantes ao processamento de transa√ß√£o. A Se√ß√£o 21.2.1 descreve os diversos estados em que uma transa√ß√£o pode estar, e discute outras opera√ß√µes necess√°rias no processamento de transa√ß√£o. A Se√ß√£o 21.2.2 discute  o  log  do  sistema,  que  mant√©m  informa√ß√µes sobre  transa√ß√µes  e  itens  de  dados  que  ser√£o  necess√°rios para recupera√ß√£o. A Se√ß√£o 21.2.3 descreve o conceito  de  pontos  de  confirma√ß√£o  das  transa√ß√µes, e por que eles s√£o importantes no processamento da transa√ß√£o.

## 21.2.1 Estados de transa√ß√£o e opera√ß√µes adicionais

Uma transa√ß√£o √© uma unidade at√¥mica de trabalho, que deve ser conclu√≠da totalmente ou n√£o ser feita de forma alguma. Para fins de recupera√ß√£o, o sistema precisa registrar quando cada transa√ß√£o come√ßa, termina e confirma ou aborta (ver Se√ß√£o 21.2.3). Portanto, o gerenciador de recupera√ß√£o do SGBD precisa acompanhar as seguintes opera√ß√µes:

- ¬Ñ BEGIN\_TRANSACTION. Esta  marca  o  in√≠cio da execu√ß√£o da transa√ß√£o.
- ¬Ñ READ ou WRITE. Estas especificam opera√ß√µes de leitura ou grava√ß√£o nos itens do banco de dados que s√£o executados como parte de uma transa√ß√£o.
- ¬Ñ END\_TRANSACTION. Esta especifica que opera√ß√µes de transa√ß√£o READ e WRITE terminaram e marca o final da execu√ß√£o da transa-
- √ß√£o. Por√©m, nesse ponto pode ser necess√°rio verificar  se  as  mudan√ßas  introduzidas  pela transa√ß√£o podem ser permanentemente aplicadas ao banco de dados (confirmadas) ou se a transa√ß√£o precisa ser abortada, pois viola a serializa√ß√£o  (ver  Se√ß√£o  21.5)  ou  por  algum outro motivo.
- ¬Ñ COMMIT\_TRANSACTION. Esta sinaliza um final bem-sucedido da transa√ß√£o, de modo que quaisquer  mudan√ßas  (atualiza√ß√µes)  executadas  pela  transa√ß√£o  podem  ser  seguramente confirmadas (committed) ao banco de dados e n√£o ser√£o desfeitas.
- ¬Ñ ROLLBACK (ou ABORT ).  Esta  opera√ß√£o  sinaliza que a transa√ß√£o foi encerrada sem sucesso , de modo que quaisquer mudan√ßas ou efeitos que a transa√ß√£o possa ter aplicado ao banco de dados precisam ser desfeitos .

A Figura 21.4 mostra um diagrama de transi√ß√£o de estado que ilustra como uma transa√ß√£o percorre seus estados de execu√ß√£o. Uma transa√ß√£o entra em um estado  ativo imediatamente  ap√≥s  iniciar  a  execu√ß√£o,  onde  pode  executar  suas  opera√ß√µes READ e WRITE . Quando a transa√ß√£o termina, ela passa para o estado parcialmente confirmado . Nesse ponto, alguns  protocolos  de  recupera√ß√£o  precisam  garantir que uma falha no sistema n√£o resultar√° em uma incapacidade  de  registrar  as  mudan√ßas  da  transa√ß√£o permanentemente (em geral, gravando mudan√ßas no log do sistema, discutido na pr√≥xima se√ß√£o). 5  Quando essa verifica√ß√£o √© bem-sucedida, diz-se que a transa√ß√£o alcan√ßou seu ponto de confirma√ß√£o e ela entra no estado  confirmado .  Os  pontos  de  confirma√ß√£o ser√£o discutidos com mais detalhes na Se√ß√£o 21.2.3. Quando uma transa√ß√£o √© confirmada, ela concluiu sua execu√ß√£o com sucesso e todas as suas mudan√ßas

Figura 21.4



Diagrama de transi√ß√£o de estado ilustrando os estados para execu√ß√£o da transa√ß√£o.

5 O controle de concorr√™ncia otimista (ver Se√ß√£o 22.4) tamb√©m exige que certas verifica√ß√µes sejam feitas nesse ponto para garantir que a transa√ß√£o n√£o interfira em outras transa√ß√µes em execu√ß√£o.

6 O log √†s vezes √© chamado de di√°rio do SGBD .

precisam ser gravadas permanentemente no banco de dados, mesmo que haja uma falha no sistema.

Entretanto, uma transa√ß√£o pode ir para o estado de falha se uma das verifica√ß√µes falhar ou se a transa√ß√£o for abortada durante seu estado ativo. A transa√ß√£o pode ent√£o ter de ser cancelada para desfazer o efeito de suas opera√ß√µes WRITE no banco de dados. O estado terminado corresponde √† transa√ß√£o que sai do sistema. A informa√ß√£o da transa√ß√£o que √© mantida nas tabelas do sistema enquanto a transa√ß√£o estava rodando √© removida quando esta termina. As transa√ß√µes com falha ou abortadas podem ser reiniciadas depois - seja de maneira autom√°tica ou depois de serem  submetidas  outra  vez  pelo  usu√°rio  -  como transa√ß√µes totalmente novas.

## 21.2.2 O log do sistema

Para  poder  recuperar-se  de  falhas  que  afetam transa√ß√µes, o sistema mant√©m um log 6 para registrar todas as opera√ß√µes de transa√ß√£o que afetam os valores dos itens de banco de dados, bem como outras informa√ß√µes de transa√ß√£o que podem ser necess√°rias para permitir a recupera√ß√£o de falhas. O log √© um arquivo sequencial, apenas para inser√ß√£o, que √© mantido no disco, de modo que n√£o √© afetado por qualquer tipo de falha, exceto por falha de disco ou catastr√≥fica. Normalmente, um (ou mais) buffers de mem√≥ria mant√™m a √∫ltima parte do arquivo de log, de modo que as entradas do log s√£o primeiro acrescentadas ao buffer da mem√≥ria principal. Quando o buffer de log √© preenchido, ou quando ocorrem certas condi√ß√µes, o buffer de log √© anexado ao final do arquivo de log no disco . Al√©m disso, o arquivo de log do disco √© periodicamente copiado para arquivamento (fita), para proteger contra falhas catastr√≥ficas. A seguir est√£o os tipos de entradas - chamados registros de log - que s√£o gravados para o arquivo de log e a a√ß√£o correspondente para cada registro de log. Nessas entradas, T refere-se a uma id de transa√ß√£o exclusiva que √© gerada automaticamente pelo sistema para cada transa√ß√£o e que √© usada para identificar cada transa√ß√£o.

- 1. [ start\_transaction , T ]. Indica que a transa√ß√£o T iniciou sua execu√ß√£o.
- 2. [ write\_item , T X valor\_antigo , , , valor\_novo ] . Indica que a transa√ß√£o T mudou o valor do item  do  banco  de  dados X de valor\_antigo para valor\_novo.
- 3. [ read\_item , T X , ] .  Indica que a transa√ß√£o T leu o valor do item de banco de dados X .
- 4. [ commit , T ] .  Indica  que  a  transa√ß√£o T foi conclu√≠da com sucesso, e afirma que seu efei-

to  pode  ser  confirmado  (registrado  permanentemente) no banco de dados.

- 5. [ abort , T ] . Indica que a transa√ß√£o T foi abortada.

Protocolos  para  recupera√ß√£o  que  evitam  propaga√ß√£o de rollbacks (ver Se√ß√£o 21.4.2) - que incluem  quase  todos  os  protocolos  pr√°ticos  n√£o exigem que opera√ß√µes READ sejam gravadas no log do  sistema.  Contudo,  se  o  log  tamb√©m  for  usado para outras finalidades - como auditoria (mantendo registro de todas as opera√ß√µes do banco de dados) -, ent√£o essas entradas podem ser inclu√≠das. Al√©m disso, alguns protocolos de recupera√ß√£o que exigem entradas WRITE mais simples s√≥ incluem um valor\_novo ou valor\_antigo em vez de incluir ambos (ver Se√ß√£o 21.4.2).

Observe que n√£o estamos assumindo que todas as mudan√ßas permanentes no banco de dados ocorrem nas transa√ß√µes, de modo que a no√ß√£o de recupera√ß√£o  de  uma  falha  de  transa√ß√£o  equivale a  desfazer  ou  refazer  opera√ß√µes  de  transa√ß√£o  individualmente  com  base  no  log.  Se  o  sistema  falhar, podemos recuperar para um estado coerente do banco de dados ao examinar o log e usar uma das t√©cnicas descritas no Cap√≠tulo 23. Como o log cont√©m um registro de cada opera√ß√£o WRITE que muda o valor de algum item do banco de dados, √© poss√≠vel desfazer o efeito dessas opera√ß√µes WRITE de  uma  transa√ß√£o T rastreando  o  log  de  volta e retornando todos os itens alterados por uma opera√ß√£o WRITE de T a seus valores\_antigos . Tamb√©m pode ser necess√°rio refazer uma opera√ß√£o se uma transa√ß√£o tiver suas atualiza√ß√µes registradas no log, mas houver uma falha antes que o sistema possa estar certo de que todos esses novos\_valores tenham sido gravados no banco de dados real em disco com base nos buffers da mem√≥ria principal. 7

## 21.2.3 Ponto de confirma√ß√£o de uma transa√ß√£o

Uma transa√ß√£o T alcan√ßa seu ponto de confirma√ß√£o quando todas as suas opera√ß√µes que acessam o banco de dados tiverem sido executadas com sucesso e o efeito de todas as opera√ß√µes de transa√ß√£o no banco  de  dados  tiverem  sido  registradas  no  log.  Al√©m do ponto de confirma√ß√£o, a transa√ß√£o √© considerada confirmada ,  e  seu  efeito  deve ser registrado permanentemente no  banco  de  dados.  A  transa√ß√£o  ent√£o grava um registro de confirma√ß√£o [ commit, T ] no log. Se houver uma falha no sistema, podemos pesquisar de volta no log para todas as transa√ß√µes T que gravaram um registro [ start\_transaction, T ] no log, mas

7 Desfazer e refazer s√£o opera√ß√µes discutidas de maneira mais completa no Cap√≠tulo 23.

ainda n√£o gravaram seu registro [ commit, T ].  Essas transa√ß√µes  podem  ter  de  ser descartadas  (rollback) para desfazer seu efeito sobre o banco de dados durante o processo de recupera√ß√£o. As transa√ß√µes que gravaram seu registro de confirma√ß√£o no log tamb√©m devem ter gravado todas as suas opera√ß√µes WRITE no log, de modo que seu efeito no banco de dados possa ser refeito com base nos registros de log.

Observe que o arquivo de log precisa ser mantido no disco. Conforme discutimos no Cap√≠tulo 17, a atualiza√ß√£o de um arquivo do disco envolve copiar o bloco apropriado do arquivo para um buffer na mem√≥ria principal, atualizar o buffer na mem√≥ria principal e copiar o buffer para o disco. √â comum manter um ou mais blocos do arquivo de log nos buffers da mem√≥ria principal, chamado buffer de log , at√© que eles sejam preenchidos com entradas de log e, depois, grav√°-los de volta ao disco apenas uma vez, ao inv√©s de gravar em disco toda vez que uma entrada de log √© acrescentada. Isso economiza o overhead de v√°rias grava√ß√µes de disco do mesmo buffer do arquivo de log. No momento de uma falha do sistema, apenas as entradas de log que foram gravadas de volta para o disco s√£o consideradas no processo de recupera√ß√£o,  pois  o  conte√∫do  da  mem√≥ria  principal pode ser perdido. Logo, antes que uma transa√ß√£o alcance seu ponto de confirma√ß√£o, qualquer parte do log que ainda n√£o tenha sido gravada no disco deve agora s√™-lo. Esse processo √© chamado de grava√ß√£o for√ßada do buffer de log antes da confirma√ß√£o de uma transa√ß√£o.

## 21.3 Propriedades desej√°veis das transa√ß√µes

As  transa√ß√µes  devem  possuir  v√°rias  propriedades,  normalmente  chamadas  propriedades ACID; elas devem ser impostas pelos m√©todos de controle de concorr√™ncia e recupera√ß√£o do SGBD. A seguir est√£o as propriedades ACID:

- ¬Ñ Atomicidade. Uma transa√ß√£o √© uma unidade de processamento at√¥mica; ela deve ser realizada em sua totalidade ou n√£o ser realizada de forma alguma.
- ¬Ñ Preserva√ß√£o da consist√™ncia. Uma transa√ß√£o deve  preservar  a  consist√™ncia,  significando que, se ela for completamente executada do in√≠cio ao fim sem interfer√™ncia de outras transa√ß√µes, deve levar o banco de dados de um estado consistente para outro.
- ¬Ñ Isolamento. Uma transa√ß√£o deve parecer como se  fosse  executada  isoladamente  de  outras transa√ß√µes, embora muitas delas estejam sen-
- do  executadas  de  maneira  simult√¢nea.  Ou seja, a execu√ß√£o de uma transa√ß√£o n√£o deve ser  interferida  por  quaisquer  outras  transa√ß√µes que acontecem simultaneamente.
- ¬Ñ Durabilidade ou perman√™ncia. As mudan√ßas aplicadas ao banco de dados pela transa√ß√£o confirmada  precisam  persistir  no  banco  de dados. Essas mudan√ßas n√£o devem ser perdidas por causa de alguma falha.

A propriedade de atomicidade exige que executemos uma transa√ß√£o at√© o fim. √â responsabilidade do subsistema  de  recupera√ß√£o  de  transa√ß√£o de  um SGBD garantir a atomicidade. Se uma transa√ß√£o n√£o for completada por algum motivo, como uma falha no sistema no meio da execu√ß√£o da transa√ß√£o, a t√©cnica de recupera√ß√£o precisa desfazer quaisquer efeitos da transa√ß√£o no banco de dados. Por sua vez, as opera√ß√µes de grava√ß√£o de uma transa√ß√£o confirmada devem ser, por fim, gravadas no disco.

A preserva√ß√£o da consist√™ncia geralmente  √©  considerada  uma  responsabilidade  dos  programadores que escrevem os programas de banco de dados ou do m√≥dulo de SGBD que imp√µe restri√ß√µes de integridade. Lembre-se de que um estado de banco de dados √© uma cole√ß√£o de todos os itens de dados armazenados (valores)  no  banco  de  dados  em  determinado  ponto  no tempo. Um estado consistente do banco de dados satisfaz as restri√ß√µes especificadas no esquema, bem como quaisquer outras restri√ß√µes no banco de dados que devem ser mantidas. Um programa de banco de dados deve ser escrito de modo que garanta que, se o banco de dados estiver em um estado consistente antes de executar a transa√ß√£o, ele estar√° em um estado consistente depois de concluir a execu√ß√£o da transa√ß√£o, supondo que n√£o haja interfer√™ncia em outras transa√ß√µes .

A propriedade  de  isolamento √©  imposta  pelo subsistema de controle de concorr√™ncia do SGBD. 8 Se cada transa√ß√£o n√£o tornar suas atualiza√ß√µes (opera√ß√µes de grava√ß√£o) vis√≠veis para outras transa√ß√µes at√©  que  seja  confirmada, uma forma de isolamento √©  imposta para solucionar o problema da atualiza√ß√£o tempor√°ria e eliminar rollback em cascata (ver Cap√≠tulo 23), mas ela n√£o elimina todos os outros problemas. Tem havido tentativas de definir o n√≠vel de  isolamento de  uma transa√ß√£o. Uma transa√ß√£o √© considerada como tendo isolamento de n√≠vel 0 (zero) se n√£o gravar sobre as leituras sujas das transa√ß√µes de n√≠vel mais alto. O isolamento de n√≠vel 1 (um) n√£o tem atualiza√ß√µes perdidas, e o isolamento de n√≠vel 2 n√£o tem atualiza√ß√µes perdidas ou leituras sujas. Finalmente, o isolamento de n√≠vel 3 (tamb√©m chamado

8 Discutiremos os protocolos de controle de concorr√™ncia no Cap√≠tulo 22.

9 A sintaxe SQL para o n√≠vel de isolamento, discutida mais adiante na Se√ß√£o 21.6, est√° bastante relacionada a esses n√≠veis.

isolamento verdadeiro )  tem,  al√©m das propriedades de n√≠vel 2, leituras repetitivas. 9

E  por  fim,  a propriedade  de  durabilidade √©  a responsabilidade  do subsistema  de  recupera√ß√£o do SGBD. Vamos apresentar o modo como os protocolos de recupera√ß√£o imp√µem a durabilidade e a atomicidade na pr√≥xima se√ß√£o, para discutirmos isso com mais detalhes no Cap√≠tulo 23.

## 21.4 Caracterizando schedules com base na facilidade de recupera√ß√£o

Quando as transa√ß√µes est√£o executando simultaneamente em um padr√£o intercalado, ent√£o a ordem da execu√ß√£o das opera√ß√µes de todas as diversas transa√ß√µes √© conhecida como um schedule (ou hist√≥rico ). Nesta se√ß√£o, primeiro definimos o conceito de schedules e, depois, caracterizamos os tipos de sched  ules que facilitam a recupera√ß√£o quando ocorrem falhas. Na Se√ß√£o 21.5, caracterizamos os schedules em rela√ß√£o  √†  interfer√™ncia  das  transa√ß√µes  participantes, levando aos conceitos de serializa√ß√£o e schedules serializ√°veis.

## 21.4.1 Schedules (hist√≥ricos) de transa√ß√µes

Um schedule (ou hist√≥rico ) S de n transa√ß√µes T 1 , T 2 , ..., T n √© uma ordena√ß√£o das opera√ß√µes das transa√ß√µes. As opera√ß√µes das diferentes transa√ß√µes podem ser intercaladas no schedule S .  Contudo, para cada transa√ß√£o T i que participa no schedule S ,  as  opera√ß√µes de T i em S precisam aparecer na mesma ordem em que ocorrem em T i . A ordem das opera√ß√µes em S √© considerada uma ordena√ß√£o total , significando que para duas opera√ß√µes quaisquer no schedule, uma precisa ocorrer antes da outra. √â poss√≠vel teoricamente lidar com schedules cujas opera√ß√µes formam ordens parciais (conforme discutiremos mais adiante), mas consideraremos por enquanto a ordena√ß√£o total das opera√ß√µes em um schedule.

Para  fins  de  recupera√ß√£o  e  controle  de  concorr√™ncia,  estamos  interessados  principalmente nas  opera√ß√µes read\_item e write\_item das  transa√ß√µes,  bem  como  nas  opera√ß√µes commit e abort . Uma nota√ß√£o abreviada para descrever um schedule utiliza os s√≠mbolos b , r   w   e   c , , , e a para as opera√ß√µes begin\_transaction, read\_item, write\_item, end\_transaction, commit e abort, respectivamente, e  acrescenta  como  um subscrito a  id  da  transa√ß√£o  (n√∫mero  da  transa√ß√£o)  a  cada  opera√ß√£o  no schedule. Nessa nota√ß√£o, o item de banco de dados X que √© lido ou gravado segue as opera√ß√µes r e w entre  par√™nteses.  Em  alguns  schedules,  s√≥ mostraremos as opera√ß√µes read e write , enquanto em outros, mostraremos todas as opera√ß√µes. Por exemplo, o schedule na Figura 21.3(a), que chamaremos de S a , pode ser escrito da seguinte forma nessa nota√ß√£o:

<!-- formula-not-decoded -->

De modo semelhante, o schedule para a Figura 21.3(b),  que  chamamos S b ,  pode  ser  escrito  da  seguinte forma, se considerarmos que a transa√ß√£o T 1 foi cancelada ap√≥s sua opera√ß√£o read\_item ( Y ):

<!-- formula-not-decoded -->

Duas  opera√ß√µes  em  um  schedule  s√£o  consideradas  como  entrando  em conflito se  satisfizerem  a todas as tr√™s condi√ß√µes a seguir: (1) elas pertencem a diferentes  transa√ß√µes ;  (2)  elas  acessam  o mesmo item X ;  e  (3) pelo menos uma das  opera√ß√µes √© um write\_item ( X ).  Por exemplo, no schedule S a ,  as  opera√ß√µes r 1 ( X ) e w X 2 ( ) est√£o em conflito, assim como as  opera√ß√µes r 2 ( X )  e w X 1 ( )  e  as  opera√ß√µes w 1 ( X )  e w X 2 ( ).  No  entanto,  as  opera√ß√µes r 1 ( X )  e r 2 ( X )  n√£o est√£o em conflito, pois ambas s√£o opera√ß√µes de leitura; as opera√ß√µes w X 2 ( ) e w Y 1 ( ) n√£o est√£o em conflito porque operam em itens de dados distintos X e Y ; e as opera√ß√µes r 1 ( X ) e w X 1 ( )  n√£o est√£o em conflito porque pertencem √† mesma transa√ß√£o.

Intuitivamente,  duas  opera√ß√µes  est√£o  em  conflito se a mudan√ßa de sua ordem puder resultar em algo  diferente.  Por  exemplo,  se  mudarmos  a  ordem das duas opera√ß√µes r 1 ( X ); w X 2 ( )  para w 2 ( X ); r 1 ( X ), ent√£o o valor de X que √© lido pela transa√ß√£o T 1 muda,  pois  na  segunda  ordem  o  valor  de X √© mudado por w X 2 ( ) antes que seja lido por r 1 ( X ), enquanto na primeira ordem o valor √© lido antes de ser alterado. Isso √© chamado de conflito de leitura-grava√ß√£o .  O  outro tipo √© chamado de conflito de grava√ß√£o-grava√ß√£o , e √© ilustrado pelo caso em que mudamos a ordem das duas opera√ß√µes como w X 1 ( ); w X 2 ( ) para w X  w 2 ( ); 1 ( X ). Para um conflito de grava√ß√£o-grava√ß√£o, o √∫ltimo valor de X ser√° diferente porque em um caso ele √© gravado por T 2 e no outro caso, por T 1 . Observe que duas opera√ß√µes de leitura n√£o est√£o em conflito, porque mudar sua ordem n√£o faz diferen√ßa no resultado.

O restante desta se√ß√£o aborda algumas defini√ß√µes te√≥ricas com rela√ß√£o a schedules. Um schedule S de n transa√ß√µes T 1 , T 2 ,  ..., T n √©  considerado um schedule completo se as seguintes condi√ß√µes forem mantidas:

- 1. As  opera√ß√µes  em S s√£o  exatamente  aquelas opera√ß√µes em T 1 , T 2 , ..., T n , incluindo uma  opera√ß√£o  de  confirma√ß√£o  ou  cancela-

mento como √∫ltima opera√ß√£o em cada transa√ß√£o no schedule.

- 2. Para  qualquer  par  de  opera√ß√µes  da  mesma transa√ß√£o T i , sua ordem de aparecimento relativa em S √© a mesma que sua ordem de aparecimento em T i .
- 3. Para  duas  opera√ß√µes  quaisquer  em  conflito, uma das duas precisa ocorrer antes da outra no schedule. 10

A condi√ß√£o anterior (3) permite que duas opera√ß√µes n√£o em conflito ocorram no mesmo sched  ule sem definir qual ocorre primeiro, levando assim √† defini√ß√£o de um schedule como uma ordem parcial das opera√ß√µes nas n transa√ß√µes. 11 Por√©m, uma ordem total precisa ser especificada no schedule para qualquer par de opera√ß√µes em conflito (condi√ß√£o 3) e para qualquer par de opera√ß√µes da mesma transa√ß√£o (condi√ß√£o 2). A condi√ß√£o 1 simplesmente indica que todas as opera√ß√µes nas transa√ß√µes precisam aparecer no schedule completo. Como cada transa√ß√£o √© confirmada ou cancelada, um schedule completo n√£o ter√° quaisquer transa√ß√µes ativas ao final do schedule.

Em geral, √© dif√≠cil encontrar schedules completos em um sistema de processamento de transa√ß√£o, pois  novas  transa√ß√µes  est√£o  sendo  continuamente submetidas ao sistema. Logo, √© √∫til definir o conceito  da proje√ß√£o  confirmada C S ( )  de  um  schedule S , que inclui apenas as opera√ß√µes em S que pertencem a transa√ß√µes confirmadas - ou seja, transa√ß√µes T i cuja opera√ß√£o de confirma√ß√£o c i est√° em S .

## 21.4.2 Caracterizando schedules com base na facilidade de recupera√ß√£o

Para alguns schedules, √© f√°cil recuperar-se de falhas de transa√ß√£o e sistema, enquanto para outros o processo de recupera√ß√£o pode ser bem complicado. Em alguns casos, nem sequer √© poss√≠vel recuperar-se corretamente ap√≥s uma falha. Portanto, √© importante caracterizar os tipos de schedules para os quais a recupera√ß√£o  √©  poss√≠vel ,  bem  como  aqueles  para  os quais  a recupera√ß√£o  √©  relativamente  simples .  Essas caracteriza√ß√µes n√£o oferecem de fato o algoritmo de recupera√ß√£o;  elas  s√≥  tentam  caracterizar  de  modo te√≥  rico os diferentes tipos de schedules.

durabilidade das transa√ß√µes n√£o √© violada (ver Se√ß√£o 21.3). Os schedules que teoricamente atendem a esse crit√©rio s√£o chamados schedules recuper√°veis ; aqueles que n√£o o fazem s√£o chamados n√£o recuper√°veis e,  portanto,  n√£o  devem  ser  permitidos  pelo  SGBD. A defini√ß√£o de schedules  recuper√°veis √©  a  seguinte: um schedule S √© recuper√°vel se nenhuma transa√ß√£o T em S for confirmada at√© que todas as transa√ß√µes T ', que tiverem gravado algum item X que T l√™,  sejam confirmadas. Uma transa√ß√£o T l√™ da transa√ß√£o T ' em um schedule S se algum item X for gravado primeiro  por T '  e  depois  lido  por T .  Al√©m  disso, T '  n√£o deve  ser  cancelado  antes  que T leia  o  item X ,  e n√£o deve haver transa√ß√µes que gravam X depois que T ' o grave e antes que T o leia (a menos que essas transa√ß√µes, se houver, forem abortadas antes que T leia X ).

Alguns schedules recuper√°veis podem exigir um processo de recupera√ß√£o complexo, conforme veremos, mas se forem mantidas informa√ß√µes suficientes (no  log),  um  algoritmo  de  recupera√ß√£o  poder√°  ser criado para qualquer schedule recuper√°vel. Os schedules (parciais) S a e S b da se√ß√£o anterior s√£o ambos recuper√°veis, pois satisfazem a defini√ß√£o acima. Considere o schedule S a '  dado a seguir, que √© o mesmo que o schedule S a , exceto que duas opera√ß√µes de confirma√ß√£o foram acrescentadas a S a :

<!-- formula-not-decoded -->

S a ' √©  recuper√°vel,  embora  sofra  do  problema da atualiza√ß√£o; esse problema √© tratado pela teoria da serializa√ß√£o  (ver  Se√ß√£o  21.5).  Por√©m,  considere  os dois schedules (parciais) S c e S d a seguir:

S c : r 1 ( X  w ); 1 ( X  r ); 2 ( X  r ); 1 ( Y  w ); 2 ( X  c ); 2 ; a 1 ; S d : r 1 ( X  w ); 1 ( X  r ); 2 ( X  r ); 1 ( Y  w ); 2 ( X  w ); 1 ( Y  c ); 1 ; c 2 ; ;

S e : r 1 ( X  w ); 1 ( X  r ); 2 ( X  r ); 1 ( Y  w ); 2 ( X  w ); 1 ( Y  a ); 1 ; a 2

Primeiro, gostar√≠amos de garantir que, quando uma transa√ß√£o T √© confirmada, nunca deve ser necess√°rio cancelar T . Isso garante que a propriedade de

S c n√£o √© recuper√°vel porque T 2 l√™ o item X de T 1 , mas T 2 confirma antes que T 1 confirme. O problema ocorre se T 1 abortar  depois  da  opera√ß√£o c 2 em S c , ent√£o o valor de X que T 2 l√™ n√£o √© mais v√°lido e T 2 precisa  ser  abortado depois de  ser  confirmado, levando a um schedule que n√£o √© recuper√°vel . Para o schedule ser recuper√°vel, a opera√ß√£o c 2 em S c precisa  ser  adiada  at√©  depois  de T 1 confirmar, como mostramos em S d .  Se T 1 abortar  em  vez  de confirmar, ent√£o T 2 tamb√©m deve abortar, conforme mostrado em S e , pois o valor de X lido n√£o √© mais v√°lido. Em S e ,  abortar T 2 √©  aceit√°vel porque ainda

10 Teoricamente, n√£o √© necess√°rio determinar uma ordem entre pares de opera√ß√µes n√£o em conflito .

11 Na pr√°tica, a maioria dos schedules possui uma ordem total de opera√ß√µes. Se o processamento paralelo for empregado, na teoria √© poss√≠vel ter schedules com opera√ß√µes n√£o em conflito parcialmente ordenadas.

n√£o foi confirmado, o que n√£o √© o caso para o schedule n√£o recuper√°vel S c .

Em um schedule recuper√°vel, nenhuma transa√ß√£o confirmada precisa ser cancelada e, portanto, a defini√ß√£o da transa√ß√£o confirmada como dur√°vel n√£o √©  violada.  Por√©m,  √©  poss√≠vel  que  um  fen√¥meno  conhecido como rollback em cascata (ou propaga√ß√£o de cancelamento )  ocorra em alguns schedules recuper√°veis, no qual uma transa√ß√£o n√£o confirmada foi cancelada porque leu um item de uma transa√ß√£o que falhou. Isso √© ilustrado no schedule S e , onde a transa√ß√£o T 2 foi cancelada porque leu o item X de T 1 , e T 1 ent√£o foi cancelada.

Como o rollback em cascata pode ser muito demorado - pois diversas transa√ß√µes podem ser canceladas (ver Cap√≠tulo 23) -, √© importante caracterizar os schedules nos quais esse fen√¥meno certamente n√£o ocorrer√°. Um schedule √© considerado sem cascata , ou que evita  o  rollback  em  cascata ,  se  cada  transa√ß√£o nele ler apenas itens que foram gravados por transa√ß√µes confirmadas. Nesse caso, todos os itens lidos n√£o  ser√£o  descartados,  de  modo  que  nenhum  rollback em cascata ocorrer√°. Para satisfazer esse crit√©rio, o comando r 2 ( X ) nos schedules S d e S e precisam ser adiados at√© depois que T 1 tiver sido confirmada (ou  cancelada),  adiando  assim T 2 ,  mas  garantindo que n√£o haja rollback em cascata se T 1 for cancelada.

Finalmente, existe um terceiro tipo de schedule, mais restritivo, chamado schedule estrito ,  em que as transa√ß√µes n√£o podem ler nem gravar um item X at√© que a √∫ltima transa√ß√£o que gravou X tenha sido confirmada (ou cancelada). Schedules estritos simplificam o processo de recupera√ß√£o. Em um schedule estrito, o processo de desfazer uma opera√ß√£o write\_item ( X )  de uma transa√ß√£o abortada serve apenas para restaurar a imagem anterior ( valor\_antigo ou BFIM) do item de dados X . Esse procedimento simples sempre funciona corretamente  para  schedules  estritos,  mas  pode  n√£o funcionar para schedules recuper√°veis ou sem cascata. Por exemplo, considere o schedule S f :

<!-- formula-not-decoded -->

Suponha que o valor de X fosse originalmente 9, que √© a imagem anterior armazenada no log do sistema junto com a opera√ß√£o w X 1 ( , 5). Se T 1 for cancelada, como em S f , o procedimento de recupera√ß√£o que restaura a imagem anterior de uma opera√ß√£o de grava√ß√£o cancelada restaurar√° o valor de X para 9, embora j√° tenha sido alterado para 8 pela transa√ß√£o T 2 ,  levando,  ent√£o,  a  resultados  potencialmente  incorretos. Embora o schedule S f seja sem cascata, ele n√£o √© um schedule estrito, pois permite que T 2 grave o item X embora a transa√ß√£o T 1 , que gravou X por

√∫ltimo, ainda n√£o tenha sido confirmada (ou cancelada). Um schedule estrito n√£o tem esse problema.

√â importante observar que qualquer schedule estrito tamb√©m √© sem cascata, e qualquer schedule sem cascata tamb√©m √© recuper√°vel. Suponha que tenhamos   transa√ß√µes i T 1 , T 2 , ..., T i , e seu n√∫mero de opera√ß√µes seja n 1 , n 2 , ..., n i , respectivamente. Se criarmos um conjunto de todos os schedules poss√≠veis dessas transa√ß√µes,  podemos  dividir  os  schedules  em  dois subconjuntos disjuntos: recuper√°veis e n√£o recuper√°veis. Os schedules sem cascata ser√£o um subconjunto dos schedules recuper√°veis, e os schedules estritos ser√£o um subconjunto dos schedules sem cascata. Assim,  todos  os  schedules  estritos  s√£o  sem  cascata,  e todos os schedules sem cascata s√£o recuper√°veis.

## 21.5 Caracterizando schedules com base na facilidade de serializa√ß√£o

Na  se√ß√£o  anterior,  caracterizamos  os  schedules com base em suas propriedades de facilidade de recupera√ß√£o. Agora, caracterizamos os tipos de schedules que s√£o  sempre  considerados corretos quando  transa√ß√µes concorrentes  est√£o  sendo  executadas.  Esses  schedules s√£o conhecidos como schedules serializ√°veis . Suponha que dois usu√°rios - por exemplo, dois agentes de reservas a√©reas - submetam √†s transa√ß√µes do SGBD T 1 e T 2 da Figura 21.2 aproximadamente ao mesmo tempo. Se nenhuma intercala√ß√£o de opera√ß√µes for permitida, existem apenas dois resultados poss√≠veis:

- 1. Executar todas as opera√ß√µes da transa√ß√£o T 1 (em sequ√™ncia) seguidas por todas as opera√ß√µes da transa√ß√£o T 2 (em sequ√™ncia).
- 2. Executar todas as opera√ß√µes da transa√ß√£o T 2 (em sequ√™ncia) seguidas por todas as opera√ß√µes da transa√ß√£o T 1 (em sequ√™ncia).

Esses  dois  schedules  -  chamados schedules  seriais - s√£o mostrados na Figura 21.5(a) e (b), respectivamente. Se a intercala√ß√£o de opera√ß√µes for permitida, haver√° muitas ordens poss√≠veis em que o sistema pode executar as opera√ß√µes individuais das transa√ß√µes. Dois schedules poss√≠veis aparecem na Figura 21.5(c). O conceito de serializa√ß√£o de schedules √© usado para identificar  quais  schedules  est√£o  corretos  quando  as execu√ß√µes da transa√ß√£o tiverem intercala√ß√£o de suas opera√ß√µes nos schedules. Esta se√ß√£o define a serializa√ß√£o e discute como ela pode ser usada na pr√°tica.

## 21.5.1 Schedules seriais, n√£o seriais e serializ√°veis por conflito

Os schedules A e B da Figura 21.5(a) e (b) s√£o



Schedule A



Schedule C

Schedule B





Schedule D

Figura 21.5

Exemplos de schedules seriais e n√£o seriais envolvendo as transa√ß√µes T  e T . (a) Schedule serial A: T  seguida por T . (b) 1 2 1 2 Schedule serial B: T  seguida por T . (c) Dois schedules n√£o seriais C e D com intercala√ß√£o de opera√ß√µes. 2 1

chamados  de seriais porque  as  opera√ß√µes  de  cada transa√ß√£o  s√£o  executadas  consecutivamente,  sem quaisquer  opera√ß√µes  intercaladas  da  outra  transa√ß√£o. Em um schedule serial, transa√ß√µes inteiras s√£o realizadas em ordem serial: T 1 e, depois, T 2 na Figura 21.5(a), e T 2 e, depois, T 1 na Figura 21.5(b). Os schedules C e D da Figura 21.5(c) s√£o chamados de n√£o seriais ,  pois cada sequ√™ncia intercala opera√ß√µes das duas transa√ß√µes.

correto . Podemos assumir isso porque cada transa√ß√£o √© considerada correta se executada por conta pr√≥pria (de acordo com a propriedade de preserva√ß√£o de consist√™ncia da Se√ß√£o 21.3). Logo, n√£o importa qual transa√ß√£o √© executada em primeiro lugar. Desde que cada transa√ß√£o seja executada do in√≠cio ao fim isoladamente das opera√ß√µes das outras transa√ß√µes, obtemos um resultado correto no banco de dados.

De mesma forma, um schedule S √© serial se, para cada transa√ß√£o T participante do schedule, todas as opera√ß√µes  de T forem  executadas  consecutivamente no schedule; caso contr√°rio, o schedule √© chamado de n√£o serial . Portanto, em um schedule serial, somente uma transa√ß√£o de cada vez est√° ativa - o commit (ou abort) da transa√ß√£o ativa inicia a execu√ß√£o da pr√≥xima transa√ß√£o. N√£o ocorre nenhuma intercala√ß√£o em um schedule serial. Uma suposi√ß√£o razo√°vel que podemos fazer, se considerarmos que as transa√ß√µes s√£o independentes , √© que cada schedule serial √© considerado

O problema com os schedules seriais √© que eles limitam a concorr√™ncia ao proibir a intercala√ß√£o de opera√ß√µes.  Em  um  schedule  serial,  se  uma  transa√ß√£o  espera  que  uma  opera√ß√£o  de  E/S  termine,  n√£o podemos passar o processador da CPU para outra transa√ß√£o, desperdi√ßando assim um valioso tempo de processamento da CPU. Al√©m disso, se alguma transa√ß√£o T for muito longa, as outras transa√ß√µes dever√£o esperar at√© que T termine todas as suas opera√ß√µes antes de poderem come√ßar. Portanto, os schedules seriais s√£o considerados inaceit√°veis na pr√°tica. Por√©m, se pudermos determinar quais outros schedules s√£o

(b)

equivalentes a um schedule serial, podemos permitir que estes ocorram.

Para ilustrar nossa discuss√£o, considere os schedules da Figura 21.5 e considere que os valores iniciais  dos  itens  de  banco  de  dados  sejam X =  90  e Y = 90, e que N = 3 e M = 2. Depois de executar as transa√ß√µes T 1 e T 2 , esperamos que os valores do banco de dados sejam X = 89 e Y = 93, de acordo com o significado das transa√ß√µes. Com certeza, a execu√ß√£o dos  schedules  seriais  A  ou  B  produz  os  resultados corretos. Agora, considere os schedules n√£o seriais C e D. O schedule C (que √© o mesmo da Figura 21.3(a)) produz os resultados X = 92 e Y = 93, em que o valor X est√° errado, enquanto o schedule D produz os resultados corretos.

O schedule C produz um resultado errado devido ao problema da atualiza√ß√£o perdida , discutido na Se√ß√£o 21.1.3. A transa√ß√£o T 2 l√™  o  valor de X antes de ele ser alterado pela transa√ß√£o T 1 ,  de  modo que somente o efeito de T 2 em X √© refletido no banco de dados. O efeito de T 1 em X √© perdido ,  sobrescrito por T 2 ,  levando ao resultado incorreto para o item X .  No entanto, alguns schedules n√£o seriais produzem o resultado correto esperado, como o schedule D.  Gostar√≠amos de determinar quais dos schedules n√£o seriais sempre produzem o resultado correto e quais podem gerar resultados err√¥neos. O conceito utilizado para caracterizar schedules dessa maneira √© o da serializa√ß√£o de um schedule.

A defini√ß√£o de schedule serializ√°vel √© a seguinte: um schedule S de n transa√ß√µes  √© serializ√°vel se  for equivalente  a  algum  schedule  serial das  mesmas n transa√ß√µes.  Definiremos  o  conceito  de equival√™ncia de schedules em breve. Observe que existem n ! schedules seriais poss√≠veis de n transa√ß√µes e muito mais schedules n√£o seriais poss√≠veis. Podemos formar dois grupos distintos dos schedules n√£o seriais - aqueles que s√£o equivalentes a um (ou mais) dos schedules seriais  e,  portanto,  que  s√£o  serializ√°veis,  e  aqueles que n√£o s√£o equivalentes a qualquer schedule serial e, portanto, n√£o s√£o serializ√°veis.

Dizer que um schedule n√£o serial S √© serializ√°vel √© equivalente a dizer que ele √© correto, pois √© equivalente a um schedule serial, que √© considerado correto. A pergunta que resta √©: quando dois schedules s√£o considerados equivalentes ?

Existem v√°rias maneiras de definir a equival√™ncia de schedule. A defini√ß√£o mais simples, por√©m menos satisfat√≥ria, envolve comparar os efeitos dos sched  ules no banco de dados. Dois schedules s√£o chamados equivalentes no resultado se produzirem o mesmo estado final do banco de dados. Contudo, dois schedules diferentes podem acidentalmente produzir o mesmo estado final. Por exemplo, na Figura 21.6, os sched  ules

S 1 e S 2 produzir√£o o mesmo estado de banco de dados final se forem executados em um banco de dados com um valor inicial de X = 100; por√©m, para outros valores iniciais de X , os schedules n√£o s√£o equivalentes no  resultado.  Al√©m  disso,  esses  schedules  executam transa√ß√µes  diferentes,  de  modo  que  definitivamente n√£o dever√£o ser  considerados  equivalentes.  Assim,  a equival√™ncia isolada no resultado n√£o pode ser usada para definir a equival√™ncia de schedules. A t√©cnica mais segura e mais geral para definir a equival√™ncia de schedule √© n√£o fazer quaisquer suposi√ß√µes sobre os tipos de opera√ß√µes inclu√≠das nas transa√ß√µes. Para dois schedules serem equivalentes, as opera√ß√µes aplicadas a cada item de dados afetado pelos schedules devem ser aplicadas a esse item nos dois schedules na mesma ordem . Duas defini√ß√µes de equival√™ncia de schedules costumam ser usadas: equival√™ncia de conflito e equival√™ncia de vis√£o . Vamos discutir a equival√™ncia de conflito em seguida, que √© a defini√ß√£o mais utilizada.

A defini√ß√£o de equival√™ncia de conflito dos schedules √© a seguinte: dois schedules s√£o considerados equivalentes  em  conflito se  a  ordem  de  duas opera√ß√µes em conflito quaisquer for a mesma nos dois schedules. Lembre-se, da Se√ß√£o 21.4.1, que duas opera√ß√µes em um schedule s√£o consideradas em conflito se pertencerem a transa√ß√µes diferentes, acessarem o mesmo item do banco de dados, e se uma ou ambas forem opera√ß√µes write\_item ou uma for um write\_item e a outra, um read\_item. Se duas opera√ß√µes em conflito  forem  aplicadas  em ordens  diferentes em  dois schedules,  o  efeito  pode  ser  diferente  no  banco  de dados  ou  nas  transa√ß√µes  no  schedule,  e,  portanto, os  schedules  n√£o  s√£o  equivalentes  em  conflito.  Por exemplo,  conforme  discutimos  na  Se√ß√£o  21.4.1,  se uma opera√ß√£o de leitura e grava√ß√£o ocorrer na ordem r 1 ( X ), w X 2 ( ) no schedule S 1 , e na ordem contr√°ria w X  r 2 ( ), 1 ( X ) no schedule S 2 , o valor lido por r 1 ( X ) pode ser diferente nos dois schedules. De modo semelhante, se duas opera√ß√µes de grava√ß√£o ocorrerem na ordem w X 1 ( ), w X 2 ( ) em S 1 , e na ordem contr√°ria w X 2 ( ), w X 1 ( )  em S 2 ,  a  pr√≥xima  opera√ß√£o r X ( )  nos dois schedules ler√° valores potencialmente diferentes; ou, ent√£o, se estas forem as √∫ltimas opera√ß√µes gra-

Figura 21.6





Dois schedules que s√£o equivalentes no resultado para o valor inicial de X = 100, mas n√£o s√£o equivalentes no resultado em geral.

vando o item X nos schedules, o valor final do item X no banco de dados ser√° diferente.

Usando a no√ß√£o de equival√™ncia de conflito, definimos  um  schedule S como  sendo serializ√°vel  de conflito 12 se ele for equivalente (em conflito) a algum schedule  serial S '.  Nesse  caso,  podemos  reordenar as  opera√ß√µes n√£o  em  conflito em S at√©  formarmos o schedule serial equivalente S '. De acordo com essa defini√ß√£o, o schedule D da Figura 21.5(c) √© equivalente ao schedule serial A da Figura 21.5(a). Em ambos os schedules, o read\_item ( X ) de T 2 l√™ o valor de X gravado por T 1 , enquanto as outras opera√ß√µes read\_ item leem os valores do banco de dados com base no estado inicial do banco de dados. Al√©m disso, T 1 √© a √∫ltima transa√ß√£o a gravar Y , e T 2 √© a √∫ltima transa√ß√£o a gravar X nos dois schedules. Como A √© um schedule serial e o schedule D √© equivalente a A, D √© um schedule serializ√°vel. Observe que as opera√ß√µes r 1 ( Y )  e w Y 1 ( )  do  schedule  D  n√£o  est√£o  em  conflito com as opera√ß√µes r 2 ( X ) e w X 2 ( ), pois acessam itens de dados diferentes. Portanto, podemos mover r 1 ( Y ), w Y 1 ( ) antes de r 2 ( X  w ), 2 ( X ), levando ao schedule serial equivalente T 1 , T 2 .

O schedule C da Figura 21.5(c) n√£o √© equivalente a qualquer um dos dois poss√≠veis schedules seriais A e B, e, portanto, n√£o √© serializ√°vel . Tentar reordenar as opera√ß√µes do schedule C para encontrar um schedule serial equivalente gera uma falha, pois r 2 ( X ) e w X 1 ( ) est√£o em conflito, o que significa que n√£o podemos mover r 2 ( X ) para baixo para obter o sched  ule serial equivalente T 1 , T 2 . De modo semelhante, como w X 1 ( ) e w X 2 ( ) est√£o em conflito, n√£o podemos mover w X 1 ( ) para baixo para obter o schedule serial equivalente T 2 , T 1 .

Outra  defini√ß√£o  de  equival√™ncia,  mais  complexa  chamada equival√™ncia de vis√£o , que leva ao conceito de serializa√ß√£o de vis√£o -, √© discutida na Se√ß√£o 21.5.4.

## 21.5.2 estando a serializa√ß√£o por T conflito de um schedule

Existe  um  algoritmo  simples  para  determinar se  determinado  schedule  √©  serializ√°vel  de  conflito ou n√£o. A maioria dos m√©todos de controle de concorr√™ncia n√£o testa realmente a serializa√ß√£o. Em vez disso,  protocolos  ou  regras  s√£o  desenvolvidas  para garantir que qualquer schedule que siga essas regras ser√°  serializ√°vel.  Discutimos  aqui  o  algoritmo  para testar a serializa√ß√£o de conflito dos schedules, para entendermos melhor esses protocolos de controle de concorr√™ncia, que ser√£o discutidos no Cap√≠tulo 22.

O Algoritmo 21.1 pode ser usado para testar um schedule para serializa√ß√£o de conflito. O algoritmo examina apenas as opera√ß√µes read\_item e write\_item em um schedule para construir um grafo de preced√™ncia (ou grafo de serializa√ß√£o ), o qual √© um grafo direcionado G = ( N E , ) que consiste em um conjunto de n√≥s N = { T 1 , T 2 , ..., T n } e um conjunto de arestas direcionadas A = { a 1 , a 2 , ..., a n }. Existe um n√≥ no grafo para cada transa√ß√£o T i no schedule. Cada aresta e i no grafo tem a forma ( T j ‚Üí T k ), 1 ‚â§ j ‚â§ n , 1 ‚â§ k ‚â§ n , onde T j √© o n√≥ inicial de a i e T k √© o n√≥ final de a i . Tal aresta do n√≥ T j ao n√≥ T k √© criada pelo algoritmo se uma das opera√ß√µes em T j aparecer no schedule antes de alguma opera√ß√£o de conflito em T k .

Algoritmo 21.1. Testando a serializa√ß√£o de conflito de um schedule S

- 1. Para  cada  transa√ß√£o T i participante  no  schedule S ,  crie  um  n√≥  rotulado  com T i no  grafo  de preced√™ncia.
- 2. Para  cada  caso  em S onde T j executa  um read\_item ( X ) depois de T i executar um write\_item ( X ),  crie  uma  aresta  ( T i ‚Üí T j )  no grafo de preced√™ncia.
- 3. Para cada caso em S onde T j executa um write\_ item ( X ) ap√≥s T i executar um read\_item ( X ), crie uma aresta ( T i ‚Üí T j ) no grafo de preced√™ncia.
- 4. Para cada caso em S onde T j executa um write\_ item ( X ) ap√≥s T i executar um write\_item ( X ), crie uma aresta ( T i ‚Üí T j ) no grafo de preced√™ncia.
- 5. O schedule S √© serializ√°vel se, e somente se, o grafo de preced√™ncia n√£o tiver ciclos.

O grafo de preced√™ncia √© constru√≠do conforme descrito no Algoritmo 21.1. Se houver um ciclo no grafo  de  preced√™ncia,  o  schedule S n√£o  √©  serializ√°vel (conflito); se n√£o houve ciclo, S √© serializ√°vel. Um ciclo em um grafo direcionado √© uma sequ√™ncia de arestas C = (( T j ‚Üí T k ), ( T k ‚Üí T p ), ..., ( T i ‚Üí T j )) com a propriedade de que o n√≥ inicial de cada aresta exceto a primeira aresta - √© o mesmo que o n√≥ final da aresta anterior, e o n√≥ inicial da primeira aresta √© o mesmo que o n√≥ final da √∫ltima aresta (a sequ√™ncia come√ßa e termina no mesmo n√≥).

No grafo de preced√™ncia, uma aresta de T i para T j significa  que  a  transa√ß√£o T i precisa  vir  antes  da transa√ß√£o T j em  qualquer  schedule  serial  que  seja equivalente a S , pois duas opera√ß√µes em conflito aparecem no schedule nessa ordem. Se n√£o houver ciclo no grafo de preced√™ncia, podemos criar um schedule serial equivalente S ' que √© equivalente a S , ordenando

12 Usaremos o termo serializ√°vel para indicar serializ√°vel de conflito. Outra defini√ß√£o de serializ√°vel usada na pr√°tica (ver Se√ß√£o 21.6) √© ter leituras repetitivas, n√£o leituras sujas, e nenhum registro fantasma (ver na Se√ß√£o 22.7.1 uma discuss√£o sobre fantasmas).

as transa√ß√µes que participam em S da seguinte forma: sempre que existir uma aresta no grafo de preced√™ncia de T i para T j , T i deve aparecer antes de T j no schedule  serial  equivalente S '. 13 Observe  que  as  arestas ( T i ‚Üí T j ) em um grafo de preced√™ncia opcionalmente podem ser rotuladas pelo(s) nome(s) do item (ou itens)  de  dados  que  leva(m)  √†  cria√ß√£o  da  aresta.  A Figura 21.7 mostra esses r√≥tulos nas arestas.

Em  geral,  v√°rios  schedules  seriais  podem  ser equivalentes  a S se  o  grafo  de  preced√™ncia  para S n√£o tiver ciclo. Contudo, se o grafo de preced√™ncia tiver um ciclo, √© f√°cil mostrar que n√£o podemos criar qualquer schedule serial equivalente, de modo que S n√£o √© serializ√°vel. Os grafos de preced√™ncia criados para os schedules A a D, respectivamente, na Figura 21.5, aparecem na Figura 21.7(a) a (d). O grafo para o schedule C tem um ciclo, de modo que n√£o √© serializ√°vel. O grafo para o schedule D n√£o tem ciclo, de modo que √© serializ√°vel, e o schedule serial equivalente √© T 1 seguido por T 2 . Os grafos para os schedules A e B n√£o t√™m ciclos, como √© de se esperar, pois os schedules s√£o seriais e, portanto, serializ√°veis.

haver mais de um schedule serial equivalente para um schedule serializ√°vel. A Figura 21.8(f) mostra um grafo de preced√™ncia representando um sched  ule que  tem  dois  schedules  seriais  equivalentes.  Para achar um schedule serial equivalente, comece com um n√≥ que n√£o tem quaisquer arestas chegando, e depois cuide para que a ordem dos n√≥s para cada aresta n√£o seja violada.

## 21.5.3 Como a serializa√ß√£o √© usada para controle de concorr√™ncia

Outro exemplo, em que tr√™s transa√ß√µes participam,  aparece  na  Figura  21.8.  A  Figura  21.8(a) mostra as opera√ß√µes read\_item e write\_item em cada transa√ß√£o.  Dois  schedules E e F para  essas  transa√ß√µes  s√£o  exibidos  na  Figura  21.8(b)  e  (c),  respectivamente, e os grafos de preced√™ncia para os schedules  E  e  F  aparecem  nas  partes  (d)  e  (e). O schedule E n√£o √© serializ√°vel porque o grafo de preced√™ncia correspondente tem ciclos. O schedule F √© serializ√°vel, e o schedule serial equivalente a F aparece  na  Figura  21.8(e).  Embora  s√≥  exista  um schedule serial equivalente para F , em geral, pode

Conforme discutimos  anteriormente,  dizer  que um schedule S √© serializ√°vel (de conflito) - ou seja, S √© equivalente (em conflito) a um schedule serial √©  equivalente  a  dizer  que S est√°  correto.  Contudo, ser serializ√°vel √© diferente de ser serial . Um schedule serial representa um processamento ineficiente, pois nenhuma  intercala√ß√£o  de  opera√ß√µes  de  diferentes transa√ß√µes √© permitida. Isso pode levar a uma baixa utiliza√ß√£o  de  CPU  enquanto  uma  transa√ß√£o  espera pela E/S de disco, ou que outra transa√ß√£o termine, dessa  forma,  atrasando  consideravelmente  o  processamento. Um schedule serializ√°vel oferece os benef√≠cios da execu√ß√£o concorrente sem abrir m√£o de qualquer exatid√£o. Na pr√°tica, √© muito dif√≠cil testar a serializa√ß√£o de um schedule. A intercala√ß√£o de opera√ß√µes de transa√ß√µes concorrentes - que normalmente s√£o executadas como processos pelo sistema operacional - costuma ser determinada pelo scheduler do sistema operacional, que aloca recursos para todos os processos. Fatores como carga do sistema, tempo de submiss√£o de transa√ß√£o e prioridades de processos contribuem para a ordena√ß√£o de opera√ß√µes em um schedule. Logo, √© dif√≠cil determinar como as opera-

Figura 21.7 Construindo os grafos de preced√™ncia para os schedules A a D da Figura 21.5 para testar a serializa√ß√£o de conflito. (a) Grafo



de preced√™ncia para o schedule serial A. (b) Grafo de preced√™ncia para o schedule serial B. (c) Grafo de preced√™ncia para o schedule C (n√£o serializ√°vel). (d) Grafo de preced√™ncia para o schedule D (serializ√°vel, equivalente ao schedule A).

13 Esse processo de ordena√ß√£o dos n√≥s de um grafo ac√≠clico √© conhecido como ordena√ß√£o topol√≥gica .

(a)

## Transa√ß¬™o T 1

read\_item(

X

);

write\_item(

X

read\_item(

Y

);

);

## Transa√ß¬™o T 3

read\_item(

Y

);

read\_item(

Z

);

write\_item( Y );

write\_item(

Y

);

write\_item(

Z

);



| (b)   | Transa√ß¬™o T 1                    | Transa√ß¬™o T 2                                    | Transa√ß¬™o T 3                                                     |
|-------|----------------------------------|--------------------------------------------------|-------------------------------------------------------------------|
| Tempo | read_item( X ); write_item( X ); | read_item( Z ); read_item( Y ); write_item( Y ); | read_item( Y ); read_item( Z ); write_item( Y ); write_item( Z ); |
|       |                                  | read_item( X );                                  |                                                                   |
|       | read_item( Y ); write_item( Y ); | write_item( X );                                 |                                                                   |

Schedule E

| (c)   | Transa√ß¬™o T 1                    | Transa√ß¬™o T 2   | Transa√ß¬™o T 3                                                     |
|-------|----------------------------------|-----------------|-------------------------------------------------------------------|
| Tempo | read_item( X ); write_item( X ); | read_item( Z ); | read_item( Y ); read_item( Z ); write_item( Y ); write_item( Z ); |

Schedule F

( continua )

## Figura 21.8

Outro exemplo de teste de serializa√ß√£o. (a) As opera√ß√µes de leitura e grava√ß√£o de tr√™s transa√ß√µes T 1 , T 2 e T 3 . (b) Schedule E. (c) Schedule F.

√ß√µes de um schedule ser√£o intercaladas de antem√£o para garantir a serializa√ß√£o.

Se as transa√ß√µes forem executadas √† vontade e depois o schedule resultante tiver a serializa√ß√£o testada, temos de cancelar o efeito do schedule se ele n√£o for serializ√°vel. Esse √© um problema s√©rio, que torna essa t√©cnica impratic√°vel. Logo, a t√©cnica usada na maioria dos sistemas pr√°ticos √© determinar m√©todos ou protocolos que garantam a serializa√ß√£o, sem ter de testar os pr√≥prios schedules. A t√©cnica usada na maioria  dos  SGBDs  comerciais  √©  projetar protoco- los (conjuntos de regras) que - se seguidos por toda transa√ß√£o individual ou se impostos por um subsistema de controle de concorr√™ncia do SGBD - garantir√£o a serializa√ß√£o de todos os schedules em que as transa√ß√µes participam .

Outro problema aparece aqui: quando as transa√ß√µes  s√£o  submetidas  continuamente  ao  sistema, √©  dif√≠cil  determinar  quando  um  schedule  come√ßa  e quando ele termina. A teoria da serializa√ß√£o pode ser adaptada para lidar com esse problema, considerando apenas a proje√ß√£o confirmada de um schedule S .



## Schedules seriais equivalentes

Nenhum

## Motivo

<!-- formula-not-decoded -->

Schedules seriais equivalentes

<!-- formula-not-decoded -->

## Schedules seriais equivalentes

<!-- formula-not-decoded -->

Figura 21.8 (continua√ß√£o)

Outro exemplo de teste de serializa√ß√£o. Grafo de preced√™ncia para o schedule E. Grafo de preced√™ncia para o schedule F. Grafo de preced√™ncia com dois schedules seriais equivalentes.

Lembre-se, da Se√ß√£o 21.4.1, que a proje√ß√£o confirmada C S ( ) de um schedule S inclui apenas as opera√ß√µes em S que pertencem √†s transa√ß√µes confirmadas. Teoricamente, podemos definir um schedule S para ser serializ√°vel se sua proje√ß√£o confirmada C S ( )  for equivalente a algum schedule serial, pois apenas transa√ß√µes confirmadas s√£o garantidas pelo SGBD.

√ß√µes de serializa√ß√£o ap√≥s as transa√ß√µes terminarem, mas antes que elas possam ser confirmadas.

## 21.5.4 Equival√™ncia de vis√£o e serializa√ß√£o de vis√£o

No Cap√≠tulo 22, discutimos uma s√©rie de protocolos de controle de concorr√™ncia diferentes, que garantem a serializa√ß√£o. A t√©cnica mais comum, chamada bloqueio em duas fases , √© baseada no bloqueio de itens de dados para impedir que transa√ß√µes concorrentes interfiram umas com as outras, e na imposi√ß√£o de uma condi√ß√£o adicional que garanta a serializa√ß√£o. Isso √© usado na maioria dos SGBDs comerciais. Outros protocolos foram propostos; 14  entre eles est√£o a ordena√ß√£o por r√≥tulo de tempo (timestamp), em que cada transa√ß√£o recebe um r√≥tulo de tempo √∫nico e o protocolo garante que quaisquer opera√ß√µes em conflito sejam executadas na ordem dos r√≥tulos de tempo da transa√ß√£o; protocolos multivers√£o , que s√£o baseados na manuten√ß√£o de v√°rias vers√µes dos itens de dados; e protocolos otimistas (tamb√©m chamados de certifica√ß√£o ou valida√ß√£o ), que verificam as poss√≠veis viola-

Na Se√ß√£o 21.5.1, definimos os conceitos de equival√™ncia de conflito dos schedules e serializa√ß√£o de conflito. Outra defini√ß√£o menos restritiva da equival√™ncia de sched  ules √© chamada equival√™ncia de vis√£o .  Isso leva a outra defini√ß√£o de serializa√ß√£o, chamada serializa√ß√£o de vis√£o . Dois schedules S e S ' s√£o considerados equivalentes de vis√£o se as tr√™s condi√ß√µes a seguir forem mantidas:

- 1. O  mesmo  conjunto  de  transa√ß√µes  participa em S e S ', e S e S ' incluem as mesmas opera√ß√µes dessas transa√ß√µes.
- 2. Para qualquer opera√ß√£o r i ( X )  de T i em S ,  se  o valor de X lido pela opera√ß√£o tiver sido gravado por uma opera√ß√£o w j ( X ) de T j (ou se for o valor original de X antes do schedule ter sido iniciado), a mesma condi√ß√£o deve ser mantida para o valor de X lido pela opera√ß√£o r i ( X ) de T i em S '.
- 3. Se a opera√ß√£o w k ( Y ) de T k for a √∫ltima opera-

14 Esses outros protocolos n√£o foram incorporados em muitos sistemas comerciais; a maioria dos SGBDs relacionais utiliza alguma varia√ß√£o do protocolo de bloqueio em duas fases.

√ß√£o a gravar o item Y em S , ent√£o w k ( Y ) de T k tamb√©m deve ser a √∫ltima opera√ß√£o a gravar o item Y em S '.

A ideia por tr√°s da equival√™ncia de vis√£o √© que, desde que cada opera√ß√£o de leitura de uma transa√ß√£o leia o resultado da mesma opera√ß√£o de grava√ß√£o nos  dois  schedules,  as  opera√ß√µes  de  grava√ß√£o  de cada transa√ß√£o devem produzir os mesmos resultados. As opera√ß√µes de leitura, portanto, veem a mesma vis√£o nos dois schedules. A condi√ß√£o 3 garante que a opera√ß√£o de grava√ß√£o final em cada item de dados  seja  a  mesma  nos  dois  schedules,  de  modo que o estado do banco de dados dever√° ser o mesmo ao final dos dois schedules. Um schedule S √©  considerado serializ√°vel de vis√£o se for equivalente de vis√£o a um schedule serial.

As defini√ß√µes de serializa√ß√£o de conflito e serializa√ß√£o de vis√£o s√£o semelhantes se uma condi√ß√£o conhecida como suposi√ß√£o de grava√ß√£o restrita (ou sem grava√ß√µes cegas ) se mantiver em todas as transa√ß√µes no schedule. Essa condi√ß√£o afirma que qualquer opera√ß√£o de grava√ß√£o w i ( X ) em T i √© precedida por um r i ( X ) em T i e que o valor gravado por w i ( X ) em T i depende apenas do valor de X lido por r i ( X ). Isso considera que o c√°lculo do novo valor de X √© uma fun√ß√£o  ( f X ) baseada no valor antigo de X lido do banco de dados. Uma grava√ß√£o cega √© uma opera√ß√£o de grava√ß√£o em uma transa√ß√£o T em um item X que n√£o depende do valor de X , de modo que n√£o √© precedida por uma leitura de X na transa√ß√£o T .

A defini√ß√£o de serializa√ß√£o de vis√£o √© menos restrita do que a da serializa√ß√£o de conflito sob a suposi√ß√£o de grava√ß√£o irrestrita , em que o valor gravado por uma opera√ß√£o w i ( X ) em T i pode ser independente de seu valor antigo do banco de dados. Isso √© poss√≠vel quando as grava√ß√µes cegas s√£o permitidas, e √© ilustrado pelo schedule S g a seguir, de tr√™s transa√ß√µes T 1 : r 1 ( X  w ); 1 ( X  T ); 2 : w 2 ( X ); e T 3 : w 3 ( X ):

<!-- formula-not-decoded -->

Em S g , as opera√ß√µes w X 2 ( ) e w X 3 ( ) s√£o grava√ß√µes cegas, pois T 2 e T 3 n√£o leem o valor de X . O schedule S g √© serializ√°vel de vis√£o, pois √© equivalente de vis√£o ao schedule serial T 1 , T 2 , T 3 . Por√©m, S g n√£o √© serializ√°vel de conflito, visto que n√£o √© equivalente de conflito para qualquer schedule serial. J√° foi mostrado que qualquer schedule serializ√°vel de conflito tamb√©m √© serializ√°vel de vis√£o, mas n√£o o contr√°rio, conforme ilustrado pelo exemplo anterior. Existe um algoritmo para testar se um schedule   √© serializ√°vel de vis√£o ou n√£o. Contudo, S o problema de testar a serializa√ß√£o de vis√£o tem sido mostrado como muito dif√≠cil, significando que desco- brir um algoritmo de tempo polinomial eficiente para esse problema √© altamente improv√°vel.

## 21.5.5 Outros tipos de equival√™ncia de schedules

A serializa√ß√£o de schedules √†s vezes √© considerada muito restritiva como uma condi√ß√£o para garantir a exatid√£o das execu√ß√µes concorrentes. Algumas aplica√ß√µes podem produzir schedules que s√£o corretas ao satisfazer condi√ß√µes menos rigorosas do que a serializa√ß√£o de conflito ou a serializa√ß√£o de vis√£o. Um exemplo √© o tipo de transa√ß√µes conhecido como transa√ß√µes de d√©bito-cr√©dito - por exemplo, aquelas que aplicam dep√≥sitos e saques a um item de  dados  cujo  valor  √©  o  saldo  atual  de  uma  conta banc√°ria. A sem√¢ntica das opera√ß√µes de d√©bitocr√©dito √© que elas atualizam o valor de um item de dados X ao  subtrair  ou  somar  ao  valor  do  item de dados. Como as opera√ß√µes de adi√ß√£o e subtra√ß√£o s√£o comutativas - ou seja, elas podem ser aplicadas  em  qualquer  ordem  -,  √©  poss√≠vel  produzir schedules corretos que n√£o sejam serializ√°veis. Por exemplo, considere as transa√ß√µes a seguir, cada qual podendo ser usada para transferir um valor monet√°rio entre duas contas banc√°rias:

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

Considere o schedule n√£o serializ√°vel S h a seguir para as duas transa√ß√µes:

<!-- formula-not-decoded -->

Com o conhecimento adicional,  ou sem√¢ntica , de que as opera√ß√µes entre cada r i ( I )  e w i ( I )  s√£o  comutativas,  sabemos  que  a  ordem  de  execu√ß√£o  das sequ√™n  cias que consistem em (ler, atualizar, gravar) n√£o  √©  importante,  desde  que  cada  sequ√™ncia  (ler, atua  lizar, gravar) por uma transa√ß√£o T i em um item I em particular n√£o seja interrompida por opera√ß√µes em conflito. Logo, o schedule S h √© considerado correto embora n√£o seja serializ√°vel. Os pesquisadores t√™m trabalhado na extens√£o da teoria do controle de concorr√™ncia para lidar com casos em que a serializa√ß√£o √©  considerada  muito  restritiva  como  uma  condi√ß√£o para a exatid√£o dos schedules. Al√©m disso, em certos dom√≠nios de aplica√ß√µes, como o projeto auxiliado por computador (CAD) de sistemas complexos de aeronaves, as transa√ß√µes de projeto duram um longo per√≠odo. Em tais aplica√ß√µes, esquemas de controle de

concorr√™ncia mais relaxados t√™m sido propostos para manter a consist√™ncia do banco de dados.

## 21.6 Suporte para transa√ß√£o em SQL

Nesta  se√ß√£o,  oferecemos  uma  r√°pida  introdu√ß√£o ao suporte para transa√ß√£o em SQL. Existem muito mais detalhes, e os padr√µes mais novos t√™m mais comandos para processamento de transa√ß√£o. A defini√ß√£o b√°sica de uma transa√ß√£o SQL √© semelhante ao conceito j√° definido de uma transa√ß√£o. Ou seja, ela √© uma unidade l√≥gica de trabalho e tem garantias de ser at√¥mica (ou indivis√≠vel). Uma √∫nica instru√ß√£o SQL sempre √© considerada at√¥mica - ou ela completa a execu√ß√£o sem um erro, ou falha e deixa o banco de dados inalterado.

Com  a  SQL,  n√£o  existe  uma  instru√ß√£o Begin\_ Transaction expl√≠cita. O in√≠cio da transa√ß√£o √© feito implicitamente quando instru√ß√µes SQL em particular s√£o encontradas. Por√©m, cada transa√ß√£o precisa ter uma instru√ß√£o de fim expl√≠cita, que √© um COMMIT ou um ROLLBACK. Cada transa√ß√£o tem certas caracter√≠sticas atribu√≠das a ela. Essas caracter√≠sticas s√£o especificadas por uma instru√ß√£o SET TRANSACTION em SQL. As caracter√≠sticas s√£o o modo de acesso ,  o tamanho da √°rea de diagn√≥stico e o n√≠vel de isolamento .

O modo de acesso pode ser especificado como READ  ONLY ou READ  WRITE. O  default  √© READ WRITE, a menos que o n√≠vel de isolamento de READ UNCOMMITTED seja especificado (ver a seguir), caso em  que READ  ONLY √©  assumido.  Um  modo READ WRITE permite a execu√ß√£o de comandos de sele√ß√£o, atualiza√ß√£o, inser√ß√£o, exclus√£o e cria√ß√£o. Um modo READ ONLY, como o nome indica, serve simplesmente para a recupera√ß√£o de dados.

A  op√ß√£o  de tamanho  da  √°rea  de  diagn√≥stico , DIAGNOSTIC SIZE n ,  especifica  um  valor  inteiro n , que  indica  o  n√∫mero  de  condi√ß√µes  que  podem  ser mantidas de maneira simult√¢nea na √°rea de diagn√≥stico. Essas condi√ß√µes fornecem informa√ß√µes de feedback (erros ou exce√ß√µes) ao usu√°rio ou programa nas n instru√ß√µes SQL executadas mais recentemente.

A  op√ß√£o  de n√≠vel  de  isolamento √©  especificada usando a instru√ß√£o ISOLATION  LEVEL &lt;isolamento&gt;, em  que  o  valor  para  &lt; isolamento &gt;  pode  ser READ UNCOMMITTED , READ  COMMITTED , REPEATABLE READ ou SERIALIZABLE . 15 O n√≠vel de isolamento default √© SERIALIZABLE, embora alguns sistemas usem READ COMMITTED como  default.  O  uso  do  termo SERIALIZABLE aqui √© baseado em n√£o permitir viola√ß√µes que causam leitura suja, leitura n√£o repetitiva e fantasmas, 16  e, assim, n√£o √© id√™ntico ao modo como a  serializa√ß√£o  foi  definida  anteriormente  na  Se√ß√£o 21.5. Se uma transa√ß√£o √© executada em um n√≠vel de isolamento inferior a SERIALIZABLE, ent√£o uma ou mais das tr√™s viola√ß√µes a seguir pode ocorrer:

- 1. Leitura  suja. Uma  transa√ß√£o T 1 pode  ler  a atualiza√ß√£o de uma transa√ß√£o T 2 ,  que ainda n√£o foi confirmada. Se T 2 falhar e for abortada,  ent√£o T 1 teria  lido  um  valor  que  n√£o existe e √© incorreto.
- 2. Leitura  n√£o  repetitiva. Uma  transa√ß√£o T 1 pode  ler  determinado  valor  de  uma  tabela. Se  outra  transa√ß√£o T 2 mais  tarde  atualizar esse valor e T 1 ler o valor novamente, T 1 ver√° um valor diferente.
- 3. Fantasmas. Uma  transa√ß√£o T 1 pode  ler  um conjunto de linhas de uma tabela, talvez com base em alguma condi√ß√£o especificada na cl√°usula SQL WHERE .  Agora,  suponha que uma transa√ß√£o T 2 insira uma nova linha que tamb√©m satisfa√ßa a condi√ß√£o da cl√°usula WHERE usada em T 1 ,  na  tabela  usada  por T 1 .  Se T 1 for repetida, ent√£o T 1 ver√° um fantasma, uma linha que anteriormente n√£o existia.

A Tabela 21.1 resume as poss√≠veis viola√ß√µes para os diferentes n√≠veis de isolamento. Uma entrada Sim indica  que  uma  viola√ß√£o  √©  poss√≠vel  e  uma  entrada N√£o indica  que  ela  n√£o  √©  poss√≠vel. READ UNCOMMITTED √©  a  mais  complacente, e SERIALIZABLE √©  a mais restritiva porque evita todos os tr√™s problemas mencionados anteriormente.

Uma transa√ß√£o SQL de exemplo pode se parecer com o seguinte:

EXEC  SQL  WHENEVER  SQLERROR  GOTO  UNDO; EXEC  SQL  SET  TRANSACTION READ  WRITE DIAGNOSTIC  SIZE  5 ISOLATION  LEVEL  SERIALIZABLE; EXEC    SQL    INSERT    INTO    FUNCIONARIO    (Pnome, Unome,  Cpf,  Dnr,  Salario)    VALUES  ('Roberto',  'Silva', '99100432111', 2, 35.000); EXEC  SQL  UPDATE  FUNCIONARIO SET  Salario  =  Salario  *  1.1  WHERE  Dnr  =  2; EXEC  SQL  COMMIT; GOTO  THE\_END; UNDO:  EXEC  SQL  ROLLBACK; THE\_END:  ...  ;

15 Estes s√£o semelhantes aos n√≠veis de isolamento discutidos rapidamente ao final da Se√ß√£o 21.3.

16 Os problemas de leitura suja e leitura n√£o repetitiva foram discutidos na Se√ß√£o 21.1.3. Fantasmas ser√£o discutidos na Se√ß√£o 22.7.1.

Tabela 21.1

Viola√ß√µes poss√≠veis com base nos n√≠veis de isolamento definidos na SQL.

| Tipo de viola√ß√£o    | Tipo de viola√ß√£o   | Tipo de viola√ß√£o       | Tipo de viola√ß√£o   |
|---------------------|--------------------|------------------------|--------------------|
| N√≠vel de isolamento | Leitura suja       | Leitura n√£o repetitiva | Fantasma           |
| READ UNCOMMITTED    | Sim                | Sim                    | Sim                |
| READ COMMITTED      | N√£o                | Sim                    | Sim                |
| REPEATABLE READ     | N√£o                | N√£o                    | Sim                |
| SERIALIZABLE        | N√£o                | N√£o                    | N√£o                |

Essa  transa√ß√£o  consiste  em  primeiro  inserir uma nova linha na tabela FUNCIONARIO e, depois, atualizar o sal√°rio de todos os funcion√°rios que trabalham no departamento 2. Se houver um erro em qualquer uma das instru√ß√µes SQL, a transa√ß√£o inteira √© cancelada. Isso implica que qualquer sal√°rio atualizado  (por  essa  transa√ß√£o)  seria  restaurado  a seu valor anterior e que a linha rec√©m-inserida seria removida.

Conforme vimos, a SQL oferece uma s√©rie de recursos orientados √† transa√ß√£o. O DBA ou programadores de banco de dados podem tirar proveito dessas op√ß√µes para tentar melhorar o desempenho da transa√ß√£o ao relaxar a serializa√ß√£o, se isso for aceit√°vel para suas aplica√ß√µes.

Depois,  definimos  um  schedule  (ou  hist√≥rico) como uma sequ√™ncia de execu√ß√£o das opera√ß√µes de v√°rias  transa√ß√µes  com  poss√≠vel  intercala√ß√£o.  Caracterizamos  os  schedules  em  rela√ß√£o  a  sua  facilidade de recupera√ß√£o. Os schedules recuper√°veis garantem que,  quando  uma transa√ß√£o √© confirmada, ela nunca  precisar√°  ser  desfeita.  Os  schedules  sem  cascata acrescentam  uma  condi√ß√£o  para  garantir  que  nenhuma  transa√ß√£o  cancelada  exija  o  cancelamento em  cascata  de  outras  transa√ß√µes.  Schedules  estritos oferecem uma condi√ß√£o ainda mais forte que permite um esquema de recupera√ß√£o simples, consistindo em restaurar os valores antigos dos itens que foram alterados por uma transa√ß√£o abortada.

## Resumo

Neste  cap√≠tulo,  discutimos  os  conceitos  de  SGBD para processamento de transa√ß√£o. Apresentamos o conceito de uma transa√ß√£o de banco de dados e as opera√ß√µes relevantes ao processamento de transa√ß√£o. Comparamos sistemas monousu√°rio com sistemas de multiusu√°rio e, depois, apresentamos exemplos de como a execu√ß√£o n√£o controlada  de  transa√ß√µes  simult√¢neas  em  um  sistema multiusu√°rios pode gerar resultados e valores de banco de dados incorretos. Tamb√©m discutimos os diversos tipos de falhas que podem ocorrer durante a execu√ß√£o da transa√ß√£o.

Em seguida,  apresentamos  os  estados  t√≠picos  pelos quais uma transa√ß√£o passa durante a execu√ß√£o e discutimos v√°rios conceitos que s√£o usados nos m√©todos de recupera√ß√£o e controle de concorr√™ncia. O log do sistema registra os acessos do banco de dados, e o sistema utiliza essa informa√ß√£o para se recuperar de falhas. Uma transa√ß√£o tem sucesso ou atinge seu ponto de confirma√ß√£o, ou falha e precisa ser cancelada. Uma transa√ß√£o confirmada tem suas mudan√ßas gravadas permanentemente no banco de dados. Apresentamos uma vis√£o geral das propriedades desej√°veis das transa√ß√µes - atomicidade, preserva√ß√£o de consist√™ncia,  isolamento  e  durabilidade  -  que  normalmente s√£o conhecidas como propriedades ACID.

Definimos a equival√™ncia dos schedules e vimos que um schedule serializ√°vel √© equivalente a algum schedule serial.  Definimos  os  conceitos  de  equival√™ncia  de  conflito e equival√™ncia de vis√£o, que levam √†s defini√ß√µes de serializa√ß√£o de conflito e serializa√ß√£o de vis√£o. Um schedule  serializ√°vel  √©  considerado  correto.  Apresentamos um algoritmo para testar a serializa√ß√£o (conflito) de um schedule. Discutimos por que o teste de serializa√ß√£o √© impratic√°vel em um sistema real, embora possa ser usado para definir e verificar os protocolos de controle de concorr√™ncia,  e  mencionamos  rapidamente  defini√ß√µes menos restritivas de equival√™ncia de schedule. Por fim, fornecemos uma breve vis√£o geral de como os conceitos de transa√ß√£o s√£o usados na pr√°tica dentro da SQL.

## Perguntas de revis√£o

- 21.1. O que significa a execu√ß√£o concorrente de transa√ß√µes de banco de dados em um sistema multiusu√°rio? Discuta por que o controle de concorr√™ncia √© necess√°rio e d√™ exemplos informais.
- 21.2. Discuta os diferentes tipos de falhas. O que significa uma falha catastr√≥fica?
- 21.3. Discuta as a√ß√µes tomadas pelas opera√ß√µes read\_ item e write\_item em um banco de dados.
- 21.4. Desenhe um diagrama de estado e discuta os estados  t√≠picos  pelos  quais  uma  transa√ß√£o  passa durante a execu√ß√£o.

- 21.5. Para que √© usado o log do sistema? Quais s√£o os tipos caracter√≠sticos de registros em um log do sistema?  O  que  s√£o  pontos  de  confirma√ß√£o  da transa√ß√£o e por que eles s√£o importantes?
- 21.6. Discuta as propriedades de atomicidade, durabilidade, isolamento e preserva√ß√£o da consist√™ncia de uma transa√ß√£o de banco de dados.
- 21.7. O que √© um schedule (hist√≥rico)? Defina os conceitos  de  schedules  recuper√°veis,  sem  cascata  e estritos, e compare-os em mat√©ria de sua facilidade de recupera√ß√£o.
- 21.8. Discuta as diferentes medidas de equival√™ncia de transa√ß√£o. Qual √© a diferen√ßa entre equival√™ncia de conflito e equival√™ncia de vis√£o?
- 21.9. O que √© um schedule serial? O que √© um schedule serializ√°vel? Por que um schedule serial √© considerado correto? Por que um schedule serializ√°vel √© considerado correto?
- 21.10. Qual √© a diferen√ßa  entre  as  suposi√ß√µes  de  grava√ß√£o restrita e grava√ß√£o irrestrita? Qual √© mais realista?
- 21.11. Discuta como a serializa√ß√£o √© usada para impor o  controle  de  concorr√™ncia  em  um  sistema  de banco de dados. Por que a serializa√ß√£o √†s vezes √© considerada muito restritiva como uma medida da exatid√£o para os schedules?
- 21.12. Descreva  os  quatro  n√≠veis  de  isolamento  em SQL.
- 21.13. Defina as viola√ß√µes causadas por cada um dos seguintes itens: leitura suja, leitura n√£o repetitiva e fantasmas.

## Exerc√≠cios

21.14. Mude a transa√ß√£o T 2 da Figura 21.2(b) para read\_item ( X );

X := X + M ;

if X &gt; 90 then exit else write\_item ( X );

Discuta o resultado final dos diferentes schedules na Figura 21.3(a) e (b), onde M = 2 e N = 2, em rela√ß√£o √†s seguintes quest√µes: a inclus√£o da condi√ß√£o acima muda o resultado final? O resultado obedece √† regra de consist√™ncia impl√≠cita (de que a capacidade de X √© 90)?

- 21.15. Repita o Exerc√≠cio 21.14, acrescentando uma verifica√ß√£o em T 1 de modo que Y n√£o exceda 90.
- 21.16. Inclua  o  commit  da  opera√ß√£o  ao  final  de  cada uma  das  transa√ß√µes T 1 e T 2 na  Figura  21.2,  e depois  liste  todos  os  schedules  poss√≠veis  para as transa√ß√µes modificadas. Determine quais dos schedules s√£o recuper√°veis, quais s√£o sem cascata e quais s√£o estritos.
- 21.17. Liste  todos  os  schedules  poss√≠veis  para  as  transa√ß√µes T 1 e T 2 na Figura 21.2 e determine quais s√£o serializ√°veis de conflito (corretos) e quais n√£o s√£o.
- 21.18. Quantos  schedules seriais existem  para  as  tr√™s transa√ß√µes  da  Figura  21.8(a)?  Quais  s√£o  eles? Qual √© o n√∫mero total de schedules poss√≠veis?
- 21.19. Escreva um programa para criar todos os schedules poss√≠veis para as tr√™s transa√ß√µes da Figura 21.8(a) e para determinar quais desses schedules s√£o serializ√°veis de conflito e quais n√£o s√£o. Para cada  schedule  serializ√°vel  de  conflito,  seu  programa dever√° imprimir o schedule e listar todos os schedules seriais equivalentes.
- 21.20. Por que uma instru√ß√£o de fim de transa√ß√£o expl√≠cita √© necess√°ria em SQL, mas n√£o uma instru√ß√£o de in√≠cio expl√≠cita?
- 21.21. Descreva situa√ß√µes em que cada um dos diferentes n√≠veis de isolamento seriam √∫teis para o processamento de transa√ß√£o.
- 21.22. Qua   dos  seguintes  schedules  √©  serializ√°vel  (de l conflito)? Para cada schedule serializ√°vel, determine os schedules seriais equivalentes.

a. r 1 ( X  r ); 3 ( X  w ); 1 ( X  r ); 2 ( X  w ); 3 ( X ); b. r 1 ( X  r ); 3 ( X  w ); 3 ( X  w ); 1 ( X  r ); 2 ( X ); c. r 3 ( X  r ); 2 ( X  w ); 3 ( X  r ); 1 ( X  w ); 1 ( X ); );

d. r 3 ( X  r ); 2 ( X  r ); 1 ( X  w ); 3 ( X  w ); 1 ( X

- 21.23. Considere  as  tr√™s  transa√ß√µes T 1 , T 2 e T 3 ,  e  os schedules S 1 e S 2 a seguir. Desenhe os grafos de serializa√ß√£o (preced√™ncia) para S 1 e S 2 e indique se  cada  schedule  √©  serializ√°vel  ou  n√£o.  Se  um schedule for serializ√°vel, escreva o(s) schedule(s) serial(is) equivalente(s).

T  r   X : ( ); r ( Z  w   X ); ( );

1 1 1 1 T  r   Z 2 : 2 ( ); r 2 ( Y  w   Z ); 2 ( ); w   Y 2 ( ); T  r   X 3 : 3 ( ); r 3 ( Y  w   Y ); 3 ( ); S 1 : r 1 ( X  r   Z ); 2 ( ); r 1 ( Z  r   X ); 3 ( ); r 3 ( Y  w   X ); 1 ( ); w   Y 3 ( ); r 2 ( Y  w   Z ); 2 ( ); w   Y 2 ( ); S 2 : r 1 ( X  r   Z ); 2 ( ); r 3 ( X  r   Z ); 1 ( ); r 2 ( Y  r   Y ); 3 ( ); w 1 ( X  w   Z ); 2 ( ); w   Y 3 ( ); w   Y 2 ( );

21.24. Considere os schedules S 3 , S 4 e S 5 a  seguir. Determine se cada schedule √© estrito, sem cascata, recuper√°vel  ou  n√£o  recuper√°vel.  (Determine  a condi√ß√£o de facilidade de recupera√ß√£o mais estrita que cada schedule satisfaz.)

S 3 : r 1 ( X  r   Z ); 2 ( ); r 1 ( Z  r   X ); 3 ( ); r 3 ( Y  w   X ); 1 ( ); c 1 ; w   Y 3 ( ); c 3 ; r 2 ( Y  w   Z ); 2 ( ); w   Y 2 ( ); c 2 ; S 4 : r 1 ( X  r   Z ); 2 ( ); r 1 ( Z  r   X ); 3 ( ); r 3 ( Y  w   X ); 1 ( ); w   Y 3 ( ); r 2 ( Y  w   Z ); 2 ( ); w   Y 2 ( ); c 1 ; c 2 ; c 3 ; S 5 : r 1 ( X  r   Z ); 2 ( ); r 3 ( X  r   Z ); 1 ( ); r 2 ( Y  r   Y ); 3 ( ); w 1 ( X  c ); 1 ; w   Z 2 ( ); w   Y 3 ( ); w   Y 2 ( ); c 3 ; c 2 ;

## Bibliografia selecionada

O conceito de serializa√ß√£o e as ideias relacionadas para manter a consist√™ncia em um banco de dados foram introduzidas em Gray et al. (1975). O conceito da transa√ß√£o  de  banco  de  dados  foi  discutido  inicialmente  em  Gray (1981), que ganhou o cobi√ßado ACM Turing Award em 1998 por seu trabalho sobre transa√ß√µes de  banco de dados e implementa√ß√£o de transa√ß√µes em SGBDs  relacionais.  Bernstein,  Hadzilacos  e  Goodman (1988) focalizam as t√©cnicas de controle de concorr√™ncia e recupera√ß√£o em sistemas de banco de dados centraliza- dos e distribu√≠dos; trata-se de uma excelente refer√™ncia. Papadimitriou  (1986)  oferece  um  ponto  de  vista  mais te√≥rico.  Um  grande  livro  de  refer√™ncia  de  mais  de  mil p√°ginas, por Gray e Reuter (1993), oferece um ponto de vista mais pr√°tico dos conceitos e t√©cnicas de processamento de transa√ß√£o. Elmagarmid (1992) oferece cole√ß√µes de artigos de pesquisa sobre processamento de transa√ß√£o para aplica√ß√µes avan√ßadas. O suporte de transa√ß√£o em SQL √© descrito em Date e Darwen (1997). A serializa√ß√£o de vis√£o √© definida em Yannakakis (1984). A facilidade de recupera√ß√£o de schedules e a confiabilidade em bancos de dados s√£o discutidas em Hadzilacos (1983, 1988).



N este  cap√≠tulo,  discutimos  diversas  t√©cnicas  de controle  de  concorr√™ncia  que  s√£o  usadas  para garantir a propriedade de n√£o interfer√™ncia ou isolamento das transa√ß√µes  executadas  simultaneamente. A maior parte dessas t√©cnicas garante a serializa√ß√£o de schedules - que definimos na Se√ß√£o 21.5 - usando protocolos de controle de concorr√™ncia (conjuntos de regras) que garantem a serializa√ß√£o. Um conjunto de protocolos importante - conhecido como protocolos de bloqueio em duas fases - emprega a t√©cnica de bloqueio de itens de dados para impedir que m√∫ltiplas transa√ß√µes acessem os itens ao mesmo tempo; diversos protocolos de bloqueio s√£o descritos nas se√ß√µes 22.1 e 22.3.2. Os protocolos de bloqueio s√£o  utilizados  na  maioria  dos  SGBDs  comerciais. Outro  conjunto  de  protocolos  de  controle  de  concorr√™ncia utiliza r√≥tulos de tempo (timestamp) .  Um r√≥tulo  de  tempo  √©  um  identificador  exclusivo  para cada transa√ß√£o, gerado pelo sistema. Os valores de r√≥tulo de tempo s√£o gerados na mesma ordem que os tempos de in√≠cio de transa√ß√£o. Os protocolos de controle de concorr√™ncia que usam ordena√ß√£o por r√≥tulo de  tempo  para  garantir  a  serializa√ß√£o  s√£o  introduzidos na Se√ß√£o 22.2. Na Se√ß√£o 22.3, discutimos os protocolos de controle de concorr√™ncia multivers√£o que utilizam m√∫ltiplas vers√µes de um item de dados. Um protocolo multivers√£o estende a ordem do r√≥tulo de tempo para a ordena√ß√£o de r√≥tulo de tempo multivers√£o (Se√ß√£o 22.3.1), e outro estende o bloqueio em duas fases (Se√ß√£o 22.3.2). Na Se√ß√£o 22.4, apresentamos um protocolo baseado no conceito de valida√ß√£o ou certifica√ß√£o de uma transa√ß√£o depois que ela executa suas opera√ß√µes. Esse √†s vezes √© chamado de protocolo otimista , e tamb√©m assume que m√∫ltiplas vers√µes de um item de dados podem existir.

Outro fator que afeta o controle de concorr√™ncia √© a granularidade dos itens de dados - ou seja, que

## T√©cnicas de controle de concorr√™ncia

parte do banco de dados um item de dados representa. Um item pode ser pequeno como um √∫nico valor de atributo  (campo)  ou  t√£o  grande  quanto  um  bloco de disco, ou ainda, um arquivo inteiro ou o banco de dados inteiro. Discutimos a granularidade dos itens e um protocolo de controle de concorr√™ncia com granularidade m√∫ltipla, que √© uma extens√£o do bloqueio em duas fases, na Se√ß√£o 22.5. Na Se√ß√£o 22.6, descrevemos as quest√µes de controle de concorr√™ncia que surgem quando os √≠ndices s√£o usados para processar  transa√ß√µes,  e  na  Se√ß√£o  22.7,  discutimos  alguns conceitos adicionais do controle de concorr√™ncia. No final do cap√≠tulo h√° um resumo.

√â suficiente ler as se√ß√µes 22.1, 22.5, 22.6 e 22.7, e  possivelmente  a  22.3.2,  se  seu  interesse  principal for uma introdu√ß√£o √†s t√©cnicas de controle de concorr√™ncia baseadas no bloqueio, que s√£o usadas com mais  frequ√™ncia  na  pr√°tica.  As  outras  t√©cnicas  s√£o principalmente de interesse te√≥rico.

## 22.1 √©cnicas de bloqueio em T duas fases para controle de concorr√™ncia

Algumas  das  principais  t√©cnicas  usadas  para controlar a execu√ß√£o concorrente de transa√ß√µes s√£o baseadas no conceito de bloqueio de itens de dados. Um bloqueio √©  uma  vari√°vel  associada  a  um  item de  dados  que  descreve  o  status  do  item  em  rela√ß√£o a poss√≠veis opera√ß√µes que podem ser aplicadas a ele. Em geral, existe um bloqueio para cada item de dados no banco de dados. Os bloqueios s√£o utilizados como um meio de sincronizar o acesso por transa√ß√µes concorrentes aos itens do banco de dados. Na Se√ß√£o 22.1.1,  discutimos  a  natureza  e  os  tipos de bloqueios. Depois, na Se√ß√£o 22.1.2, apresentamos

protocolos que utilizam o bloqueio para garantir a serializa√ß√£o de schedules de transa√ß√£o. Finalmente, na Se√ß√£o 22.1.3, descrevemos dois problemas associados ao uso de bloqueios - deadlock e inani√ß√£o (starvation) - e mostramos como esses problemas s√£o tratados em protocolos de controle de concorr√™ncia.

## 22.1.1 Tipos de bloqueios e tabelas de bloqueio do sistema

V√°rios tipos de bloqueios s√£o usados no controle  de  concorr√™ncia.  Para  introduzir  os  conceitos  de bloqueio gradualmente, primeiro discutimos os bloqueios bin√°rios, que s√£o simples, mas tamb√©m muito restritivos para fins de controle de concorr√™ncia e,  portanto, n√£o s√£o usados na pr√°tica. Depois, discutimos os  bloqueios compartilhados exclusivos / -  tamb√©m conhecidos como bloqueios de leitura grava√ß√£o / -, que oferecem capacidades de bloqueio mais gerais e s√£o utilizados em esquemas de bloqueio de banco de dados  pr√°ticos.  Na  Se√ß√£o  22.3.2,  descrevemos  um tipo adicional de bloqueio chamado bloqueio de certifica√ß√£o , e mostramos como ele pode ser usado para melhorar o desempenho dos protocolos de bloqueio.

Bloqueios bin√°rios. Um bloqueio bin√°rio pode ter dois estados ou valores :  bloqueado e desbloqueado (ou 1 e 0, para simplificar). Um bloqueio distinto √© associado a cada item do banco de dados X . Se o valor do bloqueio em X for 1, o item X n√£o pode ser acessado por uma opera√ß√£o de banco de dados que requisita o item. Se o valor do bloqueio em X for 0 , o item pode ser acessado quando requisitado, e o valor do bloqueio  √©  mudado  para  1.  Referimo-nos  ao  valor atual (ou estado) do bloqueio associado ao item X como lock( X ) .

Duas opera√ß√µes, lock\_item e unlock\_item, s√£o usadas com o bloqueio bin√°rio. Uma transa√ß√£o requisita acesso a um item X emitindo primeiro uma opera√ß√£o lock\_ item( X ) . Se LOCK ( X ) = 1, a transa√ß√£o √© for√ßada a esperar. Se LOCK ( X ) = 0, ela √© configurada como 1 (a transa√ß√£o bloqueia o item) e a transa√ß√£o tem permiss√£o para acessar  o  item X .  Quando a transa√ß√£o termina de usar o item, ela emite uma opera√ß√£o unlock\_item( X ) , que define LOCK ( X ) de volta para 0 ( desbloqueia o item), de modo que X pode ser acessado por outras transa√ß√µes. Logo, um bloqueio bin√°rio imp√µe a exclus√£o m√∫tua no item de dados. Uma descri√ß√£o das opera√ß√µes lock\_item ( X ) e unlock\_item ( X ) √© mostrada na Figura 22.1.

Observe  que  as  opera√ß√µes lock\_item e unlock\_ item devem ser implementadas como unidades indivis√≠veis (conhecidas como se√ß√µes cr√≠ticas em sistemas operacionais);  ou  seja,  nenhuma  intercala√ß√£o  deve ser permitida quando uma opera√ß√£o de bloqueio ou desbloqueio √© iniciada, at√© que a opera√ß√£o termine ou a transa√ß√£o espere. Na Figura 22.1, o comando wait  na  opera√ß√£o lock\_item ( X )  normalmente  √©  implementado ao colocar a transa√ß√£o em uma fila de espera para o item X at√© que X seja desbloqueado e a transa√ß√£o possa receber acesso a ele. Outras transa√ß√µes que tamb√©m querem acessar X s√£o colocadas na mesma fila. Logo, o comando wait √© considerado fora da opera√ß√£o lock\_item.

## lock\_item( X ):

```
B: se LOCK( X ) = 0 (* item est√° desbloqueado *) ent√£o LOCK( X ) ‚Üê 1 (* bloqueia o item *) se n√£o in√≠cio wait (until LOCK( X ) = 0 go to B
```

## unlock\_item( X

```
e o gerenciador de bloqueio desperta a transa√ß√£o); fim ; ): LOCK( X ) ‚Üê 0; (* desbloqueia o item *)
```

se alguma transa√ß√£o estiver esperando ent√£o acorda uma das transa√ß√µes em espera;

√â  muito  simples  implementar  um  bloqueio  bin√°rio;  basta  uma  vari√°vel  de  valor  bin√°rio, LOCK, associada a cada item de dados X no banco de dados. Em sua forma mais simples, cada bloqueio pode ser um registro com tr√™s campos: &lt; Nome\_item\_dado, LOCK, Bloqueio\_de\_transa√ß√£o &gt;  mais  uma  fila  para transa√ß√µes que est√£o esperando para acessar o item. O sistema precisa manter apenas esses registros para os  itens  que  est√£o  atualmente  bloqueados em  uma tabela  de  bloqueio ,  que  poderiam  ser  organizados como um arquivo de hash no nome do item. Os itens que n√£o est√£o na tabela de bloqueio s√£o considerados desbloqueados. O SGBD possui um subsistema de gerenciador de bloqueio para registrar e controlar o acesso aos bloqueios.

Se o esquema de bloqueio bin√°rio simples descrito aqui for usado, cada transa√ß√£o precisa obedecer √†s seguintes regras:

- 1. Uma transa√ß√£o T precisa  emitir  a  opera√ß√£o lock\_item ( X ) antes  de  quaisquer  opera√ß√µes read\_item ( X )  ou write\_item ( X )  serem realizadas em T .
- 2. Uma transa√ß√£o T precisa  emitir  a  opera√ß√£o unlock\_item ( X ) ap√≥s todas as opera√ß√µes read\_ item ( X )  e write\_item ( X )  serem  completadas em T .
- 3. Uma transa√ß√£o T n√£o emitir√° uma opera√ß√£o lock\_item ( X )  se  j√°  mantiver  o  bloqueio  no item X . 1
- 4. Uma transa√ß√£o T n√£o emitir√° uma opera√ß√£o unlock\_item ( X ) a menos que ela j√° mantenha o bloqueio no item X .

Essas  regras  podem  ser  impostas  pelo  m√≥dulo gerenciador de bloqueio do SGBD. Entre as opera√ß√µes lock\_item ( X )  e unlock\_item ( X )  na  transa√ß√£o T , diz-se que T mant√©m o bloqueio no item X . No m√°ximo uma transa√ß√£o pode manter o bloqueio de um item em particular. Assim, duas transa√ß√µes n√£o podem acessar o mesmo item simultaneamente.

Bloqueios compartilhados/exclusivos (ou de leitura/grava√ß√£o). O esquema de bloqueio bin√°rio que explicamos  √©  muito  restritivo  para  itens  de  banco de dados porque, no m√°ximo, uma transa√ß√£o pode manter  um  bloqueio  em  determinado  item.  Devemos permitir que v√°rias transa√ß√µes acessem o mesmo item X se  todas  elas  acessarem X apenas para fins de leitura . Isso porque as opera√ß√µes de leitura no mesmo item por diferentes transa√ß√µes n√£o est√£o em conflito (ver Se√ß√£o 21.4.1). Contudo, se uma transa√ß√£o tiver de gravar um item X , ela precisa ter acesso exclusivo a X . Para essa finalidade, um tipo diferente de  bloqueio,  chamado bloqueio  de  modo  m√∫ltiplo , √©  utilizado.  Nesse  esquema  -  chamado  bloqueios compartilhados/exclusivos ou de leitura/grava√ß√£o -, existem tr√™s opera√ß√µes de bloqueio: read\_lock ( X ), wri-te\_lock ( X ) e unlock ( X ). Um bloqueio associado a um item X , LOCK ( X ),  agora  tem  tr√™s  estados  poss√≠veis: bloqueado  para  leitura , bloqueado  para  grava√ß√£o ou desbloqueado .  Um item  bloqueado  para  leitura tamb√©m √© chamado de bloqueado para compartilhamento , pois outras transa√ß√µes podem ler o item, enquanto um item bloqueado para grava√ß√£o √© chamado bloqueado exclusivo , visto que uma √∫nica transa√ß√£o mant√©m exclusivamente o bloqueio no item.

Um m√©todo para implementar as opera√ß√µes anteriores em um bloqueio de leitura/grava√ß√£o √© registrar o  n√∫mero  de  transa√ß√µes  que  mant√™m  um  bloqueio compartilhado (leitura) em um item na tabela de bloqueio. Cada registro na tabela de bloqueio ter√° quatro campos: &lt; Nome\_item\_dado, LOCK, Num\_de\_leituras, Bloqueio\_de\_transa√ß√£o(√µes)&gt; .  Novamente, para economizar espa√ßo, o sistema precisa manter registros de bloqueio somente para os itens bloqueados na tabela de bloqueio. O valor (estado) de LOCK √© bloqueado para  leitura  ou  bloqueado  para  grava√ß√£o,  adequadamente codificado (se considerarmos que nenhum registro √© mantido na tabela de bloqueio para itens desbloqueados). Se LOCK ( X ) = bloqueado para grava√ß√£o, o valor de Bloqueio\_de\_transa√ß√£o √© uma √∫nica transa√ß√£o que mant√©m o bloqueio exclusivo (grava√ß√£o) sobre X . Se LOCK ( X ) = bloqueado para leitura, o valor de Bloqueio\_de\_transa√ß√£o √© uma lista de uma ou mais transa√ß√µes que mant√™m o bloqueio compartilhado (leitura) em X . As tr√™s opera√ß√µes read\_lock ( X ), write\_lock ( X ) e unlock ( X ) s√£o  descritas  na  Figura 22.2. 2 Como  antes,  cada  uma  dessas  opera√ß√µes  de bloqueio deve ser considerada indivis√≠vel; nenhuma intercala√ß√£o deve ser permitida depois que uma das opera√ß√µes  for  iniciada  at√©  que  a  opera√ß√£o  termine concedendo o bloqueio ou a transa√ß√£o seja colocada em uma fila de espera para o item.

Quando usamos o esquema de bloqueio compartilhado/exclusivo, o sistema deve impor as seguintes regras:

- 1. Uma  transa√ß√£o T precisa  emitir  a  opera√ß√£o read\_lock ( X ) ou write\_lock ( X ) antes que qualquer opera√ß√£o read\_item ( X ) seja realizada em T .

1 Essa regra pode ser removida se modificarmos a opera√ß√£o lock\_item( X ) na Figura 22.1 de modo que, se o item estiver atualmente bloqueado pela transa√ß√£o requisitante , o bloqueio seja concedido.

2 Esses algoritmos n√£o permitem o upgrading ou downgrading de bloqueios, conforme descrevemos mais adiante nesta se√ß√£o. O leitor pode estender os algoritmos para permitir essas opera√ß√µes adicionais.

## read\_lock ( X ):

desperta uma das transa√ß√µes aguardando, se houver

B: se LOCK( X ) = 'unlocked' ent√£o in√≠cio LOCK( X ) ‚Üê 'read-locked'; num\_de\_leituras( X ) ‚Üê 1 fim se n√£o se LOCK( X ) = 'read-locked' ent√£o num\_de\_leituras( X ) ‚Üê num\_de\_leituras( X ) + 1 se n√£o in√≠cio wait (at√© que LOCK( X ) = 'unlocked' e o gerenciador de bloqueio desperta a transa√ß√£o); go to B fim ; write\_lock ( X ): B: se LOCK( X ) = 'unlocked' ent√£o LOCK( X ) ‚Üê 'write-locked' ent√£o in√≠cio wait (at√© que LOCK( X ) = 'unlocked' e o gerenciador de bloqueio desperta a transa√ß√£o); go to B fim ; unlock ( X ): se LOCK( X ) = 'write-locked' ent√£o in√≠cio LOCK( X ) ‚Üê 'unlocked'; desperta uma das transa√ß√µes aguardando, se houver fim se n√£o se LOCK( X ) = 'read-locked' ent√£o in√≠cio num\_de\_leituras( X ) ‚Üê num\_de\_leituras(X) -1; se num\_de\_leituras( X ) = 0 ent√£o in√≠cio LOCK( X ) = 'unlocked'; fim fim ;

- 2. Uma transa√ß√£o T precisa  emitir  a  opera√ß√£o write\_lock ( X )  antes  que  qualquer  opera√ß√£o write\_item ( X ) seja realizada em T .
- 3. Uma  transa√ß√£o T precisa  emitir  a  opera√ß√£o unlock ( X ) ap√≥s todas as opera√ß√µes read\_item ( X ) e write\_item ( X ) serem completadas em T. 3
- 4. Uma transa√ß√£o T n√£o  emitir√°  uma  opera√ß√£o read\_lock ( X ) se ela j√° mantiver um bloqueio de leitura (compartilhado) ou um bloqueio de grava√ß√£o (exclusivo) no item X .  Essa regra pode ser flex√≠vel, conforme discutiremos em breve.
- 5. Uma transa√ß√£o T n√£o  emitir√°  uma  opera√ß√£o write\_lock ( X ) se ela j√° mantiver um bloqueio de leitura (compartilhado) ou um bloqueio de grava√ß√£o (exclusivo) no item X .  Essa regra pode ser flex√≠vel, conforme discutiremos em breve.
- 6. Uma  transa√ß√£o T n√£o  emitir√°  uma  opera√ß√£o unlock ( X )  a  menos que j√° mantenha um bloqueio de leitura (compartilhado) ou um bloqueio de grava√ß√£o (exclusivo) no item X .

Convers√£o  de  bloqueios. √Äs  vezes,  √©  desej√°vel  flexibilizar as condi√ß√µes 4 e 5 da lista anterior a fim de permitir a convers√£o de bloqueio ;  ou  seja,  uma transa√ß√£o que j√° mant√©m um bloqueio no item X tem permiss√£o, sob certas condi√ß√µes de converter o  bloqueio de um estado bloqueado para outro. Por exemplo, √© poss√≠vel que uma transa√ß√£o T emita um read\_lock ( X ) e, depois fa√ßa um upgrade do bloqueio, emitindo uma opera√ß√£o write\_lock ( X ). Se T for a √∫nica transa√ß√£o que mant√©m um bloqueio de leitura em X ao momento em que emite a opera√ß√£o write\_lock ( X ),  o  bloqueio  pode passar pelo upgrade; caso contr√°rio, a transa√ß√£o deve esperar. Tamb√©m √© poss√≠vel que uma transa√ß√£o T emita um write\_lock ( X ) e depois fa√ßa um downgrade do bloqueio ao emitir uma opera√ß√£o read\_lock ( X ). Quando o upgrade ou downgrade dos bloqueios √© usado, a tabela de bloqueios precisa incluir identificadores de transa√ß√£o na estrutura do registro para cada bloqueio (no campo Bloqueio\_de\_transa√ß√£o )  para  armazenar a informa√ß√£o sobre quais transa√ß√µes mant√™m bloqueios no item. As descri√ß√µes  das  opera√ß√µes read\_lock ( X )  e write\_lock ( X ) da Figura 22.2 precisam ser alteradas adequadamente para permitir o upgrading e downgrading do bloqueio. Deixamos isso como um exerc√≠cio para o leitor.

z√°vel. Isso porque, na Figura 22.3(a), os itens Y em T 1 e X em T 2 foram desbloqueados muito cedo. Isso permite que ocorra um schedule como aquele mostrado na Figura 22.3(c), que n√£o √© um schedule serializ√°vel e, portanto, gera resultados incorretos. Para garantir a serializa√ß√£o, temos de seguir um protocolo adicional em rela√ß√£o ao posicionamento das opera√ß√µes de bloqueio e desbloqueio em cada transa√ß√£o. O protocolo mais conhecido, o bloqueio em duas fases, √© descrito na pr√≥xima se√ß√£o.

## 22.1.2 Garantindo a serializa√ß√£o pelo bloqueio em duas fases

Diz-se que uma transa√ß√£o segue o protocolo de bloqueio em duas fases se todas as opera√ß√µes de bloqueio ( read\_lock, write\_lock ) precedem a primeira opera√ß√£o  de  desbloqueio  na  transa√ß√£o. 4 Essa  transa√ß√£o pode ser dividida em duas fases: uma fase de expans√£o ou crescimento (primeira) , durante a qual novos bloqueios em itens podem ser adquiridos, mas nenhum pode ser liberado; e uma fase de encolhimento (segunda) , durante a qual os bloqueios existentes podem ser liberados, mas nenhum novo bloqueio pode ser adquirido. Se a convers√£o de bloqueio for permitida, ent√£o o upgrading de bloqueios (de read-locked para write-locked) deve ser feito durante a fase de expans√£o, e o downgrading de bloqueios (de write-locked para read-locked) deve ser feito na fase de encolhimento. Logo, uma opera√ß√£o read\_lock ( X ) que realiza o downgrade de um bloqueio de grava√ß√£o j√° mantido em X s√≥ pode aparecer na fase de encolhimento.

As transa√ß√µes T 1 e T 2 da Figura 22.3(a) n√£o seguem o protocolo de bloqueio em duas fases porque a opera√ß√£o write\_lock ( X ) segue a opera√ß√£o unlock ( Y ) em T 1 ,  e,  de maneira semelhante, a opera√ß√£o write\_ lock ( Y ) segue a opera√ß√£o unlock ( X ) em T 2 . Se for√ßarmos o bloqueio em duas fases, as transa√ß√µes poder√£o ser reescritas como T 1 ' e T 2 ', como mostra a Figura 22.4.  Agora,  o  schedule  exibido  na  Figura  22.3(c) n√£o √© permitido para T 1 ' e T 2 ' (com sua ordem modificada de opera√ß√µes de bloqueio e desbloqueio) sob as regras do bloqueio descritas na Se√ß√£o 22.1.1, pois T 1 '  emitir√°  seu write\_lock ( X ) antes de  desbloquear o item Y . Consequentemente, quando T 2 ' emite seu read\_lock ( X ),  ele  √©  for√ßado a esperar at√© que T 1 '  libere o bloqueio emitindo um unlock ( X ) no schedule.

O uso de bloqueios bin√°rios ou de leitura/grava√ß√£o, conforme descrito anteriormente, n√£o garante a serializa√ß√£o de schedules por si s√≥. A Figura 22.3 mostra um exemplo em que as regras de bloqueio anteriores s√£o seguidas, mas pode resultar em um schedule n√£o seriali-

Pode ser provado que, se cada transa√ß√£o em um schedule seguir o protocolo de bloqueio em duas fases, o  schedule  √© garantidamente serializ√°vel ,  evitando  a necessidade de testar a serializa√ß√£o dos schedules. O protocolo de bloqueio, ao impor as regras de bloqueio em duas fases, tamb√©m imp√µe a serializa√ß√£o.

3 Essa regra pode ser flex√≠vel para permitir que uma transa√ß√£o desbloqueie um item, depois o bloqueie novamente mais tarde.

4 Isso n√£o est√° relacionado ao protocolo de confirma√ß√£o em duas fases para recupera√ß√£o nos bancos de dados distribu√≠dos (ver Cap√≠tulo 25).

| (a) T 1                                                                                                                  | T 2                                                                                                                      |
|--------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------|
| read_lock( Y ); read_item( Y ); unlock( Y ); write_lock( X ); read_item( X ); X := X + Y ; write_item( X ); unlock( X ); | read_lock( X ); read_item( X ); unlock( X ); write_lock( Y ); read_item( Y ); Y := X + Y ; write_item( Y ); unlock( Y ); |



| (c)   | T 1                                                                         | T 2                                                                                                                      |
|-------|-----------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------|
| Tempo | read_lock( Y ); read_item( Y ); unlock( Y );                                | read_lock( X ); read_item( X ); unlock( X ); write_lock( Y ); read_item( Y ); Y := X + Y ; write_item( Y ); unlock( Y ); |
|       | write_lock( X ); read_item( X ); X := X + Y ; write_item( X ); unlock( X ); |                                                                                                                          |

- Valores iniciais: X = 20, Y =30 (b)
- Schedule serial resultante T 1 seguido por T 2 : X =50, Y =80

Schedule serial resultante T 2 seguido por T 1 : X =70, Y =50

Resultado de schedule S: X =50, Y =50 (n¬™o serializ√Üvel)

Figura 22.3

Transa√ß√µes que n√£o obedecem ao bloqueio em duas fases. (a) Duas transa√ß√µes T 1 e T 2 . (b) Resultados de poss√≠veis schedules seriais de T 1 e T 2 . (c) Um schedule n√£o serializ√°vel S que usa bloqueios.

Figura 22.4



Transa√ß√µes T 1 ' e T 2 ', que s√£o iguais a T 1 e T 2 da Figura 22.3, mas seguem o protocolo de bloqueio em duas fases. Observe que elas podem produzir um deadlock.

um item X depois de us√°-lo se T tiver de bloquear um item adicional Y depois; ou, reciprocamente, T precisa bloquear um item adicional Y antes que precise dele, de modo que pode liberar X . Logo, X precisa permanecer bloqueado por T at√© que todos os itens que a transa√ß√£o precisa ler ou gravar tenham sido bloqueados; somente ent√£o X pode ser liberado por T .  Nesse meio tempo, outra transa√ß√£o buscando acessar X pode ser for√ßada a esperar, embora T tenha terminado de usar X . De maneira rec√≠proca, se Y estiver bloqueado antes que seja necess√°rio, outra transa√ß√£o buscando acessar Y √© for√ßada a esperar embora T ainda n√£o esteja usando Y . Esse √© o pre√ßo para garantir a serializa√ß√£o de todos os schedules sem ter de verificar os pr√≥prios schedules.

O bloqueio em duas fases pode limitar a quantidade de concorr√™ncia pass√≠vel de ocorrer em um schedule, visto que uma transa√ß√£o T pode n√£o ser capaz de liberar

Embora o protocolo de bloqueio em duas fases garanta a serializa√ß√£o (ou seja, cada schedule permitido √© serializ√°vel), ele n√£o permite todos os schedules serializ√°veis  poss√≠veis (ou  seja,  alguns  schedules serializ√°veis ser√£o proibidos pelo protocolo).

Bloqueio em duas fases b√°sico, conservador, estrito e rigoroso. Existem diversas varia√ß√µes do bloqueio em duas fases (2PL). A t√©cnica que descrevemos √© conhecida como 2PL b√°sico . Uma varia√ß√£o conhecida como 2PL  conservador (ou 2PL  est√°tico )  requer  que  uma transa√ß√£o bloqueie todos os itens que ela acessa antes que a transa√ß√£o inicie a execu√ß√£o , pr√©-declarando seu conjunto de leitura e conjunto de grava√ß√£o . Lembre-se, da Se√ß√£o 21.1.2, que o conjunto de leitura de uma transa√ß√£o √© o conjunto de todos os itens que a transa√ß√£o l√™, e o conjunto de grava√ß√£o √© o conjunto de todos os itens que ela grava. Se qualquer um dos itens pr√©-declarados necess√°rios n√£o puder ser bloqueado, a transa√ß√£o n√£o bloqueia item algum; em vez disso, ela espera at√© que todos os itens estejam dispon√≠veis para bloqueio. O 2PL conservador √© um protocolo livre de deadlock, conforme veremos na Se√ß√£o 22.1.3,  quando  discutiremos  o problema de deadlock. Por√©m, ele √© dif√≠cil de ser usado na pr√°tica por causa da necessidade de pr√©-declarar o conjunto de leitura e o conjunto de grava√ß√£o, o que n√£o √© poss√≠vel em muitas situa√ß√µes.

Na pr√°tica, a varia√ß√£o mais popular do 2PL √© o 2PL estrito , que garante schedules estritos (ver Se√ß√£o 21.4).  Nessa  varia√ß√£o,  uma  transa√ß√£o T n√£o  libera nenhum de seus bloqueios exclusivos (grava√ß√£o) at√© depois de confirmar ou abortar. Logo, nenhuma outra transa√ß√£o pode ler ou gravar um item que √© gravado por T a menos que T tenha sido confirmado, levando a um schedule estrito para facilidade de recupera√ß√£o. O 2PL estrito n√£o √© livre de deadlock. Uma varia√ß√£o mais restritiva do 2PL estrito √© o 2PL rigoroso ,  que tamb√©m  garante  schedules  estritos.  Nessa  varia√ß√£o, uma transa√ß√£o T n√£o libera nenhum de seus bloqueios (exclusivo ou compartilhado) at√© depois de confirmar ou abortar, e, portanto, √© mais f√°cil de implementar do que o 2PL estrito. Observe a diferen√ßa entre o 2PL conservador e o rigoroso: o primeiro precisa bloquear todos os itens antes de come√ßar , de modo que, quando a transa√ß√£o come√ßa, ela est√° em sua fase de encolhimento; o segundo n√£o desbloqueia nenhum dos seus itens at√© depois de terminar (confirmando ou abortando), de modo que a transa√ß√£o est√° em sua fase de expans√£o at√© que termine.

tema coloca T na fila de espera para o item X ; caso contr√°rio,  ele  concede  a  solicita√ß√£o read\_lock ( X )  e permite que a opera√ß√£o read\_item ( X )  de T execute. Por sua vez, se a transa√ß√£o T emitir um write\_item ( X ), o sistema chama a opera√ß√£o write\_lock ( X ) em favor de T .  Se  o  estado  de LOCK ( X )  estiver  bloqueado para grava√ß√£o ou bloqueado para leitura por alguma outra transa√ß√£o T ', o sistema coloca T na fila de espera para o item X ; se o estado de LOCK ( X ) for bloqueado para leitura e o pr√≥prio T for a √∫nica transa√ß√£o que mant√©m o bloqueio de leitura em X ,  o  sistema faz o upgrade do bloqueio para bloqueado para grava√ß√£o e permite a opera√ß√£o write\_item ( X ) por T . Finalmente, se o estado de LOCK ( X ) estiver desbloqueado, o sistema concede a solicita√ß√£o write\_lock ( X ) e permite que a opera√ß√£o write\_item ( X ) seja executada. Ap√≥s cada a√ß√£o, o sistema precisa atualizar sua tabela de bloqueio corretamente.

O uso de bloqueios pode causar dois problemas adicionais: deadlock e inani√ß√£o (starvation). Discutiremos esses problemas e suas solu√ß√µes na pr√≥xima se√ß√£o.

## 22.1.3 Lidando com deadlock e inani√ß√£o

O deadlock (impasse) ocorre quando cada transa√ß√£o T em um conjunto de duas ou mais transa√ß√µes est√° esperando por algum item que est√° bloqueado por alguma outra transa√ß√£o T '  no  conjunto. Logo, cada transa√ß√£o no conjunto est√° em uma fila de espera, aguardando que uma das outras transa√ß√µes no conjunto libere o bloqueio em um item. Mas, como a outra transa√ß√£o tamb√©m est√° esperando, ela nunca liberar√° o bloqueio. Um exemplo simples aparece na Figura 22.5(a), em que as duas transa√ß√µes T 1 ' e T 2 ' est√£o em deadlock em um schedule parcial; T 1 ' est√° na fila de espera para X , que est√° bloqueada por T 2 ', enquanto T 2 ' est√° na fila de espera para Y , que est√° bloqueado por T 1 '. Nesse meio-tempo, nem T 1 ', nem T 2 ', nem qualquer outra transa√ß√£o podem acessar os itens X e Y .

Em muitos casos, o pr√≥prio subsistema de controle de concorr√™ncia √© respons√°vel por gerar as solicita√ß√µes read\_lock e write\_lock . Por exemplo, suponha que o sistema deva impor o protocolo 2PL estrito. Ent√£o,  sempre  que  a  transa√ß√£o T emitir  um read\_ item ( X ), o sistema chama a opera√ß√£o read\_lock ( X ) em favor de T .  Se o estado de LOCK ( X ) for bloqueado para grava√ß√£o por alguma outra transa√ß√£o T ', o sis-

Protocolos  de  preven√ß√£o  de  deadlock. Uma  maneira de impedir o deadlock √© usar um protocolo de preven√ß√£o de deadlock. 5 Um protocolo de preven√ß√£o de deadlock, que √© utilizado no bloqueio de duas fases conservador, requer que cada transa√ß√£o bloqueie todos os itens que precisar com anteced√™ncia (o  que geralmente n√£o √© uma suposi√ß√£o pr√°tica) - se qualquer um dos itens n√£o puder ser obtido, nenhum item √© bloqueado. Ao contr√°rio, a transa√ß√£o espera e, depois, tenta novamente bloquear todos os itens de que precisa. √â claro que essa solu√ß√£o limita ainda mais a concorr√™ncia. Um segundo protocolo, que tamb√©m li-

5 Esses protocolos geralmente n√£o s√£o usados na pr√°tica, ou por causa de suposi√ß√µes n√£o realistas ou por causa de seu poss√≠vel overhead. A detec√ß√£o de deadlock e timeouts (tempos-limite, abordados nas pr√≥ximas se√ß√µes) s√£o mais pr√°ticos.

Figura 22.5



Ilustrando o problema do deadlock. (a) Um schedule parcial de T 1 ' e T 2 ' que est√° em um estado de deadlock. (b) Um grafo de espera para o schedule parcial em (a).

mita a concorr√™ncia, envolve ordenar todos os itens no banco de dados e garantir que uma transa√ß√£o que precisa  de  v√°rios  itens  os  bloquear√°  de  acordo  com essa ordem. Isso requer que o programador (ou o sistema) esteja ciente da ordem escolhida dos itens, o que tamb√©m n√£o √© pr√°tico no contexto do banco de dados.

Diversos outros esquemas de preven√ß√£o de dead  lock foram propostos para tomar uma decis√£o sobre o que fazer com uma transa√ß√£o envolvida em uma poss√≠vel situa√ß√£o de deadlock: ela deve ser bloqueada e aguardar, ou deve ser abortada, ou a transa√ß√£o deve apoderar-se de outra transa√ß√£o e abort√°-la? Algumas dessas t√©cnicas utilizam o conceito de r√≥tulo de tempo ( timestamp ) de transa√ß√£o TS ( T ), que √© um identificador exclusivo atribu√≠do a cada transa√ß√£o. Os r√≥tulos de tempo normalmente s√£o baseados na ordem em que as transa√ß√µes s√£o iniciadas; logo, se a transa√ß√£o T 1 iniciar antes da transa√ß√£o T 2 , ent√£o TS( T 1 ) &lt; TS ( T 2 ). Observe que a transa√ß√£o mais  antiga (que  come√ßa  primeiro)  tem  o menor valor de r√≥tulo de tempo. Dois esquemas que impedem  o  deadlock  s√£o  chamados esperar-morrer (wait-die) e ferir-esperar (wound-wait). Suponha que a transa√ß√£o T i tente bloquear um item X , mas n√£o consiga porque X est√° bloqueado por alguma outra transa√ß√£o T j com um bloqueio em conflito. As regras seguidas por esses esquemas s√£o:

item mantido por uma transa√ß√£o mais antiga √© abortada e reiniciada. A t√©cnica ferir-esperar faz o contr√°rio: uma transa√ß√£o mais nova tem permiss√£o para esperar por  uma  mais  antiga ,  enquanto  uma  transa√ß√£o  mais antiga que solicita um item mantido por uma transa√ß√£o mais nova apodera-se da transa√ß√£o mais nova ao abort√°-la. Os dois esquemas acabam abortando a mais nova das  duas  transa√ß√µes  (a  transa√ß√£o  que  come√ßou mais tarde), que pode estar envolvida em um deadlock, supondo que isso desperdi√ßar√° menos processamento. Pode-se mostrar que essas duas t√©cnicas s√£o livres de deadlock ,  pois  em  esperar-morrer  as  transa√ß√µes  apenas esperaram pelas transa√ß√µes mais novas, de modo que nenhum ciclo √© criado. De maneira semelhante, em ferir-esperar, as transa√ß√µes s√≥ esperam pelas transa√ß√µes mais antigas, de modo que o ciclo n√£o √© criado. Por√©m, as duas t√©cnicas podem fazer que algumas transa√ß√µes sejam abortadas e reiniciadas sem necessidade, embora elas nunca possam realmente causar um deadlock .

- ¬Ñ Esperar-morrer (wait-die)  Se . TS ( T i ) &lt; TS ( T j ), ent√£o ( T i mais antigo que T j ) T i tem permiss√£o  para  esperar;  caso  contr√°rio  ( T i mais novo que T j ) aborta T i ( T i morre ) e o reinicia mais tarde com o mesmo r√≥tulo de tempo .
- ¬Ñ Ferir-esperar (wound-wait) Se . TS ( T i ) &lt; TS ( T j ), ent√£o ( T i mais antigo que T j ) aborta T j ( T i fere T j ) e o reinicia mais tarde com o mesmo r√≥tulo de tempo ; caso contr√°rio ( T i mais novo que T j ), T i tem permiss√£o para esperar.

Em esperar-morrer, uma transa√ß√£o mais antiga tem permiss√£o para esperar por uma transa√ß√£o mais nova , enquanto  uma  transa√ß√£o  mais  nova  que  solicita  um

Outro grupo de protocolos que impede o deadlock n√£o exige r√≥tulos de tempo. Estes incluem os algoritmos sem espera (NW no waiting ) e espera cuidadosa (CW cautious waiting ). No algoritmo sem espera , se uma transa√ß√£o for incapaz de obter um bloqueio, ela √© imediatamente abortada e, depois, reiniciada ap√≥s certo atraso de tempo sem verificar se um deadlock realmente ocorrer√° ou n√£o. Nesse caso, nenhuma transa√ß√£o espera, de modo que nenhum deadlock ocorrer√°. Contudo, esse esquema pode fazer que as transa√ß√µes abortem e reiniciem sem necessidade. O algoritmo de espera cuidadosa foi proposto para tentar reduzir o n√∫mero de abortos/rein√≠cios  desnecess√°rios.  Suponha  que  a  transa√ß√£o T i tente bloquear um item X ,  mas n√£o consiga fazer isso porque X est√° bloqueado por alguma outra transa√ß√£o T j com um bloqueio em conflito. As regras de espera cuidadosa s√£o as seguintes:

- ¬Ñ Espera cuidadosa. Se T j n√£o estiver bloqueada (n√£o  esperando  por  outro  item  bloqueado), ent√£o T i est√° bloqueada e tem permiss√£o para esperar; caso contr√°rio, aborte T i .

Pode-se  demonstrar  que  a  espera  cuidadosa  √© livre  de  deadlock,  pois  nenhuma  transa√ß√£o  esperar√°  por  outra  transa√ß√£o  bloqueada.  Considerando o  tempo b T ( )  em  que  cada  transa√ß√£o  bloqueada T foi bloqueada, se as duas transa√ß√µes T i e T j se tornarem bloqueadas, e T i estiver esperando por T j , ent√£o b T ( i ) &lt; b T ( j ), pois T i s√≥ pode esperar por T j em um momento em que a pr√≥pria T j n√£o est√° bloqueada. Logo, os tempos de bloqueio formam uma ordena√ß√£o total em todas as transa√ß√µes bloqueadas, de modo que nenhum ciclo que causa deadlock pode acontecer.

Detec√ß√£o de deadlock. Uma segunda t√©cnica, mais pr√°tica, para lidar com o deadlock, √© a detec√ß√£o de deadlock , em que o sistema verifica se um estado de deadlock realmente existe. Essa solu√ß√£o √© atraente se soubermos  que  haver√°  pouca  interfer√™ncia  entre  as transa√ß√µes  -  ou  seja,  se  diferentes  transa√ß√µes  raramente acessarem os mesmos itens ao mesmo tempo. Isso  pode  acontecer  se  as  transa√ß√µes  forem  curtas  e cada uma bloquear apenas alguns itens, ou se a carga da transa√ß√£o for leve. No entanto, se as transa√ß√µes forem longas e cada transa√ß√£o usar muitos itens, ou se a carga da transa√ß√£o for muito pesada, pode ser vantajoso usar um esquema de preven√ß√£o de deadlock.

Um  modo  simples  de  detectar  um  estado  de deadlock √© que o sistema construa e mantenha um grafo de espera . Um n√≥ √© criado no grafo de espera para cada transa√ß√£o que est√° atualmente sendo executada.  Sempre  que  uma  transa√ß√£o T i est√°  esperando para bloquear um item X que est√° atualmente bloqueado por uma transa√ß√£o T j , uma aresta direcionada ( T i ‚Üí T j ) √© criada no grafo de espera. Quanto T j libera o(s) bloqueio(s) nos itens que T i estava esperando, a aresta direcionada √© removida do grafo de espera. Temos um estado de deadlock se, e somente se, o grafo de espera tiver um ciclo. Um problema com essa t√©cnica √© a quest√£o de determinar quando o sistema deve procurar um deadlock. Uma possibilidade √© verificar um ciclo toda vez que uma aresta for acrescentada ao grafo de espera, mas isso pode causar overhead excessivo. Crit√©rios como o n√∫mero de transa√ß√µes atualmente em execu√ß√£o ou o  per√≠odo  em  que  v√°rias  transa√ß√µes  estiveram  esperando para bloquear itens podem ser usados em vez de verificar um ciclo. A Figura 22.5(b) mostra o grafo de espera para o schedule (parcial) mostrado na Figura 22.5(a).

Se o sistema estiver em um estado de deadlock, algumas das transa√ß√µes que causam o deadlock precisam ser abortadas. A escolha de quais transa√ß√µes abortar √© conhecida como sele√ß√£o de v√≠tima . O algoritmo para a sele√ß√£o de v√≠tima geralmente deve evitar a sele√ß√£o de transa√ß√µes que estiveram em execu√ß√£o por muito tem- po e que realizaram muitas atualiza√ß√µes, e deve tentar, em vez disso, selecionar transa√ß√µes que n√£o fizeram muitas mudan√ßas (transa√ß√µes mais novas).

Timeouts. Outro esquema simples para lidar com o deadlock √© o uso de timeouts . Esse m√©todo √© pr√°tico devido a seu baixo overhead e sua simplicidade. Nesse m√©todo, se uma transa√ß√£o esperar por um per√≠odo maior que o per√≠odo de timeout (tempo-limite) definido pelo sistema, o sistema pressup√µe que a transa√ß√£o pode entrar em deadlock e a aborta - independentemente de um deadlock realmente existir ou n√£o.

Inani√ß√£o. Outro problema que pode ocorrer quando usamos o bloqueio √© a inani√ß√£o ( starvation ), que acontece quando uma transa√ß√£o n√£o pode prosseguir  por  um  per√≠odo  indefinido  enquanto  outras transa√ß√µes no  sistema  continuam  normalmente. Isso pode ocorrer se o esquema de espera para itens bloqueados  for  injusto,  dando  prioridade  a  algumas transa√ß√µes em rela√ß√£o a outras. Uma solu√ß√£o para a inani√ß√£o √© ter um esquema de espera justo, como o uso de uma fila primeiro-a-chegar-primeiro-a-ser-atendido ;  as  transa√ß√µes s√£o habilitadas para bloquear  um  item  na  ordem  em  que  solicitaram o bloqueio originalmente. Outro esquema permite que  algumas  transa√ß√µes  tenham  prioridade  sobre outras, mas aumenta a prioridade de uma transa√ß√£o quanto mais tempo ela esperar, at√© que, por fim, receba a maior prioridade e prossiga. A inani√ß√£o tamb√©m pode ocorrer por causa da sele√ß√£o de v√≠tima se o algoritmo selecionar a mesma transa√ß√£o como v√≠tima repetidamente, fazendo assim que ela aborte e nunca termine a execu√ß√£o. O algoritmo pode usar prioridades  maiores  para  transa√ß√µes  que  tiverem sido  abortadas  v√°rias  vezes,  para  evitar  esse  problema. Os esquemas esperar-morrer e ferir-esperar, discutidos  anteriormente,  evitam  a  inani√ß√£o,  pois eles reiniciam uma transa√ß√£o que foi abortada com o mesmo r√≥tulo de tempo original, de modo que a possibilidade de que a mesma transa√ß√£o seja abortada repetidamente √© pequena.

## 22.2 Controle de concorr√™ncia baseado na ordena√ß√£o de r√≥tulo de tempo (timestamp)

O  uso  de  bloqueios,  combinado  com  o  protocolo  2PL,  garante  a  serializa√ß√£o  de  schedules.  Os schedules serializ√°veis produzidos pelo 2PL t√™m seus schedules  seriais  equivalentes  com  base  na  ordem em que as transa√ß√µes em execu√ß√£o bloqueiam os itens que elas adquirem. Se uma transa√ß√£o precisar de um item que j√° est√° bloqueado, ela pode ser for√ßada a esperar at√© que o item seja liberado. Algumas transa√ß√µes

podem ser abortadas e reiniciadas devido ao problema de deadlock. Uma t√©cnica diferente, que garante a serializa√ß√£o, envolve o uso de r√≥tulos de tempo de transa√ß√£o para ordenar a execu√ß√£o da transa√ß√£o para um schedule serial equivalente. Na Se√ß√£o 22.2.1, discutimos estampas de tempo, e na Se√ß√£o 22.2.2, abordamos como a serializa√ß√£o √© imposta ao ordenar as transa√ß√µes com base em seus r√≥tulos de tempo.

## 22.2.1 R√≥tulos de tempo (timestamp)

Lembre-se de que um r√≥tulo de tempo √© um identificador exclusivo criado pelo SGBD para identificar uma transa√ß√£o. Normalmente, os valores de r√≥tulo de tempo s√£o atribu√≠dos na ordem em que as transa√ß√µes s√£o submetidas ao sistema, de modo que um r√≥tulo  de  tempo  pode  ser  imaginado  como  a hora de in√≠cio da transa√ß√£o . Vamos nos referir ao r√≥tulo de tempo  da  transa√ß√£o T como TS( T ) . As  t√©cnicas de controle de concorr√™ncia baseadas na ordena√ß√£o por r√≥tulo de tempo n√£o usam bloqueios; logo, deadlocks n√£o podem ocorrer .

Os r√≥tulos de tempo podem ser gerados de v√°rias maneiras.  Uma  possibilidade  √©  utilizar  um  contador que √© incrementado toda vez que seu valor √© atribu√≠do a  uma transa√ß√£o. Os r√≥tulos de tempo de transa√ß√£o s√£o numerados com 1, 2, 3, ... nesse esquema. Um contador do computador tem um valor m√°ximo finito, de modo que o sistema precisa reiniciar o contador periodicamente para zero quando nenhuma transa√ß√£o estiver sendo executada por algum per√≠odo curto de tempo. Outra maneira de implementar r√≥tulos de tempo √© usar o valor atual de data/hora do clock do sistema e garantir que dois valores de r√≥tulo de tempo quaisquer sejam gerados durante a mesmo batida do clock.

## 22.2.2 O algoritmo de ordena√ß√£o de r√≥tulo de tempo (timestamp)

A ideia para esse esquema √© ordenar as transa√ß√µes com base em seus r√≥tulos de tempo. Um sched  ule em que as transa√ß√µes participam √© ent√£o serializ√°vel, e o √∫nico schedule serial equivalente permitido tem as transa√ß√µes na ordem de seus valores de r√≥tulo de tempo. Isso  √©  chamado  de ordena√ß√£o de r√≥tulo  de tempo (TO) .  Observe como isso difere do 2PL, em que um schedule √© serializ√°vel por ser equivalente a algum schedule serial permitido pelos protocolos de bloqueio. Na ordena√ß√£o de r√≥tulo de tempo, por√©m, o schedule √© equivalente √† ordem serial em particular correspondente √† ordem dos r√≥tulos de tempo da transa√ß√£o.  O  algoritmo  precisa  garantir  que,  para cada item acessado pelas opera√ß√µes em conflito no schedule, a ordem em que o item √© acessado n√£o viola a ordem do r√≥tulo de tempo. Para fazer isso, o algo- ritmo associa a cada item X do banco de dados dois valores de r√≥tulo de tempo ( TS ):

- 1. read\_TS( X ). O r√≥tulo de tempo de leitura do item X √©  o  maior  entre  todos  os  r√≥tulos  de tempo das transa√ß√µes que leram com sucesso o item X - ou seja, read\_TS ( X ) = TS ( T ), onde T √© a transa√ß√£o mais recente que leu X com sucesso.
- 2. write\_TS( X ). O r√≥tulo  de  tempo  de  grava√ß√£o do item X √© o maior de todos os r√≥tulos de tempo das transa√ß√µes que gravaram com sucesso  o  item X -  ou  seja, write\_TS ( X )  = TS ( T ), onde T √© a transa√ß√£o mais recente que gravou X com sucesso.

Ordena√ß√£o de r√≥tulo de tempo (TO) b√°sica. Sempre que alguma transa√ß√£o T tenta  emitir  uma opera√ß√£o read\_item ( X ) ou write\_item ( X ), o  algoritmo de TO b√°sico compara o r√≥tulo de tempo de T com read\_TS ( X ) e write\_TS ( X ) para garantir que a ordem do r√≥tulo de tempo da execu√ß√£o da transa√ß√£o n√£o seja violada. Se essa ordem for violada, ent√£o a transa√ß√£o T √© abortada e submetida novamente ao sistema como uma nova transa√ß√£o com um novo r√≥tulo de  tempo .  Se T for  abortada  e  revertida,  qualquer transa√ß√£o T 1 que possa ter usado um valor gravado por T tamb√©m precisa ser revertida. De modo semelhante, qualquer transa√ß√£o T 2 que possa ter utilizado um valor gravado por T tamb√©m precisa ser revertida, e assim por diante. Esse efeito √© conhecido como propaga√ß√£o de cancelamento (ou rollback em cascata)  e  √©  um  dos  problemas  associados  √†  TO  b√°sica, pois  os  schedules  produzidos  n√£o  t√™m  garantias  de serem recuper√°veis. Um protocolo adicional precisa ser imposto para garantir que os schedules sejam recuper√°veis, sem cascata ou estritos. Primeiro, descrevemos o algoritmo de TO b√°sico aqui. O algoritmo de controle de concorr√™ncia deve verificar se as opera√ß√µes em conflito violam a ordena√ß√£o de r√≥tulo de tempo nos dois casos a seguir:

- 1. Sempre que uma transa√ß√£o T emitir uma opera√ß√£o write\_item ( X ), o seguinte deve ser verificado:
- a. Se read\_TS ( X ) &gt; TS ( T ) ou se write\_TS ( X ) &gt; TS ( T ), ent√£o aborte e reverta T e rejeite a opera√ß√£o. Isso deve ser feito porque alguma transa√ß√£o mais recente com um r√≥tulo de tempo maior que TS ( T ) - e, portanto, depois de T na ordena√ß√£o do r√≥tulo de tempo - j√° leu ou gravou o valor do item X antes que T tivesse uma chance de gravar X ,  violando  assim  a ordena√ß√£o do r√≥tulo de tempo.
- b. Se a condi√ß√£o na parte (a) n√£o ocorrer, ent√£o execute a opera√ß√£o write\_item ( X ) de T e defina write\_TS ( X ) como TS ( T ).

- 2. Sempre que uma transa√ß√£o T emitir a opera√ß√£o read\_item ( X ), o seguinte deve ser verificado:
- a. Se write\_TS ( X ) &gt; TS ( T ), ent√£o aborte e reverta T e  rejeite a opera√ß√£o. Isso deve ser feito porque alguma transa√ß√£o mais recente com r√≥tulo de tempo maior que TS ( T ) - e, portanto, depois de T na ordena√ß√£o do r√≥tulo de tempo - j√° gravou o valor do item X antes que T tivesse uma chance de ler X.
- b. Se write\_TS ( X ) ‚â§ TS ( T ), ent√£o execute a opera√ß√£o read\_item ( X ) de T e defina read\_TS ( X ) como o maior de TS ( T ) e o read\_TS ( X ) atual.

Sempre que o algoritmo de TO b√°sico detectar  duas opera√ß√µes  em  conflito que  ocorrem  na ordem  incorreta,  ele  rejeita  a  √∫ltima  das  duas, abortando a transa√ß√£o que a emitiu. Os sched  ules produzidos pela TO b√°sica, portanto, t√™m garantias  de  serem serializ√°veis  por  conflito ,  como  o protocolo  2PL.  Contudo,  alguns  schedules  s√£o poss√≠veis  sob  um  protocolo  que  n√£o  s√£o  permitidos sob o outro. Assim, nenhum protocolo permite todos os  schedules  serializ√°veis poss√≠veis . Conforme j√° mencionamos, o deadlock n√£o ocorre com a ordena√ß√£o de r√≥tulo de tempo. Por√©m, o  rein√≠cio  c√≠clico  (e,  portanto,  a  inani√ß√£o)  pode acontecer  se  uma  transa√ß√£o  for  continuamente abortada e reiniciada.

Ordena√ß√£o de r√≥tulo de tempo (TO) estrita. Uma varia√ß√£o  da  TO  b√°sica,  chamada TO estrita ,  garante  que  os  schedules  sejam  tanto estritos (para maior facilidade de recupera√ß√£o) quanto serializ√°veis  (conflito).  Nessa  varia√ß√£o,  uma  transa√ß√£o T emite  um read\_item ( X )  ou write\_item ( X ),  tal  que TS ( T ) &gt; write\_TS ( X ) tenha sua opera√ß√£o de leitura ou grava√ß√£o adiada at√© que a transa√ß√£o T ' que gravou o valor de X (portanto, TS ( T ') = write\_TS ( X )) tenha  sido  confirmada  ou  abortada.  Para  implementar esse algoritmo, √© necess√°rio simular o bloqueio de um item X que foi gravado pela transa√ß√£o T '  at√©  que T '  seja  confirmada  ou  abortada.  Esse algoritmo n√£o causa deadlock ,  pois T espera por T ' somente se TS ( T ) &gt; TS ( T ').

Regra da grava√ß√£o de Thomas. Uma modifica√ß√£o do algoritmo de TO b√°sico, conhecida como regra da grava√ß√£o de Thomas ,  n√£o imp√µe a serializa√ß√£o por conflito,  mas  rejeita  menos  opera√ß√µes  de  grava√ß√£o ao modificar as verifica√ß√µes para a opera√ß√£o write\_ item ( X ) da seguinte forma:

- 1. Se read\_TS ( X ) &gt; TS ( T ), ent√£o aborte e reverta T , e rejeite a opera√ß√£o.
- 2. Se write\_TS ( X )  &gt; TS ( T ),  ent√£o  n√£o  execute a  opera√ß√£o  de  grava√ß√£o,  mas  continue  pro-

cessando. Isso porque alguma transa√ß√£o com r√≥tulo de tempo maior que TS ( T ) - e, portanto, depois de T na ordena√ß√£o da r√≥tulo de tempo - j√° gravou o valor de X . Assim, temos de ignorar a opera√ß√£o write\_item ( X ) de T porque j√° est√° desatualizada e obsoleta. Observe  que  qualquer  conflito  que  surja  dessa situa√ß√£o seria detectado pelo caso (1).

- 3. Se nem a condi√ß√£o na parte (1) nem a condi√ß√£o  na  parte  (2)  acontecer,  ent√£o  execute  a  opera√ß√£o write\_item ( X )  de T e  defina write\_TS ( X ) para TS ( T ).

## 22.3 √©cnicas de controle de T concorr√™ncia multivers√£o

Outros protocolos para controle de concorr√™ncia mant√™m os valores antigos de um item de dados quando este √© atualizado. Eles s√£o conhecidos como controle de concorr√™ncia multivers√£o ,  pois  diversas vers√µes (valores) de um item s√£o mantidas. Quando uma transa√ß√£o requer acesso a um item, uma vers√£o apropriada √©  escolhida  para  manter  a  serializa√ß√£o do schedule atualmente em execu√ß√£o, se poss√≠vel. A ideia √© que algumas opera√ß√µes de leitura, que seriam rejeitadas em outras t√©cnicas, ainda possam ser aceitas ao ler uma vers√£o mais antiga do item para manter a serializa√ß√£o. Quando uma transa√ß√£o grava um item, ela grava uma nova vers√£o ,  e  a(s) vers√£o(√µes) antiga(s) do item √©(s√£o) retida(s). Alguns algoritmos de controle de concorr√™ncia multivers√£o usam o conceito de serializa√ß√£o de vis√£o em vez da serializa√ß√£o de conflito.

Uma desvantagem √≥bvia das t√©cnicas de multivers√£o √© a necessidade de mais armazenamento para manter v√°rias vers√µes dos itens do banco de dados. Por√©m, vers√µes mais antigas podem ter de ser mantidas de qualquer forma - por exemplo, para fins de recupera√ß√£o. Al√©m disso, algumas aplica√ß√µes de banco de dados exigem que vers√µes mais antigas sejam mantidas como um hist√≥rico da evolu√ß√£o de valores do item de dados. O caso extremo √© um banco de dados temporal (ver Se√ß√£o 26.2), que registra todas as mudan√ßas e os momentos em que elas ocorreram. Nesses  casos,  n√£o  existe  penalidade  de  armazenamento  adicional  para  t√©cnicas  multivers√£o,  pois  as vers√µes mais antigas j√° s√£o mantidas.

V√°rios  esquemas  de  controle  de  concorr√™ncia multivers√£o  foram  propostos.  Discutimos  dois  esquemas aqui, um baseado na ordena√ß√£o de r√≥tulo de tempo e o outro baseado no 2PL. Al√©m disso, o m√©todo de controle de concorr√™ncia de valida√ß√£o (ver Se√ß√£o 22.4) tamb√©m mant√©m m√∫ltiplas vers√µes.

## 22.3.1 √©cnica multivers√£o baseada na T ordena√ß√£o de r√≥tulo de tempo

Nesse m√©todo, diversas vers√µes X 1 , X 2 , ..., X k de cada item de dados X s√£o mantidas. Para cada vers√£o , o valor da vers√£o X i e os dois r√≥tulos de tempo a seguir s√£o mantidos:

- 1. read\_TS( X i ). O r√≥tulo de tempo de leitura de X i √© o maior de todos os r√≥tulos de tempo de transa√ß√µes que leram a vers√£o X i com sucesso.
- 2. write\_TS( X i ). O r√≥tulo de tempo de grava√ß√£o de X i √© o r√≥tulo de tempo da transa√ß√£o que gravou o valor da vers√£o X i .

Sempre que uma transa√ß√£o T tem permiss√£o para executar uma opera√ß√£o write\_item ( X ), uma nova vers√£o X k +1 do  item X √©  criada,  e  tanto write\_TS ( X k +1 ) quanto read\_TS ( X k +1 ) s√£o definidos como TS ( T ). De modo  correspondente,  quando  uma  transa√ß√£o T tem permiss√£o para ler o valor da vers√£o X i , o valor de read\_TS ( X )  √©  definido como sendo o maior dentre o read\_TS ( X i ) atual e TS ( T ).

Para garantir a serializa√ß√£o, as seguintes regras s√£o usadas:

- 1. Se  a  transa√ß√£o T emitir  uma  opera√ß√£o wri-te\_item ( X )  e  a  vers√£o i de X tiver  o write\_ TS ( X i )  mais  alto  de  todas  as  vers√µes  de X que  tamb√©m  seja menor  ou  igual  a TS ( T ), e read\_TS ( X i )  &gt; TS ( T ),  ent√£o  aborte  e  retroceda a transa√ß√£o T ;  caso  contr√°rio,  crie uma nova vers√£o X j de X com read\_TS ( X j ) = write\_TS ( X j ) = TS ( T ).
- 2. Se a transa√ß√£o T emitir uma opera√ß√£o read\_ item(X) , determine a vers√£o   de i X que tem o write\_TS ( X i ) mais alto de todas as vers√µes de X que tamb√©m seja menor ou igual a TS ( T ); depois, retorne o valor de X i √† transa√ß√£o T , e defina o valor de read\_TS ( X i ) ao maior de TS ( T ) e o read\_TS ( X i ) atual.

Como podemos ver no caso 2, um read\_item ( X ) sempre tem sucesso, pois encontra a vers√£o apropriada X i para ler com base no write\_TS de diversas vers√µes existentes de X . No caso 1, por√©m, a transa√ß√£o T pode ser abortada e retrocedida. Isso acontece se T tentar gravar uma vers√£o de X que deveria ter sido lida por outra transa√ß√£o T' cujo r√≥tulo de tempo √© read\_TS ( X i ); no entanto, T' j√° leu a vers√£o X i ,  que  foi  gravada  pela  transa√ß√£o  com  r√≥tulo  de tempo igual a write\_TS ( X i ). Se houver esse conflito, T √© retrocedida; caso contr√°rio, uma nova vers√£o de X , gravada pela transa√ß√£o T , √© criada. Observe que, se T for retrocedida, pode haver rollback em casca- ta. Portanto, para garantir a facilidade de recupera√ß√£o, uma transa√ß√£o T n√£o deve ter permiss√£o para confirmar at√© que todas as transa√ß√µes que gravaram alguma vers√£o que T leu tenham sido confirmadas.

## 22.3.2 Bloqueio em duas fases multivers√£o usando bloqueios de certifica√ß√£o

Neste esquema de bloqueio em modo m√∫ltiplo, existem tr√™s modos de bloqueio para um item: leitura, grava√ß√£o e certifica√ß√£o , em vez de apenas dois modos (leitura, grava√ß√£o) discutidos anteriormente. Logo, o estado de LOCK ( X ) para um item X pode ser um dentre bloqueado para leitura, bloqueado para grava√ß√£o, bloqueado  para  certifica√ß√£o  ou  desbloqueado.  No esquema de bloqueio padr√£o, com apenas bloqueios de leitura e grava√ß√£o (ver Se√ß√£o 22.1.1), um bloqueio de grava√ß√£o √© um bloqueio exclusivo. Podemos descrever  o  relacionamento  entre  bloqueios  de  leitura e  grava√ß√£o  no  esquema-padr√£o  por  meio  da tabela de compatibilidade de bloqueio mostrada na Figura 22.6(a). Uma entrada Sim significa que, se uma transa√ß√£o T mantiver o tipo de bloqueio especificado no cabe√ßalho da coluna no item X e  se  a  transa√ß√£o T ' solicitar o tipo de bloqueio especificado no cabe√ßalho de linha no mesmo item X , ent√£o T' pode obter o bloqueio , pois os modos de bloqueio s√£o compat√≠veis. Por sua vez, uma entrada N√£o na tabela indica que os bloqueios n√£o s√£o compat√≠veis, de modo que T' precisa esperar at√© que T libere o bloqueio.

No esquema de bloqueio padr√£o, quando uma transa√ß√£o  obt√©m  um  bloqueio  de  grava√ß√£o  em  um

Figura 22.6

| (a)          | Leitura   | Grava√ß¬™o   |              |
|--------------|-----------|------------|--------------|
| Leitura      | Sim       | N¬™o        |              |
| Grava√ß¬™o     | N¬™o       | N¬™o        |              |
| (b)          | Leitura   | Grava√ß¬™o   | Certifica√ß¬™o |
| Leitura      | Sim       | Sim        | N¬™o          |
| Grava√ß¬™o     | Sim       | N¬™o        | N¬™o          |
| Certifica√ß¬™o | N¬™o       | N¬™o        | N¬™o          |

Tabelas de compatibilidade de bloqueio. (a) Uma tabela de compatibilidade para o esquema de bloqueio leitura/ grava√ß√£o. (b) Uma tabela de compatibilidade para o esquema de bloqueio leitura/grava√ß√£o/certifica√ß√£o.

item,  nenhuma  outra  transa√ß√£o  pode  acessar  esse item. A ideia por tr√°s do 2PL multivers√£o √© permitir que outras transa√ß√µes T leiam um item X enquanto uma √∫nica transa√ß√£o T mant√©m um bloqueio de grava√ß√£o em X . Isso √© realizado ao permitir duas vers√µes para cada item X ; uma vers√£o sempre precisa ser gravada por alguma transa√ß√£o confirmada. A segunda vers√£o X ' √© criada quando uma transa√ß√£o T adquire um bloqueio de grava√ß√£o em um item. Outras transa√ß√µes  podem  continuar  a  ler  a vers√£o  confirmada de X enquanto T mant√©m o bloqueio de grava√ß√£o. A transa√ß√£o T pode gravar o valor de X ' conforme a necessidade, sem afetar o valor da vers√£o confirmada X .  Por√©m, quanto T estiver pronta para confirmar, ela deve obter um bloqueio de certifica√ß√£o em todos os itens sobre os quais atualmente mant√©m bloqueios de grava√ß√£o antes que possa confirmar. O bloqueio de certifica√ß√£o n√£o √© compat√≠vel com os bloqueios de leitura, de modo que a transa√ß√£o pode ter que esperar sua confirma√ß√£o at√© que todos os itens bloquea  dos para grava√ß√£o sejam liberados por quaisquer transa√ß√µes de leitura, a fim de obter os bloqueios de certifica√ß√£o. Quando os bloqueios de certifica√ß√£o - que s√£o bloqueios exclusivos - s√£o adquiridos, a vers√£o confirmada X do  item  de  dados √© definida como o valor da vers√£o X ', a vers√£o X ' √© descartada e os bloqueios de certifica√ß√£o s√£o ent√£o liberados. A tabela de  compatibilidade  de  bloqueio  para  esse  esquema aparece na Figura 22.6(b).

Nesse esquema 2PL multivers√£o, as leituras podem  prosseguir  simultaneamente  com  uma  √∫nica opera√ß√£o de grava√ß√£o - um arranjo n√£o permitido sob  os  esquemas  2PL  padr√£o.  O  custo  √©  que  uma transa√ß√£o  pode  ter  de  esperar  sua  confirma√ß√£o  at√© que obtenha bloqueios de certifica√ß√£o exclusivos em todos  os  itens que  atualizou.  Pode-se  mostrar  que esse esquema evita a propaga√ß√£o de abortos, pois as transa√ß√µes s√≥ t√™m permiss√£o para ler a vers√£o X que foi gravada por uma transa√ß√£o confirmada. Por√©m, podem ocorrer deadlocks se o upgrading de um bloqueio de leitura para um bloqueio de grava√ß√£o for permitido, e estes devem ser tratados por varia√ß√µes das t√©cnicas discutidas na Se√ß√£o 22.1.3.

## 22.4 √©cnicas de controle de T concorr√™ncia de valida√ß√£o (otimista)

√© feita para determinar se o item acessado est√° bloqueado. Na ordena√ß√£o de r√≥tulo de tempo, o r√≥tulo de tempo da transa√ß√£o √© verificado contra os r√≥tulos de tempo de leitura e grava√ß√£o do item. Essa verifica√ß√£o representa o overhead durante a execu√ß√£o da transa√ß√£o, com o efeito de atrasar todas as transa√ß√µes.

Nas t√©cnicas de controle de concorr√™ncia otimistas , tamb√©m conhecidas como t√©cnicas de valida√ß√£o ou certifica√ß√£o , nenhuma verifica√ß√£o √© feita enquanto  a  transa√ß√£o  est√°  executando.  V√°rios  m√©todos te√≥ricos  de  controle  de  concorr√™ncia  s√£o  baseados na t√©cnica de valida√ß√£o. Descreveremos apenas um esquema  aqui.  Nesse  esquema,  as  atualiza√ß√µes  na transa√ß√£o n√£o s√£o aplicadas diretamente aos itens do banco de dados at√© que a transa√ß√£o alcance seu final. Durante a execu√ß√£o da transa√ß√£o, todas as atualiza√ß√µes s√£o aplicadas a c√≥pias locais dos itens de dados que s√£o mantidas para a transa√ß√£o. 6  Ao final da execu√ß√£o da transa√ß√£o, uma fase de valida√ß√£o verifica se qualquer uma das atualiza√ß√µes da transa√ß√£o viola a serializa√ß√£o. Algumas informa√ß√µes necess√°rias √† fase de valida√ß√£o precisam ser mantidas pelo sistema. Se a serializa√ß√£o n√£o for violada, a transa√ß√£o √© confirmada e o banco de dados √© atualizado com base em c√≥pias locais; caso contr√°rio, a transa√ß√£o √© abortada e reiniciada mais tarde.

Existem tr√™s fases para esse protocolo de controle de concorr√™ncia:

- 1. Fase de leitura. Uma transa√ß√£o pode ler valores dos itens de dados confirmados com base no  banco  de  dados.  Por√©m,  as  atualiza√ß√µes s√£o aplicadas apenas a c√≥pias locais (vers√µes) dos itens de dados mantidos no espa√ßo de trabalho da transa√ß√£o.
- 2. Fase de valida√ß√£o. A  verifica√ß√£o  √©  realizada para garantir que a serializa√ß√£o n√£o ser√° violada  se  as  atualiza√ß√µes  da  transa√ß√£o  forem aplicadas ao banco de dados.
- 3. Fase de grava√ß√£o. Se a fase de valida√ß√£o for bem-sucedida,  as  atualiza√ß√µes  da  transa√ß√£o s√£o aplicadas ao banco de dados; caso contr√°rio,  as  atualiza√ß√µes  s√£o  descartadas  e  a transa√ß√£o √© reiniciada.

Em todas as t√©cnicas de controle de concorr√™ncia que discutimos at√© aqui, certo grau de verifica√ß√£o √© feito antes que uma opera√ß√£o do banco de dados possa ser executada. Por exemplo, no bloqueio, uma verifica√ß√£o

A  ideia  por  tr√°s  do  controle  de  concorr√™ncia otimista  √©  realizar  todas  as  verifica√ß√µes  ao  mesmo tempo; logo, a execu√ß√£o da transa√ß√£o prossegue com um m√≠nimo de overhead at√© que a fase de valida√ß√£o seja alcan√ßada. Se houver pouca interfer√™ncia entre as transa√ß√µes, a maioria ser√° validada com sucesso. Contudo, se houver muita interfer√™ncia, muitas tran-

6 Observe que isso pode ser considerado mantendo m√∫ltiplas vers√µes dos itens!

sa√ß√µes que executam at√© o t√©rmino ter√£o seus resultados descartados e dever√£o ser reiniciadas mais tarde. Sob  essas  circunst√¢ncias,  as  t√©cnicas  otimistas  n√£o funcionam bem. As t√©cnicas s√£o chamadas de otimistas porque consideram que haver√° pouca interfer√™ncia  e,  portanto,  n√£o  haver√°  necessidade  de  realizar verifica√ß√£o durante a execu√ß√£o da transa√ß√£o.

O protocolo otimista que descrevemos usa r√≥tulos  de  tempo  de  transa√ß√£o  e  tamb√©m  requer  que os write\_sets e read\_sets das transa√ß√µes sejam mantidos pelo sistema. Al√©m disso, tempos de in√≠cio e fim para algumas das tr√™s  fases  precisam  ser  mantidos  para cada transa√ß√£o. Lembre-se de que o write\_set de uma transa√ß√£o √© o conjunto de itens que ela grava, e o read\_set √© o conjunto de itens que ela l√™. Na fase de valida√ß√£o para a transa√ß√£o T i , o protocolo verifica se T i n√£o interfere com quaisquer transa√ß√µes confirmadas ou com quaisquer outras transa√ß√µes atualmente em sua fase de valida√ß√£o. A fase de valida√ß√£o para T i verifica se, para cada transa√ß√£o T j que √© confirmada ou est√° em sua fase de valida√ß√£o, uma das seguintes condi√ß√µes √© mantida:

- 1. A transa√ß√£o T j completa sua fase de grava√ß√£o antes que T i inicie sua fase de leitura.
- 2. T i inicia sua fase de grava√ß√£o depois que T j completa sua fase de grava√ß√£o, e o read\_set de T i n√£o  tem  itens  em  comum  com  o wri-te\_set de T j .
- 3. Tanto o read\_set quanto o write\_set de T i n√£o t√™m itens em comum com o write\_set de T j , e T j completa sua fase de leitura antes que T i o fa√ßa.

Ao validar a transa√ß√£o T i , a primeira condi√ß√£o √© verificada primeiro para cada transa√ß√£o T j , pois (1) √© a condi√ß√£o mais simples de verificar. Somente se a condi√ß√£o 1 for falsa √© que a condi√ß√£o 2 √© verificada, e somente se (2) for falsa √© que a condi√ß√£o 3 - a mais complexa de ser avaliada - √© verificada. Se qualquer uma dessas tr√™s condi√ß√µes se mantiver, n√£o haver√° interfer√™ncia e T i ser√° validada com sucesso. Se nenhuma dessas tr√™s condi√ß√µes for mantida, a valida√ß√£o da transa√ß√£o T i falha e √© abortada e reiniciada mais tarde porque pode ter havido uma interfer√™ncia.

## 22.5 Granularidade dos itens de dados e bloqueio de granularidade m√∫ltiplo

Todas as t√©cnicas de controle de concorr√™ncia consideram que o banco de dados √© formado por uma s√©rie de itens de dados nomeados. Um item de banco de dados poderia ser escolhido como sendo um dos seguintes:

- ¬Ñ Um registro de banco de dados.
- ¬Ñ Um valor de campo de um registro de banco de dados.
- ¬Ñ Um bloco de disco.
- ¬Ñ Um arquivo inteiro.
- ¬Ñ Um banco de dados inteiro.

A granularidade pode afetar o desempenho do controle  de  concorr√™ncia  e  recupera√ß√£o.  Na  Se√ß√£o 22.5.1, discutimos alguns dos dilemas com rela√ß√£o √† escolha do n√≠vel de granularidade usado para o bloqueio e, na Se√ß√£o 22.5.2, tratamos de um esquema de bloqueio com granularidade m√∫ltipla, em que o n√≠vel de granularidade (tamanho do item de dados) pode ser alterado dinamicamente.

## 22.5.1 Considera√ß√µes de n√≠vel de granularidade para o bloqueio

O tamanho dos itens de dados normalmente √© chamado de granularidade do item de dados .  Uma granularidade fina refere-se a tamanhos de item pequenos, enquanto a granularidade grossa refere-se a tamanhos de item grandes. V√°rios dilemas precisam ser considerados na escolha do tamanho do item de dados.  Discutiremos  o  tamanho  do  item  de  dados no contexto do bloqueio, embora argumentos semelhantes possam ser feitos para outras t√©cnicas de controle de concorr√™ncia.

Primeiro, observe que, quanto maior o tamanho do item de dados, menor o grau de concorr√™ncia permitido. Por exemplo, se o tamanho do item de dados for um bloco de disco, uma transa√ß√£o T que precisa bloquear um registro B deve bloquear o bloco de disco X inteiro  que  cont√©m B ,  pois  um  bloqueio  est√° associado ao item de dados (bloco) inteiro. Agora, se outra transa√ß√£o S quiser bloquear um registro C diferente, que por acaso reside no mesmo bloco X em um modo de bloqueio em conflito, ela √© for√ßada a esperar. Se o tamanho do item de dados fosse um √∫nico registro, a transa√ß√£o S poderia prosseguir, pois estaria bloqueando um item de dados (registro) diferente.

Por sua vez, quanto menor o tamanho do item de dados, maior √© o n√∫mero de itens no banco de dados. Como cada item est√° associado a um bloqueio, o sistema ter√° um grande n√∫mero de bloqueios ativos para serem  tratados  pelo  gerenciador  de  bloqueio.  Mais opera√ß√µes de bloqueio e desbloqueio ser√£o realizadas, causando um overhead maior. Al√©m disso, mais espa√ßo de armazenamento ser√° exigido para a tabela de bloqueio. Para os r√≥tulos de tempo, o armazenamento √© exigido para o read\_TS e write\_TS para cada item de dados, e haver√° um overhead semelhante para o tratamento de um grande n√∫mero de itens.

Dados esses dilemas, uma pergunta √≥bvia pode ser feita: qual √© o melhor tamanho de item? A resposta √© que isso depende dos tipos de transa√ß√µes envolvidas . Se uma transa√ß√£o t√≠pica acessa um pequeno n√∫mero de registros, √© vantajoso ter uma granularidade de  item  de  dados  com  um  registro.  Mas,  se  uma transa√ß√£o  normalmente  acessa  muitos  registros  no mesmo arquivo, pode ser melhor ter granularidade de bloco ou arquivo de modo que a transa√ß√£o considerar√° todos esses registros como um (ou alguns) item(ns) de dados.

## 22.5.2 Bloqueio com n√≠vel de granularidade m√∫ltiplo

Como o melhor tamanho de granularidade depende da transa√ß√£o dada, parece apropriado que um sistema de banco de dados admita m√∫ltiplos n√≠veis de granularidade, sendo que este pode ser diferente para v√°rias misturas de transa√ß√µes. A Figura 22.7 mostra uma hierarquia de granularidade simples com um banco de dados que cont√©m dois arquivos, cada arquivo com v√°rias p√°ginas de disco, e cada p√°gina contendo v√°rios registros. Isso pode ser usado para ilustrar um protocolo 2PL com n√≠vel de granularidade m√∫ltiplo , no qual um bloqueio pode ser solicitado em qualquer n√≠vel. Por√©m, tipos adicionais de bloqueios ser√£o necess√°rios para dar suporte a tal protocolo com efici√™ncia.

√©  mais  eficiente  do  que  a  defini√ß√£o  de n bloqueios em n√≠vel de p√°gina ou ter de bloquear cada registro individual. Agora, suponha que outra transa√ß√£o T 2 s√≥ queira ler o registro r 1 nj da p√°gina p 1 n do arquivo f 1 ;  ent√£o, T 2 solicitaria um bloqueio compartilhado em n√≠vel de registro em r 1 nj .  No entanto, o sistema de banco de dados (ou seja, o gerenciador de transa√ß√£o ou, mais especificamente, o gerenciador de bloqueio) deve verificar a compatibilidade do bloqueio solicitado com os bloqueios j√° mantidos. Um modo de  verificar  isso  √©  atravessar  a  √°rvore  da  folha r 1 nj para p 1 n para f 1 para db .  Se,  a  qualquer  momento, um bloqueio em conflito for mantido em qualquer um desses itens, ent√£o a solicita√ß√£o de bloqueio para r 1 nj √© negada e T 2 √© bloqueada e precisa esperar. Essa travessia seria muito eficiente.

Mas, e se a solicita√ß√£o da transa√ß√£o T 2 veio antes da solicita√ß√£o da transa√ß√£o T 1 ? Nesse caso, o bloqueio de registro compartilhado √© concedido a T 2 para r 1 nj , mas quando o bloqueio em n√≠vel de arquivo de T 1 for solicitado,  √©  muito  dif√≠cil  que  o  gerenciador  de  bloqueio verifique todos os n√≥s (p√°ginas e registros) que s√£o  descendentes  do  n√≥ f 1 para  um  conflito  de  bloqueio. Isso seria muito ineficaz e frustraria o prop√≥sito de ter m√∫ltiplos bloqueios em n√≠vel de granularidade.

Considere o seguinte cen√°rio, apenas com os tipos de bloqueio compartilhado e exclusivo, que se refere  ao  exemplo  da  Figura  22.7.  Suponha  que  a transa√ß√£o T 1 queira  atualizar todos os registros no arquivo f 1 , e T 1 solicite e receba um bloqueio exclusivo para f 1 . Ent√£o todas as p√°ginas de f 1 ( p 11 at√© p 1 n ) e os registros contidos nessas p√°ginas s√£o bloqueados no modo exclusivo. Isso √© ben√©fico para T 1 , porque a defini√ß√£o de um bloqueio √∫nico em n√≠vel de arquivo

Para  tornar  o  bloqueio  com  n√≠vel  de  granularidade  m√∫ltiplo  pr√°tico,  outros  tipos  de  bloqueios, chamados bloqueios de inten√ß√£o , s√£o necess√°rios. A ideia por tr√°s dos bloqueios de inten√ß√£o √© que uma transa√ß√£o indique, junto com o caminho da raiz at√© o n√≥ desejado, que tipo de bloqueio (compartilhado ou exclusivo) ela exigir√° de um dos descendentes do n√≥. Existem tr√™s tipos de bloqueios de inten√ß√£o:

- 1. Intention-shared (IS) indica que um ou mais bloqueios  compartilhados  ser√£o  solicitados em algum ou alguns n√≥s descendentes.

Figura 22.7 Uma hierarquia de granularidade para ilustrar o bloqueio com n√≠vel de granularidade m√∫ltiplo.



- 2. Intention-exclusive  (IX)  indica  que  um  ou mais  bloqueios  exclusivos  ser√£o  solicitados em algum ou alguns n√≥s descendentes.
- 3. Shared-intention-exclusive  (SIX)  indica  que o n√≥ atual est√° bloqueado no modo compartilhado  (shared),  mas  que  um  ou  mais  bloqueios exclusivos ser√£o solicitados em algum ou alguns n√≥s descendentes.

A tabela de compatibilidade dos tr√™s bloqueios de inten√ß√£o, e os bloqueios compartilhados e exclusivos, aparece na Figura 22.8. Al√©m da introdu√ß√£o dos tr√™s tipos de bloqueios de inten√ß√£o, um protocolo de bloqueio apropriado precisa ser usado. O protocolo de bloqueio com granularidade m√∫ltipla ( MGL -Multiple  Granularity  Locking )  consiste nas seguintes regras:

- 1. A compatibilidade de bloqueio (baseada na Figura 22.8) deve ser aderida.
- 2. A raiz  da  √°rvore  precisa  ser  bloqueada  primeiro, em qualquer modo.
- 3. Um n√≥ N pode ser bloqueado por uma transa√ß√£o T no modo S ou IS somente se o n√≥ pai N j√°  estiver  bloqueado pela transa√ß√£o T no modo IS ou IX.
- 4. Um n√≥ N s√≥  pode  ser  bloqueado  por  uma transa√ß√£o T no modo X, IX ou SIX se o pai do n√≥ N j√° estiver bloqueado pela transa√ß√£o T no modo IX ou SIX.
- 5. Uma transa√ß√£o T s√≥  pode  bloquear  um  n√≥ se n√£o tiver desbloqueado qualquer n√≥ (para impor o protocolo 2PL).
- 6. Uma  transa√ß√£o T s√≥  pode  desbloquear  um n√≥, N , se nenhum dos filhos do n√≥ N estiver atualmente bloqueado por T .

|     | IS   | IX   | S   | SIX   | X   |
|-----|------|------|-----|-------|-----|
| IS  | Sim  | Sim  | Sim | Sim   | N¬™o |
| IX  | Sim  | Sim  | N¬™o | N¬™o   | N¬™o |
| S   | Sim  | N¬™o  | Sim | N¬™o   | N¬™o |
| SIX | Sim  | N¬™o  | N¬™o | N¬™o   | N¬™o |
| X   | N¬™o  | N¬™o  | N¬™o | N¬™o   | N¬™o |

## Figura 22.8

Matriz de compatibilidade de bloqueio para o bloqueio com granularidade m√∫ltipla.

A regra 1 afirma simplesmente que os bloqueios em conflito n√£o podem ser concedidos. As regras 2, 3 e 4 indicam as condi√ß√µes quando uma transa√ß√£o pode bloquear determinado n√≥ em qualquer um dos modos  de  bloqueio.  As  regras  5  e  6  do  protocolo MGL imp√µem regras 2PL para  produzir  schedules serializ√°veis. Para ilustrar o protocolo MGL com a hierarquia de banco de dados na Figura 22.7, considere as tr√™s transa√ß√µes a seguir:

- 1. T 1 deseja atualizar os registros r 111 e r 211 .
- 2. T 2 deseja atualizar todos os registros na p√°gina p 12 .
- 3. T 3 deseja ler o registro r 11 j e o arquivo f 2 inteiro.

A Figura 22.9 mostra um schedule serializ√°vel poss√≠vel para essas tr√™s transa√ß√µes. Somente as opera√ß√µes de bloqueio e desbloqueio aparecem. A nota√ß√£o &lt; tipo\_bloqueio &gt;(&lt; item &gt;) √© usada para exibir as opera√ß√µes de bloqueio no schedule.

| T 1                | T 2      | T 3                                                                                                        |
|--------------------|----------|------------------------------------------------------------------------------------------------------------|
| IX( db ) IX( f 1 ) | IX( db ) | IS( db ) IS( f 1 ) IS( p 11 ) S( r 11 j ) S( f 2 ) unlock( r 11 j ) unlock( p 11 unlock( f 1 ) unlock( f ) |

## Figura 22.9

Opera√ß√µes de bloqueio para ilustrar um schedule serializ√°vel.

O protocolo de n√≠vel de granularidade m√∫ltiplo √©  especialmente adequado quando se processa uma mistura de transa√ß√µes que inclui (1) transa√ß√µes curtas que acessam apenas alguns itens (registros ou campos) e (2) transa√ß√µes longas que acessam arquivos inteiros. Nesse ambiente, menos bloqueio de transa√ß√£o e menos overhead de bloqueio s√£o contra√≠dos por tal protocolo  quando comparado com uma t√©cnica de bloqueio com granularidade de √∫nico n√≠vel.

## 22.6 Usando bloqueios para controle de concorr√™ncia em √≠ndices

O  bloqueio  em  duas  fases  tamb√©m  pode  ser aplicado a √≠ndices (ver Cap√≠tulo 18), nos quais os n√≥s de um √≠ndice correspondem a p√°ginas de disco. Por√©m, manter bloqueios em p√°ginas de √≠ndice at√© a fase de encolhimento do 2PL poderia causar uma quantidade indevida de bloqueio de transa√ß√£o porque pesquisar um √≠ndice sempre inicia  na  raiz . Portanto, se uma transa√ß√£o quiser inserir um registro (opera√ß√£o de grava√ß√£o), a raiz seria bloqueada no modo exclusivo, de modo que todas as outras solicita√ß√µes  de  bloqueio  em  conflito  para  o  √≠ndice devem esperar que a transa√ß√£o entre na fase de encolhimento. Isso impede todas as outras transa√ß√µes de acessarem o √≠ndice, de modo que, na pr√°tica, outras  t√©cnicas  para  o  bloqueio  de  um  √≠ndice  devem ser usadas.

A estrutura de √°rvore do √≠ndice pode ser aproveitada quando se desenvolve um esquema de controle  de  concorr√™ncia.  Por  exemplo,  quando  uma pesquisa de √≠ndice (opera√ß√£o de leitura) est√° sendo executada, um caminho na √°rvore √© atravessado da raiz at√© uma folha. Quando um n√≥ no n√≠vel inferior no caminho for acessado, os n√≥s de n√≠vel mais alto nesse caminho n√£o ser√£o usados novamente. Assim, quando um bloqueio de leitura em um n√≥ filho for obtido, o bloqueio no pai pode ser liberado. Quando uma inser√ß√£o est√° sendo aplicada a um n√≥ folha (ou seja, quando uma chave e um ponteiro s√£o inseridos), ent√£o um n√≥ folha espec√≠fico deve ser bloqueado no modo exclusivo. Por√©m, se esse n√≥ n√£o estiver cheio, a inser√ß√£o n√£o causar√° mudan√ßas nos n√≥s √≠ndice de n√≠vel mais alto, o que implica que eles n√£o precisar√£o ser bloqueados de maneira exclusiva.

Uma t√©cnica conservadora para inser√ß√µes seria bloquear o n√≥ raiz no modo exclusivo e depois acessar o n√≥ filho apropriado da raiz. Se o n√≥ filho n√£o estiver cheio, ent√£o o bloqueio no n√≥ raiz pode ser liberado. Essa t√©cnica pode ser aplicada em toda a √°rvore, at√© a folha, que normalmente est√° a tr√™s ou quatro n√≠veis da raiz. Embo- ra os bloqueios exclusivos sejam mantidos, eles s√£o logo liberados. Uma t√©cnica alternativa, mais otimista ,  seria requisitar  e  manter  bloqueios compartilhados nos  n√≥s que levam ao n√≥ folha, com um bloqueio exclusivo na folha. Se a inser√ß√£o fizer que a folha seja dividida, a inser√ß√£o se propagar√° para um ou mais n√≥s de n√≠vel mais alto. Depois, os bloqueios nos n√≥s de n√≠vel mais alto podem receber um upgrade para o modo exclusivo.

Outra t√©cnica para o bloqueio de √≠ndice √© usar uma variante da B + -tree, chamada √°rvore B-link . Em uma √°rvore B-link, n√≥s irm√£os no mesmo n√≠vel s√£o ligados em cada n√≠vel. Isso permite que os bloqueios compartilhados sejam usados quando se solicita uma p√°gina e exige que o bloqueio seja liberado antes de acessar o n√≥ filho. Para uma opera√ß√£o de inser√ß√£o, o bloqueio compartilhado em um n√≥ receberia um upgrade para o modo exclusivo. Se houver uma divis√£o, o n√≥ pai precisa ser bloqueado novamente no modo exclusivo. Uma complica√ß√£o se d√° para opera√ß√µes de pesquisa executadas simultaneamente com a atualiza√ß√£o. Suponha que uma opera√ß√£o de atualiza√ß√£o concorrente siga o mesmo caminho que a pesquisa, e insira uma nova entrada no n√≥ folha. Al√©m disso, suponha que a inser√ß√£o fa√ßa que o n√≥ folha seja dividido. Quando a inser√ß√£o √© feita, o processo de pesquisa retoma, seguindo o ponteiro para a folha desejada, somente para descobrir que a chave que ele est√° procurando n√£o est√° presente, pois a divis√£o moveu essa chave para um novo n√≥ folha, que seria o irm√£o da direita do n√≥ folha original. Entretanto, o processo de pesquisa ainda pode ter sucesso se seguir o ponteiro (liga√ß√£o) no n√≥ folha original para seu irm√£o da direita, para onde a chave desejada foi movida.

O tratamento do caso de exclus√£o, em que dois ou mais n√≥s da √°rvore de √≠ndice s√£o mesclados, tamb√©m faz parte do protocolo de concorr√™ncia da √°rvore B-link. Nesse caso, os bloqueios nos n√≥s a serem mesclados s√£o mantidos, bem como um bloqueio no pai dos dois n√≥s a serem mesclados.

## 22.7 Outras quest√µes de controle de concorr√™ncia

Nesta se√ß√£o, discutimos algumas outras quest√µes relevantes  ao  controle  de  concorr√™ncia.  Na  Se√ß√£o 22.7.1, abordamos os problemas associados √† inser√ß√£o e exclus√£o de registros e ao chamado problema do fantasma ,  que pode ocorrer quando os registros s√£o inseridos. Esse problema foi descrito como um problema  em  potencial  que  exige  uma  medida  de controle  de  concorr√™ncia  na  Se√ß√£o  21.6.  Na  Se√ß√£o 22.7.2,  discutimos  problemas  que  podem  ocorrer quando uma transa√ß√£o envia alguns dados a um monitor antes que ela seja confirmada, e depois a transa√ß√£o √© abortada.

## 22.7.1 Inser√ß√£o, exclus√£o e registros fantasma

Quando um novo item de dados √© inserido no banco de dados, ele obviamente n√£o pode ser acessado antes que o item seja criado e a opera√ß√£o de inser√ß√£o seja conclu√≠da. Em um ambiente de bloqueio, um bloqueio para o item pode ser criado e definido com o modo exclusivo (grava√ß√£o); o bloqueio pode ser liberado ao mesmo tempo em que outros bloqueios de grava√ß√£o seriam liberados, com base no protocolo de controle de concorr√™ncia que est√° sendo usado. Para um protocolo baseado em r√≥tulo de tempo, os r√≥tulos de tempo de leitura e grava√ß√£o do novo item s√£o definidos como o r√≥tulo de tempo da transa√ß√£o de cria√ß√£o.

Em seguida, considere uma opera√ß√£o de exclus√£o que √© aplicada em um item de dados existente. Para  protocolos  de  bloqueio,  novamente  um  bloqueio exclusivo (grava√ß√£o) deve ser obtido antes que a transa√ß√£o possa excluir o item. Para a ordena√ß√£o do r√≥tulo de tempo, o protocolo precisa garantir que nenhuma transa√ß√£o posterior tenha lido ou gravado o item antes de permitir que o item seja exclu√≠do.

Uma situa√ß√£o conhecida como problema do fantasma pode ocorrer quando um novo registro que est√° sendo inserido por alguma transa√ß√£o T satisfaz uma condi√ß√£o que um conjunto de registros acessados por outra  transa√ß√£o T '  precisa  satisfazer.  Por  exemplo, suponha que a transa√ß√£o T esteja inserindo um novo registro  de FUNCIONARIO cujo Dnr =  5,  enquanto  a transa√ß√£o T ' est√° acessando todos os registros de FUNCIONARIO cujo Dnr = 5 (digamos, para somar todos os seus valores de Salario para calcular o or√ßamento pessoal  para  o  departamento  5).  Se  a  ordem  serial equivalente for T seguido por T ', ent√£o T ' precisa ler o novo registro de FUNCIONARIO e incluir seu Salario no c√°lculo da soma. Para a ordem serial equivalente T ' seguida por T , o novo sal√°rio n√£o deve ser inclu√≠do. Observe que, embora as transa√ß√µes estejam logicamente em conflito, no √∫ltimo caso n√£o existe de fato um registro (item de dados) em comum entre as duas transa√ß√µes, pois T ' pode ter bloqueado todos os registros com Dnr = 5 antes que T tenha inserido o novo registro.  Isso  porque o registro que causa o conflito √© um registro fantasma ,  que de repente apareceu no banco de dados ao ser inserido. Se outras opera√ß√µes nas duas transa√ß√µes estiverem em conflito, o conflito devido ao registro fantasma pode n√£o ser reconhecido pelo protocolo de controle de concorr√™ncia.

Uma solu√ß√£o para o problema do registro fantasma √© usar o bloqueio de √≠ndice , conforme discutido na Se√ß√£o 22.6. Lembre-se, do Cap√≠tulo 18, que um √≠ndice inclui entradas que t√™m um valor de atributo, mais um conjunto de ponteiros para todos os regis- tros no arquivo com esse valor. Por exemplo, um √≠ndice em Dnr de FUNCIONARIO incluiria uma entrada para cada valor de Dnr distinto, mais um conjunto de ponteiros para todos os registros de FUNCIONARIO com esse valor. Se a entrada de √≠ndice for bloqueada antes que o pr√≥prio registro possa ser acessado, ent√£o o conflito no registro fantasma pode ser detectado, pois a transa√ß√£o T ' solicitaria um bloqueio de leitura na entrada de √≠ndice para Dnr = 5, e T solicitaria um bloqueio de grava√ß√£o na mesma entrada antes que elas pudessem colocar os bloqueios nos registros atuais. Como os bloqueios de √≠ndice est√£o em conflito, o conflito fantasma seria detectado.

Uma t√©cnica mais geral, chamada bloqueio de predicado , bloquearia o acesso a todos os registros que  satisfazem  um predicado (condi√ß√£o)  qualquer de uma maneira semelhante; por√©m, os bloqueios de predicado  provaram  ser  dif√≠ceis  de  implementar de modo eficiente.

## 22.7.2 ransa√ß√µes interativas T

Outro problema ocorre quando transa√ß√µes interativas leem entrada e gravam sa√≠da em um dispositivo interativo, como uma tela de monitor, antes que sejam  confirmadas.  O  problema  √©  que  um  usu√°rio pode inserir um valor de um item de dados em uma transa√ß√£o T que √© baseado em algum valor escrito na tela pela transa√ß√£o T ', a qual pode n√£o ter sido confirmada. Essa depend√™ncia entre T e T ' n√£o pode ser modelada pelo m√©todo de controle de concorr√™ncia do sistema, pois s√≥ √© baseada no usu√°rio interagindo com as duas transa√ß√µes.

Uma  t√©cnica  para  lidar  com  esse  problema  √© adiar a sa√≠da de transa√ß√µes para a tela at√© que elas tenham sido confirmadas.

## 22.7.3 Latches

Os bloqueios mantidos por uma curta dura√ß√£o normalmente  s√£o  chamados  de latches .  Os  latches n√£o seguem o protocolo de controle de concorr√™ncia normal, como o bloqueio em duas fases. Por exemplo,  um  latch  pode  ser  usado  para  garantir  a  integridade f√≠sica de uma p√°gina quando ela est√° sendo gravada do buffer para o disco. Um latch seria adquirido para a p√°gina, a p√°gina seria gravada no disco e, depois, o latch seria liberado.

## Resumo

Neste  cap√≠tulo,  discutimos  t√©cnicas  de  SGBD para controle de concorr√™ncia. Come√ßamos abordando os protocolos baseados em bloqueio, que de longe s√£o sem d√∫vida os mais usados na pr√°tica. Descreve-

mos o protocolo de bloqueio em duas fases (2PL) e diversas  de  suas  varia√ß√µes:  2PL  b√°sico,  2PL  estrito, 2PL conservador e 2PL rigoroso. As varia√ß√µes estrita e  rigorosa  s√£o  mais  comuns  por  causa  de  suas  melhores  propriedades  de  recupera√ß√£o.  Apresentamos os  conceitos  de  bloqueios  compartilhado  (leitura)  e exclusivo (grava√ß√£o), e mostramos como o bloqueio pode garantir a serializa√ß√£o quando usado em conjunto com a regra do bloqueio em duas fases. Tamb√©m mostramos v√°rias t√©cnicas para lidar com o problema de deadlock, que pode ocorrer com o bloqueio. Na pr√°tica, √© comum usar timeouts e detec√ß√£o de deadlock (grafos de espera).

Apresentamos outros protocolos de controle de concorr√™ncia que n√£o s√£o utilizados com frequ√™ncia na pr√°tica, mas s√£o importantes para as alternativas te√≥ricas que eles mostram para solucionar esse problema.  Estes  incluem  o  protocolo  de  ordena√ß√£o  de r√≥tulo  de  tempo  (timestamp),  que  garante  a  serializa√ß√£o com base na ordem dos r√≥tulos de tempo da transa√ß√£o.  Os  r√≥tulos  de  tempo  s√£o  identificadores de  transa√ß√£o  √∫nicos,  gerados  pelo  sistema.  Discutimos a regra da grava√ß√£o de Thomas, que melhora o desempenho, mas n√£o garante a serializa√ß√£o de conflito.  O  protocolo  de  ordena√ß√£o  de  r√≥tulo  de  tempo estrito tamb√©m foi apresentado. Discutimos dois protocolos multivers√£o, que assumem que as vers√µes mais antigas dos itens de dados podem ser mantidas no banco de dados. Uma t√©cnica, chamada bloqueio em  duas  fases  multivers√£o  (que  tem  sido  usado  na pr√°tica),  considera  que  podem  existir  duas  vers√µes para um item e tenta aumentar a concorr√™ncia ao tornar bloqueios de grava√ß√£o e leitura compat√≠veis (ao custo de introduzir um modo de bloqueio de certifica√ß√£o  adicional).  Tamb√©m  apresentamos  um  protocolo multivers√£o baseado na ordena√ß√£o de r√≥tulo de tempo e um exemplo de um protocolo otimista, que tamb√©m √© conhecido como um protocolo de certifica√ß√£o ou valida√ß√£o.

Depois, voltamos nossa aten√ß√£o para a importante quest√£o pr√°tica da granularidade do item de dados. Descrevemos  um  protocolo  de  bloqueio  de  multigranularidade  que  permite  a  mudan√ßa  de  granularidade (tamanho do item) com base na mistura de transa√ß√µes atual,  com  o  objetivo  de  melhorar  o  desempenho  do controle de concorr√™ncia. Uma quest√£o pr√°tica importante foi  ent√£o  apresentada, que √© desenvolver protocolos de bloqueio para √≠ndices de modo que estes n√£o se  tornem  um  empecilho  para  o  acesso  concorrente. Finalmente,  apresentamos  o  problema  do  fantasma  e problemas  com  transa√ß√µes  interativas,  e  descrevemos rapidamente o conceito de latches e como ele difere dos bloqueios.

## Perguntas de revis√£o

- 22.1. O que √© o protocolo de bloqueio em duas fases? Como ele garante a serializa√ß√£o?
- 22.2. Quais  s√£o  algumas  varia√ß√µes  do  protocolo  de bloqueio em duas fases? Por que o bloqueio em duas  fases  estrito  ou  rigoroso  normalmente  √© preferido?
- 22.3. Discuta os problemas de deadlock e inani√ß√£o e as diferentes t√©cnicas para lidar com esses problemas.
- 22.4. Compare  os  bloqueios  bin√°rios  com  os  bloqueios  exclusivo/compartilhado.  Por  que  esse √∫ltimo tipo de bloqueio √© prefer√≠vel?
- 22.5. Descreva  os  protocolos  esperar-morrer  e  ferir-esperar para a preven√ß√£o de deadlock.
- 22.6. Descreva  os  protocolos  de  espera  cuidadosa, nenhuma espera e timeout para a preven√ß√£o de deadlock.
- 22.7. O que √© um r√≥tulo de tempo? Como o sistema gera r√≥tulos de tempo?
- 22.8. Discuta o protocolo de ordena√ß√£o de r√≥tulo de tempo para o controle de concorr√™ncia. Como a ordena√ß√£o de r√≥tulo de tempo estrita difere da ordena√ß√£o de r√≥tulo de tempo b√°sica?
- 22.9. Discuta duas t√©cnicas multivers√£o para o controle de concorr√™ncia.
- 22.10. O que √© um bloqueio de certifica√ß√£o? Quais s√£o as  vantagens  e  desvantagens  do  uso  dos  bloqueios de certifica√ß√£o?
- 22.11. Como as  t√©cnicas  de  controle  de  concorr√™ncia otimistas diferem de outras t√©cnicas de controle de concorr√™ncia? Por que elas tamb√©m s√£o chamadas de t√©cnicas de valida√ß√£o ou certifica√ß√£o? Discuta as fases t√≠picas de um m√©todo de controle de concorr√™ncia otimista.
- 22.12. Como a granularidade de itens de dados afeta o desempenho do controle de concorr√™ncia? Que fatores afetam a sele√ß√£o do tamanho de granularidade para itens de dados?
- 22.13. Que tipo de bloqueio √© necess√°rio para opera√ß√µes de inser√ß√£o e exclus√£o?
- 22.14. O que √© o bloqueio com granularidade m√∫ltipla? Sob que circunst√¢ncias ele √© usado?
- 22.15. O que s√£o bloqueios de inten√ß√£o?
- 22.16. Quando s√£o usados os latches?
- 22.17. O que √© um registro fantasma? Discuta o problema que um registro fantasma pode causar para o controle de concorr√™ncia.
- 22.18. Como o bloqueio de √≠ndice resolve o problema do fantasma?
- 22.19. O que √© um bloqueio de predicado?

## Exerc√≠cios

22.20. Prove  que  o  protocolo  b√°sico  de  bloqueio  em duas fases garante a serializa√ß√£o de conflito dos schedules. ( Dica: mostre que, se um grafo de serializa√ß√£o para um schedule tiver um ciclo, ent√£o pelo menos uma das transa√ß√µes participantes do schedule n√£o obedece ao protocolo de bloqueio em duas fases.)

22.21. Modifique as estruturas de dados para bloqueios de  modo  m√∫ltiplo  e  os  algoritmos  para read\_ lock ( X ), write\_lock ( X ) e unlock ( X ), de modo que o upgrading e o downgrading dos bloqueios sejam poss√≠veis. ( Dica: o bloqueio precisa verificar as ids de transa√ß√£o que mant√™m o bloqueio, se houver alguma.)

- 22.22. Prove que o bloqueio estrito em duas fases garante schedules estritos.
- 22.23. Prove que os protocolos esperar-morrer e ferir-esperar evitam deadlock e inani√ß√£o.

22.24. Prove que a espera cuidadosa evita deadlock.

22.25. Aplique o algoritmo de ordena√ß√£o de r√≥tulo de tempo aos schedules na Figura 21.8(b) e (c) e determine se o algoritmo permitir√° a execu√ß√£o dos schedules.

22.26. Repita o Exerc√≠cio 22.25, mas use o m√©todo de ordena√ß√£o de r√≥tulo de tempo multivers√£o.

22.27. Por que o bloqueio em duas fases n√£o √© usado como m√©todo de controle de concorr√™ncia para √≠ndices como B + -trees?

A  matriz  de  compatibilidade  na  Figura  22.8 mostra que os bloqueios IS e IX s√£o compat√≠veis.

22.28. Explique por que isso √© v√°lido.

22.29.

O  protocolo  MGL  afirma  que  uma  transa√ß√£o T pode  desbloquear  um  n√≥ N ,  somente se  nenhum dos filhos do n√≥ N ainda  estiver bloqueado pela transa√ß√£o T . Mostre que, sem essa  condi√ß√£o,  o  protocolo  MGL  estaria  incorreto.

## Bibliografia selecionada

O protocolo de bloqueio em duas fases e o conceito de bloqueios de predicado foram propostos inicialmente  por  Eswaran  et  al.  (1976).  Bernstein  et  al.  (1987), Gray e Reuter (1993), e Papadimitriou (1986) focalizam o controle de concorr√™ncia e a recupera√ß√£o. Kumar (1996) focaliza o desempenho dos m√©todos de controle de concorr√™ncia. O bloqueio √© discutido em Gray et al. (1975), Lien e Weinberger (1978), Kedem e Silbershatz (1980),  e  Korth  (1983).  Os  deadlocks  e  os  grafos  de espera s√£o formalizados por Holt (1972), e os esquemas esperar-ferir  e  ferir-morrer  s√£o  apresentados  em  Rosenkrantz et al. (1978). A espera cuidadosa √© discutida em Hsu e Zhang (1992). Helal et al. (1993) comparam diversas t√©cnicas de bloqueio. As t√©cnicas de controle de concorr√™ncia baseadas em r√≥tulo de tempo s√£o discutidas em Bernstein e Goodman (1980) e Reed (1983). O controle de concorr√™ncia otimista √© discutido em Kung e Robinson (1981) e Bassiouni (1988). Papadimitriou e Kanellakis (1979) e Bernstein e Goodman (1983) discutem t√©cnicas multivers√£o. A ordena√ß√£o de r√≥tulo de tempo multivers√£o foi proposta em Reed (1979, 1983), e o bloqueio em duas fases multivers√£o √© discutido em Lai e Wilkinson (1984). Um m√©todo para granularidade  de  bloqueio  m√∫ltiplo  foi  proposto  em  Gray  et  al. (1975), e os efeitos das granularidades de bloqueio s√£o analisados em Ries e Stonebraker (1977). Bhargava e Reidl (1988) apresentam uma t√©cnica para escolher dinamicamente entre v√°rios m√©todos de controle de concorr√™ncia e recupera√ß√£o. Estes m√©todos de controle de concorr√™ncia para √≠ndices s√£o apresentados em Lehman e Yao (1981) e em Shasha e Goodman (1988). Um estudo de desempenho de diversos algoritmos de controle de concorr√™ncia de B + -tree √© apresentado em Srinivasan e Carey (1991).

Outro trabalho sobre controle de concorr√™ncia inclui o controle de concorr√™ncia baseado em sem√¢ntica (Badrinath e Ramamritham, 1992), modelos de transa√ß√£o para atividades de longa dura√ß√£o (Dayal et al., 1991) e gerenciamento de transa√ß√£o multin√≠vel (Hasse e Weikum, 1991).



## T√©cnicas de recupera√ß√£o de banco de dados

N este cap√≠tulo, discutimos  algumas  das  t√©cnicas  que  podem  ser  usadas  para  a  recupera√ß√£o do banco de dados contra falhas. Na Se√ß√£o 21.1.4, abordamos as diferentes causas de falha, como as do sistema e erros de transa√ß√£o. Al√©m disso, na Se√ß√£o 21.2, cobrimos muitos dos conceitos que s√£o usados pelos processos de recupera√ß√£o, como log do sistema e pontos de confirma√ß√£o.

Este cap√≠tulo apresenta conceitos adicionais que s√£o relevantes aos protocolos de recupera√ß√£o, e oferece uma vis√£o geral dos diversos algoritmos de recupera√ß√£o de banco de dados. Come√ßamos na Se√ß√£o 23.1 com um esbo√ßo de um procedimento de recupera√ß√£o t√≠pico e uma categoriza√ß√£o dos algoritmos de recupera√ß√£o,  depois  discutimos  diversos  conceitos de recupera√ß√£o, incluindo o logging write-ahead (escrita antecipada), atualiza√ß√µes no local versus sombra,  e  o  processo  de  reverter  (desfazer)  o  efeito  de uma transa√ß√£o incompleta ou com falha. Na Se√ß√£o 23.2,  apresentamos  t√©cnicas  de  recupera√ß√£o  baseadas na atualiza√ß√£o adiada , tamb√©m conhecida como t√©cnica NO-UNDO/REDO , em que os dados no disco s√≥ s√£o atualizados depois que uma transa√ß√£o √© confirmada. Na Se√ß√£o 23.3, discutimos as t√©cnicas de recupera√ß√£o baseadas na atualiza√ß√£o imediata , na qual os dados podem ser atualizados no disco durante a execu√ß√£o da transa√ß√£o; estas incluem os algoritmos UNDO/REDO e UNDO/NO-REDO .  Tratamos  da  t√©cnica conhecida como sombreamento e pagina√ß√£o de sombra, que pode ser categorizada como um algoritmo NO-UNDO/NO-REDO na  Se√ß√£o 23.4. Um exemplo de um esquema de recupera√ß√£o de SGBD pr√°tico,  chamado ARIES, √© apresentado na Se√ß√£o 23.5. A recupera√ß√£o em multibancos de dados √© discutida rapidamente na Se√ß√£o 23.6. Finalmente, as t√©cnicas para recupera√ß√£o de falha catastr√≥fica s√£o discutidas na Se√ß√£o 23.7. No final do cap√≠tulo h√° um resumo.

Nossa √™nfase est√° na descri√ß√£o conceitual de v√°rias  t√©cnicas  de  recupera√ß√£o  diferentes.  Para  obter descri√ß√µes dos recursos de recupera√ß√£o em sistemas espec√≠ficos,  o  leitor  deve  consultar  as  notas  bibliogr√°ficas ao final do cap√≠tulo e os manuais de usu√°rio on-line e impressos relativos a esses sistemas. As t√©cnicas  de  recupera√ß√£o  normalmente  est√£o  intercaladas com os mecanismos de controle de concorr√™ncia. Certas  t√©cnicas  de  recupera√ß√£o  s√£o  melhor  usadas com m√©todos espec√≠ficos de controle de concorr√™ncia. Discutiremos os conceitos de recupera√ß√£o independentemente dos mecanismos de controle de concorr√™ncia,  mas  abordaremos  as  circunst√¢ncias  sob as  quais  determinado  mecanismo  de  recupera√ß√£o  √© melhor utilizado com certo protocolo de controle de concorr√™ncia.

## 23.1 Conceitos de recupera√ß√£o

## 23.1.1 Esbo√ßo da recupera√ß√£o e categoriza√ß√£o dos algoritmos de recupera√ß√£o

A recupera√ß√£o de falhas de transa√ß√£o em geral significa que o banco de dados √© restaurado ao estado consistente mais recente antes do momento da falha. Para fazer isso, o sistema precisa manter informa√ß√µes sobre as mudan√ßas que foram aplicadas aos itens de dados  pelas  diversas  transa√ß√µes.  Essa  informa√ß√£o costuma  ser  mantida  no log  do  sistema ,  conforme discutimos  na  Se√ß√£o  21.2.2.  Uma  estrat√©gia  t√≠pica para recupera√ß√£o pode ser resumida informalmente da seguinte maneira:

- 1. Se houver dano extensivo a uma grande parte  do  banco  de  dados  devido  √†  falha  catastr√≥fica, como uma falha de disco, o m√©todo

- de  recupera√ß√£o  restaura  uma  c√≥pia  antiga do banco de dados que teve backup para o arquivamento  (normalmente,  fita  ou  outro meio  de  armazenamento  off-line  de  grande capacidade) e reconstr√≥i um estado mais recente, reaplicando ou refazendo as opera√ß√µes das transa√ß√µes confirmadas do log em backup , at√© o momento da falha.
- 2. Quando o banco de dados no disco n√£o est√° danificado fisicamente e uma falha n√£o catastr√≥fica dos tipos de 1 a 4 na Se√ß√£o 21.1.4 tiver ocorrido, a estrat√©gia de recupera√ß√£o √© identificar quaisquer mudan√ßas que possam causar uma inconsist√™ncia no banco de dados. Por exemplo,  uma  transa√ß√£o  que  atualizou  alguns itens do banco de dados no disco, mas n√£o  confirmou  as  necessidades  de  ter  suas mudan√ßas revertidas ao desfazer suas opera√ß√µes de grava√ß√£o. Tamb√©m pode ser preciso refazer algumas opera√ß√µes a fim de restaurar um estado consistente do banco de dados; por  exemplo,  se  uma  transa√ß√£o  tiver  sido confirmada, mas algumas de suas opera√ß√µes de  grava√ß√£o  ainda  n√£o  tiverem  sido  gravadas em disco. Para a falha n√£o catastr√≥fica, o protocolo de recupera√ß√£o n√£o precisa de uma c√≥pia de arquivamento completa do banco de dados. Em vez disso, as entradas mantidas no log do sistema on-line no disco s√£o analisadas para  determinar  as  a√ß√µes  apropriadas  para recupera√ß√£o.

Conceitualmente, podemos distinguir duas t√©cnicas principais para recupera√ß√£o de falhas de transa√ß√£o n√£o catastr√≥ficas: atualiza√ß√£o adiada e atualiza√ß√£o imediata. As t√©cnicas de atualiza√ß√£o adiada n√£o atualizam fisicamente  o  banco  de  dados  no  disco at√© que  uma transa√ß√£o atinge seu ponto de confirma√ß√£o; ent√£o as atualiza√ß√µes s√£o registradas no banco de dados. Antes de atingir a confirma√ß√£o, todas as atualiza√ß√µes de transa√ß√£o s√£o registradas no espa√ßo de trabalho de transa√ß√£o local ou nos buffers da mem√≥ria principal que o SGBD mant√©m (o cache de mem√≥ria principal do SGBD). Antes da confirma√ß√£o, as atualiza√ß√µes s√£o gravadas persistentemente no log e, ap√≥s a confirma√ß√£o, elas s√£o gravadas no banco de dados no disco. Se uma transa√ß√£o falhar antes de atingir seu ponto de confirma√ß√£o, ela n√£o ter√° alterado o banco de dados de forma alguma, de modo que o UNDO n√£o √© necess√°rio. Pode ser preciso um REDO para desfazer o efeito das opera√ß√µes de uma transa√ß√£o confirmada com base no log, pois seu efeito pode ainda n√£o ter sido registrado no banco de dados em disco. Assim, a atualiza√ß√£o adiada tamb√©m √© conhecida  como algoritmo NO-UNDO/REDO .  Discutimos essa t√©cnica na Se√ß√£o 23.2.

Nas t√©cnicas  de atualiza√ß√£o  imediata ,  o  banco de  dados pode ser  atualizado por  algumas  opera√ß√µes de uma transa√ß√£o antes que a transa√ß√£o alcance seu  ponto  de  confirma√ß√£o.  Por√©m,  essas  opera√ß√µes tamb√©m precisam ser registradas no log no disco ao for√ßar a grava√ß√£o antes que elas sejam aplicadas ao banco de dados no disco, tornando a recupera√ß√£o ainda poss√≠vel.  Se  uma  transa√ß√£o  falhar  depois  de  gravar  algumas mudan√ßas no disco, mas antes de atingir seu ponto de confirma√ß√£o, o efeito de  suas  opera√ß√µes  no  banco  de dados precisa ser desfeito; ou seja, a transa√ß√£o deve ser revertida. No caso geral da atualiza√ß√£o imediata, tanto undo quanto redo podem ser exigidos durante a recupera√ß√£o. Essa t√©cnica, conhecida como algoritmo UNDO/REDO , requer as duas opera√ß√µes durante a recupera√ß√£o, e √© usada na pr√°tica. Uma varia√ß√£o do algoritmo, em que todas as atualiza√ß√µes precisam ser registradas no banco de dados em disco antes que a transa√ß√£o confirme, requer apenas undo , de modo que √© conhecida como algoritmo UNDO/NO-REDO . Discutiremos essas t√©cnicas na Se√ß√£o 23.3.

As opera√ß√µes UNDO e REDO precisam ser idempotentes -  ou  seja,  a  execu√ß√£o  de  uma  opera√ß√£o v√°rias vezes √© equivalente a execut√°-la apenas uma vez. De fato, o processo de recupera√ß√£o inteiro deve ser idempotente, pois se o sistema falhasse durante o processo de recupera√ß√£o, a pr√≥xima tentativa de recupera√ß√£o poderia realizar um UNDO e um REDO de certas opera√ß√µes write\_item que j√° tinham sido executadas  durante  o  primeiro  processo  de  recupera√ß√£o. O resultado da recupera√ß√£o de uma falha do sistema durante a recupera√ß√£o deve ser igual ao resultado da recupera√ß√£o quando n√£o h√° falha durante esse processo!

## 23.1.2 Caching (buffering) de blocos de disco

O processo de recupera√ß√£o em geral est√° bastante interligado √†s fun√ß√µes do sistema operacional - em particular, o buffering de p√°ginas de disco do banco de dados no cache de mem√≥ria principal do SGBD. Normalmente, v√°rias p√°ginas de disco que incluem os itens de dados a serem atualizados s√£o mantidas em cache nos buffers da mem√≥ria principal e, depois, atualizados na mem√≥ria antes de serem gravados de volta no disco. O caching de p√°ginas de disco √© tradicionalmente  uma  fun√ß√£o  do  sistema  operacional, mas devido a sua import√¢ncia para a efici√™ncia dos procedimentos  de  recupera√ß√£o,  ele  √©  tratado  pelo SGBD chamando rotinas de baixo n√≠vel do sistema operacional.

Em geral, √© conveniente considerar a recupera√ß√£o em rela√ß√£o √†s p√°ginas de disco (blocos) do banco de dados. Normalmente, uma cole√ß√£o de buffers na

mem√≥ria, chamada cache do SGBD ,  √©  mantida sob o controle do SGBD com a finalidade de manter esses buffers. Um diret√≥rio para o cache √© usado para acompanhar quais itens de banco de dados est√£o nos buffers. 1 Isso pode ser uma tabela de entradas &lt; Ende-re√ßo\_pagina\_disco, Localiza√ß√£o\_buffer, ...&gt;. Quando o SGBD solicita a√ß√£o em algum item, primeiro ele verifica o diret√≥rio do cache para determinar se a p√°gina de disco que cont√©m o item est√° no cache do SGBD. Se n√£o estiver, o item precisa ser localizado no disco, e as p√°ginas de disco apropriadas s√£o copiadas para o cache. Pode ser necess√°rio substituir (ou esvaziar ) alguns dos buffers de cache para criar espa√ßo dispon√≠vel para o novo item. Alguma estrat√©gia de substitui√ß√£o  de  p√°gina  semelhante  √†quelas  usadas  nos sistemas  operacionais,  como  a  usada  menos  recentemente (MRU) ou first-in-first-out (FIFO), ou uma nova estrat√©gia que seja espec√≠fica do SGBD, pode ser utilizada para selecionar os buffers para substitui√ß√£o, como DBMIN ou Least-Likely-to-Use (ver bibliografia selecionada).

As  entradas  no  diret√≥rio  de  cache  do  SGBD mant√™m informa√ß√µes adicionais relevantes ao gerenciamento de buffer. Associado a cada buffer na cache est√° um bit sujo , que pode ser inclu√≠do na entrada de diret√≥rio, para indicar se o buffer foi modificado ou n√£o. Quando uma p√°gina √© lida inicialmente do disco do banco de dados para o buffer no cache, uma nova entrada √© inserida no diret√≥rio de cache com o novo endere√ßo de p√°gina do disco, e o bit sujo √© definido como 0 (zero). Assim que o buffer √© modificado, o bit  sujo  para  a  entrada  de  diret√≥rio  correspondente √© definido como 1 (um). Informa√ß√µes adicionais, como a(s) id(s) de transa√ß√£o das transa√ß√µes que modificaram o buffer, tamb√©m podem ser mantidas no diret√≥rio. Quando o conte√∫do do buffer √© substitu√≠do (esvaziado) do cache, o conte√∫do primeiro precisa ser gravado de volta √† p√°gina de disco correspondente somente se seu bit sujo for 1 . Outro bit, chamado bit de preso-solto , tamb√©m √© necess√°rio - uma p√°gina no cache est√° presa (valor de bit 1 (um)) se ainda n√£o puder ser gravada de volta ao disco. Por exemplo, o protocolo de recupera√ß√£o pode impedir que certas p√°ginas de buffer sejam gravadas no disco at√© que as transa√ß√µes que mudaram esse buffer tenham sido confirmadas.

Duas estrat√©gias principais podem ser empregadas quando se esvazia um buffer modificado para o disco.  A  primeira  estrat√©gia,  conhecida como atualiza√ß√£o no local ,  grava o buffer no mesmo local de disco original , modificando assim o valor antigo de quaisquer itens de dados alterados no disco. 2  Logo, uma √∫nica c√≥pia de cada bloco de disco do banco de dados √© mantida. A segunda estrat√©gia, conhecida como sombreamento , grava um buffer atualizado em um local diferente no disco, de modo que m√∫ltiplas vers√µes dos itens de dados podem ser mantidas, mas essa t√©cnica normalmente n√£o √© utilizada na pr√°tica.

Em geral, o valor antigo do item de dados antes da atualiza√ß√£o √© chamado de imagem antes (BFIM before image , e o novo valor ap√≥s a atualiza√ß√£o √© ) chamado de imagem depois (AFIM after image . ) Se o sombreamento for usado, tanto a BFIM quanto a AFIM podem ser mantidas no disco; assim, n√£o √© estritamente necess√°rio manter um log para recupera√ß√£o. Na Se√ß√£o 23.4, discutimos rapidamente a recupera√ß√£o baseada no sombreamento.

## 23.1.3 ogging write-ahead, steal/noL -steal e force/no-force

Quando a atualiza√ß√£o no local √© utilizada, √© necess√°rio  usar  um  log  para  recupera√ß√£o  (ver  Se√ß√£o 21.2.2).  Nesse  caso,  o  mecanismo  de  recupera√ß√£o precisa garantir que a BFIM do item de dados esteja  registrada  na  entrada  de  log  apropriada  e  que  a entrada de log seja esvaziada para o disco antes de a BFIM ser modificada pela AFIM no banco de dados em disco. Esse processo geralmente √© conhecido como logging write-ahead , e √© necess√°rio poder desfazer ( UNDO ) a opera√ß√£o se isso for exigido durante a recupera√ß√£o. Antes de podermos descrever um protocolo para o logging write-ahead, precisamos distinguir entre dois tipos de informa√ß√£o de entrada de log inclu√≠da para um comando de grava√ß√£o: a informa√ß√£o necess√°ria para UNDO e a informa√ß√£o necess√°ria para REDO. Uma entrada de log tipo REDO inclui um valor novo (AFIM) do item gravado pela opera√ß√£o, pois isso √© necess√°rio para refazer seu efeito com base no log (ao definir o valor do item no banco de dados em disco para a sua AFIM). As entradas de log tipo UNDO incluem o valor antigo (BFIM) do item, visto que isso √© necess√°rio para desfazer o efeito da opera√ß√£o baseada no log (ao definir o valor do item no banco de dados de volta para a sua BFIM). Em um algoritmo UNDO/REDO , os dois tipos de entradas de log s√£o combinados. Al√©m disso, quando o rollback em cascata √© poss√≠vel, entradas read\_item no log s√£o consideradas entradas tipo UNDO (ver Se√ß√£o 23.1.5).

Como  dissemos,  o  cache  do  SGBD  mant√©m os blocos de disco do banco de dados em cache nos  buffers  da  mem√≥ria  principal,  que  incluem n√£o  apenas blocos  de  dados ,  mas  tamb√©m blocos  de  √≠ndice e blocos  de  log do  disco.  Quando

1 Isso √© semelhante ao conceito de tabelas de p√°gina usadas pelo sistema operacional.

2 A atualiza√ß√£o no local √© usada na maioria dos sistemas na pr√°tica.

um registro de log √© gravado, ele √© armazenado no buffer de log atual no cache do SGBD. O log √©  simplesmente  um  arquivo  de  disco  sequencial (apenas para acr√©scimo) e o cache do SGBD pode conter v√°rios blocos de disco nos buffers da mem√≥ria principal (em geral, os √∫ltimos n blocos de log do arquivo de log). Quando √© feita uma atualiza√ß√£o em um bloco de dados - armazenado no cache do SGBD -, um registro de log associado √©  gravado  no  √∫ltimo  buffer  de  log  no  cache  do SGBD. Com a t√©cnica de logging write-ahead, os buffers (blocos) de log que cont√™m os registros de log  associados  para  determinada  atualiza√ß√£o  do bloco  de  dados precisam  primeiro  ser  gravados em disco , antes que o pr√≥prio bloco de dados possa ser gravado de volta no disco com base em seu buffer de mem√≥ria principal.

A terminologia de recupera√ß√£o de SGBD padr√£o  inclui  os  termos steal/no-steal e force/no-force ,  que  especificam  as  regras  que  controlam quando uma p√°gina do banco de dados pode ser gravada do cache para o disco:

- 1. Se uma p√°gina do buffer em cache atualizada por uma transa√ß√£o n√£o puder ser gravada em disco antes que a transa√ß√£o confirme, o m√©todo de recupera√ß√£o √© chamado de t√©cnica no-steal . O bit de preso-solto ser√° usado para indicar se uma p√°gina n√£o puder ser gravada de volta no disco.  Contudo,  se  o protocolo de recupera√ß√£o permitir gravar um buffer  atualizado antes que  a  transa√ß√£o confirme, isso √© chamado de steal . Steal √© usado quando o gerenciador de cache (buffer) do SGBD precisa de um frame buffer para  outra  transa√ß√£o  e  o  gerenciador  de buffer substitui uma p√°gina existente que tinha sido atualizada, mas cuja transa√ß√£o n√£o  foi  confirmada.  A regra  do  no-steal significa que UNDO nunca ser√° necess√°rio durante  a  recupera√ß√£o,  pois  uma  transa√ß√£o  confirmada  n√£o  ter√°  qualquer  uma de suas atualiza√ß√µes no disco antes de ser confirmada.
- O  esquema  de  recupera√ß√£o  com  atualiza√ß√£o adiada  ( NO-UNDO )  discutido  na  Se√ß√£o  23.2  segue uma t√©cnica no-steal . Por√©m, os sistemas de banco de dados t√≠picos empregam uma estrat√©gia steal/no-force . A vantagem do steal √© que ele evita a necessidade de um espa√ßo de buffer muito grande para armazenar todas as p√°ginas atualizadas na mem√≥ria. A vantagem do no-force √© que uma p√°gina atualizada de uma transa√ß√£o  confirmada  ainda  pode  estar  no  buffer quando  outra  transa√ß√£o  precisar  atualiz√°-la,  eliminando assim o custo de E/S para gravar essa p√°gina v√°rias vezes em disco, e possivelmente ter de l√™-la novamente do disco. Isso pode oferecer uma economia substancial no n√∫mero de opera√ß√µes de E/S de disco quando uma p√°gina espec√≠fica √© bastante atualizada por v√°rias transa√ß√µes.

Para permitir a recupera√ß√£o quando a atualiza√ß√£o no local √© usada, as entradas apropriadas exigidas precisam ser permanentemente gravadas no log em disco antes que as mudan√ßas sejam aplicadas ao banco de dados. Por exemplo, considere o seguinte protocolo de logging write-ahead ( WAL )  para  um algoritmo de recupera√ß√£o que exige tanto UNDO quanto REDO:

- 1. A imagem antes de um item n√£o pode ser modificada por sua imagem depois no banco de dados em disco at√© que todos os registros de log tipo UNDO para  a  transa√ß√£o em atualiza√ß√£o - at√© este ponto - tenham sido gravados √† for√ßa no disco.
- 2. A opera√ß√£o de confirma√ß√£o de uma transa√ß√£o n√£o pode ser conclu√≠da at√© que todos os registros de log tipo REDO e tipo UNDO para essa transa√ß√£o tenham sido gravados √† for√ßa no disco.
- 2. Se  todas  as  p√°ginas  atualizadas  por  uma transa√ß√£o forem imediatamente gravadas em disco antes que a transa√ß√£o confirme, essa √© chamada de t√©cnica force . Caso contr√°rio, ela √© chamada no-force . A regra do force significa que REDO nunca ser√° necess√°rio durante a recupera√ß√£o, pois qualquer transa√ß√£o confirmada ter√° todas as suas atualiza√ß√µes em disco antes de ser confirmada.

Para facilitar o processo de recupera√ß√£o, o subsistema de recupera√ß√£o do SGBD pode manter uma s√©rie  de  listas  relacionadas  √†s  transa√ß√µes  que  est√£o sendo processadas no sistema. Estas incluem uma lista para transa√ß√µes ativas que come√ßaram, mas ainda n√£o foram confirmadas, e tamb√©m podem incluir listas de todas as transa√ß√µes confirmadas e abortadas desde  o  √∫ltimo  check  point  (ver  a  pr√≥xima  se√ß√£o). Manter essas listas torna o processo de recupera√ß√£o mais eficiente.

## 23.1.4 Check point no log do sistema e check point fuzzy

Outro tipo de entrada no log √© chamado de check point . 3 Um  registro [checkpoint, lista  de  transa√ß√µes ativas ] √© gravado no log periodicamente no ponto em

3 O termo check point tem sido usado para descrever situa√ß√µes mais restritivas em alguns sistemas, como DB2. Ele tamb√©m tem sido empregado na literatura para descrever conceitos inteiramente diferentes.

que o sistema grava, no banco de dados em disco, todos os buffers do SGBD que foram modificados. Como consequ√™ncia disso, todas as transa√ß√µes que t√™m suas entradas [commit, T ] no log antes de uma entrada [checkpoint] n√£o precisam ter suas opera√ß√µes WRITE refeitas no caso de uma falha do sistema, pois todas as suas atualiza√ß√µes ser√£o registradas no banco de dados em disco durante o check point. Como parte do check point, a lista de ids de transa√ß√£o para transa√ß√µes ativas no momento do check point √© inclu√≠da no registro do check point, de modo que essas transa√ß√µes  possam  ser  facilmente  identificadas  durante a recupera√ß√£o.

- O  gerenciador  de  recupera√ß√£o  de  um  SGBD precisa decidir em que intervalos realizar um check point. O intervalo pode ser medido em tempo - digamos, a cada m minutos - ou no n√∫mero   de trant sa√ß√µes confirmadas desde o √∫ltimo check point, onde os valores de m ou   s√£o par√¢metros do sistema. Ret alizar um check point consiste nas seguintes a√ß√µes:
- 1. Suspender a execu√ß√£o de transa√ß√µes temporariamente.
- 2. For√ßar a grava√ß√£o em disco de todos os buffers da mem√≥ria principal que foram modificados.
- 3. Gravar um registro [checkpoint] no log e for√ßar a grava√ß√£o do log em disco.
- 4. Retomar a execu√ß√£o das transa√ß√µes.

Como uma consequ√™ncia da etapa 2, um registro de check point no log tamb√©m pode incluir informa√ß√µes adicionais, como uma lista de ids de transa√ß√£o ativas e os locais (endere√ßos) do primeiro e mais recente (√∫ltimo) registros no log para cada transa√ß√£o ativa. Isso pode facilitar o desfazer de opera√ß√µes de transa√ß√£o caso uma transa√ß√£o tenha de ser desfeita.

O tempo necess√°rio para for√ßar a grava√ß√£o de todos os buffers de mem√≥ria modificados pode atrasar o processamento da transa√ß√£o por causa da etapa 1. Para reduzir esse atraso, √© comum usar uma t√©cnica chamada check point fuzzy . Nessa t√©cnica, o sistema pode retomar o processamento da transa√ß√£o ap√≥s um registro [begin\_checkpoint] ser  gravado  no  log  sem esperar que a etapa 2 termine. Quando a etapa 2 √© conclu√≠da, um registro [end\_checkpoint, ...] √© gravado no log com a informa√ß√£o relevante coletada durante o check point. Por√©m, at√© que a etapa 2 termine, o registro do check point anterior deve permanecer v√°lido. Para isso, o sistema mant√©m um arquivo no disco que cont√©m um ponteiro para o check point v√°lido, que continua a apontar para o registro do check point anterior no log. Quando a etapa 2 termina, o ponteiro √© mudado de modo a apontar para o novo check point no log.

## 23.1.5 Rollback de transa√ß√£o e rollback em cascata

Se  uma  transa√ß√£o  falhar  por  um  motivo  qualquer depois de atualizar o banco de dados, mas antes que a transa√ß√£o seja confirmada, pode ser preciso reverter (roll  back)  a  transa√ß√£o.  Se  quaisquer valores de item de dados tiverem sido alterados pela transa√ß√£o e gravados no banco de dados, eles precisam  ser  restaurados  para  seus  valores  anteriores (BFIMs). As entradas de log do tipo undo s√£o usadas para restaurar os valores antigos dos itens de dados que precisam ser revertidos.

Se uma transa√ß√£o T for revertida, qualquer transa√ß√£o S que tenha, enquanto isso, lido o valor de algum item de dados X gravado por T tamb√©m deve ser revertida. De modo semelhante, quando S for revertida, qualquer transa√ß√£o R que tenha lido o valor de algum item de dados Y gravado por S tamb√©m precisa ser revertida, e assim por diante. Esse fen√¥meno √©  chamado de rollback  em  cascata (propaga√ß√£o  de cancelamento), e pode ocorrer quando o protocolo de recupera√ß√£o garante schedules recuper√°veis , mas n√£o  garante  schedules estritos ou sem  propaga√ß√£o (ver Se√ß√£o 21.4.2). √â f√°cil entender que o rollback em cascata pode ser muito complexo e demorado. √â por isso que quase todos os mecanismos de recupera√ß√£o s√£o projetados de modo que o rollback em cascata nunca seja necess√°rio .

A  Figura  23.1  mostra  um  exemplo  em  que  o rollback em cascata √© exigido. As opera√ß√µes de leitura e grava√ß√£o de tr√™s transa√ß√µes individuais aparecem na Figura 23.1(a). A Figura 23.1(b) mostra o log do sistema no ponto de uma falha no sistema para determinado schedule de execu√ß√£o dessas transa√ß√µes. Os valores dos itens de dados A B C , , e D , que s√£o utilizados pelas transa√ß√µes, aparecem √† direita das entradas do log do sistema. Supomos que os valores de item originais, mostrados na primeira linha, s√£o A = 30, B = 15, C = 40 e D = 20. No ponto de falha do sistema, a transa√ß√£o T 3 n√£o alcan√ßou sua conclus√£o e deve ser revertida. As opera√ß√µes WRITE de T 3 ,  marcadas com um √∫nico * na Figura 23.1(b), s√£o as opera√ß√µes T 3 desfeitas durante a revers√£o da transa√ß√£o. A Figura 23.1(c) mostra graficamente as opera√ß√µes das diferentes transa√ß√µes ao longo do eixo do tempo.

Agora, temos de verificar o rollback em cascata.



- * T  √© revertido porque n√£o atingiu 3 seu ponto de confirma√ß√£o.

Falha do sistema

Figura 23.1

Ilustrando o rollback em cascata (um processo que nunca ocorre nos schedules estritos ou sem cascata). (a) As opera√ß√µes de leitura e grava√ß√£o de tr√™s transa√ß√µes. (b) O log do sistema no ponto de falha. (c) Opera√ß√µes antes da falha.

Pela Figura 23.1(c), vemos que a transa√ß√£o T 2 l√™  o valor do item B que foi gravado pela transa√ß√£o T 3 ; isso  tamb√©m  pode  ser  determinado  ao  examinar  o log. Como T 3 √© revertido, T 2 agora precisa ser revertido tamb√©m. As opera√ß√µes WRITE de T 2 ,  marcadas com ** no log, s√£o aquelas que s√£o desfeitas. Obser- ve que somente as opera√ß√µes write\_item precisam ser desfeitas  durante  a  revers√£o  da  transa√ß√£o;  as  opera√ß√µes read\_item s√£o gravadas no log somente para determinar se o rollback em cascata das transa√ß√µes adicionais √© necess√°rio.

Na pr√°tica, o rollback em cascata das transa√ß√µes

nunca √© exigido porque os m√©todos de recupera√ß√£o pr√°ticos garantem schedules sem cascata ou estritos . Logo, n√£o √© necess√°rio gravar quaisquer opera√ß√µes read\_item no log, pois estas s√≥ s√£o necess√°rias para determinar o rollback em cascata.

## 23.1.6 A√ß√µes da transa√ß√£o que n√£o afetam o banco de dados

Em geral, uma transa√ß√£o ter√° a√ß√µes que n√£o afetam o banco de dados, como a gera√ß√£o e impress√£o de mensagens ou relat√≥rios das informa√ß√µes recuperadas do banco de dados. Se uma transa√ß√£o falhar antes de concluir, podemos n√£o querer que o usu√°rio receba  esses  relat√≥rios,  pois  a  transa√ß√£o  deixou  de completar. Se esses relat√≥rios err√¥neos forem produzidos, parte do processo de recupera√ß√£o teria de informar ao usu√°rio que esses relat√≥rios est√£o errados, visto que o usu√°rio pode tomar uma a√ß√£o, com base nesses relat√≥rios, que afeta o banco de dados. Logo, esses  relat√≥rios  s√≥  devem  ser  gerados depois  que  a transa√ß√£o atinge seu ponto de confirma√ß√£o . Um m√©todo comum de tratar tais a√ß√µes √© emitir os comandos  que  geram  os  relat√≥rios,  mas  mant√™-las  como tarefas em batch, que s√£o executadas somente depois que a transa√ß√£o atinge seu ponto de confirma√ß√£o. Se a transa√ß√£o falha, as tarefas em batch s√£o canceladas.

## 23.2 Recupera√ß√£o NO-UNDO/ REDO baseada em atualiza√ß√£o adiada

A ideia por tr√°s da atualiza√ß√£o adiada √© adiar ou postergar quaisquer atualiza√ß√µes reais para o banco de dados em disco at√© que a transa√ß√£o termine sua execu√ß√£o com sucesso e atinja seu ponto de confirma√ß√£o. 4

Durante a execu√ß√£o da transa√ß√£o, as atualiza√ß√µes s√£o registradas apenas no log e nos buffers de cache. Depois que a transa√ß√£o atinge seu ponto de confirma√ß√£o e o log √© for√ßado a gravar em disco, as atualiza√ß√µes  s√£o  registradas  no  banco  de  dados.  Se  uma transa√ß√£o falhar antes de atingir seu ponto de confirma√ß√£o, n√£o √© preciso desfazer qualquer opera√ß√£o, pois a transa√ß√£o n√£o afetou o banco de dados no disco de forma alguma. Portanto, somente entradas de log tipo REDO s√£o necess√°rias no log, que incluem o valor novo (AFIM) do item gravado por uma opera√ß√£o  de  grava√ß√£o.  As entradas  de  log  tipo UNDO n√£o s√£o necess√°rias, pois n√£o ser√° preciso desfazer as opera√ß√µes durante a recupera√ß√£o. Embora isso possa simplificar o processo de recupera√ß√£o, n√£o pode ser usado na pr√°tica a menos que as transa√ß√µes sejam curtas e que cada transa√ß√£o mude poucos itens. Para outros tipos de transa√ß√µes, existe o potencial de esgotar o espa√ßo de buffer, pois as mudan√ßas na transa√ß√£o devem ser mantidas nos buffers de cache at√© o ponto de confirma√ß√£o.

Podemos declarar um protocolo de atualiza√ß√£o adiada t√≠pico da seguinte forma:

- 1. Uma transa√ß√£o n√£o pode mudar o banco de dados no disco at√© que atinja seu ponto de confirma√ß√£o.
- 2. Uma transa√ß√£o n√£o atinge seu ponto de confirma√ß√£o  at√©  que  todas  as  suas  entradas  de log tipo REDO sejam  registradas  no  log e o buffer de log seja gravado √† for√ßa no disco.

Observe  que  a  etapa  2  desse  protocolo  √©  uma reafirma√ß√£o  do  protocolo  de  logging  write-ahead (WAL). Como o banco de dados nunca √© atualizado em disco antes de a transa√ß√£o ser confirmada, nunca h√° necessidade de desfazer ( UNDO ) quaisquer opera√ß√µes. REDO √© necess√°rio caso o sistema falhe depois que a transa√ß√£o for confirmada, mas antes que todas as mudan√ßas sejam gravadas no banco de dados em disco. Nesse caso, as opera√ß√µes da transa√ß√£o s√£o refeitas das entradas de log durante a recupera√ß√£o.

Para sistemas multiusu√°rios com controle de concorr√™ncia, os processos de controle de concorr√™ncia e recupera√ß√£o s√£o inter-relacionados. Considere um sistema em que o controle de concorr√™ncia usa o bloqueio estrito em duas fases, de modo que os bloqueios nos itens permanecem em vigor at√© que a transa√ß√£o atinja seu ponto de confirma√ß√£o .  Depois disso, os bloqueios podem ser liberados. Isso garante schedules estritos e serializ√°veis. Supondo que entradas [checkpoint] sejam  inclu√≠das  no log, um algoritmo de recupera√ß√£o poss√≠vel para esse caso, que chamamos RDU\_M (recupera√ß√£o usando atualiza√ß√£o adiada em um ambiente multiusu√°rio), √© dado a seguir.

Procedimento RDU\_M (NO-UNDO/REDO com check point). Use duas listas de transa√ß√µes mantidas pelo sistema: as transa√ß√µes confirmadas T desde  o  √∫ltimo  check  point  (lista  de  confirma√ß√£o) e as transa√ß√µes ativas T ' (lista ativa). Refa√ßa (REDO) todas as opera√ß√µes WRITE das transa√ß√µes confirmadas com base no log, na ordem em que foram  gravadas  nele .  As  transa√ß√µes  que  est√£o ativas e n√£o confirmaram s√£o efetivamente canceladas e devem ser submetidas de novo.

O  procedimento REDO √©  definido  da  seguinte maneira:

Procedimento  REDO  (WRITE\_OP). Refazer

4 Logo, a atualiza√ß√£o adiada geralmente pode ser caracterizada como uma t√©cnica no-steal .

uma  opera√ß√£o write\_item WRITE\_OP consiste em examinar sua entrada de log [ write\_item , T , X valor\_novo , ]  e  definir  o  valor  do  item  X  no banco de dados para valor\_novo ,  que √© a imagem depois (AFIM).

A Figura 23.2 ilustra uma linha de tempo para um schedule poss√≠vel de transa√ß√µes execut√°veis. Quando o check point foi tomado no tempo t 1 , a transa√ß√£o T 1 tinha sido confirmada, enquanto as transa√ß√µes T 3 e T 4 n√£o o tinham. Antes da falha do sistema no tempo t 2 , T 3 e T 2 tinham  sido  confirmadas,  mas  n√£o T 4 e T 5 . De acordo com o m√©todo RDU\_M , n√£o √© preciso refazer as opera√ß√µes write\_item da transa√ß√£o T 1 - ou quaisquer transa√ß√µes confirmadas antes do momento do √∫ltimo check point t 1 . As opera√ß√µes write\_item de T 2 e T 3 devem ser refeitas, contudo, pois as duas transa√ß√µes atingiram seus pontos de confirma√ß√£o ap√≥s o √∫ltimo check point. Lembre-se de que o log √© gravado √† for√ßa antes de confirmar uma transa√ß√£o. As transa√ß√µes T 4 e T 5 s√£o ignoradas: elas s√£o efetivamente canceladas ou revertidas porque nenhuma de suas opera√ß√µes write\_item foram gravadas no banco de dados em disco sob o protocolo de atualiza√ß√£o adiado.

Podemos tornar o algoritmo de recupera√ß√£o NO-UNDO/REDO mais eficiente ao observar que, se um item de dados X tiver  sido atualizado - conforme indicado nas entradas de log - mais de uma vez por transa√ß√µes confirmadas desde o √∫ltimo check point, s√≥ √© necess√°rio refazer ( REDO ) a √∫ltima atualiza√ß√£o de X com base no log durante a recupera√ß√£o, pois as outras atualiza√ß√µes seriam modificadas por esse √∫ltimo REDO. Nesse caso, come√ßamos do final do log ; depois, sempre que um item for refeito, ele √© acrescentado  a  uma  lista  de  itens  refeitos.  Antes  que  o REDO seja aplicado a um item, a lista √© verificada; se o item aparecer na lista, ele n√£o √© refeito novamente, pois seu √∫ltimo valor j√° foi recuperado.

ela √© simplesmente submetida novamente, pois n√£o alterou  o  banco  de  dados  no  disco.  Uma  desvantagem do m√©todo descrito aqui √© que ele limita a execu√ß√£o concorrente das transa√ß√µes, porque todos os  itens  bloqueados  para  a  grava√ß√£o  permanecem bloqueados at√© que a transa√ß√£o atinja seu ponto de confirma√ß√£o .  Al√©m  disso,  pode  ser  exigido  um  espa√ßo de buffer excessivo para manter todos os itens atualizados  at√©  que  as  transa√ß√µes  sejam  confirmadas. O principal benef√≠cio do m√©todo √© que as opera√ß√µes  da  transa√ß√£o nunca  precisam  ser  desfeitas , por dois motivos:

- 1. Uma  transa√ß√£o  n√£o  registra  quaisquer  mudan√ßas no banco de dados em disco at√© que atinja seu ponto de confirma√ß√£o - ou seja, at√© que complete sua execu√ß√£o com sucesso. Portanto, uma transa√ß√£o nunca √© revertida por falha durante a execu√ß√£o da transa√ß√£o.
- 2. Uma transa√ß√£o nunca ler√° o valor de um item que √© gravado por uma transa√ß√£o n√£o confirmada, visto que os itens permanecem bloqueados at√© que uma transa√ß√£o atinja seu ponto de confirma√ß√£o. Assim, n√£o haver√° rollback em cascata.

A Figura 23.3 mostra um exemplo de recupera√ß√£o para um sistema multiusu√°rio que utiliza o m√©todo de recupera√ß√£o e controle de concorr√™ncia que descrevemos.

## 23.3 √©cnicas de recupera√ß√£o T baseadas em atualiza√ß√£o imediata

Se uma transa√ß√£o for abortada por algum motivo (digamos, pelo m√©todo de detec√ß√£o de deadlock),

Nessas  t√©cnicas,  quando  uma  transa√ß√£o  emite um comando de atualiza√ß√£o, o banco de dados no disco pode ser atualizado imediatamente , sem qualquer necessidade de esperar que a transa√ß√£o atinja seu  ponto  de  confirma√ß√£o.  Observe  que n√£o  √©  um



| (a)   | T 1             | T 2             | T 3             | T 4             |
|-------|-----------------|-----------------|-----------------|-----------------|
|       | read_item( A )  | read_item( B )  | read_item( A )  | read_item( B )  |
|       | read_item( D )  | write_item( B ) | write_item( A ) | write_item( B ) |
|       | write_item( D ) | read_item( D )  | read_item( C )  | read_item( A )  |
|       |                 | write_item( D ) | write_item( C ) | write_item( A ) |



T 2 e T 3 s√£o ignorados porque n√£o atingiram seus pontos de confirma√ß√£o. T 4 √© refeito porque seu ponto de confirma√ß√£o est√° depois do √∫ltimo check point do sistema.

Figura 23.3

Exemplo de recupera√ß√£o usando a atualiza√ß√£o adiada com transa√ß√µes concorrentes. (a) As opera√ß√µes READ e WRITE de quatro transa√ß√µes. (b) Log do sistema no ponto de falha.

requisito que cada atualiza√ß√£o seja aplicada imediatamente ao disco; √© apenas poss√≠vel que algumas atualiza√ß√µes sejam aplicadas ao disco antes que a transa√ß√£o seja confirmada .

Devem-se  tomar  provid√™ncias  para desfazer o efeito das opera√ß√µes de atualiza√ß√£o que foram aplicadas ao banco de dados por uma transa√ß√£o com falha . Isso √© obtido ao reverter a transa√ß√£o e desfazer o efeito das opera√ß√µes write\_item da transa√ß√£o. Portanto, as entradas de log tipo UNDO , que incluem o valor antigo (BFIM) do item, devem ser armazenadas no log. Como UNDO pode ser necess√°rio durante a recupera√ß√£o,  esses  m√©todos  seguem  uma estrat√©gia steal para  decidir  quando  os  buffers  da  mem√≥ria principal  atualizados  podem  ser  gravados  de  volta no disco (ver Se√ß√£o 23.1.3). Teoricamente, podemos distinguir  duas  categorias  principais  de  algoritmos de atualiza√ß√£o imediata. Se a t√©cnica de recupera√ß√£o garante que todas as atualiza√ß√µes de uma transa√ß√£o s√£o gravadas no banco de dados em disco antes que a  transa√ß√£o  seja  confirmada ,  n√£o  h√°  motivo  para refazer  ( REDO )  quaisquer  opera√ß√µes das transa√ß√µes confirmadas. Isso √© chamado de algoritmo de recu- pera√ß√£o UNDO/NO-REDO .  Nesse m√©todo, todas as atualiza√ß√µes por uma transa√ß√£o devem ser gravadas em disco antes que a transa√ß√£o seja confirmada , de modo que o REDO nunca √© necess√°rio. Assim, esse m√©todo precisa utilizar a estrat√©gia force para decidir quando os buffers atualizados da mem√≥ria principal s√£o gravados de volta no disco (ver Se√ß√£o 23.1.3).

Se a transa√ß√£o puder confirmar antes que todas as mudan√ßas sejam gravadas no banco de dados, temos o caso mais geral,  conhecido  como algoritmo de recupera√ß√£o UNDO/REDO . Nesse caso, a estrat√©gia steal/no-force √© aplicada (ver Se√ß√£o 23.1.3). Essa tamb√©m √© a t√©cnica mais complexa. Vamos esbo√ßar um algoritmo de recupera√ß√£o UNDO/REDO e deixar como um exerc√≠cio para o leitor desenvolver a varia√ß√£o UNDO/NO-REDO .  Na  Se√ß√£o  23.5,  descrevemos uma t√©cnica mais pr√°tica conhecida como t√©cnica de recupera√ß√£o ARIES.

Quando  a  execu√ß√£o  concorrente  √©  permitida, o processo de recupera√ß√£o novamente depende dos protocolos usados para o controle de concorr√™ncia. O procedimento RIU\_M (recupera√ß√£o  usando  atualiza√ß√µes  imediatas  para  um  ambiente  multiusu√°rio)

esbo√ßa um algoritmo de recupera√ß√£o para transa√ß√µes concorrentes com atualiza√ß√µes imediatas (recupera√ß√£o UNDO/REDO ).  Suponha que o log inclua check point e que o protocolo de controle de concorr√™ncia produza schedules estritos - por exemplo, como faz o protocolo de bloqueio em duas fases. Lembre-se de que um schedule estrito n√£o permite que uma transa√ß√£o leia ou grave um item a menos que a transa√ß√£o que gravou o item por √∫ltimo tenha sido confirmada (ou abortada e revertida). Por√©m, os deadlocks podem  ocorrer  no  bloqueio  estrito  em  duas  fases, exigindo  assim  o  cancelamento  e UNDO de  transa√ß√µes. Para um schedule estrito, o UNDO de uma opera√ß√£o exige a mudan√ßa do item de volta a seu valor antigo (BFIM).

## Procedimento RIU\_M (UNDO/REDO com check point).

- 1. Use duas listas de transa√ß√µes mantidas pelo sistema:  as  transa√ß√µes  confirmadas  desde  o √∫ltimo check point e as transa√ß√µes ativas.
- 2. Desfa√ßa  todas  as  opera√ß√µes write\_item das transa√ß√µes ativas (n√£o confirmada), usando o procedimento UNDO . As opera√ß√µes devem ser desfeitas na ordem reversa em que s√£o gravadas no log.
- 3. Refa√ßa  todas  as  opera√ß√µes write\_item das transa√ß√µes confirmadas com base no log, na ordem em que foram gravadas nele, usando o procedimento REDO definido anteriormente.
- O  procedimento UNDO √©  definido  da  seguinte forma:

Procedimento  UNDO  (WRITE\_OP). Desfazer uma  opera√ß√£o write\_item  write\_op consiste  em examinar sua entrada de log [write\_item, T , X , valor\_antigo, valor\_novo] e definir o valor do item X no banco de dados para valor\_antigo, que √© a imagem  antiga  (BFIM).  Desfazer  uma  s√©rie  de opera√ß√µes write\_item de uma ou mais transa√ß√µes do log deve prosseguir na ordem reversa daquela em que as opera√ß√µes foram gravadas no log.

frente (come√ßando do in√≠cio do log). Sempre que um item √© desfeito, ele √© acrescentado a uma lista de itens desfeitos e n√£o √© desfeito novamente.

## 23.4 Pagina√ß√£o de sombra

Esse esquema de recupera√ß√£o n√£o exige o uso de um log em um ambiente monousu√°rio. Em um ambiente multiusu√°rio, um log pode ser necess√°rio para o m√©todo de controle de concorr√™ncia. A pagina√ß√£o de sombra considera o banco de dados composto de uma s√©rie de p√°ginas de disco (ou blocos de disco) de tamanho fixo - digamos, n - para fins de recupera√ß√£o. Um diret√≥rio com   entradas 5  √© constru√≠do, no n qual a  -√©sima entrada aponta para a  -√©sima p√°gina i i de banco de dados no disco. O diret√≥rio √© mantido na mem√≥ria principal se n√£o for muito grande, e todas as refer√™ncias - leituras e grava√ß√µes - a p√°ginas do banco de dados no disco passam por ela. Quando uma transa√ß√£o come√ßa a ser executada, o diret√≥rio atual - cujas entradas apontam para as p√°ginas de banco de dados mais recentes no disco - √© copiado para um diret√≥rio de sombra . O diret√≥rio de sombra √©, ent√£o, salvo em disco enquanto o diret√≥rio ativo √© usado pela transa√ß√£o.

Durante a execu√ß√£o da transa√ß√£o, o diret√≥rio de sombra nunca √© modificado. Quando uma opera√ß√£o write\_item √© realizada, uma nova c√≥pia da p√°gina de banco de dados modificada √© criada, mas a c√≥pia antiga dessa p√°gina n√£o √© modificada . Em vez disso, a nova p√°gina √© gravada em outro lugar - em algum bloco de disco anteriormente n√£o utilizado. A entrada do diret√≥rio atual √© modificada para que aponte para o novo bloco de disco, enquanto o diret√≥rio de sombra n√£o √© modificado e continua a apontar para o  antigo  bloco  de  disco  n√£o  modificado.  A  Figura 23.4 ilustra os conceitos de diret√≥rios de sombra e atual.  Para  as  p√°ginas  atualizadas  pela  transa√ß√£o, duas vers√µes s√£o mantidas. A vers√£o antiga √© referenciada pelo diret√≥rio de sombra e a nova vers√£o, pelo diret√≥rio atual.

Conforme discutimos no procedimento NO-UNDO/REDO , a etapa 3 √© realizada com mais efici√™ncia ao  iniciar  do final  do  log e  refazer  apenas a  √∫ltima atua  liza√ß√£o  de  cada  item  X .  Sempre  que  um  item  √© refeito, ele √© acrescentado √† lista de itens refeitos e n√£o √©  refeito  novamente.  Um  procedimento  semelhante pode ser elaborado para melhorar a efici√™ncia da etapa 2 de modo que um item possa ser desfeito no m√°ximo uma vez durante a recupera√ß√£o. Nesse caso, o UNDO mais antigo √© aplicado primeiro ao varrer o log para a

Para recuperar-se de uma falha durante a execu√ß√£o da transa√ß√£o, √© suficiente liberar as p√°ginas de banco de dados modificadas e descartar o diret√≥rio ativo. O estado do banco de dados antes da execu√ß√£o da transa√ß√£o est√° dispon√≠vel por meio do diret√≥rio de sombra, e esse estado √© recuperado ao restaurar o diret√≥rio de sombra. O banco de dados, assim, √© retornado ao seu estado anterior √† transa√ß√£o que estava executando quando ocorreu a falha, e quaisquer p√°ginas modificadas s√£o descartadas. A confirma√ß√£o de uma transa√ß√£o corresponde a descartar o diret√≥rio de sombra anterior. Como a recupera√ß√£o n√£o envol-

5 O diret√≥rio √© semelhante √† tabela de p√°gina mantida pelo sistema operacional para cada processo.

Figura 23.4 Um exemplo de pagina√ß√£o de sombra.



ve desfazer nem refazer itens de dados, essa t√©cnica pode ser categorizada como uma t√©cnica NO-UNDO/ NO-REDO para recupera√ß√£o.

Em  um  ambiente  multiusu√°rio  com  transa√ß√µes concorrentes, logs e check point precisam ser incorporados √† t√©cnica de pagina√ß√£o de sombra. Uma desvantagem da p√°gina de sombra √© que as p√°ginas de banco de dados atualizadas mudam de local no disco. Isso torna dif√≠cil manter p√°ginas de banco de dados relacionadas pr√≥ximas no disco sem o uso de complexas estrat√©gias de gerenciamento de armazenamento. Al√©m do mais, se o diret√≥rio for grande, o overhead de gravar diret√≥rios de sombra em disco, √† medida que as transa√ß√µes s√£o confirmadas, √© significativo. Outra complica√ß√£o √© o modo como se trata a coleta de lixo quando uma transa√ß√£o √© confirmada. As p√°ginas antigas referenciadas pelo diret√≥rio de sombra que foram atualizados devem ser liberadas e acrescentadas √† lista de p√°ginas livres para uso futuro. Essas p√°ginas n√£o s√£o mais necess√°rias ap√≥s a confirma√ß√£o da transa√ß√£o. Outra quest√£o √© que a opera√ß√£o para migrar entre os diret√≥rios atual e de sombra deve ser implementada como uma opera√ß√£o at√¥mica.

## 23.5 O algoritmo de recupera√ß√£o ARIES

Agora,  descrevemos  o  algoritmo  ARIES  como um  exemplo  de  algoritmo  de  recupera√ß√£o  usado em sistemas de banco de dados. Ele √© utilizado em muitos produtos relacionados a banco de dados relacional da IBM. O ARIES possui uma t√©cnica steal/ no-force para grava√ß√£o, e √© baseado em tr√™s concei- tos: logging write-ahead, hist√≥rico repetitivo durante  o  redo  e  mudan√ßas  no  logging  durante  o  undo. Discutimos o logging write-ahead na Se√ß√£o 23.1.3. O segundo conceito, o hist√≥rico repetitivo , significa que o ARIES retra√ßar√° todas as a√ß√µes do sistema de banco de dados antes da falha para reconstruir o estado do banco de dados quando a falha ocorrer . As transa√ß√µes que n√£o foram confirmadas no momento da falha (transa√ß√µes ativas) s√£o desfeitas. O terceiro conceito, logging durante o undo , impedir√° que o ARIES repita as opera√ß√µes de undo completadas se houver uma falha durante a recupera√ß√£o, causando um rein√≠cio do processo de recupera√ß√£o.

O procedimento de recupera√ß√£o ARIES consiste em tr√™s etapas principais: an√°lise, REDO e UNDO. A etapa  de  an√°lise identifica  as  p√°ginas  sujas  (atualizadas) no buffer 6  e o conjunto de transa√ß√µes ativas no momento da falha. O ponto apropriado no log em que a opera√ß√£o REDO deveria come√ßar tamb√©m √© determinado. A fase de REDO na realidade reaplica as atualiza√ß√µes do log ao banco de dados. Em geral, a opera√ß√£o REDO √© aplicada apenas a transa√ß√µes confirmadas. Por√©m, isso n√£o acontece no ARIES. Certas informa√ß√µes no log do ARIES oferecer√£o o ponto de partida para o REDO, com base no qual as opera√ß√µes de REDO s√£o aplicadas at√© o final do log ser alcan√ßado. Al√©m disso, as informa√ß√µes armazenadas pelo ARIES e nas p√°ginas de dados permitir√£o que o ARIES determine se a opera√ß√£o a ser refeita realmente foi aplicada ao banco de dados e, portanto, n√£o precisa ser reaplicada. Assim, somente as opera√ß√µes  de REDO necess√°rias s√£o  aplicadas  durante a recupera√ß√£o. Por fim, durante a fase de UNDO , o

6 Os buffers reais podem se perder durante uma falha, pois est√£o na mem√≥ria principal. Tabelas adicionais armazenadas no log durante o check point (tabela de p√°ginas sujas, tabela de transa√ß√µes) permitem que o ARIES identifique essa informa√ß√£o (conforme discutiremos mais adiante nesta se√ß√£o).

log √© varrido de tr√°s para a frente e as opera√ß√µes das transa√ß√µes que estavam ativas no momento da falha s√£o desfeitas na ordem contr√°ria. As informa√ß√µes necess√°rias para o ARIES realizar seu procedimento de recupera√ß√£o incluem o log, a tabela de transa√ß√µes e a tabela de p√°ginas sujas. Al√©m disso, o check point √© utilizado. Essas tabelas s√£o mantidas pelo gerenciador de transa√ß√£o e gravadas no log durante o check point.

Em ARIES, cada registro de log tem um n√∫mero de sequ√™ncia de log (LSN -Log Sequence Number) associado,  que  aumenta  monotonicamente e indica o endere√ßo do registro de log no disco. Cada LSN corresponde a uma mudan√ßa espec√≠fica (a√ß√£o) de alguma transa√ß√£o. Al√©m disso, cada p√°gina de dados armazenar√° o LSN do registro  de  log  mais  recente correspondente  a  uma  mudan√ßa  para  essa  p√°gina. Um registro de log √© gravado para qualquer uma das seguintes a√ß√µes: atualizar uma p√°gina (write), confirmar uma transa√ß√£o (commit), abortar uma transa√ß√£o (abort), desfazer uma atualiza√ß√£o (undo) e encerrar uma transa√ß√£o (end). A necessidade de incluir as tr√™s primeiras a√ß√µes no log j√° foi discutida, mas as duas √∫ltimas precisam de alguma explica√ß√£o. Quando uma atualiza√ß√£o  √©  desfeita,  um registro  de  log  de  compensa√ß√£o √© gravado no log. Quando uma transa√ß√£o termina, seja por confirma√ß√£o ou abortamento, um registro de log de fim √© gravado.

Os campos comuns em todos os registros de log incluem o LSN anterior para essa transa√ß√£o, a ID da transa√ß√£o e o tipo de registro de log. O LSN anterior √© importante porque ele liga os registros de log (em ordem reversa) para cada transa√ß√£o. Para uma a√ß√£o de atualiza√ß√£o (write), campos adicionais no registro de log incluem a ID de p√°gina para a p√°gina que cont√©m o item, o comprimento do item atualizado, seu deslocamento do in√≠cio da p√°gina, a imagem antes do item e sua imagem depois.

Al√©m do log, duas tabelas s√£o necess√°rias para uma recupera√ß√£o eficiente: a Tabela de Transa√ß√µes e a Tabela de P√°ginas Sujas , que s√£o mantidas pelo gerenciador de transa√ß√£o. Quando ocorre uma falha, essas tabelas s√£o reconstru√≠das na fase de an√°lise da recupera√ß√£o. A Tabela de Transa√ß√µes cont√©m uma entrada para cada transa√ß√£o ativa , com informa√ß√µes como a ID de transa√ß√£o, o status da transa√ß√£o e o LSN do registro de log mais recente para a transa√ß√£o. A Tabela de P√°ginas Sujas cont√©m uma entrada para cada p√°gina suja no buffer, que inclui a ID de p√°gina e o LSN correspondente √† atualiza√ß√£o mais antiga nessa p√°gina.

O check point no ARIES consiste no seguinte: gravar um registro begin\_checkpoint no log, gravar um registro end\_checkpoint no log e gravar o LSN do registro begin\_checkpoint em um arquivo especial. Esse arquivo especial √© acessado durante a recupera√ß√£o para localizar a √∫ltima informa√ß√£o de check point. Com o registro end\_checkpoint , os conte√∫dos da Tabela de Transa√ß√µes e da Tabela de P√°ginas Sujas s√£o anexados ao final do log. Para reduzir o custo, o check point fuzzy √© usado de modo que o SGBD possa continuar a executar as transa√ß√µes durante o check point (ver Se√ß√£o 23.1.4). Al√©m disso, o conte√∫do do cache do SGBD n√£o precisa ser transferido para o disco durante o check point porque a Tabela de Transa√ß√µes e a Tabela de P√°ginas Sujas - que s√£o anexadas ao log no disco - cont√™m as informa√ß√µes necess√°rias para a recupera√ß√£o. Observe que, se houver uma falha durante o check point, o arquivo especial se referir√° ao check point anterior, que √© usado para recupera√ß√£o.

Ap√≥s  uma  falha,  o  gerenciador  de  recupera√ß√£o ARIES assume. A informa√ß√£o do √∫ltimo check point √© primeiro acessada por meio do arquivo especial. A fase  de  an√°lise come√ßa  no  registro begin\_checkpoint e  prossegue  at√©  o  final  do  log.  Quando  o  registro end\_checkpoint √© encontrado, a Tabela de Transa√ß√µes e a Tabela de P√°ginas Sujas s√£o acessadas (lembre-se de que essas tabelas foram gravadas no log durante o  check  point).  No  decorrer  da  an√°lise,  os  registros de log sendo analisados podem causar modifica√ß√µes nessas duas tabelas. Por exemplo, se um registro de log de fim foi encontrado para uma transa√ß√£o T na Tabela de Transa√ß√µes, ent√£o a entrada para T √©  exclu√≠da dessa tabela. Se algum outro tipo de registro de log for encontrado para uma transa√ß√£o T' , ent√£o uma entrada para T' √©  inserida na Tabela de Transa√ß√µes, se ainda n√£o estiver presente, e o √∫ltimo campo LSN √© modificado. Se o registro de log corresponder a uma mudan√ßa para a p√°gina P ,  ent√£o  uma  entrada  seria feita para a p√°gina P (se n√£o estiver presente na tabela) e o campo LSN associado seria modificado. Quando a fase de an√°lise termina, a informa√ß√£o necess√°ria para REDO e UNDO j√° foi compilada nas tabelas.

A fase de REDO vem em seguida. Para reduzir a quantidade de trabalho desnecess√°rio, o ARIES come√ßa a refazer em um ponto no log em que ele sabe (com certeza) que as mudan√ßas anteriores nas p√°ginas sujas j√° foram aplicadas ao banco de dados no disco .  Ele pode determinar isso ao localizar o menor LSN, M , de todas as p√°ginas sujas na Tabela de P√°ginas Sujas, que indica a posi√ß√£o no log onde o ARIES precisa iniciar a fase de REDO . Quaisquer mudan√ßas correspondentes a um LSN &lt; M ,  para transa√ß√µes que podem ser refeitas, j√° precisam ter sido propagadas para o disco ou alteradas no buffer; caso contr√°rio, essas p√°ginas sujas com esse LSN estariam no buffer (e na Tabela de P√°ginas Sujas). Assim, a REDO come√ßa no registro de log com LSN = M e varre para a frente at√© o final do log. Para cada mudan√ßa registrada no log, o algoritmo

de REDO verificaria  se  a  mudan√ßa  foi  reaplicada  ou n√£o. Por exemplo, se uma mudan√ßa registrada no log pertence √† p√°gina P que n√£o est√° na Tabela de P√°ginas Sujas, ent√£o essa mudan√ßa j√° est√° no disco e n√£o precisa ser reaplicada. Ou, se uma mudan√ßa registrada no log (com LSN = N , digamos) pertence √† p√°gina P e a Tabela de P√°ginas Sujas cont√©m uma entrada para P com LSN maior que N , ent√£o a mudan√ßa j√° est√° presente.  Se  nenhuma dessas duas condi√ß√µes acontecer, a  p√°gina P √©  lida  do  disco  e  o  LSN  armazenado nessa p√°gina, LSN( P ), √© comparado com N . Se N &lt; LSN( P ), ent√£o a mudan√ßa foi aplicada e a p√°gina n√£o precisa ser regravada no disco.

cada a√ß√£o do conjunto de transa√ß√µes no undo\_set tenha sido desfeita. Quando isso √© conclu√≠do, o processo de recupera√ß√£o termina e o processamento normal pode ser iniciado novamente.

Considere o exemplo de recupera√ß√£o mostrado na Figura 23.5. Existem tr√™s transa√ß√µes: T  T 1 , 2 e T 3 . T 1 atualiza a p√°gina C T , 2 atualiza as p√°ginas B e C , e T 3 atualiza a p√°gina A.

Quando a fase de REDO terminar, o banco de dados estar√° no estado exato em que estava quando a falha ocorreu. O conjunto de transa√ß√µes ativas - chamadas undo\_set -foi identificado na Tabela de Transa√ß√µes durante a fase de an√°lise. Agora, a fase de UNDO prossegue varrendo de tr√°s para a frente, do final do log, e desfazendo as a√ß√µes apropriadas. Um registro de log de compensa√ß√£o √© gravado para cada a√ß√£o que √© desfeita. O UNDO l√™ de tr√°s para a frente no log at√© que

A Figura 23.5(a) mostra o conte√∫do parcial do log, e a Figura 23.5(b) mostra o conte√∫do da Tabela de Transa√ß√µes e da Tabela de P√°ginas Sujas. Agora, suponha que ocorra uma falha nesse ponto. Como houve um check point, o endere√ßo do registro begin\_checkpoint associado √© recuperado, que √© o local 4. A fase de an√°lise  come√ßa do local 4 at√© alcan√ßar o final. O registro end\_checkpoint teria a Tabela de Transa√ß√µes e a Tabela de P√°ginas Sujas da Figura 23.5(b), e a fase de an√°lise ainda reconstruiria essas tabelas. Quando a  fase  de  an√°lise  encontra  o  registro  de  log  6,  uma nova entrada para a transa√ß√£o T 3 √© feita na Tabela de Transa√ß√µes e uma nova entrada para a p√°gina A √© feita na Tabela de P√°ginas Sujas. Ap√≥s o registro 8

(a)

|   Lsn | Ultimo_lsn        | Id_transacao   | Tipo   | Id_pagina   | Outra_informacao   |
|-------|-------------------|----------------|--------|-------------|--------------------|
|     1 | 0                 | T 1            | update | C           | ‚Ä¶                  |
|     2 | 0                 | T 2            | update | B           | ‚Ä¶                  |
|     3 | 1                 | T 1            | commit |             | ‚Ä¶                  |
|     4 | begin check point |                |        |             |                    |
|     5 | end check point   |                |        |             |                    |
|     6 | 0                 | T 3            | update | A           | ‚Ä¶                  |
|     7 | 2                 | T 2            | update | C           | ‚Ä¶                  |
|     8 | 7                 | T 2            | commit |             | ‚Ä¶                  |

## TABELA DE TRANSA√á√ïES

## TABELA DE P√ÅGINAS SUJAS

| Id_transacoes   |   Ultimo_lsn | Status      |
|-----------------|--------------|-------------|
| T 1             |            3 | commit      |
| T 2             |            2 | in progress |

## TABELA DE TRANSA√á√ïES

| Id_transacoes   |   Ultimo_lsn | Status      |
|-----------------|--------------|-------------|
| T 1             |            3 | commit      |
| T 2             |            8 | commit      |
| T 3             |            6 | in progress |

| Id_pagina   |   Lsn |
|-------------|-------|
| C           |     1 |
| B           |     2 |

## TABELA DE P√ÅGINAS SUJAS

| Id_pagina   |   Lsn |
|-------------|-------|
| C           |     1 |
| B           |     2 |
| A           |     6 |

(b)

(b)

Figura 23.5

Exemplo de recupera√ß√£o em ARIES. (a) O log no ponto da falha. (b) As Tabelas de Transa√ß√µes e de P√°ginas Sujas no momento do check point. (c) As Tabelas de Transa√ß√µes e de P√°ginas Sujas ap√≥s a fase de an√°lise.

ser analisado, o status da transa√ß√£o T 2 √© mudado para confirmado na Tabela de Transa√ß√µes. A Figura 23.5(c) mostra as duas tabelas ap√≥s a fase de an√°lise.

Para a fase de REDO , o menor LSN na Tabela de P√°ginas Sujas √© 1. Logo, o REDO come√ßar√° no registro de log 1 e prosseguir√° com o REDO das atualiza√ß√µes. Os LSNs {1, 2, 6, 7} correspondentes √†s atualiza√ß√µes para as p√°ginas C, B, A e C, respectivamente, s√£o menores do que os LSNs dessas p√°ginas (como mostra a Tabela de P√°ginas Sujas). Assim, essas p√°ginas de dados ser√£o lidas novamente e as atualiza√ß√µes, reaplicadas com base no log (supondo que os LSNs reais armazenados nessas p√°ginas de dados sejam menores que a entrada de log correspondente). Nesse ponto, a fase de REDO termina e a fase de UNDO come√ßa. Pela  Tabela  de  Transa√ß√µes  (Figura  23.5(c)), UNDO √© aplicado somente √† transa√ß√£o ativa T 3 .  A  fase  de UNDO inicia na entrada de log 6 (a √∫ltima atualiza√ß√£o para T 3 ) e prossegue detr√°s para a frente no log. A cadeia inversa de atualiza√ß√µes para a transa√ß√£o T 3 (somente o registro de log 6 neste exemplo) √© seguida e desfeita.

## 23.6 Recupera√ß√£o em sistemas de m√∫ltiplos bancos de dados

At√© aqui, assumimos implicitamente que uma transa√ß√£o acessa um √∫nico banco de dados. Em alguns  casos,  uma  √∫nica  transa√ß√£o,  chamada transa√ß√£o multibanco de dados ,  pode  exigir  acesso  a v√°rios  bancos  de  dados.  Esses  bancos  de  dados podem ainda ser armazenados em diferentes tipos de  SGBDs;  por  exemplo,  alguns  SGBDs  podem ser relacionais, enquanto outros s√£o orientados a objeto, hier√°rquicos ou de rede. Nesse caso, cada SGBD envolvido na transa√ß√£o multibanco de dados  pode  ter  a  pr√≥pria  t√©cnica  de  recupera√ß√£o  e gerenciador de transa√ß√£o separados daqueles dos outros SGBDs. Essa situa√ß√£o √© um tanto quanto semelhante ao caso de um sistema de gerenciamento de banco de dados distribu√≠do (ver Cap√≠tulo 25), em que partes do banco de dados residem em diferentes locais que est√£o conectados por uma rede de comunica√ß√£o.

Para  manter  a  atomicidade  de  uma  transa√ß√£o multibanco de dados, √© preciso ter um mecanismo de recupera√ß√£o de dois n√≠veis. Um gerenciamento de recupera√ß√£o global , ou coordenador , √© necess√°rio para manter informa√ß√µes usadas para recupera√ß√£o, al√©m dos gerenciadores de recupera√ß√£o locais e as informa√ß√µes que eles mant√™m (log, tabelas). O coordenador costuma seguir um protocolo chamado protocolo de confirma√ß√£o em duas fases , cujas fases podem ser indicadas da seguinte forma:

- ¬Ñ Fase  1. Quando  todos  os  bancos  de  dados participantes  sinalizam  ao  coordenador  que a  parte  da  transa√ß√£o  multibanco  de  dados que envolve cada um tiver sido conclu√≠da, o coordenador envia uma mensagem de prepara√ß√£o  para  confirma√ß√£o a  cada  participante, para que se preparem para confirmar a transa√ß√£o. Cada banco de dados participante, ao receber  essa  mensagem,  for√ßar√°  a  grava√ß√£o de todos os registros do log e as informa√ß√µes necess√°rias para a recupera√ß√£o local em disco, e depois enviar√° um sinal pronto para confirma√ß√£o ou OK ao coordenador. Se a grava√ß√£o for√ßada em disco falhar ou a transa√ß√£o local n√£o puder confirmar por alguma raz√£o, o banco de dados participante enviar√° um sinal n√£o posso confirmar ou n√£o OK ao coordenador. Se o coordenador n√£o receber uma resposta do banco de dados dentro de certo limite de tempo, ele assume uma resposta n√£o OK .
- ¬Ñ Fase 2. Se todos os bancos de dados participantes responderem OK e o voto do coordenador tamb√©m for OK , a transa√ß√£o ter√° sido bem-sucedida, e o coordenador envia um sinal de confirma√ß√£o para a transa√ß√£o aos bancos de dados participantes. Como todos os efeitos locais da transa√ß√£o e as informa√ß√µes necess√°rias para a recupera√ß√£o local foram registrados nos logs dos bancos de dados participantes, a recupera√ß√£o da falha agora √© poss√≠vel. Cada banco de dados participante completa a confirma√ß√£o da transa√ß√£o ao gravar uma entrada [commit] para a transa√ß√£o no log e ao atualizar permanentemente o banco de dados, se necess√°rio. Contudo, se um ou mais dos bancos de dados participantes ou o coordenador tiverem uma resposta n√£o OK , a transa√ß√£o ter√° falhado, e o  coordenador  enviar√°  uma  mensagem  para reverter ou UNDO (desfazer) o efeito local da transa√ß√£o a cada banco de dados participante. Isso √© feito ao desfazer as opera√ß√µes da transa√ß√£o, usando o log.
- O efeito final do protocolo de confirma√ß√£o em duas fases √© que ou todos os bancos de dados participantes  confirmam  o  efeito  da  transa√ß√£o  ou  nenhum deles o faz. Caso qualquer um dos participantes - ou o coordenador - falhe, sempre √© poss√≠vel recuperar para um estado em que ou a transa√ß√£o √© confirmada ou ela √© revertida. Uma falha durante ou antes da Fase 1 normalmente requer que a transa√ß√£o seja revertida, enquanto uma falha durante a Fase 2 significa que uma transa√ß√£o bem-sucedida pode se recuperar e ser confirmada.

## 23.7 Backup e recupera√ß√£o de banco de dados contra falhas catastr√≥ficas

At√©  aqui,  todas  as  t√©cnicas  que  discutimos  se aplicam  a  falhas  n√£o  catastr√≥ficas.  Uma  suposi√ß√£o chave foi a de que o log do sistema √© mantido no disco e n√£o se perde como resultado da falha. De modo semelhante, o diret√≥rio de sombra precisa ser armazenado no disco para permitir a recupera√ß√£o quando a p√°gina de sombra for utilizada. As t√©cnicas de recupera√ß√£o que discutimos usam as entradas no log do sistema ou no diret√≥rio de sombra para se recuperarem da falha ao retornar o banco de dados a um estado consistente.

O  gerenciador  de  recupera√ß√£o  de  um  SGBD tamb√©m precisa ser equipado para lidar com falhas mais catastr√≥ficas, como as falhas de disco. A principal t√©cnica utilizada para lidar com essas falhas √© um backup do banco de dados , em que o banco de dados  inteiro  e  o  log  s√£o  periodicamente  copiados para um meio de armazenamento barato, como fitas magn√©ticas ou outros dispositivos de armazenamento  off-line  de  grande  capacidade.  No  caso  de  uma falha catastr√≥fica do sistema, a c√≥pia de backup mais recente pode ser recarregada da fita para o disco, e o sistema, reiniciado.

Os dados de aplica√ß√µes  cr√≠ticas,  como  bancos, seguros, mercado de a√ß√µes e outros bancos de dados, s√£o copiados de tempos em tempos em sua totalidade e movidos para locais seguros e fisicamente separados.  C√¢maras de armazenamento subterr√¢neas t√™m sido usadas para prote√ß√£o contra danos ocasionados por inunda√ß√£o, tempestade, terremoto ou inc√™ndio. Eventos como o ataque terrorista de 11 de setembro em Nova York (em 2001) e o desastre do furac√£o Katrina em Nova Orleans (em 2005) criaram uma maior  conscientiza√ß√£o  da recupera√ß√£o  de  desastres dos bancos de dados cr√≠ticos aos neg√≥cios .

Para evitar perder todos os efeitos das transa√ß√µes que foram executadas desde o √∫ltimo backup, √© comum fazer o backup do log do sistema em intervalos mais frequentes do que o do banco de dados inteiro,  copiando-o  periodicamente  para  fita  magn√©tica. O log do sistema costuma ser muito menor do que o pr√≥prio banco de dados, e, portanto, pode ser copiado com mais frequ√™ncia. Portanto, os usu√°rios n√£o perdem todas as transa√ß√µes que realizaram desde o √∫ltimo backup do banco de dados. Todas as transa√ß√µes confirmadas e registradas na parte do log do sistema que foi copiada para fita podem ter efeito sobre o banco de dados refeito. Um novo log √© iniciado ap√≥s cada backup do banco de dados.

Assim, para recuperar-se da falha do disco, o banco de dados √© primeiro recriado no disco com base em sua c√≥pia de backup mais recente em fita. Depois disso, os efeitos de todas as transa√ß√µes confirmadas, cujas opera√ß√µes foram registradas nas c√≥pias do log do sistema, s√£o refeitos.

## Resumo

Neste  cap√≠tulo,  discutimos  as  t√©cnicas  para  recupera√ß√£o de falhas na transa√ß√£o. O objetivo principal da recupera√ß√£o √© garantir a propriedade de atomicidade de uma transa√ß√£o. Se uma transa√ß√£o falhar antes de terminar sua execu√ß√£o, o mecanismo de recupera√ß√£o precisa garantir que a transa√ß√£o n√£o possui efeitos duradouros no banco de dados. Primeiro, fizemos um esbo√ßo informal para um processo de recupera√ß√£o e, depois, discutimos  os  conceitos  do  sistema  para  recupera√ß√£o.  Estes inclu√≠ram uma discuss√£o de caching, atualiza√ß√£o no local versus sombra,  imagens  antes  e  depois  de  um  item  de dados, opera√ß√µes de recupera√ß√£o UNDO versus REDO , pol√≠ticas  steal/no-steal  e  force/no-force,  check  point  do sistema e o protocolo de logging write-ahead.

Em  seguida,  abordamos  duas  t√©cnicas  diferentes para  a  recupera√ß√£o:  atualiza√ß√£o  adiada  e  atualiza√ß√£o imediata.  As  t√©cnicas  de  atualiza√ß√£o  adiada  postergam qualquer atualiza√ß√£o real do banco de dados em disco at√© que uma transa√ß√£o atinja seu ponto de confirma√ß√£o (commit). A transa√ß√£o for√ßa a grava√ß√£o do log em disco antes de gravar as atualiza√ß√µes no banco de dados. Essa t√©cnica, quando usada com certos m√©todos de controle de concorr√™ncia, √© projetada para nunca exigir a revers√£o (rollback)  da  transa√ß√£o,  e  a  recupera√ß√£o  consiste  simplesmente em refazer as opera√ß√µes das transa√ß√µes confirmadas ap√≥s o √∫ltimo check point do log. A desvantagem √© que muito espa√ßo em buffer pode ser necess√°rio, pois as atualiza√ß√µes s√£o mantidas nos buffers e n√£o s√£o aplicadas ao disco at√© que a transa√ß√£o seja confirmada. A atualiza√ß√£o adiada pode levar a um algoritmo de recupera√ß√£o conhecido como NO-UNDO/REDO. As t√©cnicas de atualiza√ß√£o imediata podem aplicar mudan√ßas ao banco de  dados  no  disco  antes  que  a  transa√ß√£o  alcance  uma conclus√£o bem-sucedida. Quaisquer mudan√ßas aplicadas ao banco de dados devem primeiro ser registradas no log e for√ßar a grava√ß√£o para o disco, de modo que essas opera√ß√µes possam ser desfeitas, se for preciso. Demos uma vis√£o geral de um algoritmo de recupera√ß√£o para atualiza√ß√£o  imediata,  conhecido  como UNDO/REDO. Outro algoritmo, conhecido como UNDO/NO-REDO, tamb√©m pode ser desenvolvido para atualiza√ß√£o imediata se todas as a√ß√µes da transa√ß√£o forem registradas no banco de dados antes da confirma√ß√£o.

Discutimos a t√©cnica de pagina√ß√£o de sombra para a recupera√ß√£o, que registra as antigas p√°ginas do banco de dados usando um diret√≥rio de sombra. Essa t√©cnica, que √© classificada como NO-UNDO/NO-REDO , n√£o exige um log nos sistemas monousu√°rio, mas ainda precisa do log

para  sistemas  multiusu√°rios.  Tamb√©m  apresentamos  o ARIES,  um  esquema  de  recupera√ß√£o  espec√≠fico  utilizado em muitos produtos de banco de dados relacional da IBM. Depois, discutimos o protocolo de confirma√ß√£o em duas fases, que √© usado para recupera√ß√£o de falhas que envolvem transa√ß√µes multibanco de dados. Finalmente, discutimos  a  recupera√ß√£o  de  falhas  catastr√≥ficas,  que costuma ser feita com o backup do banco de dados e do log em fita. O log pode ser copiado com mais frequ√™ncia do que o banco de dados, e o log de backup pode servir para refazer opera√ß√µes com base no √∫ltimo backup completo do banco de dados.

## Perguntas de revis√£o

- 23.1. Discuta os diferentes tipos de falhas de transa√ß√£o. O que significa uma falha catastr√≥fica?
- 23.2. Discuta as a√ß√µes tomadas pelas opera√ß√µes read\_ item e write\_item em um banco de dados.
- 23.3. Para que √© usado o log do sistema? Quais s√£o os tipos mais comuns de entradas em um log do sistema? O que s√£o check points e por que eles s√£o importantes? O que s√£o pontos de confirma√ß√£o da transa√ß√£o e por que eles s√£o importantes?
- 23.4. Como as t√©cnicas de buffering e caching s√£o usadas pelo subsistema de recupera√ß√£o?
- 23.5. O que s√£o a imagem antes (BFIM) e a imagem depois (AFIM) de um item de dados? Qual √© a diferen√ßa entre a atualiza√ß√£o no local e a sombra, com rela√ß√£o ao tratamento de BFIM e AFIM?
- 23.6. O que s√£o entradas de log tipo UNDO e REDO ?
- 23.7. Descreva o protocolo de logging write-ahead.
- 23.8. Identifique  tr√™s  listas  t√≠picas  de  transa√ß√µes  que s√£o mantidas pelo subsistema de recupera√ß√£o.
- 23.9. O que significa revers√£o (ou rollback) de transa√ß√£o? O que significa rollback em cascata? Por que os m√©todos de recupera√ß√£o pr√°ticos utilizam protocolos que n√£o permitem a propriedade de rollback em cascata? Que t√©cnicas de recupera√ß√£o n√£o exigem qualquer rollback?
- 23.10. Discuta as opera√ß√µes UNDO e REDO e as t√©cnicas de recupera√ß√£o que utilizam cada uma.
- 23.11. Discuta a t√©cnica de recupera√ß√£o com atualiza√ß√£o  adiada.  Quais  s√£o  as  vantagens  e  desvantagens dessa t√©cnica? Por que ela √© chamada de m√©todo NO-UNDO/REDO ?
- 23.12. Como a recupera√ß√£o pode tratar de opera√ß√µes com transa√ß√£o que n√£o afetam o banco de dados,  como  a  impress√£o  de  relat√≥rios  por  uma transa√ß√£o?
- 23.13. Discuta a t√©cnica de recupera√ß√£o com atualiza√ß√£o imediata nos ambientes monousu√°rio e mul-
- tiusu√°rio. Quais s√£o as vantagens e desvantagens da atualiza√ß√£o imediata?
- 23.14. Qual √© a diferen√ßa entre os algoritmos de UNDO/ REDO e UNDO/NO-REDO para  a  recupera√ß√£o com atualiza√ß√£o imediata? Desenvolva o esbo√ßo para um algoritmo UNDO/NO-REDO.
- 23.15. Descreva a t√©cnica de recupera√ß√£o com pagina√ß√£o de sombra. Sob quais circunst√¢ncias ela n√£o exige um log?
- 23.16. Descreva as tr√™s fases de recupera√ß√£o do ARIES.
- 23.17. O que s√£o n√∫meros de sequ√™ncia de log (LSNs) em ARIES? Como eles s√£o usados? Que informa√ß√£o a Tabela de P√°ginas Sujas e a Tabela de Transa√ß√µes cont√™m? Descreva como o check point fuzzy √© usado no ARIES.
- 23.18. O que significam os termos steal/no-steal e force/ no-force com rela√ß√£o ao gerenciamento de buffer para processamento de transa√ß√£o?
- 23.19. Descreva o protocolo de confirma√ß√£o em duas fases para transa√ß√µes multibanco de dados.
- 23.20. Discuta como √© tratada a recupera√ß√£o de desastre contra falhas catastr√≥ficas.

## Exerc√≠cios

Suponha que o sistema  falhe  antes  da  entrada ] ser gravada no log da Figura 23.1(b). Isso far√° alguma diferen√ßa no processo

- 23.21. [ read\_item, T 3 , A de recupera√ß√£o?
- 23.22. Suponha que o sistema falhe antes de a entrada [ write\_item, T 2 , D ,  25,  26]  ser  gravada  no  log da Figura 23.1(b). Isso far√° alguma diferen√ßa no processo de recupera√ß√£o?
- 23.23. A Figura 23.6 mostra o log correspondente a determinado schedule no ponto de uma falha do sistema para quatro transa√ß√µes T 1 , T 2 , T 3 e T 4 . Suponha que usemos o protocolo de atualiza√ß√£o imediata com check point. Descreva o processo de recupera√ß√£o da falha do sistema. Especifique  quais  transa√ß√µes  s√£o  revertidas, quais opera√ß√µes no log s√£o refeitas e quais (se houver) s√£o desfeitas, e se ocorre algum rollback em cascata.
- 23.24. Suponha  que  usemos  um  protocolo  de  atualiza√ß√£o  adiada  para  o  exemplo  da  Figura  23.6. Mostre  como  o  log  seria  diferente  no  caso  de atualiza√ß√£o adiada ao remover as entradas de log desnecess√°rias;  depois,  descreva  o  processo  de recupera√ß√£o, usando seu log modificado. Suponha que apenas opera√ß√µes REDO sejam aplicadas e

[start\_transaction, T 1 ]

[read\_item, T 1 , A ]

[read\_item, T 1 , D ]

[write\_item, T 1 , D , 20, 25]

[commit, T 1 ]

[checkpoint]

[start\_transaction, T 2 ]

[read\_item, T 2 , B ]

[write\_item, T 2 , B , 12, 18]

[start\_transaction, T 4]

[read\_item, T 4 , D ]

[write\_item, T 4 , D , 25, 15]

[start\_transaction, T 3 ]

[write\_item, T 3 , C , 30, 40]

[read\_item, T 4 , A ]

[write\_item, T 4 , A , 30, 20]

[commit, T 4 ]

[read\_item, T 2 , D ]

[write\_item, T 2 , D , 15, 25]

Falha do sistema



## Figura 23.6

Exemplo de schedule e seu log correspondente.

especifique quais opera√ß√µes no log s√£o refeitas e quais s√£o ignoradas.

- 23.25. Como o check point do ARIES difere do check point descrito na Se√ß√£o 23.1.4?
- 23.26. Como  os  n√∫meros  de  sequ√™ncia  de  log  s√£o usados  pelo  ARIES  para  reduzir  a  quantidade  de  trabalho  de REDO necess√°ria  para  a  recupera√ß√£o?  Ilustre  com  um  exemplo  usando a informa√ß√£o mostrada na Figura 23.5. Voc√™ pode fazer suas suposi√ß√µes em rela√ß√£o a quando uma p√°gina √© gravada no disco.
- 23.27. Que implica√ß√µes uma pol√≠tica de gerenciamento de buffer no-steal/force tem sobre o check point e a recupera√ß√£o?

Escolha  a  resposta  correta  para  cada  uma  das seguintes perguntas de m√∫ltipla escolha:

23.28.

- O logging incremental com atualiza√ß√µes adiadas implica que o sistema de recupera√ß√£o deve necessariamente
- a. armazenar o valor antigo do item atualizado no log.
- b. armazenar o valor novo do item atualizado no log.
- c. armazenar o valor antigo e o novo do item atualizado no log.
- d. armazenar apenas os registros Begin Transaction e Commit Transaction no log.

23.29.

- 23.31.
- 23.32.
- O protocolo de logging write-ahead (WAL) simplesmente significa que
- a. a grava√ß√£o de um item de dados deve ser feita antes de qualquer opera√ß√£o de logging.
- b. o registro de log para uma opera√ß√£o deve ser gravado antes do que os dos dados reais.
- c. todos os registros de log devem ser gravados antes que uma nova transa√ß√£o inicie a execu√ß√£o.
- d. o log nunca precisa ser gravado em disco.
- 23.30. No caso de falha da transa√ß√£o sob um esquema de logging incremental com atualiza√ß√£o adiada,

qual das seguintes opera√ß√µes ser√° necess√°ria?

- a. uma opera√ß√£o undo.
- b. uma opera√ß√£o redo.
- c. uma opera√ß√£o undo e redo.
- d. nenhuma das alternativas anteriores.
- Para o logging incremental com atualiza√ß√µes imediatas,  um  registro  de  log  para  uma  transa√ß√£o conteria
- a. um nome de transa√ß√£o, um nome de item de dados e os valores antigo e novo do item.
- b. um nome de transa√ß√£o, um nome de item de dados e o valor antigo do item.
- c. um nome de transa√ß√£o, um nome de item de dados e o valor novo do item.
- d. um nome de transa√ß√£o e um nome de item de dados.

Para o comportamento correto durante a recupera√ß√£o, opera√ß√µes de undo e redo devem ser

- a. comutativas.
- b. associativas.
- c. idempotentes.
- d. distributivas.
- 23.33. Quando ocorre uma falha, o log √© consultado e cada opera√ß√£o √© desfeita ou refeita. Isso √© um problema porque
- a. a pesquisa do log inteiro √© demorada.
- b. muitos redo s s√£o desnecess√°rios.
- c. as alternativas (a) e (b) est√£o corretas.
- d. nenhuma das alternativas anteriores.
- 23.34. Ao usar um esquema de recupera√ß√£o baseado em log, isso poderia melhorar o desempenho e tamb√©m oferecer um mecanismo de recupera√ß√£o ao
- a. gravar os registros de log em disco quando cada transa√ß√£o √© confirmada.
- b. gravar os registros de log apropriados em disco durante a execu√ß√£o da transa√ß√£o.
- c. esperar  para  gravar  os  registros  de  log  at√© que m√∫ltiplas transa√ß√µes sejam confirmadas e grav√°-las como um batch.
- d. nunca gravar os registros de log em disco.

23.35. Existe uma possibilidade de rollback em cascata quando

- a. uma transa√ß√£o grava itens que foram gravados apenas por uma transa√ß√£o confirmada.
- b. uma transa√ß√£o grava um item que foi anteriormente  gravado  por  uma  transa√ß√£o  n√£o confirmada.
- c. uma transa√ß√£o l√™ um item que foi anteriormente gravado por uma transa√ß√£o n√£o confirmada.
- d. as alternativas (b) e (c) est√£o corretas.

23.36. Para lidar com falhas de m√≠dia (disco), √© necess√°rio

- a. que  o  SGBD  s√≥  execute  transa√ß√µes  em  um ambiente monousu√°rio.
- b. manter uma c√≥pia redundante do banco de dados.
- c. nunca abortar uma transa√ß√£o.
- d. todas as alternativas anteriores.

Se  a  t√©cnica  de  sombreamento  for  usada  para transferir um item de dados para o disco, ent√£o

- a. o  item  √©  gravado  em  disco  somente  depois que a transa√ß√£o √© confirmada.
- b. o  item  √©  gravado  em  um  local  diferente  no disco.
- c. o item √© gravado em disco antes que a transa√ß√£o seja confirmada.
- d. o item √© gravado no mesmo local do disco em que ele foi lido.

## Bibliografia selecionada

Os livros de Bernstein et al. (1987) e Papadimitriou (1986) s√£o dedicados √† teoria e aos princ√≠pios de con-

23.37.

trole de concorr√™ncia e recupera√ß√£o. O livro de Gray e Reuter (1993) √© um trabalho enciclop√©dico sobre controle de concorr√™ncia, recupera√ß√£o e outras quest√µes de processamento de transa√ß√£o.

Verhofstad (1978) apresenta um tutorial e estudo das t√©cnicas de recupera√ß√£o nos sistemas de banco de dados.  A  categoriza√ß√£o  de  algoritmos  com  base  em suas  caracter√≠sticas  de UNDO/REDO √©  discutida  em Haerder e Reuter (1983) e em Bernstein et al. (1983). Gray (1978) discute a recupera√ß√£o, junto com outros aspectos  do  sistema  de  implementa√ß√£o  de  sistemas operacionais para bancos de dados. A t√©cnica de pagina√ß√£o de sombra √© discutida em Lorie (1977), Verhofstad (1978) e Reuter (1980). Gray et al. (1981) discutem o mecanismo de recupera√ß√£o no SYSTEM R. Lockemann e Knutsen (1968), Davies (1973) e Bjork (1973) s√£o artigos antigos que discutem a recupera√ß√£o. Chandy et al. (1975) discutem a revers√£o da transa√ß√£o. Lilien e Bhargava (1985) discutem o conceito de bloco de integridade e seu uso para melhorar a efici√™ncia da recupera√ß√£o.

A recupera√ß√£o usando o logging write-ahead √© analisada  em  Jhingran  e  Khedkar  (1992)  e  √©  utilizada  no sistema ARIES (Mohan et al., 1992). O trabalho mais recente sobre recupera√ß√£o inclui transa√ß√µes de compensa√ß√£o (Korth et al., 1990) e recupera√ß√£o de banco de dados na mem√≥ria principal (Kumar, 1991). Os algoritmos de  recupera√ß√£o  ARIES  (Mohan  et  al.,  1992)  t√™m  sido muito bem-sucedidos na pr√°tica. Franklin et al. (1992) discutem a recupera√ß√£o no sistema EXODUS. Dois livros de Kumar e Hsu (1998) e Kumar e Song (1998) discutem a recupera√ß√£o em detalhes e cont√™m descri√ß√µes dos m√©todos de recupera√ß√£o usados em uma s√©rie de produtos de bancos de dados relacionais. Alguns exemplos de estrat√©gias de substitui√ß√£o de p√°gina que s√£o espec√≠ficas para bancos de dados s√£o discutidos em Chou e DeWitt (1985) e Pazos et al. (2006).



T√≥picos adicionais de banco de dados: seguran√ßa e distribui√ß√£o



## Seguran√ßa de banco de dados

E ste cap√≠tulo discute t√©cnicas para proteger os bancos de dados contra uma s√©rie de amea√ßas. Ele tamb√©m apresenta esquemas para fornecer privil√©gios de acesso a usu√°rios autorizados. Algumas das amea√ßas de seguran√ßa aos bancos de dados - como Inje√ß√£o de SQL - ser√£o apresentadas. Ao final do cap√≠tulo, tamb√©m resumimos como um SGBDR comercial especificamente, o sistema Oracle - oferece diferentes tipos  de  seguran√ßa.  Come√ßamos na Se√ß√£o 24.1 com uma introdu√ß√£o √†s quest√µes de seguran√ßa e √†s amea√ßas  aos  bancos  de  dados,  e  oferecemos  uma  vis√£o geral das medidas de controle que s√£o abordadas no restante do cap√≠tulo. Tamb√©m comentamos os relacionamentos entre a seguran√ßa de dados e a privacidade aplicadas a informa√ß√µes pessoais. A Se√ß√£o 24.2 discute os mecanismos usados para conceder e revogar privil√©gios nos sistemas de banco de dados relacionais e em SQL, mecanismos que normalmente s√£o conhecidos como controle de acesso discricion√°rio . Na Se√ß√£o 24.3, apresentamos uma vis√£o geral dos mecanismos para impor v√°rios n√≠veis de seguran√ßa - um problema em particular na seguran√ßa do sistema de banco de  dados  que  √©  conhecido  como controle  de  acesso obrigat√≥rio .  Tal  se√ß√£o  tamb√©m  apresenta  as  estrat√©gias desenvolvidas mais recentemente de controle de acesso baseado em pap√©is , e a seguran√ßa baseada em r√≥tulos e baseada em linha. A Se√ß√£o 24.3 ainda oferece uma breve discuss√£o sobre controle de acesso por XML. A Se√ß√£o 24.4 discute uma amea√ßa importante aos bancos de dados, chamada Inje√ß√£o de SQL, e trata de algumas das medidas preventivas propostas contra ela. A Se√ß√£o 24.5 discute rapidamente o problema de seguran√ßa nos bancos de dados estat√≠sticos. A Se√ß√£o 24.6 introduz o assunto de controle de fluxo e menciona problemas associados aos canais secretos. A Se√ß√£o

24.7 oferece um breve resumo dos esquemas de criptografia e infraestrutura de chave sim√©trica e assim√©trica (p√∫blica). Ela tamb√©m discute os certificados digitais. A Se√ß√£o 24.8 introduz t√©cnicas de preserva√ß√£o de privacidade, e a Se√ß√£o 24.9 apresenta os desafios atuais √† seguran√ßa do banco de dados. Na Se√ß√£o 24.10, abordamos a seguran√ßa baseada em r√≥tulos do Oracle. Por fim, apresentamos um resumo do cap√≠tulo. Os leitores que  estiverem  interessados  apenas  nos  mecanismos b√°sicos de seguran√ßa do banco de dados achar√£o suficiente abordar o material nas se√ß√µes 24.1 e 24.2.

## 24.1 ntrodu√ß√£o a quest√µes de I seguran√ßa de banco de dados 1

## 24.1.1 Tipos de seguran√ßa

A seguran√ßa do banco de dados √© uma √°rea extensa, que tenta resolver muitos problemas, incluindo os seguintes:

- ¬Ñ Diversas  quest√µes  legais  e  √©ticas  com  rela√ß√£o ao direito de acessar certas informa√ß√µes - por exemplo, algumas informa√ß√µes podem ser consideradas particulares e n√£o serem acessadas legalmente por organiza√ß√µes ou pessoas n√£o autorizadas. Nos Estados Unidos, existem v√°rias leis que controlam a privacidade da informa√ß√£o.
- ¬Ñ Quest√µes  pol√≠ticas  em  n√≠vel  governamental, institucional ou corporativo quanto aos tipos de informa√ß√µes que n√£o devem se tornar p√∫blicas - por exemplo, classifica√ß√µes de cr√©dito e registros m√©dicos pessoais.

1 Agradecemos a contribui√ß√£o substancial de Fariborz Farahmand e Bharath Rengarajan a esta e √†s se√ß√µes seguintes neste cap√≠tulo.

- ¬Ñ Quest√µes relacionadas ao sistema, como os n√≠veis de sistema em que v√°rias fun√ß√µes de seguran√ßa devem ser impostas - por exemplo, se uma fun√ß√£o de seguran√ßa deve ser tratada no n√≠vel de hardware f√≠sico, no n√≠vel do sistema operacional ou no n√≠vel do SGBD.
- ¬Ñ A necessidade, em algumas organiza√ß√µes, de identificar v√°rios n√≠veis de seguran√ßa e categorizar os dados e usu√°rios com base nessas classifica√ß√µes - por exemplo, altamente secreta, secreta, confidencial e n√£o classificada. A pol√≠tica de seguran√ßa da organiza√ß√£o com rela√ß√£o a permitir o acesso a v√°rias classifica√ß√µes dos dados deve ser imposta.

Amea√ßas aos bancos de dados. As  amea√ßas  aos bancos de dados podem resultar na perda ou degrada√ß√£o de alguns ou de todos os objetivos de seguran√ßa comumente aceitos: integridade, disponibilidade e confidencialidade.

- ¬Ñ Perda de integridade. A integridade do banco de dados refere-se ao requisito de que a informa√ß√£o seja protegida contra modifica√ß√£o impr√≥pria.  A  modifica√ß√£o  de  dados  inclui cria√ß√£o,  inser√ß√£o,  atualiza√ß√£o,  mudan√ßa  do status dos dados e exclus√£o. A integridade √© perdida se mudan√ßas n√£o autorizadas forem feitas nos dados por atos intencionais ou acidentais. Se a perda da integridade do sistema ou dos dados n√£o for corrigida, o uso continuado do sistema contaminado ou de dados adulterados poderia resultar em decis√µes imprecisas, fraudulentas ou err√¥neas.
- ¬Ñ Perda  de  disponibilidade. A  disponibilidade do banco de dados refere-se a tornar os objetos dispon√≠veis a um usu√°rio humano ou a um programa ao qual eles t√™m um direito leg√≠timo.
- ¬Ñ Perda  de  confidencialidade. A confidencialidade do banco de dados refere-se √† prote√ß√£o dos dados contra exposi√ß√£o n√£o autorizada. O impacto da exposi√ß√£o n√£o autorizada de informa√ß√µes confidenciais pode variar desde a  viola√ß√£o  do  Data  Privacy  Act  at√©  o  comprometimento da seguran√ßa nacional. A exposi√ß√£o  n√£o  autorizada,  n√£o  antecipada  ou n√£o intencional poderia resultar em perda de confian√ßa p√∫blica, constrangimento ou a√ß√£o legal contra a organiza√ß√£o.

Para proteger os bancos de dados contra esses tipos de amea√ßas, √© comum implementar quatro tipos de medidas de controle : controle de acesso, controle de infer√™ncia, controle de fluxo e criptografia. Discutiremos cada um desses itens neste cap√≠tulo.

Em um sistema de banco de dados multiusu√°rio, o SGBD precisa oferecer t√©cnicas para permitir que certos usu√°rios ou grupos de usu√°rios acessem partes selecionadas de um banco de dados sem que obtenham acesso ao restante dele. Isso √© particularmente importante quando um grande banco de dados integrado precisa ser usado por diversos usu√°rios diferentes dentro da mesma organiza√ß√£o. Por exemplo, informa√ß√µes confidenciais, como sal√°rios de funcion√°rio ou an√°lises de desempenho, devem ser mantidas confidenciais para a maioria dos usu√°rios do sistema de banco de dados. Um SGBD normalmente inclui um subsistema de seguran√ßa e autoriza√ß√£o do banco de dados que √© respons√°vel por garantir a seguran√ßa de partes de um banco de dados contra acesso n√£o autorizado. Agora, √© comum referir-se a dois tipos de mecanismos de seguran√ßa de banco de dados:

- ¬Ñ Mecanismos de seguran√ßa discricion√°rios. Estes  s√£o  usados  para  conceder  privil√©gios  aos usu√°rios,  incluindo  a  capacidade  de  acessar arquivos de dados, registros ou campos espec√≠ficos em um modo especificado (como leitura, inser√ß√£o, exclus√£o ou atualiza√ß√£o).
- ¬Ñ Mecanismos de seguran√ßa obrigat√≥rios. Estes s√£o usados para impor a seguran√ßa multin√≠vel pela classifica√ß√£o de dados e usu√°rios em v√°rias classes (ou n√≠veis) de seguran√ßa e, depois, pela  implementa√ß√£o  da  pol√≠tica  de  seguran√ßa apropriada da organiza√ß√£o. Por exemplo, uma pol√≠tica  de  seguran√ßa  t√≠pica  √©  permitir que os usu√°rios em certo n√≠vel de classifica√ß√£o (ou libera√ß√£o) vejam apenas os itens de dados classificados no pr√≥prio n√≠vel de classifica√ß√£o (ou inferior) do usu√°rio. Uma extens√£o disso √© a seguran√ßa baseada em pap√©is , que imp√µe pol√≠ticas  e  privil√©gios  com  base  no  conceito de pap√©is organizacionais.

Discutiremos  a  seguran√ßa  discricion√°ria  na  Se√ß√£o 24.2 e a seguran√ßa obrigat√≥ria e baseada em pap√©is na Se√ß√£o 24.3.

## 24.1.2 Medidas de controle

Quatro medidas de controle principais s√£o usadas para fornecer seguran√ßa nos bancos de dados:

- ¬Ñ Controle de acesso.
- ¬Ñ Controle de infer√™ncia.
- ¬Ñ Controle de fluxo.
- ¬Ñ Criptografia de dados.

Um problema de seguran√ßa comum aos sistemas de computa√ß√£o √© o de impedir que pessoas n√£o au-

torizadas acessem o pr√≥prio sistema, seja para obter informa√ß√µes ou para fazer mudan√ßas maliciosas em uma parte do banco de dados. O mecanismo de seguran√ßa de um SGBD precisa incluir provis√µes para restringir o acesso ao sistema de banco de dados como um todo. Essa fun√ß√£o, chamada controle de acesso , √© tratada criando-se contas do usu√°rio e senhas para controlar o processo de login pelo SGBD. Discutimos as t√©cnicas de controle de acesso na Se√ß√£o 24.1.3.

Bancos  de  dados  estat√≠sticos s√£o  usados  para fornecer informa√ß√µes estat√≠sticas ou resumos dos valores  com base em diversos crit√©rios. Por exemplo, um banco de dados para estat√≠sticas  de  popula√ß√£o pode  oferecer  estat√≠sticas  com  base  em  faixas  et√°rias,  n√≠veis  de  renda,  tamanho de resid√™ncia, n√≠veis de educa√ß√£o e outros crit√©rios. Os usu√°rios de banco de dados estat√≠sticos,  como  os  estat√≠sticos  do  governo ou empresas de pesquisa de mercado, t√™m permiss√£o para acessar o banco de dados e recuperar informa√ß√µes estat√≠sticas sobre uma popula√ß√£o, mas n√£o para acessar  informa√ß√µes  confidenciais  detalhadas  sobre indiv√≠duos espec√≠ficos.  A  seguran√ßa  para  os  bancos de dados estat√≠sticos deve garantir que informa√ß√µes sobre os indiv√≠duos n√£o possam ser acessadas. √Äs vezes, √© poss√≠vel deduzir certos fatos com rela√ß√£o aos indiv√≠duos baseando-se em consultas que envolvem apenas  estat√≠sticas  de  resumo  sobre  grupos;  consequentemente, isso tamb√©m n√£o deve ser permitido. Esse problema, chamado de seguran√ßa de banco de dados estat√≠stico ,  √©  discutido rapidamente na Se√ß√£o 24.4.  As  medidas  de  controle  correspondentes  s√£o chamadas de medidas de controle de infer√™ncia .

Outra quest√£o de seguran√ßa √© a do controle de fluxo ,  que impede que informa√ß√µes fluam de modo que  alcancem  usu√°rios  n√£o  autorizados.  Isso  ser√° discutido na Se√ß√£o 24.6. Os canais que s√£o percursos  para  as  informa√ß√µes  flu√≠rem  implicitamente  em caminhos que violam a pol√≠tica de seguran√ßa de uma organiza√ß√£o s√£o chamados de canais secretos . Discutiremos rapidamente algumas quest√µes relacionadas a canais secretos na Se√ß√£o 24.6.1.

difica√ß√£o (ou chaves) para decifrar os dados. T√©cnicas de criptografia que s√£o muito dif√≠ceis de decodificar sem uma chave foram desenvolvidas para aplica√ß√µes militares. A Se√ß√£o 24.7 aborda de maneira breve as t√©cnicas de criptografia, incluindo t√©cnicas populares como a criptografia de chave p√∫blica, que √© bastante usada para dar suporte a transa√ß√µes baseadas na Web em rela√ß√£o a bancos de dados, e assinaturas digitais, que s√£o utilizadas em comunica√ß√µes pessoais.

Uma discuss√£o abrangente da seguran√ßa nos sistemas  de  computa√ß√£o  e  bancos  de  dados  est√°  fora do escopo deste livro-texto. Oferecemos apenas uma r√°pida vis√£o geral das t√©cnicas de seguran√ßa de banco de dados aqui. O leitor interessado pode consultar v√°rias das refer√™ncias discutidas na bibliografia selecionada ao final deste cap√≠tulo.

## 24.1.3 Seguran√ßa de banco de dados e o DBA

Conforme discutimos no Cap√≠tulo 1, o administrador do banco de dados (DBA) √© a autoridade central para gerenciar um sistema de banco de dados. As responsabilidades do DBA incluem conceder privil√©gios aos usu√°rios que precisam usar o sistema e classificar os usu√°rios e dados de acordo com a pol√≠tica da organiza√ß√£o. O DBA tem uma conta de DBA no SGBD, tamb√©m conhecida como conta do sistema ou conta de superusu√°rio , que oferece capacidades poderosas que n√£o est√£o dispon√≠veis √†s contas e usu√°rios comuns do banco de dados. 2  Os comandos privilegiados do DBA incluem aqueles para conceder e revogar privil√©gios a contas, usu√°rios ou grupos de usu√°rios individuais e para realizar os seguintes tipos de a√ß√µes:

- 1. Cria√ß√£o de conta. Essa a√ß√£o cria uma conta e senha para um usu√°rio ou grupo de usu√°rios para permitir acesso ao SGBD.
- 2. Concess√£o  de  privil√©gio. Essa  a√ß√£o  permite que o DBA conceda certos privil√©gios a determinadas contas.

Uma medida de  controle  final  √©  a criptografia de dados ,  que √© utilizada para proteger dados confidenciais (como n√∫meros de cart√£o de cr√©dito) que s√£o transmitidos por meio de algum tipo de rede de comunica√ß√£o. A criptografia tamb√©m pode ser usada para  oferecer  prote√ß√£o  adicional  para  partes  confidenciais de um banco de dados. Os dados s√£o codificados usando algum algoritmo de codifica√ß√£o. Um usu√°rio n√£o autorizado que acessa dados codificados ter√° dificuldade para decifr√°-los, mas os usu√°rios autorizados recebem algoritmos de codifica√ß√£o ou deco-

- 3. Revoga√ß√£o  de  privil√©gio. Essa  a√ß√£o  permite que o DBA revogue (cancele) alguns privil√©gios que foram dados anteriormente a certas contas.
- 4. Atribui√ß√£o de n√≠vel de seguran√ßa. Essa a√ß√£o consiste em atribuir contas do usu√°rio ao n√≠vel de libera√ß√£o de seguran√ßa apropriado.

O DBA √© respons√°vel pela seguran√ßa geral do sistema de banco de dados. A a√ß√£o 1 na lista anterior √© usada para controlar o acesso ao SGBD como um todo, enquanto as a√ß√µes 2 e 3 s√£o utilizadas para con-

2 Essa conta √© semelhante √†s contas root ou superuser que s√£o dadas aos administradores de sistema de computa√ß√£o e permitem o acesso a comandos restritos do sistema operacional.

trolar a autoriza√ß√£o de banco de dados discricion√°ria , e a a√ß√£o 4, para controlar a autoriza√ß√£o obrigat√≥ria .

## 24.1.4 Controle de acesso, contas de usu√°rio e auditorias de banco de dados

Sempre que uma pessoa ou um grupo de pessoas precisa acessar um sistema de banco de dados, o indiv√≠duo  ou  grupo  precisa  primeiro  solicitar  uma conta de usu√°rio. O DBA, ent√£o, criar√° um novo n√∫mero de conta e senha para o usu√°rio, se houver uma necessidade leg√≠tima para acessar o banco de dados. O usu√°rio precisa efetuar o login no SGBD ao entrar com o n√∫mero de conta e senha sempre que o acesso ao banco de dados for necess√°rio. O SGBD verifica se os n√∫meros de conta e senha s√£o v√°lidos; se forem, o usu√°rio tem permiss√£o para usar o SGBD e acessar  o  banco  de  dados.  Os  programas  de  aplica√ß√£o tamb√©m podem ser considerados usu√°rios e precisam efetuar o login no banco de dados (ver Cap√≠tulo 13).

√â simples registrar os usu√°rios do banco de dados e suas contas e senhas criando uma tabela criptografada ou um arquivo com dois campos: Nume-ro\_conta  e  Senha.  Essa  tabela  pode  ser  facilmente mantida pelo SGBD. Sempre que uma conta √© criada, um novo registro √© inserido na tabela. Quando uma conta √© cancelada, o registro correspondente deve ser exclu√≠do da tabela.

O sistema  de  banco  de  dados  tamb√©m  precisa registrar todas as opera√ß√µes no banco de dados que s√£o aplicadas por certo usu√°rio em cada sess√£o de login , que consiste na sequ√™ncia de intera√ß√µes do banco de dados que o usu√°rio realiza desde o momento do login at√© o momento do logoff. Quando um usu√°rio efetua o login, o SGBD pode registrar o n√∫mero de conta do usu√°rio e associ√°-lo ao computador ou dispositivo do qual o usu√°rio realizou a conex√£o. Todas as opera√ß√µes aplicadas desse computador ou dispositivo s√£o atribu√≠das √† conta do usu√°rio at√© que ele efetue o logoff. √â particularmente importante registrar as opera√ß√µes de atualiza√ß√£o que s√£o aplicadas ao banco de dados de modo que, se o banco de dados for adulterado, o DBA possa determinar qual usu√°rio mexeu nele.

Para  manter  um  registro  de  todas  as  atualiza√ß√µes realizadas no banco de dados e de usu√°rios em particular que aplicaram cada atualiza√ß√£o, podemos modificar o log  do  sistema .  Lembre-se,  dos  cap√≠tulos 21 e 23, que o log do sistema inclui uma entrada para cada opera√ß√£o aplicada ao banco de dados que pode  ser  exigida  para  a  recupera√ß√£o  de  uma  falha de transa√ß√£o ou falha do sistema. Podemos expandir as entradas de log de modo que tamb√©m incluam o n√∫mero de conta do usu√°rio e o computador on-line ou ID de dispositivo que aplicou cada opera√ß√£o registrada no log. Se houver suspeita de qualquer adultera√ß√£o no banco de dados, √© realizada uma auditoria do banco de dados , que consiste em rever o log para examinar todos os acessos e opera√ß√µes aplicadas ao banco de dados durante certo per√≠odo. Quando uma opera√ß√£o ilegal  ou  n√£o  autorizada  √©  encontrada,  o DBA pode determinar o n√∫mero de conta usado para realizar a opera√ß√£o. As auditorias s√£o particularmente  importantes para bancos de dados confidenciais, que s√£o atualizados por muitas transa√ß√µes e usu√°rios, como no caso de bancos que os atualizam por meio de seus diversos caixas. Um log de banco de dados, utilizado  principalmente  para  fins  de  seguran√ßa,  √†s vezes √© chamado de trilha de auditoria .

## 24.1.5 Dados sens√≠veis e tipos de exposi√ß√£o

A sensibilidade de dados √©  uma medida da import√¢ncia atribu√≠da aos dados por seu propriet√°rio, com a finalidade de indicar sua necessidade de prote√ß√£o. Alguns bancos de dados cont√™m apenas dados confidenciais,  enquanto  outros  podem  n√£o  conter qualquer dado confidencial. O tratamento de bancos de dados que caem nesses dois extremos √© relativamente f√°cil, pois podem ser tratados pelo controle de acesso, que √© explicado na pr√≥xima se√ß√£o. A situa√ß√£o torna-se mais complicada quando alguns dos dados s√£o confidenciais, enquanto outros n√£o o s√£o.

Diversos fatores podem fazer que os dados sejam classificados como confidenciais:

- 1. Inerentemente confidenciais. O valor dos pr√≥prios dados pode ser t√£o revelador ou confidencial que ele se torna sens√≠vel - por exemplo, o sal√°rio de uma pessoa ou o fato de um paciente ter HIV/AIDS.
- 2. De uma fonte confidencial. A fonte dos dados pode indicar uma necessidade - por exemplo,  um  informante  cuja  identidade  precisa ser mantida em segredo.
- 3. Confidenciais declarados. O propriet√°rio dos dados  pode  t√™-los  declarado  explicitamente como confidenciais.
- 4. Um atributo ou registro confidencial. O atributo ou registro em particular pode ter sido declarado  confidencial  -  por  exemplo,  o atributo de sal√°rio de um funcion√°rio ou o registro do hist√≥rico de sal√°rios em um banco de dados pessoal.
- 5. Confidencial em rela√ß√£o a dados previamente expostos. Alguns dados podem n√£o ser confi-

denciais por si s√≥s, mas assim se tornar√£o na presen√ßa de algum outro dado - por exemplo, a informa√ß√£o exata de latitude e longitude para um local onde aconteceu algum evento previamente registrado, que mais tarde foi considerado confidencial.

√â responsabilidade do administrador de banco de dados e do administrador de seguran√ßa impor coletivamente as pol√≠ticas de seguran√ßa de uma organiza√ß√£o. Isso indica se o acesso deve ser permitido a certo atributo do banco de dados (tamb√©m conhecido como coluna da tabela ou um elemento de dados )  ou n√£o para usu√°rios individuais ou para categorias de usu√°rios. V√°rios fatores precisam ser considerados antes de se decidir se √© seguro revelar os dados. Os tr√™s fatores mais importantes s√£o disponibilidade de dados, aceitabilidade de acesso e garantia de autenticidade.

- 1. Disponibilidade  de  dados. Se  um  usu√°rio estiver  atualizando  um  campo,  ent√£o  esse campo torna-se inacess√≠vel e outros usu√°rios n√£o devem visualizar esses dados. Esse bloqueio  √©  tempor√°rio  e  apenas  para  garantir que  nenhum  usu√°rio  veja  quaisquer  dados imprecisos. Isso normalmente √© tratado pelo mecanismo de controle de concorr√™ncia (ver Cap√≠tulo 22).
- 2. Aceitabilidade de acesso. Os dados s√≥ devem ser revelados a usu√°rios autorizados. Um administrador de banco de dados tamb√©m pode negar  acesso  a  uma  solicita√ß√£o  do  usu√°rio mesmo que esta n√£o acesse diretamente um item de dados confidencial, com base no fato de os dados solicitados poderem revelar informa√ß√µes sobre os dados confidenciais que o usu√°rio n√£o est√° autorizado a ter.
- 3. Garantia de autenticidade. Antes de conceder acesso, certas caracter√≠sticas externas sobre o usu√°rio tamb√©m podem ser consideradas. Por exemplo, um usu√°rio s√≥ pode ter acesso permitido durante as horas de trabalho. O sistema pode rastrear consultas anteriores para garantir  que  uma  combina√ß√£o  de  consultas n√£o  revele  dados  confidenciais.  Esse  √∫ltimo √© particularmente relevante para consultas a banco de dados estat√≠stico (ver Se√ß√£o 24.5).
- O termo precis√£o ,  quando usado na √°rea de seguran√ßa, refere-se a permitir ao m√°ximo poss√≠vel que os dados estejam dispon√≠veis, sujeito a proteger exatamente o subconjunto de dados confidenciais. As defini√ß√µes de seguran√ßa versus precis√£o s√£o as seguintes:
- ¬Ñ Seguran√ßa: meio de garantir que os dados sejam  mantidos  seguros  contra  adultera√ß√£o  e
- que o acesso a eles seja controlado de modo adequado.  Prover  seguran√ßa  significa  expor apenas  dados  n√£o  confidenciais  e  rejeitar qualquer consulta que referencie um campo confidencial.
- ¬Ñ Precis√£o :  proteger  todos  os  dados  confidenciais  enquanto exp√µe o m√°ximo poss√≠vel de dados n√£o confidenciais.

A combina√ß√£o ideal √© manter a seguran√ßa perfeita com o m√°ximo de precis√£o. Se quisermos manter a seguran√ßa, algum sacrif√≠cio precisa ser feito com a precis√£o. Logo, em geral existe um dilema entre esses dois conceitos.

## 24.1.6 Relacionamento entre seguran√ßa da informa√ß√£o e privacidade da informa√ß√£o

O avan√ßo r√°pido do uso da tecnologia da informa√ß√£o  (TI)  na  ind√∫stria,  governo  e  academia  gera quest√µes  e  problemas  desafiadores  com  rela√ß√£o  √† prote√ß√£o e ao uso de informa√ß√µes pessoais. Quest√µes como quem e quais direitos  √†  informa√ß√£o  sobre indiv√≠duos para quais finalidades tornam-se mais importantes √† medida que seguimos para um mundo em que √© tecnicamente poss√≠vel conhecer quase tudo sobre qualquer um.

Decidir como projetar considera√ß√µes de privacidade  na  tecnologia  para  o  futuro  inclui  dimens√µes filos√≥ficas, legais e pr√°ticas. Existe uma sobreposi√ß√£o consider√°vel entre quest√µes relacionadas ao acesso a recursos (seguran√ßa) e quest√µes relacionadas ao uso apropriado da informa√ß√£o (privacidade). Agora, definimos a diferen√ßa entre seguran√ßa e privacidade .

Seguran√ßa na tecnologia da informa√ß√£o diz respeito a muitos aspectos da prote√ß√£o de um sistema contra  uso  n√£o  autorizado,  incluindo  autentica√ß√£o de usu√°rios, criptografia de  informa√ß√£o,  controle  de acesso, pol√≠ticas de firewall e detec√ß√£o de intrus√£o. Para nossos prop√≥sitos aqui, limitaremos  nosso tratamento  da  seguran√ßa  aos  conceitos  associados a como um sistema pode proteger o acesso as suas informa√ß√µes. O conceito de privacidade vai al√©m da seguran√ßa. Privacidade examina como o uso da informa√ß√£o pessoal que um sistema adquire sobre um usu√°rio est√° de acordo com suposi√ß√µes expl√≠citas ou impl√≠citas relativas a esse uso. Do ponto de vista de um usu√°rio final, a privacidade pode ser considerada de duas perspectivas diferentes: impedindo o armazenamento de informa√ß√µes pessoais ou garantindo o uso apropriado de informa√ß√µes pessoais.

Para os prop√≥sitos deste cap√≠tulo, uma defini√ß√£o simples, por√©m √∫til, de privacidade √© a capacidade de

os indiv√≠duos controlarem os termos sob os quais sua informa√ß√£o pessoal √© adquirida e usada. Resumindo, a seguran√ßa envolve a tecnologia para garantir que a informa√ß√£o est√° devidamente protegida. A seguran√ßa √© um bloco de montagem necess√°rio para que exista a privacidade. A privacidade envolve mecanismos para dar  suporte  √†  conformidade  com  alguns  princ√≠pios b√°sicos  e  outras  pol√≠ticas  indicadas  explicitamente. Um princ√≠pio b√°sico √© que as pessoas devem ser informadas  sobre  a  coleta  de  informa√ß√µes,  avisadas com anteced√™ncia sobre o que ser√° feito com suas informa√ß√µes e devem receber uma oportunidade razo√°  vel de aprovar tal uso da informa√ß√£o. Um conceito relacionado, confian√ßa , relaciona-se √† seguran√ßa e √† privacidade, e √© visto como crescente quando percebido que tanto a seguran√ßa quanto a privacidade s√£o oferecidas.

## 24.2 Controle de acesso discricion√°rio baseado na concess√£o e revoga√ß√£o de privil√©gios

O m√©todo t√≠pico para impor o controle de acesso discricion√°rio em um sistema de banco de dados √© baseado na concess√£o e revoga√ß√£o de privil√©gios .  Vamos considerar os privil√©gios no contexto de um SGBD relacional. Em particular, vamos discutir um sistema de privil√©gios um tanto semelhante ao que foi desenvolvido originalmente para a linguagem SQL (ver cap√≠tulos 4 e 5). Muitos SGBDs relacionais atuais utilizam alguma varia√ß√£o dessa t√©cnica. A ideia principal √© incluir declara√ß√µes na linguagem de consulta que permitam que o DBA e usu√°rios selecionados concedam e revoguem privil√©gios.

## 24.2.1 Tipos de privil√©gios discricion√°rios

Na SQL2 e em vers√µes posteriores, 3  o conceito de identificador  de  autoriza√ß√£o √©  usado  para  se  referir, digamos assim, a uma conta de usu√°rio (ou grupo de contas de usu√°rio). Para simplificar, usaremos as palavras usu√°rio ou conta para indicar a mesma coisa, no lugar de identificador de autoriza√ß√£o . O SGBD precisa fornecer acesso seletivo a cada rela√ß√£o no banco de dados com base em contas espec√≠ficas. As opera√ß√µes tamb√©m podem ser controladas; assim, ter uma conta n√£o necessariamente capacita seu mantenedor a toda a  funcionalidade  oferecida  pelo  SGBD.  De  maneira informal, existem dois n√≠veis para atribui√ß√£o de privil√©gios na utiliza√ß√£o do sistema de banco de dados:

- ¬Ñ O n√≠vel de conta. Nesse n√≠vel, o DBA especifica os privil√©gios em particular que cada conta mant√©m independentemente das rela√ß√µes no banco de dados.
- ¬Ñ O n√≠vel de rela√ß√£o (ou tabela). Nesse n√≠vel, o DBA pode controlar o privil√©gio para acessar cada rela√ß√£o ou vis√£o individual no banco de dados.

Os privil√©gios no n√≠vel de conta se  aplicam  √†s  capacidades fornecidas √† pr√≥pria conta e podem incluir o privil√©gio CREATE SCHEMA ou CREATE TABLE ,  para  criar  um esquema ou rela√ß√£o da base; o privil√©gio CREATE VIEW ; o privil√©gio ALTER , para aplicar mudan√ßas de esquema como a inclus√£o ou remo√ß√£o de atributos das rela√ß√µes; o privil√©gio DROP , para excluir rela√ß√µes ou vis√µes; o privil√©gio MODIFY , para inserir, excluir ou atualizar tuplas; e o privil√©gio SELECT , para recuperar informa√ß√µes do banco de dados usando uma consulta SELECT . Observe que esses privil√©gios de conta se aplicam √† conta em geral. Se determinada conta n√£o tiver o privil√©gio CREATE TABLE , nenhuma rela√ß√£o pode ser criada com base nessa conta. Os privil√©gios em n√≠vel de conta n√£o s√£o definidos como parte da SQL2; eles s√£o deixados para os implementadores do SGBD definirem. Nas vers√µes mais antigas da SQL, havia um privil√©gio CREATETAB para dar a uma conta o privil√©gio de criar tabelas (rela√ß√µes).

O segundo n√≠vel de privil√©gios se aplica ao n√≠vel de rela√ß√£o ,  sejam  elas  rela√ß√µes  da  base  ou  rela√ß√µes virtuais (vis√µes). Esses privil√©gios s√£o definidos para a SQL2. Na discuss√£o a seguir, o termo rela√ß√£o pode se referir a uma rela√ß√£o da base ou a uma vis√£o, a menos que especifiquemos de maneira expl√≠cita uma ou outra. Os privil√©gios no n√≠vel de rela√ß√£o especificam para cada usu√°rio as rela√ß√µes individuais sobre as  quais  cada  tipo  de  comando  pode  ser  aplicado. Alguns privil√©gios tamb√©m se referem a colunas (atributos)  individuais  das  rela√ß√µes.  Comandos  SQL2 oferecem  privil√©gios apenas  no  n√≠vel  de  rela√ß√£o  e atributo . Embora isso seja muito geral, torna dif√≠cil criar contas com privil√©gios limitados. A concess√£o e a revoga√ß√£o de privil√©gios costuma seguir um modelo de autoriza√ß√£o para privil√©gios discricion√°rios conhecido como modelo de matriz de acesso , no qual as linhas de uma matriz M representam sujeitos (usu√°rios, contas, programas) e as colunas representam objetos (rela√ß√µes, registros, colunas, vis√µes, opera√ß√µes). Cada posi√ß√£o M i ( ,  ) na matriz representa os tipos de privij l√©gios (leitura, grava√ß√£o, atualiza√ß√£o) que o sujeito i mant√©m sobre o objeto  . j

Para  controlar  a  concess√£o  e  revoga√ß√£o  de privil√©gios de rela√ß√£o, cada rela√ß√£o R em um banco  de  dados  recebe  uma conta  de  propriet√°rio ,

3 Privil√©gios discricion√°rios foram incorporados √† SQL2 e se aplicam a vers√µes posteriores da SQL.

que normalmente √© a conta utilizada quando a rela√ß√£o foi criada em primeiro lugar. O propriet√°rio de uma rela√ß√£o recebe todos os privil√©gios sobre essa rela√ß√£o. Em SQL2, o DBA pode atribuir um propriet√°rio a um esquema inteiro ao criar o esquema e associar o identificador de autoriza√ß√£o apropriado com esse esquema, usando o comando CREATE SCHEMA (ver Se√ß√£o 4.1.1). O mantenedor  da  conta  de  propriet√°rio  pode  passar  privil√©gios para qualquer uma das rela√ß√µes possu√≠das aos  outros  usu√°rios, concedendo privil√©gios  √†s suas  contas.  Em  SQL,  os  seguintes  tipos  de  privil√©gios  podem  ser  concedidos  em  cada  rela√ß√£o individual R :

- ¬Ñ Privil√©gio SELECT (recupera√ß√£o  ou  leitura) em R. D√° o privil√©gio de recupera√ß√£o √† conta. Em SQL, isso d√° √† conta o privil√©gio de usar a instru√ß√£o SELECT para recuperar tuplas de R .
- ¬Ñ Privil√©gios  de  modifica√ß√£o  em R. Isso  d√°  √† conta a capacidade de modificar as tuplas de R . Em SQL, isso inclui tr√™s privil√©gios: UPDATE, DELETE e INSERT. Estes correspondem aos tr√™s comandos SQL (ver Se√ß√£o 4.4) para  modificar  uma  tabela R .  Al√©m  disso, tanto o privil√©gio INSERT quanto o UPDATE podem especificar que apenas certos atributos de R podem ser modificados pela conta.
- ¬Ñ Privil√©gio de refer√™ncias em R . Isso d√° √† conta  a  capacidade de referenciar (ou  referir-se a) uma rela√ß√£o R ao especificar restri√ß√µes de integridade. Esse privil√©gio tamb√©m pode ser restrito a atributos espec√≠ficos de R .

Observe que, para criar uma vis√£o, a conta precisa ter o privil√©gio SELECT em todas as rela√ß√µes envolvidas na defini√ß√£o da vis√£o a fim de especificar a consulta que corresponde √† vis√£o.

## 24.2.2 Especificando privil√©gios por meio do uso de vis√µes

O mecanismo de vis√µes (views) √© um importante mecanismo de autoriza√ß√£o discricion√°rio por  si s√≥. Por exemplo, se o propriet√°rio A de uma rela√ß√£o R quiser que outra conta B seja capaz de recuperar apenas alguns campos de R , ent√£o A pode criar uma vis√£o V de R que inclua apenas os atributos e depois conceda SELECT em V para B . O mesmo se aplica √† limita√ß√£o de B para recuperar apenas certas tuplas de R ; uma vis√£o V ' pode ser criada ao definir a vis√£o por meio de uma consulta que seleciona apenas as tuplas de R que A deseja permitir que B acesse. Ilustraremos essa discuss√£o com o exemplo dado na Se√ß√£o 24.2.5.

## 24.2.3 Revoga√ß√£o de privil√©gios

Em alguns casos, √© desej√°vel conceder um privil√©gio a um usu√°rio temporariamente. Por exemplo, o propriet√°rio de uma rela√ß√£o pode querer conceder o privil√©gio SELECT a um usu√°rio para uma tarefa espec√≠fica e, depois, revogar esse privil√©gio quando a tarefa for conclu√≠da. Logo, √© preciso que haja um mecanismo para revogar privil√©gios. Em SQL, um comando REVOKE est√° inclu√≠do com a finalidade de cancelar privil√©gios. Veremos como esse comando √© usado no exemplo da Se√ß√£o 24.2.5.

## 24.2.4 Propaga√ß√£o de privil√©gios usando a GRANT OPTION

Sempre que o propriet√°rio A de uma rela√ß√£o R concede um privil√©gio em R para outra conta B ,  o privil√©gio pode ser dado a B com ou sem a GRANT OPTION . Se a GRANT OPTION for dada, isso significa que B tamb√©m pode conceder esse privil√©gio em R para outras contas. Suponha que B receba a GRANT OPTION de A e que B ent√£o conceda o privil√©gio em R a  uma  terceira  conta C ,  tamb√©m  com  a GRANT OPTION. Desse modo, os privil√©gios em R podem se propagar para outras contas sem o conhecimento do propriet√°rio de R . Se a conta de propriet√°rio A agora revogar o privil√©gio concedido a B , todos os privil√©gios que B propagou com base nesse privil√©gio dever√£o ser revogados automaticamente pelo sistema.

√â poss√≠vel que um usu√°rio receba certo privil√©gio de duas ou mais fontes. Por exemplo, A4 pode receber um privil√©gio UPDATE R tanto de A2 quanto de A3. Nesse caso, se A2 revogar esse privil√©gio de A4, A4 ainda continuar√° a ter o privil√©gio em virtude de ter sido concedido por A3. Se A3 depois revogar o privil√©gio de A4, A4 perde totalmente o privil√©gio. Logo, o SGBD que permite a propaga√ß√£o de privil√©gios deve registrar como todos eles foram concedidos, de modo que a sua revoga√ß√£o possa ser feita de maneira correta e completa.

## 24.2.5 Exemplo para ilustrar a concess√£o e revoga√ß√£o de privil√©gios

Suponha que o DBA crie quatro contas A1, A2, A3 e A4 - e queira que apenas A1 possa criar rela√ß√µes da base. Para fazer isso, o DBA precisa emitir o seguinte comando GRANT em SQL:

## GRANT CREATETAB TO A1;

O privil√©gio CREATETAB (criar tabela) d√° √† conta A1 a capacidade de criar novas tabelas de banco de dados (rela√ß√µes da base) e, portanto, √© um privil√©gio de conta . Esse privil√©gio fazia parte das vers√µes ante-

riores da SQL, mas agora fica para cada implementa√ß√£o de sistema individual definir.

Em  SQL2,  o  mesmo  efeito  pode  ser  realizado com o DBA emitindo um comando CREATE SCHEMA , da seguinte forma:

## CREATE SCHEMA EXEMPLO AUTHORIZATION A1;

A conta de usu√°rio A1 agora pode criar tabelas sob o esquema chamado EXEMPLO. Para continuar nosso exemplo, suponha que A1 crie as duas rela√ß√µes da  base FUNCIONARIO e DEPARTAMENTO ,  mostradas na Figura 24.1; A1 √© ent√£o o propriet√°rio dessas duas rela√ß√µes e, portanto, tem todos os privil√©gios de rela√ß√£o em cada uma delas.

Em seguida, suponha que a conta A1 queira conceder √† conta A2 o privil√©gio  para  inserir  e  excluir tuplas nessas duas rela√ß√µes. Contudo, A1 n√£o quer que A2 possa propagar esses privil√©gios para outras contas. A1 pode emitir o seguinte comando:

GRANT INSERT, DELETE ON FUNCIONARIO, DEPARTAMENTO TO A2;

Observe que a conta propriet√°rio A1 de uma rela√ß√£o automaticamente tem a GRANT OPTION, permitindo que ela conceda privil√©gios na rela√ß√£o para outras contas. Por√©m, a conta A2 n√£o pode conceder privil√©gios INSERT e DELETE nas  tabelas FUNCIONARIO e DEPARTAMENTO ,  pois A2 n√£o  recebeu  a GRANT OPTION no comando anterior.

A seguir, suponha que A1 queira permitir que a conta A3 recupere informa√ß√µes de qualquer uma das duas tabelas, e que tamb√©m possa propagar o privil√©gio SELECT para outras contas. A1 pode emitir o seguinte comando:

GRANT SELECT ON FUNCIONARIO, DEPARTAMENTO TO A3 WITH GRANT OPTION ;

A cl√°usula WITH GRANT OPTION significa que A3 agora pode propagar o privil√©gio para outras contas usando GRANT. Por  exemplo, A3 pode  conceder  o privil√©gio SELECT na rela√ß√£o FUNCIONARIO para A4 ao emitir o seguinte comando:

## GRANT SELECT ON FUNCIONARIO TO A4;

Observe que A4 n√£o pode propagar o privil√©gio SELECT para outras contas, pois a GRANT OPTION n√£o foi dada a A4 .

Agora, suponha que A1 decida revogar o privil√©gio SELECT na rela√ß√£o FUNCIONARIO de A3; A1 pode ent√£o emitir este comando:

## REVOKE SELECT ON FUNCIONARIO FROM A3;

O SGBD agora precisa revogar o privil√©gio SELECT em FUNCIONARIO de A3, e  tamb√©m  deve revogar  automaticamente o privil√©gio SELECT em FUNCIONARIO de A4. Isso porque A3 concedeu esse privil√©gio a A4, mas A3 n√£o tem mais o privil√©gio.

Em seguida, suponha que A1 queira dar de volta a A3 uma capacidade limitada para SELECT da rela√ß√£o FUNCIONARIO e  queira  permitir  que A3 possa  propagar o privil√©gio. A limita√ß√£o √© recuperar apenas os atributos Nome, Data\_nasc e Endereco e somente para as tuplas com Dnr = 5. A1 , ent√£o, cria a seguinte vis√£o:

## CREATE VIEW A3FUNCIONARIO AS

SELECT Nome, Data\_nasc, Endereco

FROM FUNCIONARIO

WHERE Dnr = 5;

Depois que a vis√£o estiver criada, A1 pode conceder SELECT na vis√£o A3FUNCIONARIO para A3 da seguinte forma:

GRANT SELECT ON A3FUNCIONARIO TO A3 WITH GRANT OPTION ;

Finalmente, suponha que A1 queira permitir que A4 atualize apenas o atributo Salario de FUNCIONARIO; A1 pode ent√£o emitir o seguinte comando:

GRANT UPDATE ON FUNCIONARIO (Salario) TO A4;

Os privil√©gios UPDATE e INSERT especificam atributos em particular que podem ser atualizados ou inseridos em uma rela√ß√£o. Outros privil√©gios ( SELECT, DELETE ) n√£o s√£o espec√≠ficos do atributo, pois essa especificidade

## FUNCIONARIO



| Nome         | Cpf          | Data_nasc    | Endereco   | Sexo   | Salario   | Dnr   |
|--------------|--------------|--------------|------------|--------|-----------|-------|
| DEPARTAMENTO | DEPARTAMENTO | DEPARTAMENTO |            |        |           |       |
| Dnumero      | Dnome        | Cpf_ger      |            |        |           |       |

pode facilmente ser controlada ao criar as vis√µes apropriadas que incluam apenas os atributos desejados e ao conceder os privil√©gios correspondentes nas vis√µes. No entanto, como a atualiza√ß√£o de vis√µes nem sempre √© poss√≠vel (ver Cap√≠tulo 5), os privil√©gios UPDATE e INSERT recebem a op√ß√£o de especificar os atributos em particular de uma rela√ß√£o da base que podem ser atualizados.

## 24.2.6 Especificando limites na propaga√ß√£o de privil√©gios

T√©cnicas  para  limitar  a  propaga√ß√£o  de  privil√©gios  foram  desenvolvidas,  embora  elas  ainda  n√£o tenham sido implementadas na maioria dos SGBDs e n√£o fa√ßam parte da SQL. Limitar a propaga√ß√£o horizontal para um n√∫mero inteiro   significa que uma i conta B que recebe a GRANT OPTION pode conceder o privil√©gio a, no m√°ximo,   outras contas. i

A propaga√ß√£o vertical √© mais complicada; ela limita a profundidade da concess√£o de privil√©gios. A concess√£o de um privil√©gio com uma propaga√ß√£o vertical de zero √© equivalente a conceder o privil√©gio sem GRANT OPTION. Se a conta A concede um privil√©gio √† conta B com a propaga√ß√£o vertical definida para um n√∫mero inteiro   &gt; 0, isso significa que a conta j B tem a GRANT OPTION sobre esse privil√©gio, mas B pode conceder o privil√©gio a outras contas somente com uma propaga√ß√£o vertical menor que j . Com efeito, a propaga√ß√£o vertical limita a sequ√™ncia de GRANT OPTIONS que podem ser dadas de uma conta para a seguinte, com base em uma √∫nica concess√£o original do privil√©gio.

Ilustramos  rapidamente  os  limites  de  propaga√ß√£o horizontal e vertical - que n√£o est√£o dispon√≠veis atualmente em SQL ou em outros sistemas relacionais - com um exemplo. Suponha que A1 conceda SELECT a A2 na rela√ß√£o FUNCIONARIO com propaga√ß√£o horizontal igual a 1 e propaga√ß√£o vertical igual a 2. A2 pode ent√£o conceder SELECT a, no m√°ximo, uma conta, pois a limita√ß√£o de propaga√ß√£o horizontal √© definida como 1. Al√©m disso, A2 n√£o pode conceder o privil√©gio para outra conta, exceto com a propaga√ß√£o vertical definida como 0 (sem GRANT OPTION ) ou 1; isso porque A2 precisa  reduzir  a  propaga√ß√£o vertical em pelo menos 1 ao passar o privil√©gio para outros. Ademais, a propaga√ß√£o horizontal precisa ser menor ou igual √†quela concedida originalmente. Por exemplo, se a conta A concede um privil√©gio √† conta B com  a  propaga√ß√£o  horizontal  definida  como  um n√∫mero inteiro   &gt; 0, isso significa que j B pode conceder o privil√©gio para outras contas apenas com uma propaga√ß√£o horizontal menor ou igual a j . Como este exemplo mostra, as t√©cnicas de propaga√ß√£o horizontal e vertical s√£o projetadas para limitar a profundidade e a largura de propaga√ß√£o de privil√©gios.

## 24.3 Controle de acesso obrigat√≥rio e controle de acesso baseado em papel para seguran√ßa multin√≠vel

A t√©cnica de controle de acesso discricion√°rio de conceder e revogar privil√©gios em rela√ß√µes tradicionalmente tem sido o principal  mecanismo  de  seguran√ßa para os sistemas de banco de dados relacional. Esse √© um m√©todo tudo ou nada: um usu√°rio tem ou n√£o tem certo privil√©gio. Em muitas aplica√ß√µes, uma pol√≠tica de seguran√ßa adicional √© necess√°ria para classificar dados e usu√°rios com base nas classes de seguran√ßa. Essa t√©cnica,  conhecida  como controle  de  acesso  obrigat√≥rio ( MAC -  Mandatory  Access  Control),  normalmente seria combinada com  os  mecanismos  de  controle  de acesso  discricion√°rios  descritos  na  Se√ß√£o  24.2.  √â  importante observar que a maioria dos SGBDs comerciais hoje oferece mecanismos somente para o controle de acesso discricion√°rio. Por√©m, a necessidade de seguran√ßa multin√≠vel existe em aplica√ß√µes do governo, militares e de intelig√™ncia, bem como em muitas aplica√ß√µes industriais  e  corporativas. Alguns vendedores de SGBD por exemplo, Oracle - lan√ßaram vers√µes especiais de seus  SGBDRs  que  incorporam  o  controle  de  acesso obrigat√≥rio para uso do governo.

Classes de seguran√ßa t√≠picas s√£o altamente confidencial (top secret, TS), secreta (secret, S), confidencial (confidential,  C)  e  n√£o  classificada  (unclassified,  U), sendo que TS √© o n√≠vel mais alto e U, o mais baixo. Existem outros esquemas de classifica√ß√£o de seguran√ßa mais complexos, em que as classes de seguran√ßa s√£o organizadas em um reticulado. Para simplificar, usaremos o sistema com quatro n√≠veis de classifica√ß√£o de seguran√ßa, onde TS ‚â• S ‚â• C ‚â• U, para ilustrar nossa discuss√£o. O modelo normalmente utilizado para seguran√ßa multin√≠vel, conhecido como modelo de Bell-LaPadula , classifica cada sujeito (usu√°rio, conta, programa) e objeto (rela√ß√£o, tupla, coluna, vis√£o, opera√ß√£o) em uma das classifica√ß√µes de seguran√ßa TS, S, C ou U. Vamos nos referir √† autoriza√ß√£o (classifica√ß√£o) de um sujeito S como classe( S ) e √† classifica√ß√£o de um objeto O como classe( O ) . Duas restri√ß√µes s√£o impostas no acesso aos dados com base nas classifica√ß√µes de sujeito/objeto:

- 1. Um sujeito S n√£o tem permiss√£o para acesso  de  leitura  a  um  objeto O a  menos  que classe( S ) ‚â• classe( O ). Isso √© conhecido como propriedade de seguran√ßa simples .
- 2. Um sujeito S n√£o  tem  permiss√£o  para  gravar  um  objeto O a  menos  que  classe( S ) ‚â§ classe( O ). Isso √© conhecido como propriedade estrela (ou propriedade  ). *

A  primeira  restri√ß√£o  √©  intuitiva  e  imp√µe  a  regra √≥bvia de que nenhum sujeito pode ler um objeto cuja

classifica√ß√£o de seguran√ßa √© maior do que a autoriza√ß√£o de seguran√ßa do sujeito. A segunda restri√ß√£o √© menos intuitiva. Ela pro√≠be um sujeito de gravar um objeto em uma classifica√ß√£o de seguran√ßa inferior do que a autoriza√ß√£o de seguran√ßa do sujeito. A viola√ß√£o dessa regra permitiria que a informa√ß√£o flu√≠sse de classifica√ß√µes mais altas para mais baixas, o que viola um princ√≠pio b√°sico da seguran√ßa multin√≠vel. Por exemplo, um usu√°rio (sujeito) com autoriza√ß√£o TS pode fazer uma c√≥pia de um objeto com classifica√ß√£o TS e, depois, grav√°-lo de volta como um novo objeto com classifica√ß√£o U, tornando-o assim vis√≠vel por todo o sistema.

Para incorporar no√ß√µes de seguran√ßa multin√≠vel ao  modelo  de  banco  de  dados  relacional,  √©  comum considerar valores de atributo e tuplas como objetos de dados. Logo, cada atributo A est√° associado a um atributo de classifica√ß√£o C no esquema, e cada valor de atributo em uma tupla √© associado a uma classifica√ß√£o de seguran√ßa correspondente. Al√©m disso, em alguns modelos, um atributo de classifica√ß√£o de tupla TC √© acrescentado aos atributos de rela√ß√£o para fornecer uma classifica√ß√£o para cada tupla como um todo. O modelo que descrevemos aqui √© conhecido como o modelo  multin√≠vel ,  pois  permite  classifica√ß√µes  em m√∫ltiplos n√≠veis de seguran√ßa. Um esquema de rela√ß√£o multin√≠vel R com n atributos seria representado como:

<!-- formula-not-decoded -->

onde cada C i representa  o atributo de classifica√ß√£o associado ao atributo A i .

O valor do atributo de classifica√ß√£o de tupla TC em cada tupla   - que √© o t mais alto de todos os valores de classifica√ß√£o de atributo dentro de   - oferece t uma classifica√ß√£o geral  para  a  pr√≥pria  tupla.  Cada classifica√ß√£o de atributo C i oferece uma classifica√ß√£o de seguran√ßa mais detalhada para cada valor de atributo dentro da tupla. O valor de TC em cada tupla t √© o mais alto de todos os valores de classifica√ß√£o de atributo C i dentro de  . t

Isso  leva  ao  conceito  de poli-instancia√ß√£o , 4 em que v√°rias tuplas podem ter o mesmo valor de chave aparente, mas com diferentes valores de atributo para usu√°rios em diversos n√≠veis de autoriza√ß√£o.

Ilustramos esses conceitos com o exemplo simples de uma rela√ß√£o multin√≠vel mostrada na Figura 24.2(a), onde apresentamos os valores de atributo de classifica√ß√£o ao lado do valor de cada atributo. Suponha que o atributo Nome seja a chave aparente e considere a consulta SELECT   FROM * FUNCIONARIO. Um usu√°rio com autoriza√ß√£o de seguran√ßa S veria a mesma rela√ß√£o mostrada na Figura 24.2(a), pois todas as classifica√ß√µes de tupla s√£o menores ou iguais a  . Contudo, um usu√°rio com auS toriza√ß√£o de seguran√ßa C n√£o poderia ver os valores para Salario de 'Borges' e Desempenho\_cargo de 'Silva', pois eles t√™m classifica√ß√£o mais alta. As tuplas seriam filtradas para aparecerem como mostra a Figura 24.2(b), com Salario e Desempenho\_cargo aparecendo como nulos . Para um usu√°rio com autoriza√ß√£o de seguran√ßa U , a filtragem s√≥ permite que o atributo Nome de 'Silva' apare√ßa, com

## FUNCIONARIO (a)

| Nome     | Salario   | DesempenhoCargo   | DesempenhoCargo   | TC   |
|----------|-----------|-------------------|-------------------|------|
| Silva U  | 40.000 C  | Regular           | S                 | S    |
| Borges C | 80.000 S  | Bom               | C                 | S    |

## FUNCIONARIO (b)

| Nome     | Salario   | DesempenhoCargo   | DesempenhoCargo   | TC   |
|----------|-----------|-------------------|-------------------|------|
| Silva U  | 40.000 C  | NULL              | C                 | C    |
| Borges C | NULL C    | Bom               | C                 | C    |

## FUNCIONARIO (c)

| Nome    | Salario   | DesempenhoCargo   | TC   |
|---------|-----------|-------------------|------|
| Silva U | NULL U    | NULL U            | U    |

## FUNCIONARIO (d)

A chave  aparente de  uma  rela√ß√£o  multin√≠vel  √© o conjunto de atributos que teria formado a chave prim√°ria em uma rela√ß√£o comum (√∫nico n√≠vel). Uma rela√ß√£o  multin√≠vel  parecer√°  conter  diferentes  dados para  sujeitos  (usu√°rios)  com  n√≠veis  de  autoriza√ß√£o distintos. Em alguns casos, √© poss√≠vel armazenar uma √∫nica tupla na rela√ß√£o em um n√≠vel de classifica√ß√£o mais  alto  e  produzir  as  tuplas  correspondentes  em uma classifica√ß√£o de n√≠vel inferior por meio de um processo  conhecido  como filtragem .  Em  outros  casos, √© necess√°rio armazenar duas ou mais tuplas em n√≠veis de classifica√ß√£o diferentes, com o mesmo valor para a chave aparente .

| Nome     | Salario   | DesempenhoCargo   | DesempenhoCargo   | TC   |
|----------|-----------|-------------------|-------------------|------|
| Silva U  | 40.000 C  | Regular           | S                 | S    |
| Silva U  | 40.000 C  | Excelente         | C                 | C    |
| Borges C | 80.000 S  | Bom               | C                 | S    |

## Figura 24.2

Uma rela√ß√£o multin√≠vel para ilustrar a seguran√ßa multin√≠vel. (a) As tuplas FUNCIONARIO originais. (b) Apar√™ncia de FUNCIONARIO depois da filtragem para usu√°rios com classifica√ß√£o C. (c) Apar√™ncia de FUNCIONARIO depois da filtragem para usu√°rios com classifica√ß√£o U. (d) Poli-instancia√ß√£o da tupla de Silva.

4 Isso √© semelhante √† no√ß√£o de ter m√∫ltiplas vers√µes no banco de dados que representam o mesmo objeto do mundo real.

todos os outros atributos aparecendo como nulos (Figura 24.2(c)). Assim, a filtragem introduz valores nulos para valores de atributo cuja classifica√ß√£o de seguran√ßa √© mais alta que a autoriza√ß√£o de seguran√ßa do usu√°rio.

Em geral, a regra de integridade de entidade para rela√ß√µes multin√≠vel indica que todos os atributos que s√£o membros da chave aparente n√£o devem ser nulos e precisam ter a mesma classifica√ß√£o de seguran√ßa dentro de cada tupla individual. Al√©m disso, todos os outros valores de atributo na tupla precisam ter uma classifica√ß√£o de seguran√ßa maior ou igual √† da chave aparente. Essa restri√ß√£o garante que um usu√°rio pode ver a chave se o usu√°rio tiver permiss√£o para ver qualquer parte da tupla. Outras regras de integridade, chamadas integridade nula e integridade entre inst√¢ncias , garantem informalmente que, se um valor de tupla em algum n√≠vel de seguran√ßa puder ser filtrado (derivado) de uma tupla com classifica√ß√£o mais alta, ent√£o √© suficiente armazenar a tupla classificada mais alto na rela√ß√£o multin√≠vel.

Para ilustrar ainda mais a poli-instancia√ß√£o, suponha que um usu√°rio com autoriza√ß√£o de seguran√ßa C tente  atualizar  o  valor  de Desempenho\_cargo de 'Silva'  na  Figura  24.2  para  'Excelente';  isso  corresponde √† seguinte atualiza√ß√£o SQL sendo submetida por esse usu√°rio:

| UPDATE   | FUNCIONARIO                    |
|----------|--------------------------------|
| SET      | Desempenho_cargo = 'Excelente' |
| WHERE    | Nome = 'Silva';                |

Como a vis√£o fornecida aos usu√°rios com autoriza√ß√£o de seguran√ßa C (ver  Figura 24.2(b)) permite tal  atualiza√ß√£o,  o  sistema  n√£o  deve  rejeit√°-la;  caso contr√°rio, o usu√°rio poderia deduzir que algum valor n√£o nulo existe para o atributo Desempenho\_cargo de 'Silva', em vez do valor nulo que aparece. Esse √© um exemplo de dedu√ß√£o de informa√ß√µes que √© conhecido como um canal secreto , que n√£o deve ser permitido em sistemas altamente seguros (ver Se√ß√£o 24.6.1). Por√©m, o usu√°rio n√£o deve ter permiss√£o para gravar sobre o  valor  existente  de Desempenho\_cargo no  n√≠vel  de classifica√ß√£o mais alto. A solu√ß√£o √© criar uma poli-instancia√ß√£o para a tupla 'Silva' no n√≠vel de classifica√ß√£o mais baixo C ,  como mostra a Figura 24.2(d). Isso √© necess√°rio porque a nova tupla n√£o pode ser filtrada com base na tupla existente na classifica√ß√£o S .

As opera√ß√µes de atualiza√ß√£o b√°sicas do modelo relacional ( INSERT, DELETE, UPDATE ) devem ser modificadas para lidar com esta e outras situa√ß√µes semelhantes, mas esse aspecto do problema est√° fora do escopo de nossa apresenta√ß√£o. O leitor interessado dever√° consultar a bibliografia selecionada, ao final deste cap√≠tulo, para obter mais detalhes.

## 24.3.1 Comparando os controles de acesso discricion√°rio e obrigat√≥rio

As pol√≠ticas do controle de acesso discricion√°rio (DAC) s√£o caracterizadas por um alto grau de flexibilidade, que as torna adequadas para uma grande variedade de dom√≠nios de aplica√ß√£o. A principal desvantagem dos modelos DAC √© sua vulnerabilidade a ataques maliciosos, como cavalos de Troia embutidos nos programas de aplica√ß√£o. O motivo √© que os modelos de autoriza√ß√£o discricion√°rios n√£o imp√µem qualquer controle sobre como a informa√ß√£o √© propagada e utilizada depois de ter sido acessada pelos usu√°rios  autorizados  a  fazer  isso.  Ao  contr√°rio,  as pol√≠ticas obrigat√≥rias garantem um alto grau de prote√ß√£o - de certa forma, elas impedem qualquer fluxo de informa√ß√£o ilegal. Portanto, elas s√£o adequadas para aplica√ß√µes militares e outros tipos de alta seguran√ßa, que exigem um grau de prote√ß√£o mais alto. Por√©m, as pol√≠ticas obrigat√≥rias t√™m a desvantagem de serem muito r√≠gidas porque exigem uma classifica√ß√£o estrita de sujeitos e objetos nos n√≠veis de seguran√ßa, e, dessa forma, se aplicam a poucos ambientes. Em muitas situa√ß√µes pr√°ticas, as pol√≠ticas discricion√°rias s√£o preferidas porque oferecem uma maior facilidade de escolha entre seguran√ßa e aplicabilidade.

## 24.3.2 Controle de acesso baseado em pap√©is

O controle de acesso baseado em pap√©is (RBAC) surgiu  rapidamente  nos  anos  1990  como  uma  tecnologia comprovada para gerenciar e impor a seguran√ßa em sistemas em grande escala por toda a empresa. Sua no√ß√£o b√°sica √© que os privil√©gios e outras permiss√µes s√£o associados a pap√©is organizacionais, em vez de a usu√°rios individuais. Tais usu√°rios recebem ent√£o os pap√©is apropriados. Os pap√©is podem ser criados usando os comandos CREATE ROLE e DESTROY ROLE . Os comandos GRANT e REVOKE, discutidos na Se√ß√£o 24.2, podem ent√£o ser utilizados para atribuir  e  revogar  privil√©gios  dos  pap√©is,  bem como para usu√°rios individuais, quando necess√°rio. Por exemplo, uma empresa pode ter pap√©is como gerente  de  conta  de  vendas,  agente  de  compras, funcion√°rio  de  entrega,  gerente  de  depend√™ncia,  e assim por diante. V√°rios indiv√≠duos podem ser designados para cada papel. Os privil√©gios de seguran√ßa comuns a um papel s√£o concedidos ao nome dele, e qualquer indiv√≠duo designado para esse papel automaticamente teria esses privil√©gios concedidos.

O RBAC pode ser usado com os controles  de acesso  discricion√°rio  e  obrigat√≥rio  tradicionais;  ele garante  que  somente  usu√°rios  autorizados  em  seus pap√©is especificados recebam acesso a certos dados ou  recursos.  Os  usu√°rios  criam  sess√µes  durante  as

quais  podem  ativar  um  subconjunto  de  pap√©is  √†s quais  pertencem.  Cada  sess√£o  pode  ser  atribu√≠da  a v√°rios pap√©is, mas ela √© mapeada para um usu√°rio ou para um √∫nico sujeito apenas. Muitos SGBDs t√™m permitido o conceito de pap√©is, nos quais os privil√©gios podem ser atribu√≠dos aos pap√©is.

A separa√ß√£o de tarefas √© outro requisito importante em diversos SGBDs comerciais. Isso √© necess√°rio para impedir que um usu√°rio realize o trabalho que requer o envolvimento de duas ou mais pessoas, impedindo assim a coniv√™ncia. Um m√©todo em que a separa√ß√£o de tarefas pode ser implementada com sucesso √© a exclus√£o m√∫tua de pap√©is. Dois pap√©is s√£o considerados mutuamente exclusivos se  ambos n√£o puderem ser usados simultaneamente pelo usu√°rio. A exclus√£o m√∫tua de pap√©is pode ser categorizada em dois tipos, a saber, exclus√£o em tempo de autoriza√ß√£o (est√°tica) e exclus√£o em tempo de execu√ß√£o (din√¢mica) . Na exclus√£o em tempo de autoriza√ß√£o, dois pap√©is  que  foram  especificados  como  mutuamente exclusivos n√£o podem fazer parte da autoriza√ß√£o de um usu√°rio ao mesmo tempo. Na exclus√£o em tempo de execu√ß√£o, esses dois pap√©is podem ser autorizados a um usu√°rio, mas n√£o podem ser ativados por ele ao mesmo tempo. Outra varia√ß√£o na exclus√£o m√∫tua de pap√©is √© aquela da exclus√£o completa e parcial.

A hierarquia  de  pap√©is no  RBAC  √©  um  modo natural de organizar pap√©is para refletir as linhas de autoridade  e  responsabilidade  da  organiza√ß√£o.  Por conven√ß√£o, os pap√©is j√∫nior no final est√£o conectados a pap√©is progressivamente s√™nior √† medida que um deles  sobe  na  hierarquia.  Os  diagramas  hier√°rquicos s√£o ordens parciais, de modo que s√£o reflexivos, transitivos e antissim√©tricos. Em outras palavras, se um usu√°rio tem um papel, ele automaticamente tem pap√©is inferiores na hierarquia. A defini√ß√£o de uma hierarquia de pap√©is envolve escolher o tipo de hierarquia e os pap√©is, para depois implementar a hierarquia concedendo pap√©is a outros pap√©is. Essa hierarquia pode ser implementada da seguinte maneira:

GRANT ROLE tempo\_integral TO funcionario\_tipo1 GRANT ROLE interno TO funcionario\_tipo2

Estes s√£o exemplos de concess√£o de pap√©is tem-po\_integral e interno para dois tipos de funcion√°rios.

Outra quest√£o relacionada √† seguran√ßa √© o gerenciamento  de  identidade . Identidade refere-se  a um nome √∫nico de uma pessoa individual. Como os nomes v√°lidos  de  pessoas  n√£o  s√£o  necessariamente √∫nicos, a identidade de uma pessoa precisa incluir informa√ß√µes adicionais suficientes para tornar o nome completo √∫nico. Autorizar essa identidade e gerenciar o esquema dessas identidades √© chamado de Gerenciamento  de  Identidade .  O  Gerenciamento de Identidade explica como as organiza√ß√µes podem efetivamente  autenticar  as  pessoas  e  gerenciar  seu acesso a informa√ß√µes confidenciais. Isso tem se tornado mais vis√≠vel como um requisito de neg√≥cios por todos os setores que afetam as organiza√ß√µes de todos os tamanhos. Os administradores de Gerenciamento de Identidade constantemente precisam satisfazer os propriet√°rios da aplica√ß√£o enquanto mant√™m os gastos sob controle e aumentam a efici√™ncia da TI.

Outra considera√ß√£o importante nos sistemas RBAC s√£o as restri√ß√µes temporais poss√≠veis que podem existir nos pap√©is, como o tempo e a dura√ß√£o das ativa√ß√µes  de  pap√©is  e  o  disparo  temporizado  de  um papel por uma ativa√ß√£o de outro papel. O uso de um modelo RBAC √© um objetivo altamente desej√°vel para resolu√ß√£o dos principais requisitos de seguran√ßa das aplica√ß√µes baseadas na Web. Os pap√©is podem ser designados a tarefas de fluxo de trabalho, de modo que um usu√°rio com qualquer um dos pap√©is relacionados a uma tarefa pode ser autorizado a execut√°-la e pode desempenhar  certo  papel  somente  por  determinada dura√ß√£o.

Os modelos RBAC t√™m v√°rios recursos desej√°veis,  como  flexibilidade,  neutralidade  de  pol√≠tica, melhor suporte para gerenciamento e administra√ß√£o de seguran√ßa, e outros aspectos que os tornam candidatos atraentes para desenvolver aplica√ß√µes seguras baseadas na Web. Esses recursos n√£o existem nos modelos DAC e MAC. Al√©m disso, modelos RBAC incluem  as  capacidades  dispon√≠veis  nas  pol√≠ticas DAC e MAC tradicionais. Al√©m do mais, um modelo RBAC oferece mecanismos para resolver as quest√µes de seguran√ßa relacionadas √† execu√ß√£o de tarefas e fluxos de trabalho, e para especificar pol√≠ticas definidas pelo usu√°rio e espec√≠ficas da organiza√ß√£o. A implanta√ß√£o mais f√°cil pela Internet tem sido outra raz√£o para o sucesso desse tipo de modelos RBAC.

## 24.3.3 Seguran√ßa baseada em r√≥tulos e controle de acesso em n√≠vel de linha

Muitos  SGBDs  comerciais  atualmente  usam  o conceito de controle de acesso em n√≠vel de linha, em que regras sofisticadas de controle de acesso podem ser implementadas ao considerar os dados linha por linha.  No  controle  de  acesso  em  n√≠vel  de  linha, cada  linha  de  dados  recebe  um  r√≥tulo,  que  √©  usado  para  armazenar  informa√ß√µes  sobre  a  sensibilidade dos dados. O controle de acesso em n√≠vel de linha oferece maior detalhamento de seguran√ßa dos dados, deixando que as permiss√µes sejam definidas para cada linha e n√£o apenas para a tabela ou coluna. Inicialmente, o usu√°rio recebe um r√≥tulo de sess√£o padr√£o pelo administrador do banco de dados. Os

n√≠veis correspondem a uma hierarquia de n√≠veis de sensibilidade de dados para exposi√ß√£o ou adultera√ß√£o,  com  o  objetivo  de  manter  a  privacidade  ou  a seguran√ßa. Os r√≥tulos s√£o usados para impedir que usu√°rios  n√£o  autorizados  vejam  ou  alterem  certos dados. Um usu√°rio com um baixo n√≠vel de autoriza√ß√£o, normalmente representado por um n√∫mero baixo, tem acesso negado a dados com n√∫mero de n√≠vel mais alto. Se esse r√≥tulo n√£o for dado a uma linha, um r√≥tulo  de  linha  √©  automaticamente  atribu√≠do  a ele, dependendo do r√≥tulo de sess√£o do usu√°rio.

Uma pol√≠tica  definida  por  um  administrador  √© chamada de pol√≠tica de r√≥tulos de seguran√ßa .  Sempre que os dados afetados pela pol√≠tica s√£o acessados ou consultados por uma aplica√ß√£o, a pol√≠tica √© automaticamente chamada. Quando uma pol√≠tica √© implementada,  uma  nova  coluna  √©  acrescentada  a cada linha no esquema. A coluna adicionada cont√©m o r√≥tulo para cada linha que reflete a sensibilidade da linha quanto √† pol√≠tica. Semelhante ao MAC, em que cada usu√°rio tem uma autoriza√ß√£o de seguran√ßa,  cada  usu√°rio  tem  uma  identidade  na  seguran√ßa  baseada  em  r√≥tulo.  A  identidade  desse  usu√°rio √©  comparada  com  o  r√≥tulo  atribu√≠do  a  cada  linha para determinar se o usu√°rio tem acesso para ver o conte√∫do dessa linha. Por√©m, o pr√≥prio usu√°rio pode gravar o valor do r√≥tulo, dentro de certas restri√ß√µes e diretrizes para essa linha espec√≠fica. Esse r√≥tulo pode ser definido como um valor que est√° entre o r√≥tulo da sess√£o atual do usu√°rio e o n√≠vel m√≠nimo do usu√°rio. O DBA tem o privil√©gio para definir um r√≥tulo de linha padr√£o inicial.

Os requisitos da seguran√ßa de r√≥tulos s√£o aplicados em cima dos requisitos do DAC para cada usu√°rio. Logo, o usu√°rio precisa satisfazer os requisitos do DAC e, depois, os requisitos de seguran√ßa de r√≥tulo para acessar uma linha. Os requisitos do DAC garantem que o usu√°rio √© legalmente autorizado a executar essa opera√ß√£o no esquema. Na maioria das aplica√ß√µes,  somente  algumas  das  tabelas  precisam de  seguran√ßa  baseada  em  r√≥tulo.  Para  a  maioria das tabelas da aplica√ß√£o, a prote√ß√£o fornecida pelo DAC √© suficiente.

As pol√≠ticas de seguran√ßa geralmente s√£o criadas por gerentes e pelo pessoal de recursos humanos. Elas s√£o de alto n√≠vel, independentes da tecnologia e relacionadas aos riscos. As pol√≠ticas s√£o um resultado das instru√ß√µes da ger√™ncia para especificar procedimentos organizacionais, princ√≠pios de orienta√ß√£o e cursos de a√ß√£o considerados √°geis, prudentes ou vantajosos. Tais pol√≠ticas costumam ser acompanhadas por uma defini√ß√£o de penalidades e contramedidas se a pol√≠tica for transgredida. Essas pol√≠ticas s√£o ent√£o interpretadas e convertidas para um conjunto de pol√≠ticas orientadas a r√≥tulos pelo administrador de r√≥tulos de seguran√ßa , que define os r√≥tulos de seguran√ßa para dados e autoriza√ß√µes para usu√°rios; esses r√≥tulos e autoriza√ß√µes controlam o acesso a objetos protegidos e espec√≠ficos.

Suponha  que  um  usu√°rio  tenha  privil√©gios SELECT em uma tabela. Quando o usu√°rio executa uma instru√ß√£o SELECT nessa tabela, a seguran√ßa de r√≥tulos automaticamente avaliar√° cada linha retornada pela consulta  para  determinar  se  o  usu√°rio  tem  direitos para ver os dados. Por exemplo, se o usu√°rio tiver uma sensibilidade de 20, ent√£o o usu√°rio pode ver todas as linhas com um n√≠vel de seguran√ßa menor ou igual a 20. O n√≠vel determina a sensibilidade da informa√ß√£o contida em uma linha; quanto mais sens√≠vel a linha, maior √© seu valor de r√≥tulo de seguran√ßa. Tal r√≥tulo de seguran√ßa tamb√©m pode ser configurado para realizar verifica√ß√µes de seguran√ßa em instru√ß√µes UPDATE, DELETE e INSERT .

## 24.3.4 Controle de acesso por XML

Com o uso generalizado da XML em aplica√ß√µes comerciais e cient√≠ficas, tem havido esfor√ßos para desenvolver padr√µes de seguran√ßa. Entre esses esfor√ßos est√£o  assinaturas  digitais  e  padr√µes  de  criptografia para XML. A especifica√ß√£o de Processamento e Sintaxe de Assinaturas em XML descreve uma sintaxe em XML para representar as associa√ß√µes  entre  assinaturas  criptogr√°ficas  e  documentos  em  XML ou outros recursos eletr√¥nicos. A especifica√ß√£o tamb√©m inclui  procedimentos  para  calcular  e  verificar  assinaturas em XML. Uma assinatura digital em XML difere de outros protocolos para assinatura de mensagem, como PGP ( Pretty Good Privacy - um servi√ßo de confidencialidade e autentica√ß√£o que pode ser usado para aplica√ß√µes de correio eletr√¥nico e armazenamento de arquivo), em seu suporte para assinar apenas  partes  espec√≠ficas  da  √°rvore  em  XML  (ver Cap√≠tulo 12) em vez do documento completo. Al√©m disso, a especifica√ß√£o de assinatura em XML define mecanismos para adicionar uma assinatura e transforma√ß√µes - a chamada canoniza√ß√£o para garantir que duas inst√¢ncias de um texto produzam um resumo igual para assinatura, mesmo que suas representa√ß√µes difiram ligeiramente, por exemplo, no espa√ßo em branco tipogr√°fico.

A especifica√ß√£o de Processamento e Sintaxe de Criptografia em XML define o vocabul√°rio em XML e as regras de processamento para proteger a confidencialidade de documentos XML em todo ou em parte e tamb√©m de dados n√£o XML. O conte√∫do codificado e as informa√ß√µes de processamento adicionais para o destinat√°rio s√£o representados na XML bem formada, de modo que o resultado pode ser processado ainda mais usando ferramentas XML. Ao con-

tr√°rio de outras tecnologias normalmente utilizadas para confidencialidade, como a SSL ( Secure Sockets Layer - um importante protocolo de seguran√ßa da Internet),  e  redes  privativas  virtuais,  a  criptografia em XML tamb√©m se aplica a partes de documentos e a documentos em armazenamento persistente.

## 24.3.5 Pol√≠ticas de controle de acesso para e-commerce e a Web

Os  ambientes  de  com√©rcio  eletr√¥nico  ( e-commerce )  s√£o caracterizados por quaisquer transa√ß√µes que sejam feitas eletronicamente. Eles exigem pol√≠ticas elaboradas de controle de acesso, que v√£o al√©m dos SGBDs tradicionais. Em ambientes de banco de dados convencionais, o controle de acesso normalmente √© realizado usando um conjunto de autoriza√ß√µes indicadas pelos agentes de seguran√ßa ou usu√°rios de acordo com algumas pol√≠ticas de seguran√ßa. Esse paradigma simples n√£o √© muito adequado para um ambiente din√¢mico como o e-commerce. Al√©m do mais, em um ambiente de e-commerce, os recursos a serem protegidos n√£o s√£o apenas dados tradicionais, mas tamb√©m conhecimento e experi√™ncia. Essas peculiaridades exigem mais flexibilidade na especifica√ß√£o de pol√≠ticas de controle de acesso. O mecanismo de controle de acesso precisa ser flex√≠vel o suficiente para dar suporte a um grande espectro de objetos de prote√ß√£o heterog√™neos.

Um segundo requisito  relacionado  √©  o  suporte para  controle  de  acesso  baseado  em  conte√∫do.  O controle de acesso baseado em conte√∫do permite que algu√©m expresse pol√≠ticas de controle de acesso que levem em considera√ß√£o o conte√∫do do objeto de prote√ß√£o. Para dar suporte ao controle de acesso baseado  em  conte√∫do,  as  pol√≠ticas  de  controle  precisam permitir a inclus√£o de condi√ß√µes com base no conte√∫  do do objeto.

Um terceiro requisito est√° relacionado √† heterogeneidade dos sujeitos, que requer pol√≠ticas de controle  de  acesso  baseadas  nas  caracter√≠sticas  e  qualifica√ß√µes  do  usu√°rio,  em  vez  de  nas  caracter√≠sticas espec√≠ficas  e  individuais  (por  exemplo,  IDs  de  usu√°rio). Uma solu√ß√£o poss√≠vel, para melhor levar em conta os perfis de usu√°rio na formula√ß√£o das pol√≠ticas de controle de acesso, √© dar suporte √† no√ß√£o de credenciais. Uma credencial √©  um  conjunto de propriedades referentes a um usu√°rio, que s√£o relevantes para fins de seguran√ßa (como idade ou cargo dentro de uma organiza√ß√£o). Por exemplo, ao usar credenciais, pode-se simplesmente formular pol√≠ticas como: somente  o  pessoal  permanente  com  cinco  ou  mais

5 Ver Thuraisingham et al. (2001).

anos de servi√ßo pode acessar documentos relacionados aos detalhes internos do sistema .

Acredita-se  que  a  XML  dever√°  desempenhar  um papel  fundamental  no  controle  de  acesso  para  aplica√ß√µes de e-commerce 5  porque ela est√° se tornando a linguagem de representa√ß√£o comum para troca de documento pela Web, e tamb√©m est√° se tornando a linguagem para e-commerce. Assim, por sua vez, existe a necessidade de tornar as representa√ß√µes em XML seguras, oferecendo mecanismos de controle de acesso moldados especificamente  √†  prote√ß√£o  de  documentos  em  XML. Al√©m disso, a informa√ß√£o de controle de acesso (ou seja, pol√≠ticas de controle de acesso e credenciais do usu√°rio) pode ser expressa usando a pr√≥pria XML. A Linguagem de Marca√ß√£o do Servi√ßo de Diret√≥rios (Directory Services Markup Language DSML) √© uma representa√ß√£o da informa√ß√£o de servi√ßo de diret√≥rio na sintaxe XML. Ela oferece um alicerce para um padr√£o de comunica√ß√£o  com  servi√ßos  de  diret√≥rio  que  ser√£o  respons√°veis por oferecer e autenticar credenciais do usu√°rio. A apresenta√ß√£o uniforme de objetos de prote√ß√£o e pol√≠ticas de controle de acesso pode ser aplicada √†s pr√≥prias pol√≠ticas e credenciais. Por exemplo, algumas propriedades de credencial (como o nome do usu√°rio) podem ser acess√≠veis a todos, enquanto outras propriedades podem ser vis√≠veis apenas para uma classe de usu√°rios restrita. Ademais, o uso de uma linguagem baseada em XML para especificar credenciais e pol√≠ticas de controle de acesso facilita a submiss√£o segura da credencial e a exporta√ß√£o de pol√≠ticas de controle de acesso.

## 24.4 nje√ß√£o de SQL I

Inje√ß√£o de SQL √© uma das amea√ßas mais comuns a um sistema de banco de dados. Vamos discuti-la com detalhes mais adiante, nesta se√ß√£o. Alguns dos outros ataques a bancos de dados, que s√£o muito frequentes, s√£o:

- ¬Ñ Escalada de privil√©gios n√£o autorizada. Esse ataque √© caracterizado por um indiv√≠duo que tenta  elevar  seu  privil√©gio  atacando  pontos vulner√°veis nos sistemas de banco de dados.
- ¬Ñ Abuso de privil√©gio. Enquanto o ataque anterior √© feito por um usu√°rio n√£o autorizado, este √© realizado por um usu√°rio privilegiado. Por exemplo, um administrador que tem permiss√£o  para  alterar  a  informa√ß√£o  do  aluno pode usar esse privil√©gio para atualizar notas de alunos sem a permiss√£o do instrutor.
- ¬Ñ Nega√ß√£o de servi√ßo. Um ataque de nega√ß√£o de  servi√ßo  ( DOS -Denial  Of  Service ) √© uma tentativa  de  tornar  recursos  indispon√≠veis  a  seus  usu√°rios  intencionados.  Essa

- √© uma categoria de ataque geral em que o acesso a aplica√ß√µes ou dados da rede √© negado aos usu√°rios leg√≠timos devido ao estouro do buffer ou esgotamento de recursos.
- ¬Ñ Autentica√ß√£o fraca. Se o esquema de autentica√ß√£o  do  usu√°rio  for  fraco,  um  atacante pode personificar a identidade de um usu√°rio leg√≠timo ao obter suas credenciais de login.

## 24.4.1 M√©todos de Inje√ß√£o de SQL

Conforme  discutimos  no  Cap√≠tulo  14,  programas e aplica√ß√µes Web que acessam um banco de dados  podem  enviar  comandos  e  dados  ao  banco  de dados, bem como exibir dados recuperados do banco de dados por meio do navegador Web. Em um ataque de Inje√ß√£o de SQL , o atacante injeta uma entrada de cadeia de caracteres pela aplica√ß√£o, que muda ou manipula a instru√ß√£o SQL para o proveito do atacante. Um ataque de Inje√ß√£o de SQL pode prejudicar o banco de dados de v√°rias maneiras, como na manipula√ß√£o n√£o autorizada do banco de dados, ou recupera√ß√£o de dados confidenciais. Ele tamb√©m pode ser usado para executar comandos em n√≠vel do sistema que podem fazer o sistema negar servi√ßo √† aplica√ß√£o. Esta se√ß√£o descreve tipos de ataques de inje√ß√£o.

Manipula√ß√£o de SQL. Um ataque de manipula√ß√£o, que √© o tipo mais comum de ataque de inje√ß√£o, muda um comando SQL na aplica√ß√£o - por exemplo, ao acrescentar condi√ß√µes √† cl√°usula WHERE de uma consulta,  ou  ao  expandir  uma  consulta  com  componentes de consulta adicionais, usando opera√ß√µes de uni√£o como UNION, INTERSECT ou MINUS. Outros tipos de ataques de manipula√ß√£o tamb√©m s√£o poss√≠veis. Um ataque de manipula√ß√£o t√≠pico ocorre durante o login do banco de dados. Por exemplo, suponha que um procedimento de autentica√ß√£o simplista emita a seguinte consulta e verifique se alguma linha foi retornada:

SELECT*FROM usuario WHERE nomeusuario = 'jaque' and SENHA = 'senhajaque'.

O atacante pode tentar alterar (ou manipular) a instru√ß√£o SQL, alterando-a da seguinte forma:

SELECT * FROM users WHERE nomeusuario = 'jaque' and (SENHA = 'senhajaque' or 'x' = 'x')

Como resultado, o atacante que sabe que 'jaque' √© um login v√°lido de algum usu√°rio pode se logar no sistema de banco de dados como 'jaque' sem conhecer sua senha e ser capaz de fazer tudo o que 'jaque' pode estar autorizado a fazer nesse sistema de banco de dados.

Inje√ß√£o de c√≥digo. Esse tipo de ataque tenta acrescentar instru√ß√µes SQL ou comandos adicionais √† instru√ß√£o SQL existente, explorando um bug do computador, que √© causado pelo processamento de dados inv√°lidos. O atacante pode injetar ou introduzir c√≥digo em um programa de computador para alterar o curso da execu√ß√£o. A inje√ß√£o de c√≥digo √© uma t√©cnica popular para a invas√£o ou penetra√ß√£o do sistema para obter informa√ß√µes.

Inje√ß√£o de chamada de fun√ß√£o. Nesse tipo de ataque, uma fun√ß√£o do banco de dados ou uma chamada de fun√ß√£o do sistema operacional √© inserida em uma  instru√ß√£o  SQL  vulner√°vel  para  manipular  os dados ou fazer uma chamada do sistema privilegiada. Por exemplo, √© poss√≠vel explorar uma fun√ß√£o que realiza  algum  aspecto  relacionado  √†  comunica√ß√£o na rede. Al√©m disso, as fun√ß√µes que est√£o contidas em um pacote de banco de dados personalizado, ou qualquer fun√ß√£o de banco de dados personalizada, podem ser executadas como parte de uma consulta SQL. Em particular, consultas SQL criadas dinamicamente (ver Cap√≠tulo 13) podem ser exploradas, visto que s√£o constru√≠das em tempo de execu√ß√£o.

Por  exemplo,  a  tabela dual √©  usada  na  cl√°usula FROM da SQL no Oracle quando um usu√°rio precisa executar uma SQL que n√£o tenha logicamente um nome de tabela. Para obter a data de hoje, podemos usar:

SELECT SYSDATE FROM dual;

O exemplo a seguir demonstra que at√© mesmo as instru√ß√µes SQL mais simples podem ser vulner√°veis.

SELECT TRANSLATE ('user input', 'from\_string', 'to\_string') FROM dual;

Aqui, TRANSLATE √© usado para substituir uma cadeia de caracteres por outra cadeia de caracteres. A fun√ß√£o TRANSLATE citada substituir√° os caracteres de  'from\_string'  pelos  caracteres  de  'to\_string'  um por um. Isso significa que o   ser√° substitu√≠do pelo  , f t o r, pelo o , o o, pelo \_, e assim por diante.

Esse tipo de instru√ß√£o SQL pode estar sujeito a um ataque de inje√ß√£o de fun√ß√£o. Considere o exemplo a seguir:

SELECT TRANSLATE (' || UTL\_HTTP .REQUEST ('http://129.107.2.1/') || ','98765432', '9876') FROM dual;

O usu√°rio pode inserir a string (' || UTL\_HTTP.REQUEST ('http://129.107.2.1/') || '), onde || √© o operador de concatena√ß√£o, solicitando assim uma p√°gina de um servidor Web. A UTL\_HTTP faz chamadas do Hypertext Transfer Protocol (HTTP) com base na SQL. O ob-

jeto REQUEST recupera um URL ('http://129.107.2.1/' neste exemplo) como um par√¢metro, entra em contato com esse site e retorna os dados (normalmente HTML) obtidos  desse  site.  O  atacante  poderia  manipular  a string que ele insere, bem como o URL, para incluir outras fun√ß√µes e realizar outras opera√ß√µes ilegais. Apenas usamos um exemplo fict√≠cio para mostrar a convers√£o de '98765432' para '9876', mas a inten√ß√£o do usu√°rio seria acessar o URL e obter informa√ß√µes confidenciais. O atacante pode ent√£o recuperar informa√ß√µes √∫teis do servidor de banco de dados - localizado no URL que √© passado como par√¢metro - e envi√°-las ao servidor Web (que chama a fun√ß√£o TRANSLATE ).

## 24.4.2 Riscos associados √† Inje√ß√£o de SQL

A Inje√ß√£o de SQL √© prejudicial e os riscos associados a ela oferecem motiva√ß√£o para os atacantes. Alguns dos riscos associados a ataques de Inje√ß√£o de SQL s√£o explicados a seguir.

- ¬Ñ Impress√£o digital do banco de dados. O atacante pode determinar o tipo de banco de dados que est√° sendo usado no back-end de modo que possa utilizar ataques espec√≠ficos ao banco de dados que correspondem a pontos fracos em um SGBD em particular.
- ¬Ñ Nega√ß√£o de servi√ßo. O atacante pode inundar o servidor com solicita√ß√µes, negando assim o servi√ßo a usu√°rios leg√≠timos, ou ent√£o eles podem excluir alguns dados.
- ¬Ñ Contornar a autentica√ß√£o. Esse √© um dos riscos  mais  comuns,  em  que  o  atacante  pode obter  acesso  ao  banco  de  dados  como  um usu√°rio autorizado e realizar todas as tarefas desejadas.
- ¬Ñ Identificar  par√¢metros injet√°veis. Nesse tipo de ataque, o atacante re√∫ne informa√ß√µes importantes sobre o tipo e a estrutura do banco de dados de back-end de uma aplica√ß√£o Web. Esse ataque se torna poss√≠vel pelo fato de a p√°gina de erro padr√£o retornada pelos servidores de aplica√ß√£o normalmente ser bastante descritiva.
- ¬Ñ Executar comandos remotos. Isso oferece aos atacantes uma ferramenta para executar comandos  quaisquer  no  banco  de  dados.  Por exemplo, um usu√°rio remoto pode executar procedimentos  armazenados  e  fun√ß√µes  do banco de dados com base em uma interface interativa SQL remota.
- ¬Ñ Realizar  escalada  de  privil√©gios. Esse  tipo  de ataque tira proveito das falhas l√≥gicas dentro do banco de dados para aumentar o n√≠vel de acesso.

## 24.4.3 √©cnicas de prote√ß√£o contra T Inje√ß√£o de SQL

A  prote√ß√£o  contra  ataques  de  Inje√ß√£o  de  SQL pode ser obtida ao aplicarem-se certas regras de programa√ß√£o a todos os procedimentos e fun√ß√µes acess√≠veis pela Web. Esta se√ß√£o descreve algumas dessas t√©cnicas.

Vari√°veis de liga√ß√£o (usando comandos parametrizados). O  uso  de  vari√°veis  de  liga√ß√£o  (tamb√©m conhecidas como par√¢metros ; ver Cap√≠tulo 13) protege contra ataques de inje√ß√£o e tamb√©m melhora o desempenho.

Considere  o  seguinte  exemplo  usando  Java  e JDBC:

```
PreparedStatement stmt = conn. prepareStatement( ' SELECT * FROM FUN- CIONARIO WHERE FUNCIONARIO_ID=? AND SENHA=?'); stmt.setString(1, funcionario_id); stmt.setString(2, senha);
```

Em vez de embutir a entrada do usu√°rio na instru√ß√£o,  ela  dever√°  ser  vinculada  a  um  par√¢metro. Neste exemplo, a entrada '1' √© atribu√≠da (vinculada) √† vari√°vel de liga√ß√£o 'funcionario\_id' e a entrada '2' √† vari√°vel de liga√ß√£o 'senha', em vez de passar par√¢metros de cadeia de caracteres diretamente.

Filtragem  da  entrada  (valida√ß√£o  da  entrada). Esta t√©cnica pode ser usada para remover caracteres de escape das cadeia de caracteres de entrada ao utilizar a fun√ß√£o Replace da SQL. Por exemplo, o delimitador de aspa simples (') pode ser substitu√≠do por duas aspas simples (''). Alguns ataques de manipula√ß√£o de SQL podem ser impedidos com essa t√©cnica, pois os caracteres de escape podem ser usados para injetar ataques de manipula√ß√£o. Por√©m, como pode haver  um  grande  n√∫mero  de  caracteres  de  escape, essa t√©cnica n√£o √© confi√°vel.

Seguran√ßa da fun√ß√£o. As fun√ß√µes de banco de dados, tanto padr√£o quanto personalizadas, devem ser restringidas, pois podem ser exploradas nos ataques de inje√ß√£o de fun√ß√£o SQL.

## 24.5 ntrodu√ß√£o √† seguran√ßa do I banco de dados estat√≠stico

Bancos de dados estat√≠sticos s√£o usados principalmente para produzir estat√≠sticas sobre v√°rias popula√ß√µes. O banco de dados pode conter dados confidenciais sobre indiv√≠duos, que devem ser protegidos contra acesso do usu√°rio. Contudo, os usu√°rios t√™m

permiss√£o  para  recuperar  informa√ß√µes  estat√≠sticas sobre popula√ß√µes, como m√©dias, somas, contadores, valores m√°ximo e m√≠nimo e desvios padr√µes. As t√©cnicas que foram desenvolvidas para proteger a privacidade de informa√ß√µes individuais est√£o al√©m do escopo deste livro. Vamos ilustrar o problema com um exemplo muito simples, que se refere √† rela√ß√£o mostrada na Figura 24.3. Essa √© uma rela√ß√£o PESSOA com os atributos Nome, Cpf, Renda, Endereco, Cidade, Estado, Cep, Sexo e Escolaridade .

Uma popula√ß√£o √© um conjunto de tuplas de uma rela√ß√£o (tabela) que satisfazem alguma condi√ß√£o de sele√ß√£o. Logo, cada condi√ß√£o de sele√ß√£o na rela√ß√£o PESSOA especificar√°  uma  popula√ß√£o  em  particular de tuplas de PESSOA . Por exemplo, a condi√ß√£o Sexo = 'M' especifica a popula√ß√£o do sexo masculino; a condi√ß√£o (( ((Sexo = 'F' AND (Escolaridade = 'M.S.' OR Escolaridade =  'Ph.D.'))  especifica  a  popula√ß√£o  do sexo feminino que tem um t√≠tulo M.S. ou Ph.D. como seu t√≠tulo mais alto; e a condi√ß√£o Cidade = 'S√£o Paulo' especifica a popula√ß√£o que mora em S√£o Paulo.

As consultas estat√≠sticas envolvem a aplica√ß√£o de fun√ß√µes estat√≠sticas a uma popula√ß√£o de tuplas. Por exemplo, podemos querer recuperar o n√∫mero de indiv√≠duos em uma popula√ß√£o ou a renda m√©dia na popula√ß√£o. No entanto, usu√°rios estat√≠sticos n√£o t√™m  permiss√£o  para  recuperar  dados  individuais, como a renda de uma pessoa espec√≠fica. T√©cnicas de seguran√ßa  de  banco  de  dados  estat√≠stico precisam proibir  a  recupera√ß√£o  de  dados  individuais.  Isso pode ser obtido proibindo-se consultas que recuperam valores de atributo e permitindo apenas consultas que envolvem fun√ß√µes de agrega√ß√£o estat√≠stica, como COUNT, SUM, MIN, MAX, AVERAGE e STANDARD DEVIATION. Estas  √†s  vezes  s√£o  chamadas de consultas estat√≠sticas .

√â responsabilidade de um sistema de gerenciamento de banco de dados garantir a confidencialidade da informa√ß√£o sobre indiv√≠duos, enquanto ainda oferece resumos estat√≠sticos √∫teis de dados sobre esses indiv√≠duos aos usu√°rios. A provis√£o da prote√ß√£o da privacidade dos usu√°rios em um banco de dados estat√≠stico √© fundamental; sua viola√ß√£o √© ilustrada no exemplo a seguir.

Em alguns casos, √© poss√≠vel deduzir os  valores de tuplas individuais com base em uma sequ√™ncia de consultas  estat√≠sticas.  Isso  √©  particularmente  verda- deiro quando as condi√ß√µes resultam em uma popula√ß√£o que consiste em um pequeno n√∫mero de tuplas. Como uma ilustra√ß√£o, considere as seguintes consultas estat√≠sticas:

- C1 : SELECT COUNT (*) FROM PESSOA WHERE &lt;condicao&gt;;

C2

:

SELECT AVG

(Renda)

FROM

PESSOA

WHERE

&lt;condicao&gt;;

Agora  suponha  que  estejamos  interessados  em descobrir o Salario de Jane Silva, e sabemos que ela tem um t√≠tulo de Ph.D. e que mora na cidade de Santo Andr√©, S√£o Paulo. Emitimos a consulta estat√≠stica C1 com a seguinte condi√ß√£o:

(Escolaridade='Ph.D.' AND Sexo='F' AND Cidade='Santo Andre' AND Estado='Sao Paulo')

Se obtivermos um resultado de 1 para essa consulta, podemos emitir C2 com a mesma condi√ß√£o e descobrir o Salario de Jane Silva. Mesmo que o resultado de C1 na condi√ß√£o anterior n√£o seja 1, mas seja  um  n√∫mero  pequeno  -  digamos,  2  ou  3  -, podemos emitir consultas estat√≠sticas usando as fun√ß√µes MAX, MIN e AVERAGE para identificar o poss√≠vel intervalo de valores para o Salario de Jane Silva.

A possibilidade  de  deduzir  informa√ß√µes  individuais de consultas estat√≠sticas √© reduzida se nenhuma  consulta  estat√≠stica  for  permitida  sempre que o n√∫mero de tuplas na popula√ß√£o especificada pela condi√ß√£o de sele√ß√£o for abaixo de algum limite.  Outra  t√©cnica  para  proibir  a  recupera√ß√£o de informa√ß√µes individuais √© proibir sequ√™ncias de consultas  que  se  referem  repetidamente  √†  mesma popula√ß√£o de tuplas. Tamb√©m √© poss√≠vel introduzir pequenas imprecis√µes ou ru√≠do nos resultados das consultas estat√≠sticas de maneira deliberada, para tornar dif√≠cil deduzir informa√ß√µes individuais dos resultados. Outra t√©cnica √© o particionamento do banco de dados. O particionamento implica que os registros sejam armazenados em grupos de algum tamanho m√≠nimo; as consultas podem se referir a qualquer grupo completo ou conjunto de grupos, mas nunca a subconjuntos de registros dentro de um  grupo.  O  leitor  interessado  deve  consultar  a bibliografia  ao  final  deste  cap√≠tulo  para  uma  discuss√£o a respeito dessas t√©cnicas.

## PESSOA

## Figura 24.3

## 24.6 ntrodu√ß√£o ao controle de fluxo I

O controle de fluxo regula a distribui√ß√£o ou fluxo de informa√ß√µes entre objetos acess√≠veis. Um fluxo entre o objeto X e o objeto Y ocorre quando um programa l√™ valores de X e grava valores em Y . Os controles de fluxo verificam que a informa√ß√£o contida em alguns objetos n√£o flui explic√≠ta ou implicitamente para objetos menos protegidos. Assim, um usu√°rio  n√£o  pode  obter  indiretamente  em Y o  que ele ou ela n√£o pode obter de maneira direta em X . O controle de fluxo ativo come√ßou no in√≠cio da d√©cada de 1970. A maioria dos controles de fluxo emprega algum conceito de classe de seguran√ßa; a transfer√™ncia de informa√ß√µes de um emissor para um receptor s√≥ √© permitida se a classe de seguran√ßa do receptor for pelo menos t√£o privilegiada quanto a do emissor. Alguns  exemplos  de  um  controle  de  fluxo  incluem impedir que um programa de servi√ßo vaze dados confidenciais de um cliente e bloquear a transmiss√£o de dados militares secretos para um usu√°rio confidencial desconhecido.

Uma pol√≠tica de fluxo especifica os canais ao longo dos quais a informa√ß√£o tem permiss√£o para mover. A pol√≠tica de fluxo mais simples especifica apenas duas classes de informa√ß√£o - confidencial ( C ) e n√£o confidencial ( N ) - e permite todos os fluxos, exceto aqueles da classe C para a classe N . Essa pol√≠tica pode solucionar  o  problema  de  confinamento  que  surge quando um programa de servi√ßo trata de dados como informa√ß√µes do cliente, alguns dos quais podem ser confidenciais. Por exemplo, um servi√ßo de c√°lculo de imposto de renda poderia ter permiss√£o para reter o endere√ßo do cliente e apresentar a conta dos servi√ßos, mas n√£o a receita ou as dedu√ß√µes de um cliente.

Os mecanismos de controle  de  acesso  s√£o  respons√°veis por verificar as autoriza√ß√µes dos usu√°rios para acesso ao recurso: somente opera√ß√µes concedidas s√£o executadas. Os controles de fluxo podem ser impostos por um mecanismo estendido de controle de acesso, que envolve atribuir uma classe de seguran√ßa (normalmente chamada de autoriza√ß√£o ) a cada programa em execu√ß√£o. O programa tem permiss√£o para ler determinado segmento de mem√≥ria somente  se  sua  classe  de  seguran√ßa  for  t√£o  alta  quanto  a do segmento. Ele s√≥ tem permiss√£o para gravar em um segmento se sua classe for pelo menos a mesma que a do segmento. Isso automaticamente garante que nenhuma informa√ß√£o transmitida pela pessoa pode passar de uma classe mais alta para uma mais baixa. Por exemplo, um programa militar com autoriza√ß√£o secreta s√≥ pode ler de objetos que s√£o p√∫blicos e confidenciais, e s√≥ pode gravar em objetos que sejam secretos ou altamente secretos.

Dois tipos de fluxo podem ser distinguidos: fluxos expl√≠citos , que ocorrem como uma consequ√™ncia das  instru√ß√µes  de  atribui√ß√£o,  como Y =  f X : ( 1, X n , ),  e fluxos  impl√≠citos ,  gerados  por  instru√ß√µes  condicionais, como se  ( f X m +1, ..., X n ) ent√£o Y = f : ( X X m 1, ) .

Os  mecanismos  de  controle  de  fluxo  precisam verificar que apenas fluxos autorizados, expl√≠citos e impl√≠citos, sejam executados. Um conjunto de regras precisa ser satisfeito para garantir fluxos de informa√ß√£o seguros. As regras podem ser expressas usando rela√ß√µes de fluxo entre as classes e atribu√≠das √† informa√ß√£o, indicando os fluxos autorizados dentro de um sistema. (Um fluxo de informa√ß√£o de A para B ocorre quando a informa√ß√£o associada a A afeta o valor da informa√ß√£o associada a B . O fluxo resulta de opera√ß√µes que causam transfer√™ncia de informa√ß√µes de um objeto  para  outro.)  Essas  rela√ß√µes  podem  definir, para uma classe, o conjunto de classes em que a informa√ß√£o (confidencial nessa classe) pode fluir, ou podem indicar as rela√ß√µes espec√≠ficas a serem verificadas entre duas classes para permitir que a informa√ß√£o flua de uma para a outra. Em geral, os mecanismos de controle de fluxo implementam os controles ao atribuir um r√≥tulo a cada objeto e ao especificar a classe de seguran√ßa do objeto. Os r√≥tulos s√£o ent√£o utilizados para verificar as rela√ß√µes de fluxo definidas no modelo.

## 24.6.1 Canais secretos

Um canal secreto permite uma transfer√™ncia de informa√ß√£o que viola a seguran√ßa ou a pol√≠tica. Especificamente,  um canal  secreto permite  que  informa√ß√µes passem de um n√≠vel de classifica√ß√£o mais alto para um n√≠vel de classifica√ß√£o mais baixo por meios impr√≥prios. Os canais secretos podem ser classificados em duas categorias gerais: canais de temporiza√ß√£o e armazenamento. O recurso diferenciador entre as duas √© que em um canal de temporiza√ß√£o a informa√ß√£o √© transmitida  pela  temporiza√ß√£o  de  eventos ou processos, enquanto os canais de armazenamento n√£o exigem qualquer sincronismo temporal, visto que a informa√ß√£o √© transmitida ao acessar informa√ß√µes do sistema ou o que, de outra forma, √© inacess√≠vel ao usu√°rio.

Em um exemplo simples de canal secreto, considere  um  sistema  de  banco  de  dados  distribu√≠do em  que  dois  n√≥s  tenham  n√≠veis  de  seguran√ßa  do usu√°rio secreto (S) e n√£o classificado (U). Para que uma transa√ß√£o  seja  confirmada,  os  dois  n√≥s  precisam concordar com isso. Eles s√≥ podem realizar opera√ß√µes mutuamente que s√£o consistentes com a propriedade  , que afirma que, em qualquer transa-* √ß√£o, o n√≥ S n√£o pode gravar ou passar informa√ß√µes para o n√≥ U . Contudo, se esses dois n√≥s combina-

rem para estabelecer um canal secreto entre eles, uma transa√ß√£o envolvendo dados secretos poder√° ser  confirmada de maneira incondicional pelo n√≥ U , mas o n√≥ S pode fazer isso de alguma maneira previamente combinada, de modo que certas informa√ß√µes possam ser passadas do n√≥ S para o n√≥ U , violando  a  propriedade √© .  Isso  pode  ser  alcan√ßado  onde  a  transa√ß√£o  √©  executada  repetidamente, mas as a√ß√µes tomadas pelo n√≥ S de modo impl√≠cito transmitem informa√ß√µes ao n√≥ U .  Medidas como bloqueio,  que  discutimos  nos  cap√≠tulos  22  e  23, impedem a grava√ß√£o simult√¢nea das informa√ß√µes pelos usu√°rios com diferentes n√≠veis de seguran√ßa nos mesmos objetos, impedindo os canais secretos da categoria de armazenamento. Os sistemas operacionais e os bancos de dados distribu√≠dos oferecem controle  sobre  a  multiprograma√ß√£o  de  opera√ß√µes, o  que  permite  um  compartilhamento  de  recursos sem  a  possibilidade  de  invas√£o  de  um  programa ou processo na mem√≥ria ou outros recursos do sistema, impedindo assim os canais de temporiza√ß√£o secretos. Em geral, os canais secretos n√£o s√£o um grande problema nas implementa√ß√µes de banco de dados robustas e bem implementadas. Contudo, certos  esquemas  que  implicitamente  transferem informa√ß√µes podem ser idealizados por usu√°rios inteligentes.

Alguns  especialistas  em  seguran√ßa  acreditam que uma forma de evitar os canais secretos √© impedir que os programadores realmente tenham acesso aos dados confidenciais que um programa processar√° depois que tiver entrado em opera√ß√£o. Por exemplo, um programador de um banco n√£o tem necessidade de acessar os nomes ou saldos nas contas dos clientes. Os programadores de firmas de corretagem n√£o precisam saber quais ordens de compra e venda existem para os clientes. Durante o teste do programa, o acesso a uma forma de dados reais ou alguns dados de teste de exemplo pode ser justific√°vel, mas n√£o depois de o programa ser aceito para uso regular.

## 24.7 Criptografia e infraestruturas de chave p√∫blica

Os  m√©todos  de  acesso  anteriores  e  o  controle de fluxo, apesar de serem medidas de controle fortes,  podem  n√£o  ser  capazes  de  proteger  os  bancos de dados contra algumas amea√ßas. Suponha que comuniquemos dados, mas eles caiam nas m√£os de um usu√°rio ileg√≠timo. Nessa situa√ß√£o, ao usar a criptografia, podemos disfar√ßar a mensagem de modo que, mesmo que a transmiss√£o seja desviada, a mensagem n√£o ser√°  revelada.  A criptografia √©  a  convers√£o  de dados para um formato, chamado texto cifrado , que n√£o pode ser facilmente entendido por pessoas n√£o autorizadas. Ela melhora a seguran√ßa e a privacidade quando os controles de acesso s√£o evitados, pois em casos de perda ou roubo de dados, aqueles criptografados  n√£o  podem  ser  facilmente  entendidos  por pessoas n√£o autorizadas.

Com essa base, aderimos √†s seguintes defini√ß√µes padr√£o: 6

- ¬Ñ Texto cifrado :  dados  criptografados  (codificados).
- ¬Ñ Texto limpo (ou texto claro) : dados intelig√≠veis que t√™m significado e podem ser lidos ou atuados sem a aplica√ß√£o da descriptografia.
- ¬Ñ Criptografia: o processo de transformar texto limpo em texto cifrado.
- ¬Ñ Descriptografia: o  processo  de  transformar texto cifrado de volta para texto limpo.

A criptografia consiste em aplicar um algoritmo de  criptografia aos  dados  usando  alguma chave de criptografia pr√©-especificada.  Os  dados  resultantes precisam ser descriptografados usando uma chave de descriptografia para recuperar os dados originais.

## 24.7.1 Os padr√µes Data Encryption e Advanced Encryption

O Data Encryption Standard (DES) √© um sistema desenvolvido pelo governo dos EUA para uso pelo p√∫blico em geral. Ele foi bastante aceito como padr√£o criptogr√°fico nos Estados Unidos e no exterior. O DES pode oferecer criptografia de ponta a ponta no canal entre o emissor A e o receptor B . O algoritmo DES √© uma combina√ß√£o cuidadosa e complexa de dois blocos de montagem fundamentais da criptografia: substitui√ß√£o e permuta√ß√£o (transposi√ß√£o). O algoritmo deriva sua robustez da aplica√ß√£o repetida dessas duas t√©cnicas para um total de 16 ciclos. O texto limpo (a forma original da mensagem) √© criptografado como blocos de 64 bits. Embora a chave tenha 64 bits de extens√£o, na verdade a chave pode ser qualquer n√∫mero de 56 bits.  Ap√≥s questionar a adequa√ß√£o do DES, o NIST introduziu  o Advanced  Encryption Standard (AES). Esse algoritmo tem um tamanho de bloco de 128 bits, comparado com o tamanho de 56 bits do DES, e pode usar chaves de 128, 192 ou 256 bits, em compara√ß√£o com a chave de 56 bits do DES. O AES introduz mais chaves poss√≠veis, em compara√ß√£o com o DES, e, assim, exige muito mais tempo para quebrar uma chave.

6 Essas defini√ß√µes s√£o do NIST (National Institute of Standards and Technology), dispon√≠veis em: &lt;http://csrc.nist.gov/publications/nistpubs/800-67/ SP800-67.pdf&gt;.

## 24.7.2 Algoritmos de chave sim√©trica

Uma chave sim√©trica √© uma chave utilizada para criptografia e descriptografia. Ao usar uma chave sim√©trica, a criptografia e a descriptografia r√°pidas s√£o poss√≠veis para emprego rotineiro com dados sens√≠veis no  banco  de  dados.  Uma  mensagem  criptografada com uma chave secreta pode ser descriptografada apenas com a mesma chave secreta. Os algoritmos usados para a criptografia de chave sim√©trica s√£o chamados algoritmos de chave secreta . Como tais algoritmos s√£o utilizados principalmente para criptografar o conte√∫do de uma mensagem, eles tamb√©m s√£o chamados de algoritmos de criptografia de conte√∫do .

A principal desvantagem associada aos algoritmos de chave secreta √© a necessidade de compartilhar essa chave. Um m√©todo poss√≠vel √© derivar a chave secreta de uma cadeia de carateres de senha fornecida pelo usu√°rio ao aplicar a mesma fun√ß√£o √† cadeia de carateres no emissor e no receptor; isso √© conhecido como algoritmo de criptografia baseado em senha . A robustez da criptografia de chave sim√©trica depende do tamanho da chave utilizada. Para o mesmo algoritmo, a criptografia que utiliza uma chave mais longa √© mais dif√≠cil de ser quebrada do que aquela que usa uma chave mais curta.

## 24.7.3 Criptografia de chave p√∫blica (assim√©trica)

Em 1976, Diffie e Hellman propuseram um novo tipo de sistema criptogr√°fico, que eles chamaram de criptografia de chave p√∫blica . Os algoritmos de chave p√∫blica s√£o baseados em fun√ß√µes matem√°ticas em vez de em opera√ß√µes em padr√µes de bits. Eles resolvem um problema da criptografia de chave sim√©trica, a saber, que tanto o emissor quanto o destinat√°rio precisam trocar a chave comum de uma maneira segura. Nos sistemas de chave p√∫blica, duas chaves s√£o utilizadas para criptografia/descriptografia. A chave  p√∫blica pode ser transmitida de uma maneira n√£o segura, enquanto a chave privada n√£o √© transmitida. Esses algoritmos - que usam duas chaves relacionadas, uma chave p√∫blica e uma chave privada, para rea  lizar opera√ß√µes complementares (criptografia e descriptografia) - s√£o conhecidos como algoritmos de criptografia de chave assim√©trica . O emprego de duas chaves pode ter consequ√™ncias  profundas  nas  √°reas  de  confidencialidade,  distribui√ß√£o  de  chave  e  autentica√ß√£o.  As  duas chaves  usadas  para  a  criptografia  de  chave  p√∫blica s√£o conhecidas como chave p√∫blica e chave privada . A √∫ltima √© mantida em segredo, mas √© referenciada como chave privada em vez de chave secreta (a chave usada na criptografia convencional) para evitar confus√£o com a criptografia convencional. As duas chaves s√£o  matematicamente  relacionadas,  pois  uma  delas serve para realizar a criptografia e a outra, para realizar  a  descriptografia.  Contudo,  √©  muito  dif√≠cil derivar a chave privada com base na chave p√∫blica.

Um esquema de criptografia  de  chave  p√∫blica, ou infraestrutura , tem seis ingredientes:

- 1. Texto limpo. Trata-se dos dados ou mensagem  leg√≠vel  que  √©  alimentada  no  algoritmo como entrada.
- 2. Algoritmo de criptografia. Esse algoritmo realiza diversas transforma√ß√µes no texto limpo.
- 3. e 4. Chaves p√∫blica e privada. Trata-se de um par de chaves que foram selecionadas de modo que, se uma for usada para criptografia, a outra √© utilizada para descriptografia. As transforma√ß√µes exatas realizadas pelo algoritmo de criptografia dependem da chave p√∫blica ou privada que √© fornecida como entrada. Por exemplo, se uma mensagem √© criptografada com a chave p√∫blica, ela s√≥ pode ser descriptografada com a chave privada.
- 5. Texto cifrado. Essa √© a mensagem misturada produzida como sa√≠da. Ela depende do texto limpo e da chave. Para determinada mensagem, duas chaves diferentes produzir√£o dois textos cifrados diferentes.
- 6. Algoritmo de descriptografia. Esse algoritmo aceita  o  texto  cifrado  e  a  chave  correspondente, e produz o texto limpo original.

Como o nome sugere, a chave p√∫blica do par se torna p√∫blica para outros a usarem, enquanto a chave privada √© conhecida apenas por seu propriet√°rio.  Um algoritmo criptogr√°fico de chave p√∫blica para uso geral conta com uma chave para criptografia  e  uma chave diferente, por√©m relacionada, para descriptografia. As etapas essenciais s√£o as seguintes:

- 1. Cada usu√°rio gera um par de chaves a serem usadas para criptografar e descriptografar as mensagens.
- 2. Cada  usu√°rio  coloca  uma  das  duas  chaves em um registrador p√∫blico ou outro arquivo acess√≠vel. Essa √© a chave p√∫blica. A chave correspondente √© mantida privada.
- 3. Se  um  emissor  deseja  enviar  uma  mensagem privada a um receptor, o emissor criptografa a mensagem usando a chave p√∫blica do receptor.
- 4. Quando o receptor recebe a mensagem, ele ou ela a descriptografa com a chave privada do receptor. Nenhum outro destinat√°rio pode descriptografar a mensagem porque somente o receptor conhece sua chave privada.

O  algoritmo  de  criptografia  de  chave  p√∫blica RSA. Um dos primeiros esquemas de chave p√∫blica foi introduzido em 1978 por Ron Rivest, Adi Shamir e Len Adleman no MIT e recebeu o nome de esquema RSA devido √†s iniciais de seus sobrenomes. O esquema RSA, desde ent√£o, tem sido afirmado como a t√©cnica mais aceita e implementada para a criptografia de chave p√∫blica. O algoritmo de criptografia RSA incorpora  resultados  da  teoria  dos  n√∫meros,  combinados com a dificuldade de determinar os fatores primos de um alvo. O algoritmo RSA tamb√©m opera com a aritm√©tica modular - mod n.

Duas chaves, d e e ,  s√£o  usadas para criptografia e descriptografia. Uma propriedade importante √© que elas podem ser trocadas. n √© escolhida como um inteiro grande, que √© um produto de dois n√∫meros primos distintos grandes, a e b n , = a √ó b . A chave de criptografia e √© um n√∫mero escolhido aleatoriamente entre 1 e n que seja relativamente primo de ( a -  1) √ó ( b - 1). O bloco de texto limpo P √© criptografado como P e , onde P e = P mod n . Como a exponencia√ß√£o √© realizada como mod n , a fatora√ß√£o de P e para desvendar o texto limpo criptografado √© dif√≠cil. Por√©m, a chave de descriptografia d √© cuidadosamente escolhida de modo que ( P e )  mod d n = P. A chave de descriptografia d pode ser calculada com base na condi√ß√£o de que d √ó e =  1 mod (( a -  1)  √ó  ( b -  1)).  Assim, o receptor leg√≠timo que conhece d simplesmente calcula ( P e )  mod d n = P e recupera P sem ter de fatorar P e .

## 24.7.4 Assinaturas digitais

Uma  assinatura  digital  √©  um  exemplo  de  uso de t√©cnicas de criptografia para fornecer servi√ßos de autentica√ß√£o em aplica√ß√µes de com√©rcio eletr√¥nico. Assim como uma assinatura manual, uma assinatura digital √© um meio de associar uma marca √∫nica a um indiv√≠duo com um corpo de texto. A marca deve ser inesquec√≠vel,  significando  que  outros  devem  poder verificar se a assinatura vem do remetente.

Uma assinatura  digital  consiste  em  uma  string de s√≠mbolos. Se a assinatura digital de uma pessoa sempre fosse a mesma para cada mensagem, ent√£o algu√©m poderia facilmente falsific√°-la apenas copiando a string de s√≠mbolos. Assim, as assinaturas devem ser diferentes para cada uso. Isso pode ser obtido tornando cada assinatura digital uma fun√ß√£o da mensagem que ela est√° assinando, junto com um r√≥tulo de tempo. Para ser √∫nica a cada assinante e √† prova de falsifica√ß√£o, cada assinatura digital tamb√©m precisa depender de algum n√∫mero secreto que seja exclusivo ao assinante. Dessa forma, em geral, uma assinatura digital √† prova de falsifica√ß√£o deve depender da mensagem e de um n√∫mero secreto √∫nico do assinante. O verificador da assinatura, por√©m, n√£o deve precisar saber qualquer n√∫mero secreto. As t√©cnicas de chave p√∫blica s√£o a melhor maneira de criar assinaturas digitais com essas propriedades.

## 24.7.5 Certificados digitais

Um certificado digital √© utilizado para combinar o valor de uma chave p√∫blica com a identidade da pessoa ou servi√ßo que mant√©m a chave privada correspondente em uma declara√ß√£o assinada digitalmente. Os certificados s√£o emitidos e assinados por uma autoridade certificadora ( CA -Certification Authority ). A entidade que recebe esse certificado de uma CA √© o sujeito desse certificado. No lugar de exigir que cada participante em uma aplica√ß√£o autentique cada  usu√°rio,  uma  autentica√ß√£o  de  terceiros  conta com o uso de certificados digitais.

O pr√≥prio certificado digital cont√©m v√°rios tipos de informa√ß√£o. Por exemplo, est√£o inclu√≠das informa√ß√µes tanto da autoridade certificadora quanto do propriet√°rio do certificado. A lista a seguir descreve todas as informa√ß√µes inclu√≠das no certificado:

- 1. A informa√ß√£o do propriet√°rio do certificado, que √© representado por um identificador √∫nico, conhecido como nome distinto (DN) do propriet√°rio. Isso inclui o nome do propriet√°rio, bem como sua organiza√ß√£o e outras informa√ß√µes sobre ele.
- 2. O certificado tamb√©m inclui a chave p√∫blica do propriet√°rio.
- 3. A data de emiss√£o do certificado tamb√©m √© inclu√≠da.
- 4. O per√≠odo de validade √© especificado por datas 'V√°lido de' e 'V√°lido at√©', que est√£o inclu√≠das em cada certificado.
- 5. A informa√ß√£o do identificador do emissor √© inclu√≠da no certificado.
- 6. Finalmente, a assinatura digital da CA emissora para o certificado √© inclu√≠da. Todas as informa√ß√µes listadas s√£o codificadas por meio de uma fun√ß√£o message-digest , que cria a assinatura digital. A assinatura digital basicamente certifica  que  a  associa√ß√£o  entre  o propriet√°rio do certificado e a chave p√∫blica √© v√°lida.

## 24.8 Quest√µes de privacidade e preserva√ß√£o

A preserva√ß√£o da privacidade dos dados √© um desafio cada vez maior para os especialistas em seguran√ßa e privacidade do banco de dados. Em algumas perspectivas, para preservar a privacidade dos

dados,  devemos  at√©  mesmo  limitar  a  realiza√ß√£o  da minera√ß√£o e an√°lise de dados em grande escala. Uma das t√©cnicas mais comuns para resolver esse problema √© evitar a cria√ß√£o de warehouses centrais imensos como  um  √∫nico  reposit√≥rio  de  informa√ß√µes  vitais. Outra medida poss√≠vel √© modificar ou perturbar dados intencionalmente.

Se  todos  os  dados  estivessem  dispon√≠veis  em um  √∫nico  warehouse,  a  viola√ß√£o  da  seguran√ßa  de um √∫nico reposit√≥rio poderia expor todos os dados. Evitar warehouses centrais e usar algoritmos de minera√ß√£o de dados distribu√≠dos minimiza a troca de dados  necess√°ria  para  desenvolver  modelos  globalmente v√°lidos. Ao modificar, atrapalhar e tornar os dados an√¥nimos, tamb√©m podemos aliviar os riscos de privacidade associados √† minera√ß√£o de dados. Isso pode ser feito ao remover informa√ß√µes de identidade dos dados liberados e ao injetar ru√≠do aos dados. Por√©m, ao usar essas t√©cnicas, devemos prestar aten√ß√£o √† qualidade dos dados resultantes no banco de dados, que podem sofrer muitas modifica√ß√µes. Tamb√©m devemos poder estimar os erros pass√≠veis de serem introduzidos por essas modifica√ß√µes.

A privacidade √© uma √°rea importante de pesquisa cont√≠nua no gerenciamento de banco de dados. Isso √© complicado devido a sua natureza multidisciplinar e suas quest√µes relacionadas √† subjetividade na interpreta√ß√£o da privacidade, confian√ßa, e assim por diante.  Como  exemplo,  considere  registros  e  transa√ß√µes m√©dicos e legais, que devem manter certos requisitos de privacidade enquanto est√£o sendo definidos e impostos. Oferecer controle de acesso e privacidade para dispositivos m√≥veis tamb√©m est√° recebendo cada vez mais aten√ß√£o. Os SGBDs precisam de t√©cnicas robustas  para  o  armazenamento  eficiente  de  informa√ß√µes relevantes  √†  seguran√ßa  em  pequenos  dispositivos, bem como t√©cnicas de negocia√ß√£o de confian√ßa. Onde manter informa√ß√µes relacionadas a identidades, perfis, credenciais e permiss√µes e como us√°-las para a identifica√ß√£o  confi√°vel  do  usu√°rio  ainda  √©  um  problema importante. Como fluxos de dados de grande tamanho s√£o gerados em tais ambientes, √© preciso elaborar t√©cnicas eficientes para controle de acesso, integrando-as com t√©cnicas de processamento para consultas cont√≠nuas. Por fim, √© preciso que se garanta a privacidade dos dados de localiza√ß√£o do usu√°rio, adquiridos de sensores e redes de comunica√ß√£o.

## 24.9 Desafios da seguran√ßa do banco de dados

Considerando  o  grande  crescimento  em  volume e velocidade das amea√ßas aos bancos de dados e informa√ß√µes, √© preciso dedicar esfor√ßos de pesquisa

√†s seguintes quest√µes: qualidade dos dados, direitos de propriedade intelectual e sobreviv√™ncia do banco de dados. Estes s√£o apenas alguns dos principais desafios que os pesquisadores em seguran√ßa de banco de dados est√£o tentando resolver.

## 24.9.1 Qualidade dos dados

A comunidade de banco de dados precisa de t√©cnicas e solu√ß√µes organizacionais para avaliar e atestar a qualidade dos dados. Essas t√©cnicas podem incluir mecanismos simples, como r√≥tulos de qualidade que s√£o postados no sites Web. Tamb√©m precisamos de t√©cnicas que ofere√ßam verifica√ß√£o eficaz da sem√¢ntica de integridade e ferramentas para a avalia√ß√£o da qualidade dos dados, com base em t√©cnicas como a liga√ß√£o de registros. T√©cnicas de recupera√ß√£o em n√≠vel de aplica√ß√£o tamb√©m s√£o necess√°rias para reparar automaticamente os dados incorretos. As ferramentas de ETL ( Extract, Transform, Load - extra√ß√£o, transforma√ß√£o, carga), bastante usadas para carregar dados em data warehouses (ver Se√ß√£o 29.4), atualmente est√£o atacando essas quest√µes.

## 24.9.2 Direitos de propriedade intelectual

Com o uso generalizado da Internet e de intranets, aspectos legais e informativos dos dados est√£o se tornando  preocupa√ß√µes  importantes  das  organiza√ß√µes. Para enfrentar esses problemas, t√™m sido propostas t√©cnicas de marca d'√°gua para dados relacionais. A finalidade principal da marca d'√°gua digital √© proteger o conte√∫do contra duplica√ß√£o e distribui√ß√£o n√£o autorizadas, habilitando a propriet√°rio prov√°vel do conte√∫do. Isso tradicionalmente tem ficado por conta da disponibilidade de um grande dom√≠nio de ru√≠do, dentro do qual o objeto pode ser alterado enquanto ret√©m suas propriedades essenciais. Por√©m, √© preciso que haja pesquisa para avaliar a robustez dessas t√©cnicas e para investigar diferentes  t√©cnicas  visando  √†  preven√ß√£o  de  viola√ß√µes dos direitos de propriedade intelectual.

## 24.9.3 Sobreviv√™ncia do banco de dados

Os sistemas de banco de dados precisam operar e  continuar  suas  fun√ß√µes,  mesmo  com  capacidades reduzidas, apesar de eventos destruidores, como ataques de busca de vantagem competitiva. Um SGBD, al√©m de realizar todos os esfor√ßos para impedir um ataque e detectar um, caso ocorra, deve ser capaz de fazer o seguinte:

- ¬Ñ Confinamento. Tomar a√ß√£o imediata para eliminar o acesso do atacante ao sistema e isolar ou conter o problema para impedir que se espalhe mais.

- ¬Ñ Avalia√ß√£o de danos. Determina a extens√£o do problema, incluindo fun√ß√µes que falharam e dados adulterados.
- ¬Ñ Reconfigura√ß√£o. Reconfigurar  para  permitir que a opera√ß√£o continue em um modo reduzido enquanto a recupera√ß√£o prossegue.
- ¬Ñ Reparo. Recuperar dados adulterados ou perdidos e reparar ou reinstalar fun√ß√µes do sistema que falharam, para restabelecer um n√≠vel de opera√ß√£o normal.
- ¬Ñ Tratamento  de  falha. Ao  m√°ximo  poss√≠vel, identificar  os  pontos  fracos  explorados  no ataque  e  tomar  medidas  para  impedir  uma nova ocorr√™ncia.

O objetivo do atacante em busca de vantagem competitiva √© prejudicar a opera√ß√£o da organiza√ß√£o e  a  realiza√ß√£o  de  sua  miss√£o,  por  meio  de  danos  a seus  sistemas  de  informa√ß√£o.  O  alvo  espec√≠fico  de um ataque pode ser o pr√≥prio sistema ou seus dados. Embora os ataques que paralisam totalmente o sistema sejam graves e dram√°ticos, eles tamb√©m devem ser  bem  temporizados  para  alcan√ßar  o  objetivo  do atacante, pois os ataques receber√£o aten√ß√£o imediata e concentrada, a fim de retornar o sistema √† condi√ß√£o operacional, diagnosticar como ocorreu o ataque e instalar medidas preventivas.

At√© o momento, quest√µes relacionadas √† sobreviv√™ncia do banco de dados ainda n√£o foram suficientemente investigadas. √â preciso que se dedique muito mais pesquisa √†s t√©cnicas e metodologias que garantam a sobreviv√™ncia do sistema de banco de dados.

## 24.10 Seguran√ßa baseada em r√≥tulo no Oracle

Restringir  o  acesso  a  tabelas  inteiras  ou  isolar dados confidenciais em bancos de dados separados √© uma opera√ß√£o dispendiosa para se administrar. A Oracle Label Security evita a necessidade dessas medidas ao habilitar o controle de acesso em n√≠vel de linha. Ela estava dispon√≠vel no Oracle Database 11g Release 1 (11.1) Enterprise Edition no momento em que  este  livro  foi  escrito.  Cada  tabela  ou  vis√£o  do banco de dados tem uma pol√≠tica de seguran√ßa associada a ela. Essa pol√≠tica √© executada toda vez que a tabela ou vis√£o √© consultada ou alterada. Os desenvolvedores  podem  prontamente  acrescentar  o  controle de acesso baseado em r√≥tulo as suas aplica√ß√µes em Oracle Database. A seguran√ßa baseada em r√≥tulo oferece uma forma adapt√°vel de controlar o acesso a dados confidenciais. Tanto usu√°rios quanto dados possuem r√≥tulos associados a eles.  A  Oracle  Label Security usa esses r√≥tulos para oferecer seguran√ßa.

## 24.10.1 ecnologia Virtual Private T Database (VPD)

O Virtual Private Databases (VPDs) √© um recurso do Oracle Enterprise Edition que acrescenta predicados aos  comandos do usu√°rio para limitar seu acesso de uma maneira transparente ao usu√°rio e √† aplica√ß√£o. O conceito de VPD permite o controle de acesso imposto pelo servidor, detalhado, para uma aplica√ß√£o segura.

O VPD oferece controle de acesso baseado em pol√≠ticas. Essas pol√≠ticas de VPD imp√µem controle de acesso em n√≠vel de objeto ou seguran√ßa em n√≠vel de linha. Isso fornece uma interface de programa√ß√£o de aplica√ß√£o (API) que permite que as pol√≠ticas de seguran√ßa sejam ligadas √†s tabelas ou vis√µes do banco de dados. Ao utilizar PL/SQL, uma linguagem de programa√ß√£o hospedeira usada em aplica√ß√µes Oracle, os desenvolvedores e administradores de seguran√ßa podem implementar pol√≠ticas de seguran√ßa com a ajuda de procedimentos armazenados. 7 As pol√≠ticas VPD permitem que os desenvolvedores removam os mecanismos de seguran√ßa de acesso das aplica√ß√µes e os centralizem no Oracle Database.

O VPD √© habilitado ao associar-se uma 'pol√≠tica'  de  seguran√ßa  a  uma  tabela,  vis√£o  ou  sin√¥nimo. Um administrador usa o pacote PL/SQL fornecido, SGBD\_RLS, para vincular uma fun√ß√£o da pol√≠tica a um objeto do banco de dados. Quando um objeto que tem uma pol√≠tica de seguran√ßa associada a ela √© acessado, a fun√ß√£o que implementa essa pol√≠tica √© consultada. A fun√ß√£o da pol√≠tica retorna um predicado  (uma  cl√°usula WHERE )  que  √©  ent√£o  anexado ao comando SQL do usu√°rio, modificando assim, de forma transparente e din√¢mica ,  o  acesso aos dados pelo usu√°rio. A Oracle Label Security √© uma t√©cnica de imposi√ß√£o da seguran√ßa em n√≠vel de linha na forma de uma pol√≠tica de seguran√ßa.

## 24.10.2 Arquitetura Label Security

A Oracle  Label  Security est√° embutida na tecnologia VPD entregue no Oracle Database 11.1 Enterprise Edition. A Figura 24.4 ilustra como os dados s√£o acessados sob a Oracle Label Security, mostrando a sequ√™ncia de verifica√ß√µes do DAC e da seguran√ßa de r√≥tulo.

A Figura 24.4 mostra a sequ√™ncia de verifica√ß√µes do DAC e da seguran√ßa de r√≥tulo. A parte da esquerda da figura mostra um usu√°rio de aplica√ß√£o em uma sess√£o do Oracle Database 11g Release 1 (11.1) enviando uma requisi√ß√£o em SQL. O SGBD Oracle verifica

7 Procedimentos armazenados (ou stored procedures ) foram discutidos na Se√ß√£o 5.2.2.



requisi√ß¬™o de dados

Figura 24.4 Arquitetura Oracle Label Security. Fonte : Oracle (2007)

os privil√©gios do DAC do usu√°rio, garantindo que ele ou ela tenha privil√©gios SELECT na tabela. Depois, ele verifica se a tabela tem uma pol√≠tica de Virtual Private Database (VPD) associada para determinar se a tabela est√° protegida ao usar a Oracle Label Security. Se tiver, a modifica√ß√£o SQL da pol√≠tica VPD (cl√°usula WHERE ) √© acrescentada √† instru√ß√£o SQL original para encontrar o conjunto de linhas acess√≠veis que o usu√°rio pode ver. Depois, a Oracle Label Security verifica os r√≥tulos em cada linha, para determinar o subconjunto de linhas √†s quais o usu√°rio tem acesso (conforme explicaremos na pr√≥xima se√ß√£o). Essa consulta modificada √© processada, otimizada e executada.

## 24.10.3 Como r√≥tulos de dados e r√≥tulos de usu√°rio trabalham juntos

O r√≥tulo de um usu√°rio indica a informa√ß√£o que este tem permiss√£o para acessar. Ele tamb√©m determina o tipo de acesso (leitura ou grava√ß√£o) que o usu√°rio tem sobre essa informa√ß√£o. O r√≥tulo de uma linha mostra a sensibilidade da informa√ß√£o que a linha cont√©m, bem como a propriedade da informa√ß√£o. Quando uma tabela no banco de dados tem um acesso baseado em r√≥tulo associado a ela, uma linha s√≥ pode ser acessada se o r√≥tulo do usu√°rio atender a certos crit√©rios definidos nas defini√ß√µes da pol√≠tica. O acesso √© concedido ou negado com base no resultado da compara√ß√£o do r√≥tulo de dados e do r√≥tulo de sess√£o do usu√°rio.

Os compartimentos permitem uma classifica√ß√£o mais detalhada da sensibilidade dos dados rotulados.

Todos os dados relacionados ao mesmo projeto podem ser rotulados com o mesmo compartimento. Os compartimentos s√£o opcionais; um r√≥tulo pode conter zero ou mais compartimentos.

Os  grupos  s√£o  usados  para  identificar  organiza√ß√µes como propriet√°rias dos dados com r√≥tulos de grupo correspondentes. Os grupos s√£o hier√°rquicos; por exemplo, um grupo pode ser associado a um grupo pai.

Se um usu√°rio tiver um n√≠vel m√°ximo de SENSITIVE, ent√£o o usu√°rio potencialmente tem acesso a todos os dados com n√≠veis SENSITIVE, CONFIDENTIAL e UNCLASSIFIED. Esse usu√°rio n√£o tem acesso a dados HIGHLY\_SENSITIVE .  A  Figura 24.5 mostra como os r√≥tulos de dados e de usu√°rio trabalham juntos para oferecer controle de acesso na Oracle Label Security.

Como vemos na Figura 24.5, o Usu√°rio 1 pode ter acesso √†s linhas 2, 3 e 4, pois seu n√≠vel m√°ximo √© HS (Highly\_Sensitive). Ele tem acesso ao compartimento FIN (Finan√ßas), e seu acesso ao grupo WR (Western Region)  hierarquicamente  inclui  o  grupo  WR\_SAL (WR Sales). Ele n√£o pode acessar a linha 1 porque n√£o tem o compartimento CHEM (Chemical). √â importante que um usu√°rio tenha autoriza√ß√£o para todos os compartimentos no r√≥tulo de dados de uma linha para poder acess√°-la. Com base nesse exemplo, o usu√°rio 2 pode acessar as linhas 3 e 4, e tem um n√≠vel m√°ximo de S, que √© menor que o HS na linha 2. Portanto, embora o usu√°rio 2 tenha acesso ao compartimento FIN, ele pode acessar apenas o grupo WR\_SAL, e, dessa forma, n√£o pode acessar a linha 1.

N√≠vel de

acesso

m√Üximo

Todos os compartimentos aos quais o usu√Ürio tem acesso

N√≠vel de acesso m√≠nimo exigido

Todos os compartimentos aos quais o usu√Ürio deve ter acesso

R√≥tulo de usu√Ürio

R√≥tulo de dados

| S   | CHEM, FIN : WR   |
|-----|------------------|
| HS  | FIN : WR_SAL     |
| U   | FIN              |
| C   | FIN : WR_SAL     |



R√≥tulos de dados e r√≥tulos de usu√°rio no Oracle.

Figura 24.5 Fonte: Oracle (2007)

## Resumo

Neste  cap√≠tulo,  discutimos  v√°rias  t√©cnicas  para impor  a  seguran√ßa  do  sistema  de  banco  de  dados. Apresentamos diferentes amea√ßas aos bancos de dados  em  rela√ß√£o  √†  perda  de  integridade,  disponibilidade  e  confidencialidade.  Discutimos  os  tipos  de medidas de controle para lidar com esses problemas: controle  de  acesso,  controle  de  infer√™ncia,  controle de  fluxo  e  criptografia.  Na  introdu√ß√£o,  abordamos diversas quest√µes relacionadas √† seguran√ßa, incluindo sensibilidade  de  dados  e  tipo  de  exposi√ß√µes,  oferecendo seguran√ßa versus precis√£o no resultado quando um usu√°rio solicita informa√ß√µes, e o relacionamento entre seguran√ßa e privacidade das informa√ß√µes.

A imposi√ß√£o da seguran√ßa lida com o controle do acesso ao sistema de banco de dados como um todo e com o controle da autoriza√ß√£o para acessar partes espec√≠ficas  de  um  banco  de  dados.  O  primeiro  normalmente √© feito ao atribuir contas com senhas aos usu√°rios. O segundo pode ser realizado com o uso de um sistema de concess√£o e revoga√ß√£o de privil√©gios a  contas  individuais  para  acessar  partes  espec√≠ficas do banco de dados. Essa t√©cnica geralmente √© conhecida como controle de acesso discricion√°rio (DAC). Apresentamos  alguns  comandos  SQL  para  conceder  e  revogar  privil√©gios,  e  ilustramos  seu  uso  com exemplos.  Depois,  oferecemos  uma  vis√£o  geral  dos mecanismos de controle de acesso obrigat√≥rio (MAC) que  imp√µem  a  seguran√ßa  multin√≠vel.  Estes  exigem as  classifica√ß√µes  de  usu√°rios  e  valores  de  dados  em classes  de  seguran√ßa  e  imp√µem  as  regras  que  pro√≠bem o fluxo de informa√ß√µes dos n√≠veis de seguran√ßa mais altos para os mais baixos. Alguns dos principais conceitos  nos  quais  o  modelo  relacional  multin√≠vel se baseia, incluindo filtragem e poli-instancia√ß√£o, foram apresentados. O controle de acesso baseado em pap√©is (RBAC) foi introduzido, e atribui privil√©gios com base nos pap√©is que os usu√°rios desempenham. Abordamos a no√ß√£o de hierarquias de pap√©is, exclus√£o m√∫tua de pap√©is e seguran√ßa baseada em linha e r√≥tulo. Discutimos rapidamente o problema de controle  de  acesso  a  bancos  de  dados  estat√≠sticos  para proteger a privacidade de informa√ß√µes individuais e, ao mesmo tempo, oferecer acesso estat√≠stico a popula√ß√µes  de  registros.  Explicamos  as  principais  ideias por tr√°s da amea√ßa da Inje√ß√£o de SQL, os m√©todos nos quais ela pode ser induzida e os v√°rios tipos de riscos associados a ela. Depois, demos uma ideia das diversas formas como a Inje√ß√£o de SQL pode ser impedida. As quest√µes relacionadas a controle de fluxo e  os  problemas  associados  a  canais  secretos  foram discutidos em seguida, bem como a criptografia e as infraestruturas  baseadas  em  chave  p√∫blica/privada. A ideia de algoritmos de chave sim√©trica e o uso do popular esquema de infraestrutura de chave p√∫blica (PKI)  baseada  em  chave  assim√©trica  foram  explicados. Tamb√©m abordamos os conceitos de assinaturas digitais e certificados digitais. Destacamos a impor-

t√¢ncia de quest√µes de privacidade e sugerimos algumas t√©cnicas  de  preserva√ß√£o  da  privacidade.  Discutimos  uma  s√©rie  de  desafios  √†  seguran√ßa,  incluindo qualidade de dados, direitos de propriedade intelectual e sobreviv√™ncia do banco de dados. Terminamos o cap√≠tulo introduzindo a implementa√ß√£o de pol√≠ticas de seguran√ßa ao usar uma combina√ß√£o da seguran√ßa baseada em r√≥tulo e os bancos de dados privados virtuais no Oracle 11g.

## Perguntas de revis√£o

- 24.1. Discuta o significado de cada um dos seguintes termos: autoriza√ß√£o de banco de dados , controle de  acesso , criptografia  de  dados , conta privilegiada  (sistema) , auditoria  de  banco  de  dados , trilha de auditoria .
- 24.2. Que  conta  √©  designada  como  propriet√°ria  de uma rela√ß√£o? Que privil√©gios o propriet√°rio de uma rela√ß√£o possui?
- 24.3. Como o mecanismo de vis√£o √© usado como um mecanismo de autoriza√ß√£o?
- 24.4. Discuta os tipos de privil√©gios no n√≠vel de conta e aqueles no n√≠vel de rela√ß√£o.
- 24.5. O que significa a concess√£o de um privil√©gio? O que significa a revoga√ß√£o de um privil√©gio?
- 24.6. Discuta o sistema de propaga√ß√£o de privil√©gios e as restri√ß√µes impostas pelos limites de propaga√ß√£o horizontais e verticais.
- 24.7. Liste os tipos de privil√©gios dispon√≠veis em SQL.
- 24.8. Qual √© a diferen√ßa entre controle de acesso discricion√°rio e obrigat√≥rio ?
- 24.9. Quais s√£o as classifica√ß√µes de seguran√ßa t√≠picas? Discuta a propriedade de seguran√ßa simples e a propriedade  , e explique a justificativa por tr√°s * dessas regras para impor a seguran√ßa multin√≠vel.
- 24.10. Descreva o modelo de dados relacional multin√≠vel. Defina os seguintes termos: chave aparente , poli-instancia√ß√£o , filtragem .
- 24.11. Quais s√£o os m√©ritos relativos do uso do DAC ou do MAC?
- 24.12. O que √© controle de acesso baseado em papel? De  que  maneiras  ele  √©  superior  ao  DAC  e  ao MAC?
- 24.13. Quais s√£o os dois tipos de exclus√£o m√∫tua no controle de acesso baseado em papel?
- 24.14. O que significa controle de acesso em n√≠vel de linha?
- 24.15. O que √© a seguran√ßa de r√≥tulo? Como um administrador a imp√µe?
- 24.16. Quais s√£o os diferentes tipos de ataques de Inje√ß√£o de SQL?
- 24.17. Que riscos est√£o associados aos ataques de Inje√ß√£o de SQL?
- 24.18. Que medidas preventivas s√£o poss√≠veis contra os ataques de Inje√ß√£o de SQL?
- 24.19. O que √© um banco de dados estat√≠stico? Discuta o problema da seguran√ßa do banco de dados estat√≠stico.
- 24.20. Como  a  privacidade  est√°  relacionada  √†  seguran√ßa do banco de dados estat√≠stico? Que medidas podem ser tomadas para garantir algum grau de privacidade nos bancos de dados estat√≠sticos?
- 24.21. O que √© controle de fluxo como uma medida de seguran√ßa? Que tipos de controle de fluxo existem?
- 24.22. O que s√£o canais secretos? D√™ um exemplo de canal secreto.
- 24.23. Qual √© o objetivo da criptografia? Que processo est√° envolvido na criptografia de dados e sua recupera√ß√£o na outra ponta?
- 24.24. D√™ um exemplo de algoritmo de criptografia e explique como ele funciona.
- 24.25. Repita a pergunta anterior para o algoritmo popular RSA.
- 24.26. O que √© algoritmo de chave assim√©trica para a seguran√ßa baseada em chave?
- 24.27. O que √© esquema de infraestrutura de chave p√∫blica? Como ele oferece seguran√ßa?
- 24.28. O que s√£o assinaturas digitais? Como elas funcionam?
- 24.29. Que tipo  de  informa√ß√£o  um  certificado  digital inclui?

## Exerc√≠cios

- 24.30. Como a privacidade dos dados pode ser preservada em um banco de dados?
- 24.31. Quais  s√£o  alguns  dos  maiores  desafios  atuais para a seguran√ßa do banco de dados?

24.32.

Considere o esquema de banco de dados relacional  da  Figura  3.5.  Suponha  que  todas as rela√ß√µes tenham sido criadas pelo (e, portanto,  pertencem  ao)  usu√°rio X ,  que  deseja conceder os seguintes privil√©gios √†s contas de usu√°rio A  B , , C D , e E :

- a. A conta A pode recuperar ou modificar qualquer rela√ß√£o, exceto DEPENDENTE ,  e  pode conceder  qualquer  um  desses  privil√©gios  a outros usu√°rios.
- b. A conta B pode recuperar todos os atributos de FUNCIONARIO e DEPARTAMENTO , exceto Salario, Cpf\_ger e Data\_inicio\_ger.
- c. A  conta C pode  recuperar  ou  modificar TRABALHA\_EM ,  mas  s√≥  pode  recuperar  os atributos Pnome, Minicial, Unome e Cpf de FUNCIONARIO e  os  atributos Projnome e Projnumero de PROJETO.

- d. A conta D pode recuperar qualquer atributo de FUNCIONARIO ou DEPENDENTE e pode modificar DEPENDENTE.
- e. A conta E pode recuperar qualquer atributo de FUNCIONARIO , mas somente para tuplas de FUNCIONARIO que t√™m Dnr = 3.
- f. Escreva instru√ß√µes SQL para conceder esses privil√©gios. Use vis√µes onde for apropriado.

24.33.

Suponha que o privil√©gio (a) do Exerc√≠cio 24.32 deva  ser  dado  com GRANT OPTION ,  mas  somente para que a conta A possa conced√™-lo a no m√°ximo cinco contas, e cada uma dessas contas possa propagar o privil√©gio a outras contas, mas sem o privil√©gio GRANT OPTION . Quais seriam os  limites  de  propaga√ß√£o  horizontal  e  vertical nesse caso?

24.34. Considere a rela√ß√£o mostrada na Figura 24.2(d). Como ela apareceria para um usu√°rio com classifica√ß√£o U ? Suponha que um usu√°rio com classifica√ß√£o U tente atualizar o sal√°rio de 'Silva' para R$50.000; qual seria o resultado dessa a√ß√£o?

## Bibliografia selecionada

A  autoriza√ß√£o  baseada  na  concess√£o  e  revoga√ß√£o de  privil√©gios  foi  proposta  para  o  SGBD  experimental SYSTEM R e √© apresentada em Griffiths e Wade (1976). V√°rios livros discutem a seguran√ßa nos bancos de dados e  sistemas  de  computa√ß√£o  em  geral,  incluindo  os  livros de Leiss (1982a) e Fernandez et al. (1981), e Fugini et al. (1995). Natan (2005) √© um livro pr√°tico sobre quest√µes de seguran√ßa e auditoria em todos os principais SGBDRs.

Muitos artigos discutem as diferentes t√©cnicas para o projeto e prote√ß√£o de bancos de dados estat√≠sticos. Entre eles est√£o McLeish (1989), Chin e Ozsoyoglu (1981), Leiss  (1982),  Wong  (1984)  e  Denning  (1980).  Ghosh (1984) discute o uso de bancos de dados estat√≠sticos para o controle da qualidade. H√° tamb√©m muitos artigos que discutem a criptografia e a criptografia de dados, incluindo  Diffie  e  Hellman  (1979),  Rivest  et  al.  (1978),  Akl (1983), Pfleeger e Pfleeger (2007), Omura et al. (1990), Stallings (2000) e Iyer et al. (2004).

Halfond et al. (2006) ajudam a entender os conceitos  de  ataques  de  Inje√ß√£o  de  SQL  e  as  v√°rias  amea√ßas impostas por eles. O documento oficial Oracle (2007a)

explica como o Oracle √© menos pass√≠vel a um ataque de Inje√ß√£o de SQL em compara√ß√£o com o SQL Server. Ele tamb√©m oferece  uma  r√°pida  explica√ß√£o  de  como  esses ataques podem ser impedidos. Outras estruturas propostas s√£o discutidas em Boyd e Keromytis (2004), Halfond e Orso (2005) e McClure e Kr√ºger (2005).

A  seguran√ßa  multin√≠vel  √©  discutida  em  Jajodia  e Sandhu (1991), Denning et al. (1987), Smith e Winslett (1992), Stachour e Thuraisingham (1990), Lunt et al. (1990) e Bertino et al. (2001). Vis√µes gerais de quest√µes de pesquisa em seguran√ßa de banco de dados s√£o dadas por Lunt e Fernandez (1990), Jajodia e Sandhu (1991),  Bertino  (1998),  Castano  et  al.  (1995)  e  Thuraisingham et al. (2001). Os efeitos da seguran√ßa multin√≠vel  no  controle  de  concorr√™ncia  s√£o  discutidos  em Atluri et al. (1997). A seguran√ßa nos bancos de dados da pr√≥xima gera√ß√£o, sem√¢nticos e orientados a objeto √©  discutida  em  Rabbiti et al.  (1991),  Jajodia  e  Kogan (1990) e Smith (1990). Oh (1999) apresenta um modelo para a seguran√ßa discricion√°ria e obrigat√≥ria. Os modelos de seguran√ßa para aplica√ß√µes baseadas na Web e o controle de acesso baseado em papel s√£o discutidos em Joshi et al. (2001). As quest√µes de seguran√ßa para gerentes no contexto das aplica√ß√µes de e-commerce e a necessidade de modelos de avalia√ß√£o de risco para a sele√ß√£o de medidas apropriadas de controle de seguran√ßa s√£o discutidos em Farahmand et al. (2005). O controle de acesso em n√≠vel de linha √© explicado com detalhes em Oracle (2007b) e Sybase (2005). O √∫ltimo tamb√©m oferece  detalhes  sobre  hierarquia  de  papel  e  exclus√£o m√∫tua. Oracle (2009) explica como o Oracle usa o conceito de gerenciamento de identidade.

Avan√ßos recentes, bem como desafios futuros para seguran√ßa e privacidade de bancos de dados, s√£o discutidos  em  Bertino  e  Sandhu  (2005).  U.S.  Govt.  (1978), OECD (1980) e NRC (2003) s√£o boas refer√™ncias sobre a vis√£o da privacidade por importantes ag√™ncias do governo. Karat et al. (2009) discutem uma estrutura pol√≠tica  para  seguran√ßa  e  privacidade.  XML  e  controle  de acesso s√£o discutidos em Naedele (2003). Mais detalhes podem ser encontrados sobre as t√©cnicas de preserva√ß√£o da privacidade em Vaidya e Clifton (2004), direitos de propriedade intelectual em Sion et al. (2004) e sobreviv√™ncia de banco de dados em Jajodia et al. (1999). A tecnologia de VPD e a seguran√ßa baseada em r√≥tulo do Oracle s√£o discutidas com mais detalhes em Oracle (2007b).



N este  cap√≠tulo,  voltamos  nossa  aten√ß√£o  para  os bancos  de  dados  distribu√≠dos  (BDDs),  sistemas de  gerenciamento  de  bancos  de  dados  distribu√≠dos (SGBDDs), e de que forma a arquitetura cliente-servidor √© usada como uma plataforma para o desenvolvimento de aplica√ß√µes de banco de dados. Os bancos de dados distribu√≠dos levam as vantagens da computa√ß√£o distribu√≠da para o dom√≠nio do gerenciamento de banco de dados. Um sistema de computa√ß√£o distribu√≠do consiste em uma s√©rie de elementos de processamento, n√£o necessariamente homog√™neos, que s√£o interconectados por uma rede de computadores e que cooperam na realiza√ß√£o de certas tarefas atribu√≠das. Como um objetivo geral, os sistemas de computa√ß√£o distribu√≠dos dividem um grande problema, dif√≠cil de ser administrado em partes menores, solucionando-o de modo eficiente de uma maneira coordenada. A viabilidade econ√¥mica dessa t√©cnica tem duas raz√µes: mais poder de computa√ß√£o √© aproveitado para solucionar uma tarefa complexa, e cada elemento de processamento aut√¥nomo pode ser gerenciado independentemente para desenvolver as pr√≥prias aplica√ß√µes.

A tecnologia de BDD √© o resultado de uma fus√£o de duas tecnologias: tecnologia de banco de dados e tecnologia de rede e comunica√ß√£o de dados. As redes de computadores permitem o processamento distribu√≠do de dados. Bancos de dados tradicionais, por sua vez, enfocam o fornecimento de acesso centralizado e controlado aos dados. Os bancos de dados distribu√≠dos  permitem  uma  integra√ß√£o  de  informa√ß√µes e seu processamento por aplica√ß√µes que podem, por si mesmas, ser centralizadas ou distribu√≠das.

Diversos sistemas de prot√≥tipo de banco de dados  distribu√≠do  foram  desenvolvidos  na  d√©cada  de 1980 para resolver as quest√µes de distribui√ß√£o de dados, consulta distribu√≠da e processamento de transa-

## Bancos de dados distribu√≠dos

√ß√£o, gerenciamento de metadados de banco de dados distribu√≠do  e  outros  assuntos.  Por√©m,  um  SGBDD abrangente  em  escala  completa,  que  implementa  a funcionalidade  e  as  t√©cnicas  propostas  na  pesquisa em BDD, nunca surgiu como um produto comercialmente  vi√°vel.  A  maioria  dos  principais  vendedores redirecionou  seus  esfor√ßos  de  desenvolvimento  de um produto SGBDD puro para o desenvolvimento de sistemas com base nos conceitos cliente-servidor, ou para o desenvolvimento de tecnologias para acessar fontes de dados heterog√™neas distribu√≠das.

As organiza√ß√µes continuam a estar interessadas na descentraliza√ß√£o do  processamento  (no  n√≠vel  de sistema) enquanto alcan√ßam uma integra√ß√£o dos recursos de informa√ß√£o (no n√≠vel l√≥gico) dentro de seus sistemas de bancos de dados, aplica√ß√µes e usu√°rios distribu√≠dos  geograficamente.  Agora,  existe  um  endosso geral da abordagem cliente-servidor para o desenvolvimento de aplica√ß√µes, e a abordagem de tr√™s camadas para o desenvolvimento de aplica√ß√µes Web (ver Se√ß√£o 2.5).

Neste cap√≠tulo, discutimos os bancos de dados distribu√≠dos, suas varia√ß√µes arquitet√¥nicas e conceitos  centrais  √†  distribui√ß√£o  de  dados  e  ao  gerenciamento  de  dados  distribu√≠dos.  Alguns  detalhes  dos avan√ßos nas tecnologias de comunica√ß√£o que facilitam o desenvolvimento de BDDs est√£o fora do escopo deste livro; veja os textos sobre comunica√ß√µes de dados e redes, listados na bibliografia selecionada ao final deste cap√≠tulo.

A  Se√ß√£o  25.1  introduz  conceitos  de  gerenciamento de banco de dados distribu√≠do e outros relacionados. As se√ß√µes 25.2 e 25.3 apresentam diferentes tipos de sistemas de bancos de dados distribu√≠dos e  suas  arquiteturas,  incluindo  sistemas  federados  e multibanco de dados. Os problemas de heterogenei-

dade e as necessidades de autonomia nos sistemas de bancos de dados federados tamb√©m s√£o destacados. Quest√µes detalhadas sobre projeto de banco de dados distribu√≠do, envolvendo fragmenta√ß√£o de dados e sua distribui√ß√£o por v√°rios locais com poss√≠vel replica√ß√£o, s√£o discutidas na Se√ß√£o 25.4. As se√ß√µes 25.5 e 25.6 apresentam as t√©cnicas de processamento de transa√ß√£o e consulta de banco de dados distribu√≠do, respectivamente. A Se√ß√£o 25.7 oferece uma vis√£o geral  do  controle  de  concorr√™ncia  e  recupera√ß√£o  nos bancos de dados distribu√≠dos. A Se√ß√£o 25.8 discute os esquemas de gerenciamento de cat√°logo nos bancos  de  dados  distribu√≠dos.  Na  Se√ß√£o  25.9,  abordamos rapidamente as tend√™ncias atuais nos bancos de dados distribu√≠dos, como a computa√ß√£o em nuvem e os bancos de dados peer-to-peer. A Se√ß√£o 25.10 discute  os  recursos  de  banco  de  dados  distribu√≠do  do SGBDR Oracle. No final do cap√≠tulo h√° um resumo.

Para obter uma r√°pida introdu√ß√£o ao assunto de bancos de dados distribu√≠dos, as se√ß√µes 25.1, 25.2 e 25.3 podem ser estudadas.

## 25.1 Conceitos de banco de dados distribu√≠do 1

Podemos definir um banco de dados distribu√≠do (BDD) como uma cole√ß√£o de m√∫ltiplos bancos de dados logicamente inter-relacionados, distribu√≠dos por uma rede de computadores, e um sistema de gerenciamento  de  banco  de  dados  distribu√≠do  (SGBDD) como um sistema de software que gerencia um banco de dados distribu√≠do enquanto torna a distribui√ß√£o transparente ao usu√°rio. 2

## 25.1.1 Diferen√ßas entre sistemas multiprocessadores e BDD

Precisamos distinguir os bancos de dados distribu√≠dos dos sistemas multiprocessadores que usam armazenamento compartilhado (mem√≥ria prim√°ria ou disco). Para um banco de dados ser chamado de distribu√≠do, as seguintes condi√ß√µes m√≠nimas devem ser satisfeitas:

- ¬Ñ Conex√µes de n√≥s de banco de dados por uma rede de computadores. Existem v√°rios computadores, chamados sites ou n√≥s . Esses sites devem ser  conectados  por  uma rede  de  comunica√ß√£o b√°sica para transmitir dados e comandos entre sites, como mostramos adiante na Figura 25.3(c).
- ¬Ñ Inter-rela√ß√£o l√≥gica dos bancos de dados conectados. √â essencial que as informa√ß√µes nos bancos de dados sejam relacionadas logicamente.
- ¬Ñ Aus√™ncia de restri√ß√£o de homogeneidade entre os n√≥s conectados. N√£o √© necess√°rio que todos os n√≥s sejam id√™nticos em rela√ß√£o aos dados, hardware e software.

Todos os sites podem estar localizados nas proximidades f√≠sicas - digamos, dentro do mesmo pr√©dio ou um grupo de pr√©dios adjacentes - e conectados por uma rede local , ou podem estar distribu√≠dos geograficamente por grandes dist√¢ncias e conectados por uma rede de longa dist√¢ncia ou rede remota .  As  redes  locais  costumam utilizar hubs sem fio ou cabos, enquanto as redes de longa dist√¢ncia utilizam linhas telef√¥nicas ou sat√©lites. Tamb√©m √© poss√≠vel usar uma combina√ß√£o de redes.

Os bancos de dados distribu√≠dos s√£o diferentes dos arquivos Web da Internet. As p√°ginas Web s√£o basicamente uma cole√ß√£o muito grande de arquivos armazenados  em  diferentes  n√≥s  em  uma  rede  -  a Internet  -  com  inter-relacionamentos  entre  os  arquivos,  representados  por  hyperlinks.  As  fun√ß√µes comuns  do  gerenciamento  de  banco  de  dados,  incluindo o processamento de consulta uniforme e o processamento de transa√ß√£o, ainda n√£o se aplicam a esse cen√°rio. A tecnologia, no entanto, est√° mudando para  uma  dire√ß√£o  tal  que  os  bancos  de  dados  distribu√≠dos da World Wide Web (WWW) se tornar√£o uma  realidade  no  futuro.  Discutimos  algumas  das quest√µes de acesso a bancos de dados na web nos cap√≠tulos 12 e 14. A prolifera√ß√£o de dados em milh√µes de sites Web em v√°rias formas n√£o se qualifica como um BDD pela defini√ß√£o dada anteriormente.

As redes podem ter diferentes topologias que definem os caminhos de comunica√ß√£o diretos entre os sites. O tipo e a topologia da rede utilizada podem ter um impacto significativo no desempenho e, portanto, nas estrat√©gias para o processamento de consulta distribu√≠do e o projeto de banco de dados distribu√≠do. Para quest√µes arquitet√¥nicas de alto n√≠vel, por√©m, n√£o importa o tipo da rede utilizada; o que importa √© que cada site seja capaz de se comunicar, direta ou indiretamente, com todos  os  outros  sites.  Para  o  restante  deste  cap√≠tulo, consideramos que existe algum tipo de rede de comunica√ß√£o entre os sites, independentemente de qualquer topologia em particular. N√£o abordaremos quaisquer quest√µes  espec√≠ficas  da  rede,  embora  seja  importante entender que, para uma opera√ß√£o eficiente de um sistema de banco de dados distribu√≠do (SBDD), quest√µes de projeto e desempenho da rede s√£o cr√≠ticos e fazem parte integral da solu√ß√£o geral. Os detalhes da rede de comunica√ß√£o b√°sica s√£o invis√≠veis ao usu√°rio final.

1 Agradecemos a Narasimhan Srinivasan por sua contribui√ß√£o substancial a esta e a v√°rias outras se√ß√µes deste cap√≠tulo.

2 Esta defini√ß√£o e as discuss√µes nesta se√ß√£o s√£o baseadas em grande parte em Ozsu e Valduriez (1999).

## 25.1.2 ranspar√™ncia T

O conceito de transpar√™ncia estende a ideia geral de ocultar detalhes da implementa√ß√£o dos usu√°rios finais.  Um  sistema  altamente  transparente  oferece muita  flexibilidade  ao  usu√°rio  final/desenvolvedor de aplica√ß√£o, pois requer pouco ou nenhum conhecimento dos detalhes b√°sicos de sua parte. No caso de um banco de dados centralizado tradicional, a transpar√™ncia simplesmente pertence √† independ√™ncia l√≥gica e f√≠sica de dados para desenvolvedores de aplica√ß√£o. Contudo, em um cen√°rio de BDD, os dados e software s√£o distribu√≠dos por v√°rios sites conectados por uma rede de computadores, de modo que tipos adicionais de transpar√™ncias s√£o introduzidos.

Considere o banco de dados de empresa da Figura 3.5, que usamos como exemplo no decorrer do livro. As tabelas FUNCIONARIO, PROJETO e TRABA -LHA\_EM podem  ser  fragmentadas  horizontalmente (ou seja, em conjuntos de linhas, conforme discutiremos na Se√ß√£o 25.4) e armazenadas com poss√≠vel replica√ß√£o, como mostra a Figura 25.1. Os seguintes tipos de transpar√™ncias s√£o poss√≠veis:

- ¬Ñ Transpar√™ncia  da  organiza√ß√£o  dos  dados (tamb√©m  conhecida  como transpar√™ncia  de distribui√ß√£o ou de rede ). Isso  se  refere  √†  liberdade para o usu√°rio de detalhes operacionais da rede e o posicionamento dos dados no sistema distribu√≠do. Ela pode ser dividida em transpar√™ncia de local e transpar√™ncia de nomes. Transpar√™ncia de local refere-se ao fato

de que o comando usado para realizar uma tarefa  √©  independente  do  local  dos  dados  e do local do n√≥ onde o comando foi emitido. Transpar√™ncia de nomes implica que, quando um nome √© associado a um objeto, os objetos nomeados podem ser acessados sem ambiguidade, sem especifica√ß√£o adicional quanto ao local onde os dados se encontram.

- ¬Ñ Transpar√™ncia de replica√ß√£o. Como mostramos na Figura 25.1, as c√≥pias dos mesmos objetos de dados podem ser armazenadas em v√°rios sites para melhor disponibilidade, desempenho e confiabilidade. A transpar√™ncia de replica√ß√£o torna o usu√°rio desavisado da exist√™ncia dessas c√≥pias.
- ¬Ñ Transpar√™ncia de fragmenta√ß√£o. Dois tipos de fragmenta√ß√£o  s√£o  poss√≠veis.  A fragmenta√ß√£o horizontal distribui  uma  rela√ß√£o  (tabela)  em sub-rela√ß√µes  que  s√£o  subconjuntos  de  tuplas (linhas)  na  rela√ß√£o  original.  A fragmenta√ß√£o vertical distribui uma rela√ß√£o em sub-rela√ß√µes em que cada uma √© definida por um subconjunto  das  colunas  da  rela√ß√£o  original.  Uma consulta global pelo usu√°rio precisa ser transformada em v√°rias consultas de fragmento. A transpar√™ncia de fragmenta√ß√£o torna o usu√°rio desavisado da exist√™ncia de fragmentos.
- ¬Ñ Outras transpar√™ncias incluem transpar√™ncia de projeto e transpar√™ncia de execu√ß√£o - referindo-se √† liberdade de saber como o banco de dados distribu√≠do √© projetado e onde uma transa√ß√£o √© executada.



## 25.1.3 Autonomia

A autonomia determina a extens√£o √† qual os n√≥s individuais  ou  BDs  em  um  BDD  conectado  podem operar independentemente. Um alto grau de autonomia √© desej√°vel para maior flexibilidade e manuten√ß√£o personalizada de um n√≥ individual. A autonomia pode ser aplicada ao projeto, comunica√ß√£o e execu√ß√£o. A autonomia  de  projeto refere-se  √†  independ√™ncia  do uso do modelo de dados e t√©cnicas de gerenciamento de transa√ß√£o entre n√≥s. A autonomia de comunica√ß√£o determina a extens√£o √† qual cada n√≥ pode decidir sobre o compartilhamento de informa√ß√µes com outros n√≥s. A autonomia de execu√ß√£o refere-se √† independ√™ncia dos usu√°rios para atuarem conforme desejarem.

## 25.1.4 Confiabilidade e disponibilidade

Confiabilidade  e  disponibilidade  s√£o  duas  das vantagens em potencial mais comuns citadas para bancos de dados distribu√≠dos. A confiabilidade √© definida em termos gerais como a probabilidade de um sistema estar funcionando (n√£o parado) em certo ponto no tempo, enquanto a disponibilidade √© a probabilidade de que o sistema esteja continuamente dispon√≠vel durante um intervalo de tempo. Podemos relacionar diretamente  confiabilidade  e  disponibilidade  do  banco de dados aos defeitos, erros e falhas associadas a ele. Uma falha pode ser descrita como um desvio de um comportamento do sistema daquele especificado a fim de  garantir  a  execu√ß√£o  correta  das  opera√ß√µes. Erros constituem o subconjunto de estados do sistema que causam a falha. Falha √© a causa de um erro.

Para construir um sistema que seja confi√°vel, podemos adotar v√°rias t√©cnicas.  Uma  t√©cnica  comum enfatiza a toler√¢ncia a corre√ß√µes ;  ela reconhece que as  falhas  ocorrer√£o,  e  projeta  mecanismos  que  podem detectar e remover falhas antes que elas possam resultar em uma falha do sistema. Outra t√©cnica mais rigorosa tenta garantir que o sistema final n√£o ter√° falha alguma. Isso √© feito por meio de um processo de projeto abrangente, seguido por controle de qualidade e teste abrangentes. Um SGBDD confi√°vel tolera falhas dos componentes b√°sicos e processa solicita√ß√µes do usu√°rio desde que a coer√™ncia do banco de dados n√£o seja violada. Um gerenciador de recupera√ß√£o do SGBDD precisa lidar com falhas que surgem de  transa√ß√µes,  hardware  e  redes  de  comunica√ß√£o. As falhas de hardware podem ser aquelas que resultam em perda do conte√∫do da mem√≥ria principal ou perda  de  conte√∫do  do  armazenamento  secund√°rio. As falhas de comunica√ß√£o ocorrem devido a erros associados a mensagens e falhas na linha. Os erros de mensagem podem incluir sua perda, adultera√ß√£o ou chegada fora de ordem no destino.

## 25.1.5 Vantagens dos bancos de dados distribu√≠dos

As organiza√ß√µes lan√ßam m√£o do gerenciamento de banco de dados distribu√≠do por diversos motivos. Algumas vantagens importantes s√£o listadas a seguir.

- 1. Maior facilidade e flexibilidade de desenvolvimento da aplica√ß√£o. O desenvolvimento e a manuten√ß√£o de aplica√ß√µes em sites geograficamente distribu√≠dos de uma organiza√ß√£o s√£o facilitados  devido  √†  transpar√™ncia  da  distribui√ß√£o e controle de dados.
- 2. Maior confiabilidade e disponibilidade. Isso √©  obtido  pelo  isolamento  de  falhas  ao  seu site  de  origem,  sem afetar os outros bancos de dados conectados √† rede. Quando os dados e o software de SGBDD s√£o distribu√≠dos por  v√°rios  sites,  um  destes  pode  apresentar falha  enquanto  outros  continuam  a  operar. Apenas os dados e software que existem no site  defeituoso  n√£o  poder√£o  ser  acessados. Isso melhora tanto a confiabilidade quanto a disponibilidade.  Uma  melhoria  ainda  maior √© obtida pela devida replica√ß√£o dos dados e software em mais de um site. Em um sistema centralizado, uma falha em um √∫nico site torna o sistema inteiro indispon√≠vel a todos os usu√°rios. Em um banco de dados distribu√≠do, alguns dos dados podem ficar inalcan√ß√°veis, mas os usu√°rios ainda podem ser capazes de acessar outras partes do banco de dados. Se os dados no site que apresentou falha tiverem sido duplicados em outro site antes da falha, ent√£o  o  usu√°rio  n√£o  ser√°  afetado  de  forma alguma.
- 3. Maior  desempenho. Um  SGBD  distribu√≠do fragmenta  o  banco  de  dados  ao  manter  os dados mais pr√≥ximos de onde eles s√£o mais necess√°rios.  A localiza√ß√£o  de  dados reduz a  disputa  pela  CPU  e  servi√ßos  de  E/S  e,  ao mesmo  tempo,  reduz  os  atrasos  no  acesso envolvidos  nas  redes  remotas.  Quando  um banco de dados grande √© distribu√≠do por v√°rios sites, existem bancos de dados menores em  cada  site.  Como  resultado,  consultas  e transa√ß√µes locais que acessam dados em um √∫nico site possuem melhor desempenho por causa  dos  bancos  de  dados  locais  menores. Al√©m disso, cada site tem um n√∫mero menor de transa√ß√µes executando do que se todas as transa√ß√µes  fossem  submetidas  a  um  √∫nico banco de dados centralizado. Ainda, o paralelismo entre consultas e dentro da consulta pode ser  alcan√ßado  ao  executar  v√°rias  con-

- sultas em diferentes sites, ou ao desmembrar uma consulta em uma s√©rie de subconsultas executadas em paralelo. Isso contribui para melhorar o desempenho.
- 4. Expans√£o mais f√°cil. Em um ambiente distribu√≠do, a expans√£o do sistema em mat√©ria de inclus√£o de mais dados, aumento dos tamanhos do banco de dados ou inclus√£o de mais processadores √© muito mais f√°cil.

As transpar√™ncias que discutimos na Se√ß√£o 25.1.2 levam a um comprometimento entre a facilidade de uso e o custo de overhead da provis√£o da transpar√™ncia.  A  transpar√™ncia  total  oferece  ao  usu√°rio  global uma vis√£o do SBDD inteiro como se fosse um √∫nico  sistema  centralizado.  A  transpar√™ncia  √©  fornecida como um complemento √† autonomia , que d√° aos usu√°rios um controle mais estrito sobre os bancos de dados  locais.  Os  recursos  de  transpar√™ncia  podem ser implementados como uma parte da linguagem do usu√°rio, que pode traduzir os servi√ßos requisitados em opera√ß√µes  apropriadas.  Al√©m  disso,  a  transpar√™ncia afeta os recursos que devem ser fornecidos pelo sistema operacional e pelo SGBD.

## 25.1.6 un√ß√µes adicionais dos bancos de F dados distribu√≠dos

A distribui√ß√£o leva a uma maior complexidade no projeto e implementa√ß√£o do sistema. Para conseguir as vantagens em potencial j√° listadas, o software de SGBDD precisa ser capaz de oferecer as seguintes fun√ß√µes, al√©m daquelas de um SGBD centralizado:

- ¬Ñ Acompanhar a distribui√ß√£o de dados. A  capacidade  de  acompanhar  a  distribui√ß√£o  de dados, fragmenta√ß√£o e replica√ß√£o ao expandir o cat√°logo do SGBDD.
- ¬Ñ Processamento de consulta distribu√≠do. A capacidade de acessar sites remotos e transmitir consultas e dados entre os v√°rios sites por meio de uma rede de comunica√ß√£o.
- ¬Ñ Gerenciamento de transa√ß√£o distribu√≠do. A  capacidade  de  criar  estrat√©gias  de  execu√ß√£o para consultas e transa√ß√µes que acessem dados de mais de um site e de sincronizar o acesso  aos  dados  distribu√≠dos,  mantendo  a integridade do banco de dados geral.
- ¬Ñ Gerenciamento de dados replicado. A capacidade de decidir qual c√≥pia de um item de dados replicado  acessar  e  de  manter  a  consist√™ncia das c√≥pias de um item de dados replicado.
- ¬Ñ Recupera√ß√£o de banco de dados distribu√≠do. A capacidade de recuperar-se de falhas no site

individual e de novos tipos de falhas, como a dos links de comunica√ß√£o.

- ¬Ñ Seguran√ßa. As  transa√ß√µes  distribu√≠das  precisam  ser  executadas  com  o  gerenciamento apropriado da seguran√ßa dos dados e dos privil√©gios de autoriza√ß√£o/acesso dos usu√°rios.
- ¬Ñ Gerenciamento  de  diret√≥rio  (cat√°logo)  distribu√≠do. Um  diret√≥rio  cont√©m  informa√ß√µes (metadados) sobre os dados no banco de dados. O diret√≥rio pode ser global, para o BDD inteiro, ou local para cada site. O posicionamento e a distribui√ß√£o do diret√≥rio s√£o quest√µes de projeto e diretriz.

Essas  pr√≥prias  fun√ß√µes  aumentam  a  complexidade de um SGBDD em rela√ß√£o a um SGBD centralizado. Antes que possamos observar todas as vantagens em potencial da distribui√ß√£o, temos de encontrar solu√ß√µes satisfat√≥rias para essas quest√µes e problemas de projeto.  √â  dif√≠cil  conseguir  a  inclus√£o  de  toda  essa funcionalidade adicional, e encontrar solu√ß√µes ideais √© um passo al√©m.

## 25.2 Tipos de sistemas de bancos de dados distribu√≠dos

O termo sistema de gerenciamento de banco de dados  distribu√≠do pode  descrever  diversos  sistemas que diferem um do outro em muitos aspectos. O item principal que todos os sistemas t√™m em comum √© o fato de os dados e software serem distribu√≠dos por v√°rios sites conectados por alguma forma de rede de comunica√ß√£o. Nesta se√ß√£o, discutimos uma s√©rie de tipos de SGBDDs e os crit√©rios e fatores que tornam alguns desses sistemas diferentes.

O primeiro fator que consideramos √© o grau de homogeneidade do  software  de  SGBDD.  Se  todos os servidores (ou SGBDs locais individuais) usarem software id√™ntico e todos os usu√°rios (clientes) utilizarem software id√™ntico, o SGBDD √© chamado de homog√™neo ; caso contr√°rio, ele √© chamado de heterog√™neo . Outro fator relacionado ao grau de homogeneidade √© o grau de autonomia local . Se n√£o houver provis√£o para o site local funcionar como um SGBD independente,  ent√£o  o  sistema n√£o  tem  autonomia local . Contudo, se o acesso direto por transa√ß√µes locais a um servidor for permitido, o sistema tem algum grau de autonomia local.

A Figura 25.2 mostra a classifica√ß√£o das alternativas do SGBDD junto com eixos ortogonais de distribui√ß√£o, autonomia e heterogeneidade. Para um banco de dados centralizado, existe autonomia completa, mas uma total falta de distribui√ß√£o e heterogeneidade (Ponto A na figura). Vemos que o grau de autonomia

Figura 25.2 Classifica√ß√£o de bancos de dados distribu√≠dos.



local oferece mais espa√ßo para classifica√ß√£o em sistemas federados e multibanco de dados. No outro extremo do espectro da autonomia, temos um SGBDD que se parece com um SGBD centralizado para o usu√°rio, com autonomia zero (Ponto B). Existe um √∫nico esquema conceitual, e todo acesso ao sistema √© obtido por meio de um site que faz parte do SGBDD o que significa que n√£o existe autonomia local. Ao longo do eixo da autonomia encontramos dois tipos de  SGBDDs,  chamados sistema  de  banco  de  dados federado (Ponto  C)  e sistema  multibanco  de  dados (Ponto D). Em tais sistemas, cada servidor √© um SGBD centralizado  independente  e  aut√¥nomo,  que  tem  os pr√≥prios usu√°rios locais, transa√ß√µes locais e DBA, e, portanto, tem um grau bem alto de autonomia local . O termo sistema de banco de dados federado (SBDF) √© usado quando existe alguma vis√£o ou esquema global da federa√ß√£o de bancos de dados que √© compartilhada pelas aplica√ß√µes (Ponto C). Por sua vez, um sistema multibanco de dados tem uma autonomia local completa porque n√£o possui um esquema global, mas constr√≥i um interativamente conforme a necessidade da aplica√ß√£o (Ponto D). 3  Ambos os sistemas s√£o h√≠bridos entre sistemas distribu√≠dos e centralizados, e a distin√ß√£o que fizemos entre eles n√£o √© estritamente seguida. Vamos nos referir a eles como SBDFs em um sentido gen√©rico. O Ponto D no diagrama tamb√©m pode indicar um sistema com autonomia local e heterogeneidade totais - este poderia ser um sistema de banco de dados peer-to-peer (ver Se√ß√£o 25.9.2). Em um SBDF heterog√™neo, um servidor pode ser um SGBD relacional, outro, um SGBD de rede (como o IDMS da Computer Associates ou o IMAGE/3000 da HP), e um terceiro, um SGBD de objeto (como o ObjectStore da Object Design) ou um SGBD hier√°rquico (como o IMS da IBM); nesse caso, √© necess√°rio ter uma linguagem de sistema can√¥nica e incluir tradutores para passar subconsultas da linguagem can√¥nica para a linguagem de cada servidor.

Em seguida, discutimos rapidamente as quest√µes que afetam o projeto dos SBDFs.

## 25.2.1 Problemas com sistemas de gerenciamento de banco de dados federados

O tipo de heterogeneidade presente nos SBDFs pode  surgir  de  v√°rias  fontes.  Discutimos  primeiro essas fontes e, depois, indicamos como os diferentes tipos  de  autonomias  contribuem  para  uma  hetero-

3 O termo sistema de multibanco de dados n√£o se aplica facilmente √† maioria dos ambientes de TI empresariais. A no√ß√£o de construir um esquema global como e quando houver necessidade n√£o √© muito vi√°vel na pr√°tica para bancos de dados de empresa.

geneidade sem√¢ntica que deve ser resolvida em um SBDF heterog√™neo.

- ¬Ñ Diferen√ßas nos modelos de dados. Os bancos de dados em uma organiza√ß√£o v√™m de uma s√©rie de modelos de dados, incluindo os chamados  modelos  legados  (hier√°rquicos  e  de rede, ver ap√™ndices D e E na Web), o modelo de  dados  relacional,  o  modelo  de  dados  de objeto e at√© mesmo arquivos. As capacidades de  modelagem  variam.  Portanto,  lidar  com os modelos uniformemente por meio de um √∫nico  esquema  global  ou  process√°-los  em uma √∫nica linguagem √© algo desafiador. Mesmo que dois bancos de dados sejam ambos do ambiente do SGBDR, a mesma informa√ß√£o pode ser representada como um nome de atributo, como um nome de rela√ß√£o ou como um valor em bancos de dados diferentes. Isso exige um mecanismo inteligente de processamento de consulta, que possa relacionar informa√ß√µes com base nos metadados.
- ¬Ñ Diferen√ßas  nas  restri√ß√µes. As  facilidades  de restri√ß√£o para a especifica√ß√£o e a implementa√ß√£o variam de um sistema para outro. Existem recursos compar√°veis que devem ser reconciliados na constru√ß√£o de um esquema global. Por  exemplo,  os  relacionamentos  dos  modelos  ER s√£o representados como restri√ß√µes de integridade  referencial  no  modelo  relacional. Triggers podem precisar ser usados para implementar certas restri√ß√µes no modelo relacional. O esquema global tamb√©m deve lidar com conflitos em potencial entre as restri√ß√µes.
- ¬Ñ Diferen√ßas  nas  linguagens  de  consulta. At√© com o mesmo modelo de dados, as linguagens e  suas  vers√µes  variam.  Por  exemplo,  a  SQL tem diversas vers√µes, como SQL-89, SQL-92, SQL-99 e SQL:2008, e cada  sistema  tem  o pr√≥prio conjunto de tipos de dados, operadores de compara√ß√£o, recursos de manipula√ß√£o de string etc.

Heterogeneidade sem√¢ntica. A heterogeneidade sem√¢ntica ocorre quando existem diferen√ßas no significado, interpreta√ß√£o e uso intencionado dos mesmos dados ou dados relacionados. A heterogeneidade sem√¢ntica entre os sistemas de banco de dados (SBDs) componentes cria o maior obst√°culo no projeto de esquemas globais de bancos de dados heterog√™neos. A autonomia de projeto dos SBDs componentes refere-se a sua liberdade de escolher os seguintes par√¢metros de projeto, que, por sua vez, afetam a eventual complexidade do SBDF:

- ¬Ñ O universo de discurso do qual os dados s√£o retirados. Por exemplo, para duas contas de cliente, os bancos de dados na federa√ß√£o podem ser dos Estados Unidos e do Jap√£o e ter conjuntos de atributos totalmente diferentes sobre contas de  cliente,  exigidos  pelas  pr√°ticas  cont√°beis. Flutua√ß√µes de taxa de c√¢mbio tamb√©m apresentam um problema. Logo, as rela√ß√µes desses dois bancos de dados que possuem nomes id√™nticos -CLIENTE ou CONTA -  podem ter algumas informa√ß√µes comuns e outras totalmente distintas.
- ¬Ñ Representa√ß√£o e nomea√ß√£o. A representa√ß√£o e  a  nomea√ß√£o dos elementos de dados e da estrutura do modelo de dados podem ser previamente  especificadas  para  cada  banco  de dados local.
- ¬Ñ O  conhecimento,  significado  e  interpreta√ß√£o subjetiva dos dados. Essa √© uma contribui√ß√£o importante para a heterogeneidade sem√¢ntica.
- ¬Ñ Restri√ß√µes de transa√ß√£o e de diretriz. Lidam com  crit√©rios  de  serializa√ß√£o,  transa√ß√µes  de compensa√ß√£o e outras diretrizes de transa√ß√£o.
- ¬Ñ Deriva√ß√£o de resumos. Agrega√ß√£o, resumo e outros recursos e opera√ß√µes de processamento de dados admitidos pelo sistema.

Esses problemas relacionados √† heterogeneidade sem√¢ntica est√£o sendo encarados por todas as principais organiza√ß√µes multinacionais e governamentais em todas as √°reas de aplica√ß√£o. No ambiente comercial de hoje, a maioria das empresas est√° lan√ßando m√£o de SBDFs heterog√™neos, investindo pesado no desenvolvimento de sistemas de banco de dados individuais, usando diversos modelos de dados em diferentes plataformas nos √∫ltimos 20 a 30 anos. As empresas est√£o utilizando diversas formas de software - normalmente  chamado de middleware ,  ou  pacotes baseados na Web, chamados servidores de aplica√ß√£o (por exemplo, WebLogic ou WebSphere), e at√© mesmo sistemas gen√©ricos, chamados sistemas de Enterprise Resource Planning (ERP) (por exemplo, SAP, J. D. Edwards ERP) para gerenciar o transporte de consultas e transa√ß√µes da aplica√ß√£o global para bancos de dados individuais (com poss√≠vel processamento adicional para regras de neg√≥cios) e os dados dos servidores de banco de dados heterog√™neos para a aplica√ß√£o global. Uma discuss√£o detalhada  desses  tipos  de  sistemas  de  software  est√° fora do escopo deste livro.

Assim como oferecer a transpar√™ncia definitiva √© o objetivo de qualquer arquitetura de banco de dados distribu√≠do, os bancos de dados componentes locais lutam para preservar a autonomia. A autonomia de

comunica√ß√£o de um SBD componente refere-se a sua capacidade de decidir se ir√° se comunicar com outro SBD componente. A autonomia da execu√ß√£o refere-se √† capacidade de um SBD componente executar opera√ß√µes locais sem interfer√™ncia das opera√ß√µes externas por outros SBDs componentes e sua capacidade de decidir a ordem em que ser√£o executadas. A autonomia da associa√ß√£o de um SBD componente implica que ele tem a capacidade de decidir se e quanto compartilhar de sua funcionalidade (opera√ß√µes que ele suporta) e recursos (dados que ele gerencia) com outros SBDs componentes. O maior desafio do projeto de SBDFs √© permitir que os SBDs componentes interoperem enquanto ainda lhes fornecem os tipos de autonomias apresentados anteriormente.

## 25.3 Arquiteturas de banco de dados distribu√≠das

Nesta se√ß√£o, primeiro mostramos rapidamente a distin√ß√£o entre arquiteturas de banco de dados paralela e distribu√≠da. Embora ambas estejam bastante presentes  na  ind√∫stria  hoje,  existem  diversas  manifesta√ß√µes das arquiteturas distribu√≠das que est√£o continuamente evoluindo entre as grandes empresas. A arquitetura paralela √© mais comum na computa√ß√£o de alto desempenho, em que h√° uma necessidade de arquiteturas multiprocessadoras para enfrentar o volume de dados passando por aplica√ß√µes de processamento de transa√ß√£o e warehousing. Depois, apresentamos a arquitetura gen√©rica de um banco de dados distribu√≠do.  Isso  √©  seguido  por  discuss√µes  sobre  a arquitetura dos sistemas de banco de dados de tr√™s camadas cliente-servidor e federados.

## 25.3.1 Arquiteturas paralelas versus distribu√≠das

Existem dois tipos principais de arquiteturas de sistema multiprocessador que s√£o comumente utilizados:

- ¬Ñ Arquitetura  de  mem√≥ria  compartilhada  (altamente acoplada). M√∫ltiplos  processadores compartilham armazenamento secund√°rio (disco) e tamb√©m mem√≥ria principal.
- ¬Ñ Arquitetura  de  disco  compartilhado  (livremente  acoplada). M√∫ltiplos  processadores compartilham armazenamento secund√°rio (disco), mas cada um tem a pr√≥pria mem√≥ria principal.

Essas arquiteturas permitem que os processadores se comuniquem sem o overhead de trocar mensagens por uma rede. 4  Os sistemas de gerenciamento de banco de dados desenvolvidos que utilizam esses tipos  de  arquiteturas  s√£o  chamados  de sistemas  de gerenciamento de banco de dados paralelos , em vez de SGBDDs, pois utilizam a tecnologia de processadores paralelos. Outro tipo de arquitetura de multiprocessador √© chamado de arquitetura nada compartilhado .  Nessa arquitetura, cada processador tem a pr√≥pria mem√≥ria principal e secund√°ria (disco), n√£o existe mem√≥ria comum e os processadores se comunicam por uma rede de interconex√£o de alta velocidade (barramento ou switch). Embora a arquitetura nada compartilhado seja semelhante a um ambiente de computa√ß√£o de banco de dados distribu√≠do, existem  diferen√ßas  importantes  no  modo  de  opera√ß√£o. Nos  sistemas  de  multiprocessador  nada  compartilhado, h√° simetria e homogeneidade de n√≥s; isso n√£o acontece no ambiente de banco de dados distribu√≠do, no qual a heterogeneidade do hardware e do sistema operacional em cada n√≥ √© muito comum. A arquitetura nada compartilhado tamb√©m √© considerada um ambiente para bancos de dados paralelos. A Figura 25.3a ilustra um banco de dados paralelo (nada compartilhado), enquanto a Figura 25.3b ilustra um banco de dados centralizado com acesso distribu√≠do e a Figura 25.3c mostra um banco de dados distribu√≠do puro. N√£o vamos nos aprofundar aqui nas arquiteturas paralelas e em quest√µes de gerenciamento de dados relacionadas.

## 25.3.2 Arquitetura geral de bancos de dados distribu√≠dos puros

Nesta se√ß√£o, discutimos os modelos arquiteturais l√≥gicos e de componente de um BDD. Na Figura 25.4, que descreve a arquitetura de esquema gen√©rico de um BDD, a empresa √© apresentada com uma vis√£o consistente, unificada, que mostra a estrutura l√≥gica dos dados b√°sicos por todos os n√≥s. Essa vis√£o √© representada pelo esquema conceitual global (ECG), que oferece transpar√™ncia de rede (ver Se√ß√£o 25.1.2). Para acomodar a heterogeneidade em potencial no BDD, cada n√≥ aparece como tendo o pr√≥prio esquema interno local (EIL) com base nos detalhes da organiza√ß√£o f√≠sica nesse site em particular. A organiza√ß√£o l√≥gica dos dados em cada site √© especificada pelo esquema conceitual local (ECL). O ECG, ECL e seus mapeamentos b√°sicos oferecem a transpar√™ncia de fragmenta√ß√£o e replica√ß√£o discutida na Se√ß√£o 25.1.2. A Figura 25.5 mostra a arquitetura componente de um BDD. Ela √© uma extens√£o de sua correspondente centralizada (Figura 2.3) do Cap√≠tulo 2. Para simplificar, os elementos comuns n√£o s√£o mostrados aqui. O compilador de consulta global referencia o esquema conceitual global com base no cat√°lo-

4 Se as mem√≥rias principal e secund√°ria forem compartilhadas, a arquitetura tamb√©m √© conhecida como arquitetura tudo compartilhado .

Figura 25.3



Algumas arquiteturas de sistema de banco de dados diferentes. (a) Arquitetura nada compartilhado. (b) Uma arquitetura em rede com um banco de dados centralizado em um dos sites. (c) Uma arquitetura de banco de dados verdadeiramente distribu√≠da.

go global do sistema para verificar e impor as restri√ß√µes definidas. O otimizador de consulta global referencia os esquemas conceituais globais e locais e gera consultas locais otimizadas com base nas consultas globais. Ele avalia todas as estrat√©gias candidatas usando uma fun√ß√£o de custo que estima o custo com base no tempo de resposta (CPU, E/S e lat√™ncias de rede) e tamanhos estimados de resultados intermedi√°rios. O √∫ltimo √© particularmente  importante  em  consultas  que  envolvem jun√ß√µes. Ap√≥s calcular o custo para cada candidato, o otimizador seleciona o candidato com o menor custo para execu√ß√£o. Cada SGBD local teria seu otimizador de consulta local, gerenciador de transa√ß√£o e mecanis- mos de execu√ß√£o, bem como o cat√°logo do sistema local, que abriga os esquemas locais. O gerenciador de transa√ß√£o global √© respons√°vel por coordenar a execu√ß√£o por v√°rios sites em conjunto com o gerenciador de transa√ß√£o local nesses sites.

## 25.3.3 Arquitetura do esquema de banco de dados federado

A arquitetura t√≠pica do esquema de cinco n√≠veis para dar suporte a aplica√ß√µes globais no ambiente de SBDF aparece na Figura 25.6. Nessa arquitetura, o esquema local √© o esquema conceitual (defini√ß√£o de

Figura 25.4 Arquitetura do esquema para bancos de dados distribu√≠dos.



banco de dados completa) de um banco de dados componente, e o esquema de componente √© derivado ao se traduzir o esquema local para um modelo de dados can√¥nico ou um modelo de dados comum (MDC) para o SBDF. A tradu√ß√£o de esquema de um esquema local para o esquema componente √© acompanhada pela gera√ß√£o de mapeamentos para transformar comandos em um esquema componente em comandos no esquema local correspondente. O esquema de exporta√ß√£o representa o subconjunto  de  um  esquema componente que est√° dispon√≠vel ao SBDF. O esquema federado √© o esquema ou vis√£o  global,  que  √©  o  resultado  da  integra√ß√£o  de todos os esquemas de exporta√ß√£o compartilh√°veis. Os esquemas externos definem o esquema para um grupo de usu√°rios ou uma aplica√ß√£o, assim como na arquitetura de esquema em tr√™s n√≠veis. 5

## 25.3.4 Vis√£o geral da arquitetura cliente-servidor de tr√™s camadas

Conforme indicado na introdu√ß√£o do cap√≠tulo, os SGBDDs em escala completa n√£o foram desenvolvidos para dar suporte a todos os tipos de funcionalidades discutidos at√© aqui. Em vez disso, aplica√ß√µes de banco de dados distribu√≠do est√£o sendo desenvolvidas no contexto das arquiteturas cliente-servidor. Apresentamos a arquitetura cliente-servidor de duas camadas na Se√ß√£o 2.5. Agora, √© mais comum usar uma  arquitetura  de  tr√™s  camadas,  particularmente em aplica√ß√µes Web. Essa arquitetura √© ilustrada na Figura 25.7.

Na arquitetura cliente-servidor de tr√™s camadas, existem as seguintes camadas:

Todos os problemas relacionados ao processamento de consulta, processamento de transa√ß√£o e gerenciamento e recupera√ß√£o de diret√≥rio e metadados se aplicam aos SBDFs com considera√ß√µes adicionais. N√£o est√° em nosso escopo discutir esses problemas com detalhes aqui.

- 1. Camada de apresenta√ß√£o (cliente). Esta  oferece a interface com o usu√°rio e interage com o usu√°rio. Os programas nessa camada apresentam  interfaces  Web  ou  formul√°rios  para o  cliente,  a  fim  de  realizar  a  liga√ß√£o  com  a aplica√ß√£o. Os navegadores Web normalmente s√£o utilizados, e as linguagens e especifica√ß√µes usadas incluem HTML, XHTML, CSS, Flash,

5 Para obter uma discuss√£o detalhada sobre as autonomias e a arquitetura de cinco n√≠veis dos SGBDFs, consulte Sheth e Larson (1990).

Figura 25.5



Arquitetura de componentes dos bancos de dados distribu√≠dos.

- MathML,  Scalable  Vector  Graphics  (SVG), Java,  JavaScript,  Adobe  Flex  e  outras.  Essa camada trata da entrada, sa√≠da e navega√ß√£o do  usu√°rio,  aceitando  comandos  dele  e  exibindo  a  informa√ß√£o  necess√°ria,  em  geral  na forma de p√°ginas Web est√°ticas ou din√¢micas  . Estas  √∫ltimas  s√£o  empregadas  quando  a  intera√ß√£o  envolve  acesso  a  banco  de  dados. Quando uma interface Web √© utilizada, esta camada costuma se comunicar com a camada de aplica√ß√£o por meio do protocolo HTTP.
- 2. Camada  de  aplica√ß√£o  (l√≥gica  de  neg√≥cios). Esta camada programa a l√≥gica da aplica√ß√£o. Por exemplo, as consultas podem ser formuladas  com  base  na  entrada  do  usu√°rio  pelo cliente, ou os resultados da consulta podem ser  formatados  e  enviados  ao  cliente  para apresenta√ß√£o. A funcionalidade adicional da aplica√ß√£o pode ser tratada nessa camada, como as verifica√ß√µes de seguran√ßa, a verifica-
- √ß√£o de identidade e outras fun√ß√µes. A camada de aplica√ß√£o pode interagir com um ou mais bancos de dados ou fontes de dados, conforme a necessidade, ao conectar ao banco de dados  usando  ODBC,  JDBC,  SQL/CLI  ou outras t√©cnicas de acesso ao banco de dados.
- 3. Servidor de banco de dados. Esta camada trata de solicita√ß√µes de consulta e atualiza√ß√£o da camada de aplica√ß√£o, processa as solicita√ß√µes e envia os resultados. Normalmente, a SQL √© usada para acessar o banco de dados se ele for relacional ou objeto-relacional, e procedimentos armazenados do banco de dados tamb√©m podem ser chamados. Resultados de consulta (e consultas) podem  ser  formatados  em  XML  (ver  Cap√≠tulo 12) quando transmitidos entre o servidor de aplica√ß√£o e o servidor de banco de dados.

O modo exato como deve ser dividida a funcionalidade do SGBD entre o cliente, o servidor de aplica√ß√£o



## Figura 25.6

A arquitetura de esquema em cinco n√≠veis em um sistema de banco de dados federado (SBDF).

Fonte : Adaptado de Sheth e Larson, 'Federated Database Systems for Managing Distributed, Heterogeneous, and Autonomous Databases', ACM Computing Surveys , v. 22, n. 3, set. 1990.

e o servidor de banco de dados pode variar. A t√©cnica comum √© incluir a funcionalidade de um SGBD centralizado no n√≠vel de servidor de banco de dados. Diversos produtos de SGBD relacional utilizaram essa t√©cnica, na qual um servidor SQL √© fornecido. O servidor de aplica√ß√£o deve ent√£o formular as consultas SQL apropriadas e se conectar ao servidor de banco de dados quando necess√°rio.  O  cliente  oferece  o  processamento  para  as intera√ß√µes da interface com o usu√°rio. Como a SQL √© um padr√£o relacional, diversos servidores em SQL, possivelmente  fornecidos  por  diferentes  fornecedores,  podem aceitar comandos SQL por meio de padr√µes como ODBC, JDBC e SQL/CLI (ver Cap√≠tulo 13).

Nessa  arquitetura,  o  servidor  de  aplica√ß√£o tamb√©m  pode  se  referir  a  um  dicion√°rio  de  dados  que  inclui  informa√ß√µes  sobre  a  distribui√ß√£o de  dados  entre  os  diversos  servidores  SQL,  bem como  m√≥dulos  para  decompor  uma  consulta  global em uma s√©rie de consultas locais que podem ser executadas nos diversos sites. A intera√ß√£o entre um servidor de aplica√ß√£o e o servidor de banco de dados pode prosseguir da seguinte forma durante o processamento de uma consulta em SQL:

- 1. O servidor de aplica√ß√£o formula uma consulta do usu√°rio com base na entrada da camada do cliente e a decomp√µe em uma s√©rie de consultas  independentes  ao  site.  Cada  consulta do site √© enviada ao site do servidor de banco de dados apropriado.
- 2. Cada servidor de banco de dados processa a consulta local e envia os resultados ao site do servidor de aplica√ß√£o. Cada vez mais, a XML est√° sendo recomendada como o padr√£o para a troca de dados (ver Cap√≠tulo 12), de modo que o servidor de banco de dados pode formatar o resultado da consulta em XML antes de envi√°-lo ao servidor de aplica√ß√£o.
- 3. O servidor de aplica√ß√£o combina os resultados das subconsultas para produzir o resultado da consulta requisitada originalmente, o formata para HTML ou alguma outra forma aceita  pelo  cliente  e  o  envia  para  o  site  do cliente, para exibi√ß√£o.

O servidor de aplica√ß√£o √© respons√°vel por gerar um plano de execu√ß√£o distribu√≠do para uma consulta ou transa√ß√£o multisite e por supervisionar a execu√ß√£o distribu√≠da ao enviar comandos aos servidores. Esses  comandos  incluem  consultas  locais  e  transa√ß√µes a serem executadas, bem como comandos para transmitir dados a outros clientes ou servidores. Outra fun√ß√£o controlada pelo servidor de aplica√ß√£o (ou coordenador) √© a de garantir a consist√™ncia de c√≥pias replicadas de um item de dados empregando t√©cnicas de controle de concorr√™ncia distribu√≠do (ou global).

Figura 25.7



Arquitetura cliente-servidor de tr√™s camadas.

O servidor de aplica√ß√£o tamb√©m precisa garantir a atomicidade de transa√ß√µes globais realizando recupera√ß√£o global quando certos sites falham.

Se o SGBDD tiver a capacidade de ocultar os detalhes  da  distribui√ß√£o  de  dados  do  servidor  de aplica√ß√£o, ent√£o ele permitir√° que tal servidor execute consultas e transa√ß√µes globais como se o banco de dados fosse centralizado, sem ter de especificar os sites em que os dados referenciados na consulta ou transa√ß√£o residem. Essa propriedade √© chamada de transpar√™ncia  de  distribui√ß√£o .  Alguns  SGBDDs n√£o oferecem transpar√™ncia de distribui√ß√£o, exigindo, em seu lugar, que as aplica√ß√µes conhe√ßam os detalhes da distribui√ß√£o de dados.

## 25.4 √©cnicas de fragmenta√ß√£o, T replica√ß√£o e aloca√ß√£o de dados para projeto de banco de dados distribu√≠do

Nesta  se√ß√£o,  discutimos  t√©cnicas  usadas  para dividir o banco de dados em unidades l√≥gicas, chamadas fragmentos ,  que  podem  ser  atribu√≠das  para armazenamento nos v√°rios sites. Tamb√©m discutimos o uso da replica√ß√£o de dados , que permite que certos dados sejam armazenados em mais de um site, e o processo de aloca√ß√£o de  fragmentos  -  ou  r√©plicas de fragmentos - para armazenamento em v√°rios sites. Essas t√©cnicas s√£o usadas durante o processo de projeto do banco de dados distribu√≠do . A informa√ß√£o referente  √†  fragmenta√ß√£o,  aloca√ß√£o  e  replica√ß√£o  de dados √© armazenada em um diret√≥rio global ,  que √© acessado pelas aplica√ß√µes de SBDD conforme a necessidade.

## 25.4.1 ragmenta√ß√£o de dados F

Em  um  BDD,  precisam  ser  tomadas  decis√µes com rela√ß√£o a qual site deve ser usado para armazenar quais partes do banco de dados. Por enquanto, vamos considerar que n√£o existe replica√ß√£o ; ou seja, cada rela√ß√£o - ou parte de uma rela√ß√£o - √© armazenada apenas em um site. Discutiremos a replica√ß√£o e seus efeitos mais adiante nesta se√ß√£o. Tamb√©m usamos a terminologia dos bancos de dados relacionais, mas conceitos semelhantes tamb√©m se aplicam a outros modelos de dados. Vamos considerar que estamos come√ßando com um esquema de banco de dados relacional e precisamos decidir sobre como distribuir as  rela√ß√µes  pelos  diversos  sites.  Para  ilustrar  nossa discuss√£o, utilizamos o esquema de banco de dados relacional da Figura 3.5.

Antes  de  decidirmos  sobre  como  distribuir  os dados, temos que determinar as unidades l√≥gicas do banco de dados que devem ser distribu√≠das. As unidades l√≥gicas mais simples s√£o as pr√≥prias rela√ß√µes; ou seja, cada rela√ß√£o inteira deve ser armazenada em determinado site. Em nosso exemplo, temos que decidir sobre um site para armazenar cada uma das rela√ß√µes FUNCIONARIO, DEPARTAMENTO, PROJETO, TRABALHA\_EM e DEPENDENTE da  Figura  3.5.  Em muitos  casos,  por√©m,  uma  rela√ß√£o  pode  ser  dividida  em  unidades  l√≥gicas  menores  para  distribui√ß√£o. Por exemplo, considere o banco de dados de empresa mostrado na Figura 3.6, e suponha que existam tr√™s sites de computador - um para cada departamento na empresa. 6

Podemos  querer  armazenar  a  informa√ß√£o  do banco de dados relativa a cada departamento no site de computador para esse departamento. Uma t√©cnica, chamada fragmenta√ß√£o horizontal , pode ser usada para particionar cada rela√ß√£o por departamento.

Fragmenta√ß√£o horizontal. Uma fragmenta√ß√£o horizontal de  uma rela√ß√£o √© um subconjunto das tuplas nessa rela√ß√£o. As tuplas que pertencem ao fragmento horizontal s√£o especificadas por uma condi√ß√£o em um ou mais atributos da rela√ß√£o. Com frequ√™ncia, apenas um √∫nico atributo √© envolvido. Por exemplo, podemos definir  tr√™s  fragmentos  horizontais  na  rela√ß√£o FUNCIONARIO da Figura 3.6 com as seguintes condi√ß√µes: ( Dnr = 5), ( Dnr = 4) e ( Dnr = 1) - cada fragmento cont√©m as tuplas de FUNCIONARIO que trabalham para um departamento em particular. De modo semelhante, podemos definir tr√™s fragmentos horizontais para a  rela√ß√£o PROJETO ,  com  as  condi√ß√µes  ( Dnum =  5), ( Dnum = 4) e ( Dnum = 1) - cada fragmento cont√©m as tuplas de PROJETO controladas por determinado departamento. A fragmenta√ß√£o horizontal divide a rela√ß√£o horizontalmente , agrupando as linhas para criar subconjuntos de tuplas, onde cada subconjunto tem um significado l√≥gico. Esses fragmentos podem ent√£o ser atribu√≠dos a diferentes sites no sistema distribu√≠do. A fragmenta√ß√£o horizontal derivada se aplica ao particionamento de uma rela√ß√£o prim√°ria ( DEPARTAMEN -TO em nosso exemplo) para outras rela√ß√µes secund√°rias ( FUNCIONARIO e PROJETO em nosso exemplo), que est√£o relacionadas √† principal por meio de uma chave estrangeira. Desse modo, os dados relacionados entre as rela√ß√µes principal e secund√°ria s√£o fragmentados da mesma maneira.

Fragmenta√ß√£o vertical. Cada site pode n√£o precisar  de  todos  os  atributos  de  uma  rela√ß√£o,  o que poderia indicar  a  necessidade  de  um  tipo  de

6 Naturalmente, em uma situa√ß√£o real, haver√° muito mais tuplas na rela√ß√£o do que aquelas mostradas na Figura 3.6.

fragmenta√ß√£o  diferente.  A fragmenta√ß√£o  vertical divide  uma  rela√ß√£o  'verticalmente'  por  colunas. Um fragmento  vertical de  uma  rela√ß√£o  mant√©m apenas certos  atributos  da  rela√ß√£o.  Por  exemplo, podemos  querer  fragmentar  a  rela√ß√£o FUNCIO -NARIO em  dois  fragmentos  verticais.  O  primeiro fragmento  inclui  informa√ß√µes  pessoais  Nome, Datanasc, Endereco e Sexo -  e  o  segundo  inclui informa√ß√µes relacionadas ao trabalho -Cpf, Salario, Cpf\_supervisor e Dnr. Essa  fragmenta√ß√£o vertical n√£o √© muito apropriada, pois se os dois fragmentos forem armazenados separadamente, n√£o podemos colocar as tuplas de funcion√°rio originais de volta, pois n√£o existe um atributo comum entre os dois fragmentos. √â necess√°rio incluir a chave prim√°ria ou algum atributo de chave candidata em cada fragmento vertical, de modo que a rela√ß√£o completa possa ser reconstru√≠da com base nos  fragmentos.  Logo,  precisamos  acrescentar  o atributo Cpf ao fragmento de informa√ß√µes pessoais.

Observe que cada fragmento horizontal em uma rela√ß√£o R pode  ser  especificado  na  √°lgebra  relacional por uma opera√ß√£o œÉ C i ( R ). Um conjunto de fragmentos horizontais, cujas condi√ß√µes C  C 1 , 2 , ..., C n incluem todas as tuplas em R - ou seja, cada tupla em R satisfaz ( C 1 OR C 2 OR ... OR C n ) -, √© chamado de fragmenta√ß√£o horizontal completa de R . Em muitos casos, uma fragmenta√ß√£o horizontal completa tamb√©m √© disjunta ; isto √©, nenhuma tupla em R satisfaz ( C i AND C j ) para qualquer i ‚â† j . Nossos dois exemplos anteriores de fragmenta√ß√£o horizontal para as rela√ß√µes FUNCIONARIO e PROJETO foram completos e disjuntos. Para reconstruir a rela√ß√£o R com base em uma fragmenta√ß√£o horizontal completa , precisamos aplicar a opera√ß√£o UNI√ÉO aos fragmentos.

Um fragmento vertical em uma rela√ß√£o R pode ser  especificado  por  uma  opera√ß√£o œÄ L i ( R )  na  √°lgebra relacional. Um conjunto de fragmentos verticais cujas listas de proje√ß√£o L 1 , L 2 , ..., L n incluem todos os atributos em R, mas compartilham apenas o atributo de chave prim√°ria de R √© chamado de fragmenta√ß√£o vertical completa de R . Nesse caso, as listas de proje√ß√£o satisfazem as duas condi√ß√µes a seguir:

- ¬Ñ L 1 ‚à™ L 2 ‚à™ ... ‚à™ L n = ATTRS ( R ).
- ¬Ñ L i ‚à© L j = CRP ( R )  para qualquer i ‚â† j ,  onde ATTRS ( R )  √©  o  conjunto  de  atributos  de R e CRP ( R ) √© a chave prim√°ria de R .

Para reconstruir a rela√ß√£o R baseando-se em uma fragmenta√ß√£o vertical completa , aplicamos a opera√ß√£o UNI√ÉO  EXTERNA aos  fragmentos  verticais  (supondo que  nenhuma  fragmenta√ß√£o  horizontal  seja  usada). Observe que tamb√©m poder√≠amos aplicar uma opera√ß√£o JUN√á√ÉO EXTERNA COMPLETA e obter o mesmo resultado  para  uma  fragmenta√ß√£o  vertical  completa,  mesmo  quando  alguma  fragmenta√ß√£o  horizontal tamb√©m pode ter sido aplicada. Os dois fragmentos verticais da rela√ß√£o FUNCIONARIO com listas de proje√ß√£o L 1 =  { Cpf, Nome, Datanasc, Endereco, Sexo }  e L 2 = { Cpf , Salario , Cpf\_supervisor , Dnr } constituem uma fragmenta√ß√£o vertical completa de FUNCIONARIO .

Dois fragmentos horizontais, que n√£o s√£o completos nem disjuntos, s√£o aqueles definidos sobre a rela√ß√£o FUNCIONARIO na  Figura  3.5  pelas  condi√ß√µes ( Salario &gt; 50.000) e ( Dnr = 4); eles podem n√£o incluir todas as tuplas de FUNCIONARIO , e podem incluir  tuplas  comuns.  Dois  fragmentos  verticais  que n√£o  s√£o  completos  s√£o  aqueles  definidos  pelas  listas de atributos L 1 = { Nome , Endereco } e L 2 = { Cpf , Nome Salario , }; essas listas violam as duas condi√ß√µes de uma fragmenta√ß√£o vertical completa.

Fragmenta√ß√£o  mista  (h√≠brida). Podemos  misturar os dois tipos de fragmenta√ß√£o, produzindo uma fragmenta√ß√£o mista . Por exemplo, podemos combinar as fragmenta√ß√µes horizontal e vertical da rela√ß√£o FUNCIONARIO dada anteriormente em uma fragmenta√ß√£o mista que inclui seis fragmentos. Nesse caso, a  rela√ß√£o  original  pode  ser  reconstru√≠da  ao  aplicar opera√ß√µes UNI√ÉO e UNI√ÉO  EXTERNA (ou JUN√á√ÉO EXTERNA ) na ordem apropriada. Em geral, um fragmento de  uma rela√ß√£o R pode ser especificado por uma  combina√ß√£o SELE√á√ÉO-PROJE√á√ÉO de  opera√ß√µes œÄ L ( œÉ C ( R )). Se C = TRUE (ou seja, todas as tuplas s√£o selecionadas) e L ‚â† ATTRS ( R ), obtemos um fragmento vertical, e se C ‚â† TRUE e L = ATTRS ( R ), obtemos um fragmento horizontal. Finalmente, se C ‚â† TRUE e L ‚â† ATTRS ( R ), obtemos um fragmento misto. Observe que uma rela√ß√£o por si s√≥ pode ser considerada um fragmento com C = TRUE e L = ATTRS ( R ). Na discuss√£o a seguir, o termo fragmento √©  usado para se referir a uma rela√ß√£o ou a qualquer um dos tipos anteriores de fragmentos.

Um esquema de fragmenta√ß√£o de um banco de dados √© uma defini√ß√£o de um conjunto de fragmentos que inclui todos os  atributos  e  tuplas  no  banco  de dados e satisfaz a condi√ß√£o de que o banco de dados inteiro pode ser reconstru√≠do com base nos fragmentos ao aplicar alguma sequ√™ncia de opera√ß√µes UNI√ÉO EXTERNA (ou JUN√á√ÉO EXTERNA ) e UNI√ÉO . √Äs vezes, √© √∫til - embora n√£o necess√°rio - ter todos os fragmentos disjuntos, exceto para a repeti√ß√£o das chaves prim√°rias entre os fragmentos verticais (ou mistos). Nesse √∫ltimo caso, toda replica√ß√£o e distribui√ß√£o de fragmentos √© claramente especificada em um est√°gio subsequente, separadamente da fragmenta√ß√£o.

Um esquema de aloca√ß√£o descreve a aloca√ß√£o de fragmentos aos sites do SBDD; logo, esse √© um mapeamento que especifica para cada fragmenta√ß√£o o(s)

site(s) em que ela est√° armazenada. Se um fragmento for armazenado em mais de um site, ele √© considerado replicado .  Abordamos a replica√ß√£o e a aloca√ß√£o de dados em seguida.

## 25.4.2 Replica√ß√£o e aloca√ß√£o de dados

A replica√ß√£o √© √∫til na melhoria da disponibilidade de dados. O caso mais extremo √© a replica√ß√£o do banco de dados inteiro em cada site no sistema distribu√≠do, criando assim um banco de dados distribu√≠do totalmente replicado . Isso pode melhorar bastante a disponibilidade porque o sistema continua a operar desde  que  pelo  menos  um  site  esteja  funcionando. Isso  tamb√©m  melhora  o  desempenho  da  recupera√ß√£o para consultas globais, pois os resultados dessas consultas podem ser obtidos localmente, de qualquer site; logo, uma consulta de recupera√ß√£o pode ser processada no site local onde ela √© submetida, se esse site incluir um m√≥dulo servidor. A desvantagem da replica√ß√£o total √© que ela pode atrasar bastante as opera√ß√µes de atualiza√ß√£o, j√° que uma √∫nica atualiza√ß√£o local precisa ser realizada em cada c√≥pia do banco de dados, para manter as c√≥pias consistentes. Isso √© verdade especialmente se existirem muitas c√≥pias do banco de dados. A replica√ß√£o total torna as t√©cnicas de controle de concorr√™ncia e recupera√ß√£o mais dispendiosas do que seriam se n√£o houvesse replica√ß√£o, conforme veremos na Se√ß√£o 25.7.

O outro extremo da replica√ß√£o total envolve n√£o ter replica√ß√£o - ou seja, cada fragmento √© armazenado em exatamente um site. Nesse caso, todos os fragmentos precisam ser disjuntos, exceto pela repeti√ß√£o das chaves prim√°rias entre os fragmentos verticais (ou mistos). Isso tamb√©m √© chamado de aloca√ß√£o n√£o redundante .

Entre esses dois extremos, temos uma grande variedade de replica√ß√£o parcial dos dados - ou seja, alguns fragmentos do banco de dados podem ser replicados, enquanto outros, n√£o. O n√∫mero de c√≥pias de cada fragmento pode variar de uma at√© o total de sites no sistema distribu√≠do. Um caso especial de replica√ß√£o parcial est√° ocorrendo bastante em aplica√ß√µes em que trabalhadores m√≥veis - como o pessoal de vendas, planejadores financeiros e consultores de seguros - transportam bancos de dados parcialmente replicados com eles em laptops e PDAs e os sincronizam periodicamente com o banco de dados do servidor. 7 Uma descri√ß√£o da replica√ß√£o de fragmentos √†s vezes √© chamada de esquema de replica√ß√£o .

distribui√ß√£o de dados (ou aloca√ß√£o de dados ).  A  escolha de sites e o grau de replica√ß√£o dependem dos objetivos de desempenho e disponibilidade do sistema e dos tipos e frequ√™ncias de transa√ß√µes submetidas em cada site. Por exemplo, se a alta disponibilidade for exigida, as transa√ß√µes podem ser submetidas a qualquer site e se a maioria delas for apenas para recupera√ß√£o, um banco de dados totalmente replicado √© uma boa escolha. Por√©m, se certas transa√ß√µes que acessam determinadas partes do banco de dados forem principalmente submetidas a um site em particular, o conjunto de fragmentos correspondente pode ser alocado apenas nesse site. Os dados acessados em v√°rios sites podem ser replicados nestes √∫ltimos. Se muitas atualiza√ß√µes forem realizadas, pode ser √∫til limitar a replica√ß√£o. Encontrar uma solu√ß√£o ideal ou mesmo uma solu√ß√£o boa para a aloca√ß√£o de dados distribu√≠dos √© um problema de otimiza√ß√£o bastante complexo.

## 25.4.3 Exemplo de fragmenta√ß√£o, aloca√ß√£o e replica√ß√£o

Agora, vamos considerar um exemplo de fragmenta√ß√£o e distribui√ß√£o do banco de dados da empresa nas figuras 3.5 e 3.6. Suponha que a empresa tenha  tr√™s  sites  de  computadores  -  um  para  cada departamento atual. Os sites 2 e 3 s√£o para os departamentos 5 e 4, respectivamente. Em cada um desses sites,  esperamos  ter  acesso  frequente  √†  informa√ß√£o de FUNCIONARIO e PROJETO para  os  funcion√°rios que trabalham nesse departamento e os projetos controlados por esse departamento .  Al√©m do mais, assumimos que esses sites acessam principalmente os atributos Nome, Cpf, Salario e Cpf\_supervisor de FUNCIONARIO. O site 1 √© usado pela sede da empresa e acessa todas as informa√ß√µes de funcion√°rio e projeto regularmente, al√©m de registrar a informa√ß√£o de DEPENDENTE para fins de seguro.

Cada fragmento - ou cada c√≥pia de um fragmento - precisa ser atribu√≠do a um site em particular no sistema distribu√≠do. Esse processo √© chamado de

De acordo com esses requisitos, o banco de dados inteiro da Figura 3.6 pode ser armazenado no site 1. Para determinar os fragmentos a serem replicados nos sites  2  e  3,  primeiro podemos fragmentar horizontalmente DEPARTAMENTO por sua chave Dnumero .  Depois,  aplicamos  a  fragmenta√ß√£o  derivada  √†s  rela√ß√µes FUNCIONARIO, PROJETO e LOCALIZACAO\_DEP com base em suas chaves estrangeiras para n√∫mero de departamento - chamadas Dnr, Dnum e Dnumero, respectivamente, na Figura 3.5. Podemos fragmentar verticalmente os fragmentos de FUNCIONARIO resultantes para incluir apenas os atributos { Nome, Cpf, Salario, Cpf\_su-pervisor, Dnr }. A Figura 25.8 mostra os fragmentos mistos FUNC\_DEP\_5 e FUNC\_DEP\_4, que incluem as tuplas de FUNCIONARIO que satisfazem as condi√ß√µes Dnr = 5

7 Para ver uma t√©cnica escal√°vel, proposta para sincronizar parcialmente os bancos de dados replicados, consulte Mahajan et al. (1998).

## (a) FUNC\_DEP\_5

| Pnome    | Minicial   | Unome   |         Cpf |   Salario |   Cpf_supervisor |   Dnr |
|----------|------------|---------|-------------|-----------|------------------|-------|
| Jo√£o     | B          | Silva   | 12345678966 |        30 |      33344555587 |     5 |
| Fernando | T          | Wong    | 33344555587 |        40 |      88866555576 |     5 |
| Ronaldo  | K          | Lima    | 66688444476 |        38 |      33344555587 |     5 |
| Joice    | A          | Leite   | 45345345376 |        25 |      33344555587 |     5 |

## DEP\_5

## LOCAL\_DEP\_5

| Dnome    |   Dnumero |   Cpf_gerente | Data_inicio_ger   |
|----------|-----------|---------------|-------------------|
| Pesquisa |         5 |   33344555587 | 22-05-1988        |

## TRABALHA\_EM\_DEP\_5

|   Dnumero | Localizacao   |
|-----------|---------------|
|         5 | Santo Andr√©   |
|         5 | Itu           |
|         5 | S√£o Paulo     |

## PROJ\_DEP\_5

|        Fcpf |   Pnr | Horas   |
|-------------|-------|---------|
| 12345678966 |     1 | 32,5    |
| 12345678966 |     2 | 7,5     |
| 66688444476 |     3 | 40,0    |
| 45345345376 |     1 | 20,0    |
| 45345345376 |     2 | 20,0    |
| 33344555587 |     2 | 10,0    |
| 33344555587 |     3 | 10,0    |
| 33344555587 |    10 | 10,0    |
| 33344555587 |    20 | 10,0    |

| Projnome   |   Projnumero | Projlocal   |   Dnum |
|------------|--------------|-------------|--------|
| ProdutoX   |            1 | Santo Andr√© |      5 |
| ProdutoY   |            2 | Itu         |      5 |
| ProdutoZ   |            3 | S√£o Paulo   |      5 |

Dados no site 2

## (b) FUNC\_DEP\_4

| Pnome    | Minicial   | Unome   |         Cpf |   Salario |   Cpf_supervisor |   Dnr |
|----------|------------|---------|-------------|-----------|------------------|-------|
| Alice    | J          | Zelaya  | 99988777767 |        25 |      98765432168 |     4 |
| Jennifer | S          | Souza   | 98765432168 |        43 |      88866555576 |     4 |
| Andr√©    | V          | Pereira | 98798798733 |        25 |      98765432168 |     4 |

## DEP\_4

## LOCAL\_DEP\_4

| Dnome         |   Dnumero |   Cpf_gerente | Data_inicio_ger   |
|---------------|-----------|---------------|-------------------|
| Administra√ß√£o |         4 |   98765432168 | 01-01-1995        |

## TRABALHA\_EM\_DEP\_4

|   Dnumero | Localizacao   |
|-----------|---------------|
|         4 | Mau√°          |

## PROJ\_DEP\_4

|        Fcpf |   Pnr | Horas   |
|-------------|-------|---------|
| 33344555587 |    10 | 10,0    |
| 99988777767 |    30 | 30,0    |
| 99988777767 |    10 | 10,0    |
| 98798798733 |    10 | 35,0    |
| 98798798733 |    30 | 5,0     |
| 98765432168 |    30 | 20,0    |
| 98765432168 |    20 | 15,0    |

| Projnome         |   Projnumero | Projlocal   |   Dnum |
|------------------|--------------|-------------|--------|
| Informatiza√ß√£o   |           10 | Mau√°        |      4 |
| Novos_beneficios |           30 | Mau√°        |      4 |

Dados no site 3

## Figura 25.8

Aloca√ß√£o de fragmentos aos sites. (a) Fragmentos de rela√ß√£o no site 2 correspondentes ao departamento 5. (b) Fragmentos de rela√ß√£o no site 3 correspondentes ao departamento 4.

e Dnr = 4, respectivamente. Os fragmentos horizontais de PROJETO, DEPARTAMENTO e LOCALIZACAO\_DEP s√£o fragmentados de maneira semelhante por n√∫mero de departamento. Todos esses fragmentos - armazenados nos sites 2 e 3 - s√£o replicados porque tamb√©m s√£o armazenados na sede - site 1.

Agora,  devemos  fragmentar  a  rela√ß√£o TRABA -LHA\_EM e  decidir  quais  de  seus  fragmentos  armazenar nos sites 2 e 3. Confrontamos o problema de que nenhum atributo de TRABALHA\_EM indica diretamente o departamento ao qual cada tupla pertence. De fato, cada tupla em TRABALHA\_EM relaciona um funcion√°rio f a um projeto P .  Poder√≠amos fragmentar TRABALHA\_EM com base no departamento D em que f trabalha ou baseado no departamento D ' que controla P .  A  fragmenta√ß√£o torna-se f√°cil se temos uma restri√ß√£o indicando que D = D' para todas as tuplas de TRABALHA\_EM - ou seja, se os funcion√°rios s√≥ puderem trabalhar nos projetos controlados pelo departamento em que trabalham. Contudo, n√£o existe  tanta  restri√ß√£o  em  nosso  banco  de  dados  da Figura 3.6. Por exemplo, a tupla de TRABALHA\_EM &lt;33344555587, 10, 10,0&gt; relaciona um funcion√°rio que trabalha para o departamento 5 com um projeto  controlado  pelo  departamento  4.  Nesse  caso, poder√≠amos fragmentar TRABALHA\_EM com base no departamento em que o funcion√°rio trabalha (que √© expresso pela condi√ß√£o C ) e, depois, fragmentar mais com base no departamento que controla os projetos em que o funcion√°rio est√° trabalhando, como mostra a Figura 25.9.

fragmentos de FUNCIONARIO ou PROJETO locais no site 2 ou no site 3 e o fragmento de TRABALHA\_EM local para serem realizados completamente no local. Isso  demonstra  com  clareza  como  o  problema  de fragmenta√ß√£o e aloca√ß√£o de banco de dados √© complexo para bancos de dados grandes. A bibliografia selecionada ao final deste cap√≠tulo discute parte do trabalho feito nessa √°rea.

## 25.5 Processamento e otimiza√ß√£o de consulta em bancos de dados distribu√≠dos

Agora, vamos dar uma vis√£o geral de como um SGBDD processa e otimiza uma consulta. Primeiro, discutimos as etapas envolvidas no processamento da consulta e, depois, detalhamos os custos de comunica√ß√£o do processamento de uma consulta distribu√≠da. Por fim, discutimos uma opera√ß√£o especial, chamada semijun√ß√£o , que √© usada para otimizar alguns tipos  de  consultas  em  um  SGBDD.  Uma  discuss√£o detalhada sobre algoritmos de otimiza√ß√£o est√° al√©m do escopo deste livro. Tentamos ilustrar os princ√≠pios de otimiza√ß√£o com exemplos adequados. 8

## 25.5.1 Processamento de consulta distribu√≠do

Uma consulta de banco de dados distribu√≠do √© processada em est√°gios, da seguinte forma:

Na Figura 25.9, a uni√£o de fragmentos G 1 , G 2 e G 3 oferece todas as tuplas de TRABALHA\_EM para os funcion√°rios que trabalham para o departamento 5. De modo semelhante, a uni√£o dos fragmentos G 4 , G 5 e G 6 oferece todas as tuplas de TRABALHA\_EM para os funcion√°rios que trabalham para o departamento 4. Por sua vez, a uni√£o dos fragmentos G 1 , G 4 e G 7 oferece todas as tuplas de TRABALHA\_EM para os projetos controlados pelo departamento 5. A condi√ß√£o para cada um dos fragmentos de G 1 a G 9 √© mostrado na Figura 25.9. As rela√ß√µes que representam relacionamentos M:N, como TRABALHA\_EM, normalmente t√™m diversas fragmenta√ß√µes l√≥gicas poss√≠veis. Em nossa distribui√ß√£o na Figura 25.8, escolhemos incluir todos os fragmentos que podem ser reunidos a uma tupla FUNCIONARIO ou a uma tupla PROJETO nos sites 2 e 3. Logo, colocamos a uni√£o dos fragmentos G 1 , G 2 , G 3 , G 4 e G 7 no  site  2  e  a  uni√£o  dos  fragmentos G 4 , G  G  G 5 , 6 , 2 e G 8 no site 3. Observe que os fragmentos G 2 e G 4 s√£o replicados nos dois sites. Essa estrat√©gia de aloca√ß√£o permite a jun√ß√£o entre os

- 1. Mapeamento de consulta. A consulta de entrada em dados distribu√≠dos √© especificada formalmente usando uma linguagem de consulta. Depois, ela √© traduzida para uma consulta alg√©brica em rela√ß√µes globais. Essa tradu√ß√£o √© feita ao referir-se ao esquema conceitual global e n√£o leva em conta a distribui√ß√£o e replica√ß√£o real dos dados. Portanto, essa tradu√ß√£o √©  em  grande  parte  id√™ntica  √†quela  realizada em um SGBD centralizado. Ela √©, primeiro, normalizada, analisada quanto a erros sem√¢nticos, simplificada e finalmente reestruturada em uma consulta alg√©brica.
- 2. Localiza√ß√£o. Em um banco de dados distribu√≠do,  a  fragmenta√ß√£o  resulta  em  rela√ß√µes armazenadas em sites separados, com alguns fragmentos  possivelmente  sendo  replicados. Esse est√°gio mapeia a consulta distribu√≠da no esquema global para consultas separadas em fragmentos  individuais  usando  informa√ß√µes de distribui√ß√£o e replica√ß√£o de dados.

8 Para obter uma discuss√£o detalhada dos algoritmos de otimiza√ß√£o, veja Ozsu e Valduriez (1999).

## (a) Funcion√°rios no Departamento 5

## G1 G2

|        Fcpf |   Pnr | Horas   |
|-------------|-------|---------|
| 12345678966 |     1 | 32,5    |
| 12345678966 |     2 | 7,5     |
| 66688444476 |     3 | 40,0    |
| 45345345376 |     1 | 20,0    |
| 45345345376 |     2 | 20,0    |
| 33344555587 |     2 | 10,0    |
| 33344555587 |     3 | 10,0    |

|        Fcpf |   Pnr | Horas   |
|-------------|-------|---------|
| 33344555587 |    10 | 10,0    |

C2  =  C  e  (Pnr  em  (SELECT  Projnumero FROM PROJECT WHERE Dnum = 4))

C1  =  C  e  (Pnr  em  (SELECT  Projnumero FROM PROJETO WHERE Dnum = 5))

## (b) Funcion√°rios no Departamento 4

## G4

## G5



|        Fcpf |   Pnr | Horas   |
|-------------|-------|---------|
| 99988777767 |    30 | 30,0    |
| 99988777767 |    10 | 10,0    |
| 98798798733 |    10 | 35,0    |
| 98798798733 |    30 | 5,0     |
| 98765432168 |    30 | 20,0    |

C5  =  C  e  (Pnr  em  (SELECT  Projnumero FROM PROJETO WHERE Dnum = 4))

## (c) Funcion√°rios no Departamento 1

## G7

## G8



C7  =  C  e  (Pnr  em  (SELECT  Projnumero FROM PROJETO WHERE Dnum = 5))

C8  =  C  e  (Pnr  em  (SELECT  Projnumero FROM PROJETO WHERE Dnum = 4))

## G3

|        Fcpf |   Pnr | Horas   |
|-------------|-------|---------|
| 33344555587 |    20 | 10,0    |

C3  =  C  e  (Pnr  em  (SELECT  Projnumero FROM PROJECT WHERE Dnum = 1))

## G6

|        Fcpf |   Pnr | Horas   |
|-------------|-------|---------|
| 98765432168 |    20 | 15,0    |

C6  =  C  e  (Pnr  em  (SELECT  Projnumero FROM PROJETO WHERE Dnum = 1))

## G9

|        Fcpf |   Pnr | Horas   |
|-------------|-------|---------|
| 88866555576 |    20 | Null    |

C9  =  C  e  (Pnr  em  (SELECT  Projnumero FROM PROJETO WHERE Dnum = 1))

## Figura 25.9

Fragmentos completos e disjuntos da rela√ß√£o TRABALHA\_EM. (a) Fragmentos de TRABALHA\_EM para funcion√°rios que trabalham no departamento 5 (C=[Fcpf in (SELECT Cpf FROM FUNCIONARIO WHERE Dnr=5)]). (b) Fragmentos de TRABALHA\_EM para funcion√°rios que trabalham no departamento 4 (C=[Fcpf in (SELECT Cpf FROM FUNCIONARIO WHERE Dnr=4)]). (c) Fragmentos de TRABALHA\_EM para funcion√°rios que trabalham no departamento 1 ( C=[Fcpf in (SELECT Cpf FROM FUNCIONARIO WHERE Dnr=1)]).

## Sistemas de banco de dados Elmasri ¬∑ Navathe

6 a edi√ß√£o



6 a edi√ß√£o



Ramez Elmasri

Departamento de Ci√™ncia da Computa√ß√£o e Engenharia Universidade do Texas em Arlington Shamkant B. Navathe Faculdade de Computa√ß√£o Georgia Institute of Technology

Tradu√ß√£o: Daniel Vieira Revis√£o t√©cnica: Enzo Seraphim

Thatyana de Faria Piola Seraphim

Professores Doutores do Instituto de Engenharia de Sistemas e Tecnologias da Informa√ß√£o - Universidade Federal de Itajub√°





S√£o Paulo

S√£o Paulo

Brasil   Argentina   Col√¥mbia   Costa Rica   Chile   Espanha

Guatemala   M√©xico   Peru   Porto Rico   Venezuela

Brasil Argentina Col√¥mbia Costa Rica Chile Espanha Guatemala M√©xico Peru Porto Rico Venezuela

6 a edi√ß√£o

## ¬© 2011 by Pearson Education do Brasil.

¬© 2011, 2007, 2004, 2000, 1994 e 1989 Pearson Education, Inc.

Tradu√ß√£o autorizada a partir da edi√ß√£o original, em ingl√™s, Fundamentals of Database Systems , 6 th edition, publicada pela Pearson Education, Inc., sob o selo Addison-Wesley.

Todos os direitos reservados. Nenhuma parte desta publica√ß√£o poder√° ser reproduzida ou transmitida de qualquer modo ou por qualquer outro meio, eletr√¥nico ou mec√¢nico, incluindo fotoc√≥pia, grava√ß√£o ou qualquer outro tipo de sistema de armazenamento e transmiss√£o de informa√ß√£o, sem pr√©via autoriza√ß√£o, por escrito, da Pearson Education do Brasil.

## Diretor editorial: Roger Trimer

Gerente editorial: Sabrina Cairo Supervisor de produ√ß√£o editorial: Marcelo Fran√ßozo Editora plena: Thelma Babaoka Editora de texto: Sabrina Levensteinas Prepara√ß√£o: Paula Brand√£o Perez Mendes Revis√£o: Elisa Andrade Buzzo

Capa: Thyago Santos sobre o projeto original de Lou Gibbs/Getty Images Projeto gr√°fico e diagrama√ß√£o: Globaltec Artes Gr√°ficas Ltda.

## Dados Internacionais de Cataloga√ß√£o na Publica√ß√£o (CIP) (C√¢mara Brasileira do Livro, SP, Brasil)

## Elmasri, Ramez

Sistemas de banco de dados / Ramez Elmasri e Shamkant B. Navathe ; tradu√ß√£o Daniel Vieira ; revis√£o t√©cnica Enzo Seraphim e Thatyana de Faria Piola Seraphim. -- 6. ed. -- S√£o Paulo : Pearson Addison Wesley, 2011.

T√≠tulo original: Fundamentals of database systems.

ISBN 978-85-4301-381-7

- 1. Banco de dados I. Navathe, Shamkant B..II. T√≠tulo.

10-11462

CDD-005.75

## √çndices para cat√°logo sistem√°tico:

- 1. Banco de dados : Sistemas : Processamento de dados 005.75

2. Banco de dados : Fundamentos : Processamento de dados 005.75

1 a reimpress√£o - setembro 2011 Direitos exclusivos para a l√≠ngua portuguesa cedidos √† Pearson Education do Brasil, uma empresa do grupo Pearson Education Rua Nelson Francisco, 26 - Lim√£o Cep: 02712-100 S√£o Paulo - SP Tel: (11) 2178-8686 - Fax: (11) 2178-8688 e-mail: vendas@pearson.com 2 aa reimpress√£o - agosto 2012 Direitos exclusivos para a l√≠ngua portuguesa cedidos √† Pearson Education do Brasil Ltda., uma empresa do grupo Pearson Education Rua Nelson Francisco, 26 CEP 02712-100 - S√£o Paulo - SP - Brasil Fone: 11 2178-8686 - Fax: 11 2178-8688 88 vendas@pearson.com 2 a reimpress√£o - junho 2013 Direitos exclusivos para a l√≠ngua portuguesa cedidos √† Pearson Education do Brasil Ltda., uma empresa do grupo Pearson Education Rua Nelson Francisco, 26 CEP 02712-100 - S√£o Paulo - SP - Brasil Fone: (11) 2178-8686 - Fax: (11) 2178-8688 vendas@pearson.com 3  reimpress√£o - Julho 2014 Fone: (11) (11) 2178-86

Para Katrina, Thomas e Dora (e tamb√©m para Vicky) R.E.

Para minha esposa Aruna, m√£e Vijaya e para minha fam√≠lia inteira, por seu amor e apoio

S.B.N.

| Parte 1:                                                                                                                               | Introdu√ß√£o aos bancos de dados......1                                                                                                  |
|----------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------|
| Cap√≠tulo 1                                                                                                                             | Bancos de dados e usu√°rios de banco de dados.............................2                                                             |
| 1.1                                                                                                                                    | Introdu√ß√£o................................................. 2                                                                          |
| 1.2                                                                                                                                    | Um exemplo.............................................. 4                                                                             |
| 1.3                                                                                                                                    | Caracter√≠sticas da abordagem de banco de dados......................................................... 6                              |
| 1.4                                                                                                                                    | Atores em cena.......................................... 9                                                                             |
| 1.5                                                                                                                                    | Trabalhadores dos bastidores .................. 10                                                                                     |
| 1.6                                                                                                                                    | Vantagens de usar a abordagem de SGBD11                                                                                                |
| 1.7                                                                                                                                    | Uma breve hist√≥ria das aplica√ß√µes de banco de dados.................................................. 15                               |
| 1.8                                                                                                                                    | Quando n√£o usar um SGBD.................... 17                                                                                         |
|                                                                                                                                        | Resumo............................................................ 18                                                                  |
| Perguntas de                                                                                                                           | revis√£o......................................... 18                                                                                    |
| Exerc√≠cios.........................................................                                                                    | 18                                                                                                                                     |
| Bibliografia                                                                                                                           | selecionada.................................... 18                                                                                     |
| Cap√≠tulo 2                                                                                                                             | Conceitos e arquitetura do sistema de banco de dados.....................19                                                            |
| 2.1                                                                                                                                    | Modelos de dados, esquemas e inst√¢ncias 19                                                                                             |
| 2.2 Arquitetura de tr√™s                                                                                                                | esquemas e independ√™ncia de dados........................... 22                                                                        |
| 2.3                                                                                                                                    | Linguagens e interfaces do banco de dados... 24                                                                                        |
| 2.4                                                                                                                                    | Oambiente do sistema de banco de dados .. 26                                                                                           |
| 2.5                                                                                                                                    | Arquiteturas centralizadas e cliente/servidor para SGBDs............................................. 29                               |
| 2.6                                                                                                                                    | Classifica√ß√£o dos sistemas gerenciadores de banco de dados........................................ 32                                  |
|                                                                                                                                        | Resumo............................................................ 35                                                                  |
| Perguntas de revis√£o.........................................                                                                          | Perguntas de revis√£o.........................................                                                                          |
| 36                                                                                                                                     | 36                                                                                                                                     |
| Exerc√≠cios......................................................... 36 Bibliografia selecionada.................................... 36 | Exerc√≠cios......................................................... 36 Bibliografia selecionada.................................... 36 |

## Sum√°rio

| Parte 2:                                                                                                              | Modelo de dados relacional e SQL..37                                                                                  | Modelo de dados relacional e SQL..37                          |
|-----------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------|
| Cap√≠tulo 3                                                                                                            | Omodelo de dados relacional e as restri√ß√µes embancos de dados                                                         | Omodelo de dados relacional e as restri√ß√µes embancos de dados |
|                                                                                                                       | relacionais................................                                                                           | 38                                                            |
| 3.1                                                                                                                   | Conceitos do modelo relacional...............                                                                         | 39                                                            |
| 3.2                                                                                                                   | Restri√ß√µes em modelo relacional e esquemas                                                                            | Restri√ß√µes em modelo relacional e esquemas                    |
| 3.3                                                                                                                   | Opera√ß√µes de atualiza√ß√£o, transa√ß√µes e tratamento de viola√ß√µes de restri√ß√£o........                                   | 50                                                            |
| Resumo............................................................                                                    | Resumo............................................................                                                    | 52                                                            |
| Perguntas de revis√£o.........................................                                                         | Perguntas de revis√£o.........................................                                                         | 53                                                            |
| Exerc√≠cios.........................................................                                                   | Exerc√≠cios.........................................................                                                   | 53                                                            |
| Bibliografia selecionada....................................                                                          | Bibliografia selecionada....................................                                                          | 56                                                            |
| Cap√≠tulo 4 SQL b√°sica.................................57                                                              | Cap√≠tulo 4 SQL b√°sica.................................57                                                              |                                                               |
| 4.1                                                                                                                   | Defini√ß√µes e tipos de dados em SQL........                                                                            | 58                                                            |
| 4.2                                                                                                                   | Especificando restri√ß√µes em SQL .............                                                                         | 61                                                            |
| 4.3                                                                                                                   | Consultas de recupera√ß√£o b√°sicas em SQL..63                                                                           |                                                               |
| 4.4                                                                                                                   | Instru√ß√µes INSERT , DELETE e UPDATE em SQL...................................................                         | 70                                                            |
| 4.5                                                                                                                   | Recursos adicionais da SQL ....................                                                                       | 72                                                            |
| Resumo............................................................                                                    | Resumo............................................................                                                    | 73                                                            |
| Perguntas de revis√£o.........................................                                                         | Perguntas de revis√£o.........................................                                                         | 73                                                            |
| Exerc√≠cios.........................................................                                                   | Exerc√≠cios.........................................................                                                   | 74                                                            |
| Bibliografia selecionada....................................                                                          | Bibliografia selecionada....................................                                                          | 75                                                            |
| Cap√≠tulo 5 Mais SQL: Consultas complexas, triggers, views e modifica√ß√£o de esquema................................... | Cap√≠tulo 5 Mais SQL: Consultas complexas, triggers, views e modifica√ß√£o de esquema................................... | 76                                                            |
| 5.1 Consultas de recupera√ß√£o SQL mais complexas ...............................................                       | 5.1 Consultas de recupera√ß√£o SQL mais complexas ...............................................                       | 76                                                            |

| 5.2                                                                 | Especificando restri√ß√µes como asser√ß√µes a√ß√µes como triggers .................................              | Especificando restri√ß√µes como asser√ß√µes a√ß√µes como triggers .................................                 | e 87                                                                                                          |
|---------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|
| 5.3                                                                 | Vis√µes (views) -Tabelas virtuais em SQL..88                                                                | Vis√µes (views) -Tabelas virtuais em SQL..88                                                                   |                                                                                                               |
| 5.4                                                                 | Instru√ß√µes de altera√ß√£o de esquema emSQL..91                                                               | Instru√ß√µes de altera√ß√£o de esquema emSQL..91                                                                  |                                                                                                               |
| Resumo............................................................  | Resumo............................................................                                         | Resumo............................................................                                            | 92                                                                                                            |
| Perguntas de revis√£o.........................................       | Perguntas de revis√£o.........................................                                              | Perguntas de revis√£o.........................................                                                 | 93                                                                                                            |
| Exerc√≠cios......................................................... | Exerc√≠cios.........................................................                                        | Exerc√≠cios.........................................................                                           | 94                                                                                                            |
| Bibliografia selecionada....................................        | Bibliografia selecionada....................................                                               | Bibliografia selecionada....................................                                                  | 94                                                                                                            |
| Cap√≠tulo 6 √Ålgebra e c√°lculo relacional.......                      | Cap√≠tulo 6 √Ålgebra e c√°lculo relacional.......                                                             | Cap√≠tulo 6 √Ålgebra e c√°lculo relacional.......                                                                | 96                                                                                                            |
| 6.1                                                                 | Opera√ß√µes relacionais un√°rias: SELE√á√ÉO PROJE√á√ÉO .............................................              | Opera√ß√µes relacionais un√°rias: SELE√á√ÉO PROJE√á√ÉO .............................................                 | e                                                                                                             |
| 6.2                                                                 | Opera√ß√µes de √°lgebra relacional com base teoria dos conjuntos ..............................               | Opera√ß√µes de √°lgebra relacional com base teoria dos conjuntos ..............................                  | na 101                                                                                                        |
| 6.3                                                                 | Opera√ß√µes relacionais bin√°rias: JUN√á√ÉO DIVIS√ÉO ................................................            | Opera√ß√µes relacionais bin√°rias: JUN√á√ÉO DIVIS√ÉO ................................................               | e 105                                                                                                         |
| 6.4                                                                 | Outras opera√ß√µes relacionais.................                                                              | Outras opera√ß√µes relacionais.................                                                                 | 110                                                                                                           |
| 6.5                                                                 | Exemplos de consultas na √°lgebra relacional...............................................                 | Exemplos de consultas na √°lgebra relacional...............................................                    | 115                                                                                                           |
| 6.6                                                                 | O c√°lculo relacional de tupla.................                                                             | O c√°lculo relacional de tupla.................                                                                | 116                                                                                                           |
| 6.7                                                                 | O c√°lculo relacional de dom√≠nio............                                                                | O c√°lculo relacional de dom√≠nio............                                                                   | 123                                                                                                           |
| Resumo..........................................................    | Resumo..........................................................                                           | Resumo..........................................................                                              | 124                                                                                                           |
| Perguntas de revis√£o.......................................         | Perguntas de revis√£o.......................................                                                | Perguntas de revis√£o.......................................                                                   | 125                                                                                                           |
| Exerc√≠cios.......................................................   | Exerc√≠cios.......................................................                                          | Exerc√≠cios.......................................................                                             | 125                                                                                                           |
| Exerc√≠cios de laborat√≥rio ...............................           | Exerc√≠cios de laborat√≥rio ...............................                                                  | Exerc√≠cios de laborat√≥rio ...............................                                                     | 128                                                                                                           |
| Bibliografia selecionada..................................          | Bibliografia selecionada..................................                                                 | Bibliografia selecionada..................................                                                    | 129                                                                                                           |
| Parte 3:                                                            | Parte 3:                                                                                                   | Modelagem conceitual e projeto de banco de dados...........................130                                | Modelagem conceitual e projeto de banco de dados...........................130                                |
| Cap√≠tulo 7                                                          | Cap√≠tulo 7                                                                                                 | Modelagem de dados usando o modelo Entidade-Relacionamento (ER).......................................... 131 | Modelagem de dados usando o modelo Entidade-Relacionamento (ER).......................................... 131 |
| 7.1                                                                 | Usando modelos de dados conceituais de n√≠vel para o projeto do banco de dados...                           | Usando modelos de dados conceituais de n√≠vel para o projeto do banco de dados...                              | alto 132                                                                                                      |
| 7.2 7.3                                                             | Exemplo de aplica√ß√£o de banco de dados..133                                                                | Exemplo de aplica√ß√£o de banco de dados..133                                                                   | entidades, 134                                                                                                |
| 7.4                                                                 | Tipos e conjuntos de relacionamentos, pap√©is e restri√ß√µes estruturais ................                     | Tipos e conjuntos de relacionamentos, pap√©is e restri√ß√µes estruturais ................                        | 140                                                                                                           |
| 7.5                                                                 |                                                                                                            |                                                                                                               |                                                                                                               |
|                                                                     | Tipos de entidade fraca..........................                                                          | Tipos de entidade fraca..........................                                                             | 144                                                                                                           |
| 7.6                                                                 | Refinando o projeto de ER para o banco dados EMPRESA ...................................                   | Refinando o projeto de ER para o banco dados EMPRESA ...................................                      | de 145                                                                                                        |
| 7.7                                                                 | Diagramas ER, conven√ß√µes de nomes e quest√µes de projeto................................                    | Diagramas ER, conven√ß√µes de nomes e quest√µes de projeto................................                       | 146                                                                                                           |
| 7.8                                                                 | Exemplo de outra nota√ß√£o: diagramas de classes UML..........................................               | Exemplo de outra nota√ß√£o: diagramas de classes UML..........................................                  | 148                                                                                                           |
| 7.9                                                                 | Tipos de relacionamento de grau maior que dois ....................................................... 151 | Tipos de relacionamento de grau maior que dois ....................................................... 151    |                                                                                                               |

| Resumo..........................................................       | Resumo..........................................................       | Resumo..........................................................                                                                                                                     | Resumo..........................................................                                                                                                                     | 154                                                                                                                                                    |
|------------------------------------------------------------------------|------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------|
| Perguntas de revis√£o.......................................            | Perguntas de revis√£o.......................................            | Perguntas de revis√£o.......................................                                                                                                                          | Perguntas de revis√£o.......................................                                                                                                                          | 154                                                                                                                                                    |
| Exerc√≠cios.......................................................      | Exerc√≠cios.......................................................      | Exerc√≠cios.......................................................                                                                                                                    | Exerc√≠cios.......................................................                                                                                                                    | 155                                                                                                                                                    |
| Exerc√≠cios de laborat√≥rio ...............................              | Exerc√≠cios de laborat√≥rio ...............................              | Exerc√≠cios de laborat√≥rio ...............................                                                                                                                            | Exerc√≠cios de laborat√≥rio ...............................                                                                                                                            | 159                                                                                                                                                    |
| Bibliografia selecionada..................................             | Bibliografia selecionada..................................             | Bibliografia selecionada..................................                                                                                                                           | Bibliografia selecionada..................................                                                                                                                           | 160                                                                                                                                                    |
| Cap√≠tulo 8                                                             | Cap√≠tulo 8                                                             | Cap√≠tulo 8                                                                                                                                                                           | Cap√≠tulo 8                                                                                                                                                                           | Cap√≠tulo 8                                                                                                                                             |
|                                                                        |                                                                        |                                                                                                                                                                                      | OmodeloEntidade-Relacionamento                                                                                                                                                       | OmodeloEntidade-Relacionamento                                                                                                                         |
|                                                                        |                                                                        |                                                                                                                                                                                      | Estendido (EER)..........................161                                                                                                                                         |                                                                                                                                                        |
| 8.1                                                                    |                                                                        | Subclasses, superclasses e heran√ßa .........                                                                                                                                         | Subclasses, superclasses e heran√ßa .........                                                                                                                                         | 162                                                                                                                                                    |
|                                                                        | 8.2                                                                    | Especializa√ß√£o e generaliza√ß√£o............... Restri√ß√µes e caracter√≠sticas das hierarquias                                                                                           | Especializa√ß√£o e generaliza√ß√£o............... Restri√ß√µes e caracter√≠sticas das hierarquias                                                                                           | 163                                                                                                                                                    |
| 8.3                                                                    |                                                                        | de especializa√ß√£o e generaliza√ß√£o...........                                                                                                                                         | de especializa√ß√£o e generaliza√ß√£o...........                                                                                                                                         | 165                                                                                                                                                    |
| 8.4                                                                    | 8.5                                                                    | Modelagem dos tipos UNIAO usando categorias ..............................................                                                                                           | exemplo de                                                                                                                                                                           | 170 UNIVERSIDADE                                                                                                                                       |
|                                                                        | 8.6                                                                    | de EER, op√ß√µes de projeto e defini√ß√µes formais.................................................. Exemplo de outra nota√ß√£o: representando especializa√ß√£o e generaliza√ß√£o em diagramas | de EER, op√ß√µes de projeto e defini√ß√µes formais.................................................. Exemplo de outra nota√ß√£o: representando especializa√ß√£o e generaliza√ß√£o em diagramas | 172                                                                                                                                                    |
|                                                                        | 8.7                                                                    |                                                                                                                                                                                      |                                                                                                                                                                                      | 176                                                                                                                                                    |
|                                                                        |                                                                        | Conceitos de abstra√ß√£o de dados, representa√ß√£o do conhecimento e ontologia......................                                                                                     | Conceitos de abstra√ß√£o de dados, representa√ß√£o do conhecimento e ontologia......................                                                                                     | 181                                                                                                                                                    |
| Resumo..........................................................       | Resumo..........................................................       | Resumo..........................................................                                                                                                                     | Resumo..........................................................                                                                                                                     | 181                                                                                                                                                    |
| Exerc√≠cios.......................................................      | Exerc√≠cios.......................................................      | Exerc√≠cios.......................................................                                                                                                                    | Exerc√≠cios.......................................................                                                                                                                    | 181                                                                                                                                                    |
| Perguntas de revis√£o....................................... Exerc√≠cios | Perguntas de revis√£o....................................... Exerc√≠cios | Perguntas de revis√£o....................................... Exerc√≠cios                                                                                                               | de laborat√≥rio                                                                                                                                                                       | 186                                                                                                                                                    |
| Bibliografia selecionada..................................             | Bibliografia selecionada..................................             | Bibliografia selecionada..................................                                                                                                                           | Bibliografia selecionada..................................                                                                                                                           | 188                                                                                                                                                    |
| Cap√≠tulo 9                                                             | Cap√≠tulo 9                                                             | Cap√≠tulo 9                                                                                                                                                                           | Projeto de banco de dados relacional por mapeamento ER e EER para relacional ..................189                                                                                   | Projeto de banco de dados relacional por mapeamento ER e EER para relacional ..................189                                                     |
| 9.2                                                                    | 9.1                                                                    | Projeto de banco de dados relacional usando o mapeamento ER para relacional......... Mapeando constru√ß√µes do modelo EER rela√ß√µes .................................................   | Projeto de banco de dados relacional usando o mapeamento ER para relacional......... Mapeando constru√ß√µes do modelo EER rela√ß√µes .................................................   | para 195                                                                                                                                               |
| Resumo..........................................................       | Resumo..........................................................       | Resumo..........................................................                                                                                                                     | Resumo..........................................................                                                                                                                     | 198                                                                                                                                                    |
| Perguntas de revis√£o.......................................            | Perguntas de revis√£o.......................................            | Perguntas de revis√£o.......................................                                                                                                                          | Perguntas de revis√£o.......................................                                                                                                                          | 199                                                                                                                                                    |
| Exerc√≠cios.......................................................      | Exerc√≠cios.......................................................      | Exerc√≠cios.......................................................                                                                                                                    | Exerc√≠cios.......................................................                                                                                                                    | 199                                                                                                                                                    |
| Exerc√≠cios de laborat√≥rio ...............................              | Exerc√≠cios de laborat√≥rio ...............................              | Exerc√≠cios de laborat√≥rio ...............................                                                                                                                            | Exerc√≠cios de laborat√≥rio ...............................                                                                                                                            | 200                                                                                                                                                    |
| Bibliografia selecionada..................................             | Bibliografia selecionada..................................             | Bibliografia selecionada..................................                                                                                                                           | Bibliografia selecionada..................................                                                                                                                           | 200                                                                                                                                                    |
| Cap√≠tulo 10                                                            | Cap√≠tulo 10                                                            | Cap√≠tulo 10                                                                                                                                                                          | Metodologia pr√°tica de projeto de banco de dados e uso de                                                                                                                            | Metodologia pr√°tica de projeto de banco de dados e uso de                                                                                              |
| 10.1                                                                   | 10.1                                                                   | 10.1                                                                                                                                                                                 | diagramas UML......................201                                                                                                                                               | diagramas UML......................201                                                                                                                 |
| O                                                                      | O                                                                      | O                                                                                                                                                                                    | papel dos sistemas de informa√ß√£o nas                                                                                                                                                 | papel dos sistemas de informa√ß√£o nas                                                                                                                   |
| 10.2                                                                   |                                                                        |                                                                                                                                                                                      | organiza√ß√µes........................................ 202 O projeto de banco de dados e o processo de implementa√ß√£o................................ 205                               | organiza√ß√µes........................................ 202 O projeto de banco de dados e o processo de implementa√ß√£o................................ 205 |

| 10.3                                                                                                                         | Uso de diagramas UML como recurso para especifica√ß√£o de projeto de banco dados...................................................   | de 219                                             |
|------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------|
| 10.4                                                                                                                         | Rational Rose: uma ferramenta de projeto baseada em UML................................                                             | 225                                                |
| 10.5                                                                                                                         | Ferramentas de projeto automatizado de banco de dados....................................                                           | 229                                                |
| Resumo..........................................................                                                             | Resumo..........................................................                                                                    | 231                                                |
| Perguntas de revis√£o.......................................                                                                  | Perguntas de revis√£o.......................................                                                                         | 232                                                |
| Bibliografia selecionada..................................                                                                   | Bibliografia selecionada..................................                                                                          | 233                                                |
| Parte 4:                                                                                                                     | Objeto, objeto-relacional e XML: conceitos, modelos, linguagens e padr√µes.......................................235                 |                                                    |
| Cap√≠tulo 11 Bancos de dados de objeto e objeto-relacional....................                                                | Cap√≠tulo 11 Bancos de dados de objeto e objeto-relacional....................                                                       | 236                                                |
| 11.1                                                                                                                         | Vis√£o geral dos conceitos de banco de dados de objeto ...................................                                           | 237                                                |
| 11.2                                                                                                                         | Recursos objeto-relacional: extens√µes do banco de dados de objeto para SQL.... 247                                                  |                                                    |
| 11.3                                                                                                                         | O modelo de objeto ODMGe a Object Definition Language (ODL).................                                                        | 252                                                |
| 11.4                                                                                                                         | Projeto conceitual de banco de dados de objeto..................................................                                    | 267                                                |
| 11.5                                                                                                                         | A linguagem de consulta de objeto (OQL -Object Query Language).................                                                     | 269                                                |
| 11.6                                                                                                                         | Vis√£o geral de binding da linguagem C++ no padr√£o ODMG...............................                                               | 275                                                |
| Resumo.......................................................... Perguntas de revis√£o....................................... | Resumo.......................................................... Perguntas de revis√£o.......................................        | 276                                                |
| Exerc√≠cios.......................................................                                                            | Exerc√≠cios.......................................................                                                                   | 277                                                |
| Bibliografia selecionada..................................                                                                   | Bibliografia selecionada..................................                                                                          | 278                                                |
| Cap√≠tulo 12 XML: Extensible Markup                                                                                           | Cap√≠tulo 12 XML: Extensible Markup                                                                                                  | Language...............................279         |
| 12.2                                                                                                                         | n√£o Modelo de dados hier√°rquico (em √°rvore) da XML.............................................. 283                                | estruturados.................................. 280 |
| 12.3                                                                                                                         | Documentos XML, DTD e esquema XML...................................................                                                | 284                                                |
| 12.4                                                                                                                         | Armazenando e extraindo documentos                                                                                                  |                                                    |
| 12.5                                                                                                                         | XML de bancos de dados.................... Linguagens                                                                               | 291 XML................................. 292       |
| 12.6                                                                                                                         | Extraindo documentos XML de bancos dados relacionais.................................                                               | de 295                                             |
| Resumo..........................................................                                                             | Resumo..........................................................                                                                    | 300                                                |
| Perguntas de revis√£o.......................................                                                                  | Perguntas de revis√£o.......................................                                                                         | 300                                                |
| Exerc√≠cios.......................................................                                                            | Exerc√≠cios.......................................................                                                                   | 300                                                |
| Bibliografia selecionada..................................                                                                   | Bibliografia selecionada..................................                                                                          | 300                                                |

| Parte 5:                                                                                                                                                                                                 | T√©cnicas de programa√ß√£o de banco de dados .....................................301                                                                                                                       | T√©cnicas de programa√ß√£o de banco de dados .....................................301                                                                                                                       | T√©cnicas de programa√ß√£o de banco de dados .....................................301                                                                                                                       |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Cap√≠tulo 13                                                                                                                                                                                              | Cap√≠tulo 13                                                                                                                                                                                              | Introdu√ß√£o √†s t√©cnicas de programa√ß√£o SQL..................                                                                                                                                              | 302                                                                                                                                                                                                      |
| 13.1                                                                                                                                                                                                     | 13.1                                                                                                                                                                                                     | Programa√ß√£o de banco de dados: t√©cnicas problemas............................................ 303                                                                                                        | e                                                                                                                                                                                                        |
| 13.2                                                                                                                                                                                                     | 13.2                                                                                                                                                                                                     | SQL embutida, SQL din√¢mica e SQLJ ...                                                                                                                                                                    | 305                                                                                                                                                                                                      |
| 13.3                                                                                                                                                                                                     | 13.3                                                                                                                                                                                                     | Programa√ß√£o de banco de dados com                                                                                                                                                                        |                                                                                                                                                                                                          |
|                                                                                                                                                                                                          |                                                                                                                                                                                                          | chamadas de fun√ß√£o: SQL/CLI e JDBC...                                                                                                                                                                    | 314                                                                                                                                                                                                      |
| 13.5                                                                                                                                                                                                     | 13.5                                                                                                                                                                                                     | Comparando as tr√™s t√©cnicas ...............                                                                                                                                                              | 322                                                                                                                                                                                                      |
|                                                                                                                                                                                                          |                                                                                                                                                                                                          | Resumo..........................................................                                                                                                                                         | 323                                                                                                                                                                                                      |
| Perguntas                                                                                                                                                                                                | Perguntas                                                                                                                                                                                                | de revis√£o.......................................                                                                                                                                                        | 323                                                                                                                                                                                                      |
|                                                                                                                                                                                                          |                                                                                                                                                                                                          | Exerc√≠cios.......................................................                                                                                                                                        | 323                                                                                                                                                                                                      |
| Bibliografia                                                                                                                                                                                             | Bibliografia                                                                                                                                                                                             |                                                                                                                                                                                                          | 324                                                                                                                                                                                                      |
|                                                                                                                                                                                                          |                                                                                                                                                                                                          | selecionada..................................                                                                                                                                                            |                                                                                                                                                                                                          |
| Cap√≠tulo 14 Programa√ß√£o de banco de dados                                                                                                                                                                | Cap√≠tulo 14 Programa√ß√£o de banco de dados                                                                                                                                                                | Cap√≠tulo 14 Programa√ß√£o de banco de dados                                                                                                                                                                | Cap√≠tulo 14 Programa√ß√£o de banco de dados                                                                                                                                                                |
| Web usando PHP....................325                                                                                                                                                                    | Web usando PHP....................325                                                                                                                                                                    | Web usando PHP....................325                                                                                                                                                                    | Web usando PHP....................325                                                                                                                                                                    |
| 14.1 Um exemplo simples em PHP.............. 325                                                                                                                                                         | 14.1 Um exemplo simples em PHP.............. 325                                                                                                                                                         | 14.1 Um exemplo simples em PHP.............. 325                                                                                                                                                         | 14.1 Um exemplo simples em PHP.............. 325                                                                                                                                                         |
| dados em PHP..................................... 332 Resumo.......................................................... 335                                                                               | dados em PHP..................................... 332 Resumo.......................................................... 335                                                                               | dados em PHP..................................... 332 Resumo.......................................................... 335                                                                               | dados em PHP..................................... 332 Resumo.......................................................... 335                                                                               |
| de revis√£o....................................... 335                                                                                                                                                    | de revis√£o....................................... 335                                                                                                                                                    | de revis√£o....................................... 335                                                                                                                                                    | de revis√£o....................................... 335                                                                                                                                                    |
| Perguntas Exerc√≠cios....................................................... 335                                                                                                                          | Perguntas Exerc√≠cios....................................................... 335                                                                                                                          | Perguntas Exerc√≠cios....................................................... 335                                                                                                                          | Perguntas Exerc√≠cios....................................................... 335                                                                                                                          |
| Bibliografia selecionada.................................. 335                                                                                                                                           | Bibliografia selecionada.................................. 335                                                                                                                                           | Bibliografia selecionada.................................. 335                                                                                                                                           | Bibliografia selecionada.................................. 335                                                                                                                                           |
| Parte 6: Teoria e normaliza√ß√£o de projeto de                                                                                                                                                             | Parte 6: Teoria e normaliza√ß√£o de projeto de                                                                                                                                                             | Parte 6: Teoria e normaliza√ß√£o de projeto de                                                                                                                                                             | Parte 6: Teoria e normaliza√ß√£o de projeto de                                                                                                                                                             |
| banco de dados.......................... 336 15 Fundamentos de depend√™ncias                                                                                                                              | banco de dados.......................... 336 15 Fundamentos de depend√™ncias                                                                                                                              | banco de dados.......................... 336 15 Fundamentos de depend√™ncias                                                                                                                              | banco de dados.......................... 336 15 Fundamentos de depend√™ncias                                                                                                                              |
| Cap√≠tulo                                                                                                                                                                                                 | Cap√≠tulo                                                                                                                                                                                                 | Cap√≠tulo                                                                                                                                                                                                 | Cap√≠tulo                                                                                                                                                                                                 |
| funcionais e normaliza√ß√£o para                                                                                                                                                                           | funcionais e normaliza√ß√£o para                                                                                                                                                                           | funcionais e normaliza√ß√£o para                                                                                                                                                                           | funcionais e normaliza√ß√£o para                                                                                                                                                                           |
| 15.1 Diretrizes de projeto informais para                                                                                                                                                                | 15.1 Diretrizes de projeto informais para                                                                                                                                                                | 15.1 Diretrizes de projeto informais para                                                                                                                                                                | 15.1 Diretrizes de projeto informais para                                                                                                                                                                |
| esquemas de rela√ß√£o ............................ 338 15.2 Depend√™ncias funcionais ..................... 346 Formas normais baseadas em chaves prim√°rias............................................. 347 | esquemas de rela√ß√£o ............................ 338 15.2 Depend√™ncias funcionais ..................... 346 Formas normais baseadas em chaves prim√°rias............................................. 347 | esquemas de rela√ß√£o ............................ 338 15.2 Depend√™ncias funcionais ..................... 346 Formas normais baseadas em chaves prim√°rias............................................. 347 | esquemas de rela√ß√£o ............................ 338 15.2 Depend√™ncias funcionais ..................... 346 Formas normais baseadas em chaves prim√°rias............................................. 347 |
| Defini√ß√µes gerais da segunda e terceira                                                                                                                                                                  | Defini√ß√µes gerais da segunda e terceira                                                                                                                                                                  | Defini√ß√µes gerais da segunda e terceira                                                                                                                                                                  | Defini√ß√µes gerais da segunda e terceira                                                                                                                                                                  |
| formas normais ................................... 353                                                                                                                                                   | formas normais ................................... 353                                                                                                                                                   | formas normais ................................... 353                                                                                                                                                   | formas normais ................................... 353                                                                                                                                                   |
| Forma normal de Boyce-Codd............. 355                                                                                                                                                              | Forma normal de Boyce-Codd............. 355                                                                                                                                                              | Forma normal de Boyce-Codd............. 355                                                                                                                                                              | Forma normal de Boyce-Codd............. 355                                                                                                                                                              |
| Depend√™ncia multivalorada e quarta forma normal................................................. 357                                                                                                     | Depend√™ncia multivalorada e quarta forma normal................................................. 357                                                                                                     | Depend√™ncia multivalorada e quarta forma normal................................................. 357                                                                                                     | Depend√™ncia multivalorada e quarta forma normal................................................. 357                                                                                                     |
| Depend√™ncias de jun√ß√£o e quinta forma                                                                                                                                                                    | Depend√™ncias de jun√ß√£o e quinta forma                                                                                                                                                                    | Depend√™ncias de jun√ß√£o e quinta forma                                                                                                                                                                    | Depend√™ncias de jun√ß√£o e quinta forma                                                                                                                                                                    |
| normal................................................. 359                                                                                                                                              | normal................................................. 359                                                                                                                                              | normal................................................. 359                                                                                                                                              | normal................................................. 359                                                                                                                                              |
| 15.3                                                                                                                                                                                                     | 15.3                                                                                                                                                                                                     | 15.3                                                                                                                                                                                                     | 15.3                                                                                                                                                                                                     |
| 15.4 15.5 15.6 15.7                                                                                                                                                                                      | 15.4 15.5 15.6 15.7                                                                                                                                                                                      | 15.4 15.5 15.6 15.7                                                                                                                                                                                      | 15.4 15.5 15.6 15.7                                                                                                                                                                                      |
| Resumo.......................................................... 360                                                                                                                                     | Resumo.......................................................... 360                                                                                                                                     | Resumo.......................................................... 360                                                                                                                                     | Resumo.......................................................... 360                                                                                                                                     |

| Exerc√≠cios.......................................................                                               | Exerc√≠cios.......................................................                                               | Exerc√≠cios.......................................................                                               |
|-----------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------|
| Exerc√≠cio de laborat√≥rio.................................                                                       | Exerc√≠cio de laborat√≥rio.................................                                                       | Exerc√≠cio de laborat√≥rio.................................                                                       |
| Bibliografia selecionada..................................                                                      | Bibliografia selecionada..................................                                                      | Bibliografia selecionada..................................                                                      |
| Cap√≠tulo 16 Algoritmos de projeto de banco                                                                      | Cap√≠tulo 16 Algoritmos de projeto de banco                                                                      | Cap√≠tulo 16 Algoritmos de projeto de banco                                                                      |
| dados relacional e demais                                                                                       | dados relacional e demais                                                                                       | depend√™ncias                                                                                                    |
| 16.1 Outros t√≥picos em depend√™ncias funcionais: regras de infer√™ncia, equival√™ncia e cobertura m√≠nima ......... | 16.1 Outros t√≥picos em depend√™ncias funcionais: regras de infer√™ncia, equival√™ncia e cobertura m√≠nima ......... | 16.1 Outros t√≥picos em depend√™ncias funcionais: regras de infer√™ncia, equival√™ncia e cobertura m√≠nima ......... |
| 16.2 Propriedades de decomposi√ß√µes relacionais ...........................................                      | 16.2 Propriedades de decomposi√ß√µes relacionais ...........................................                      | 16.2 Propriedades de decomposi√ß√µes relacionais ...........................................                      |
| 16.3 Algoritmos para projeto de esquema de banco de dados relacional ...................                        | 16.3 Algoritmos para projeto de esquema de banco de dados relacional ...................                        | 16.3 Algoritmos para projeto de esquema de banco de dados relacional ...................                        |
| 16.4 Sobre nulos, tuplas suspensas e projetos relacionais alternativos........................                  | 16.4 Sobre nulos, tuplas suspensas e projetos relacionais alternativos........................                  | 16.4 Sobre nulos, tuplas suspensas e projetos relacionais alternativos........................                  |
| 16.5 Discuss√£o adicional sobre depend√™ncias multivaloradas e 4FN..........................                      | 16.5 Discuss√£o adicional sobre depend√™ncias multivaloradas e 4FN..........................                      | 16.5 Discuss√£o adicional sobre depend√™ncias multivaloradas e 4FN..........................                      |
| 16.6 Outras depend√™ncias e formas normais..                                                                     | 16.6 Outras depend√™ncias e formas normais..                                                                     | 16.6 Outras depend√™ncias e formas normais..                                                                     |
|                                                                                                                 |                                                                                                                 | Resumo..........................................................                                                |
| Perguntas de revis√£o.......................................                                                     | Perguntas de revis√£o.......................................                                                     | Perguntas de revis√£o.......................................                                                     |
| Exerc√≠cios.......................................................                                               | Exerc√≠cios.......................................................                                               | Exerc√≠cios.......................................................                                               |
| Exerc√≠cios de laborat√≥rio ...............................                                                       | Exerc√≠cios de laborat√≥rio ...............................                                                       | Exerc√≠cios de laborat√≥rio ...............................                                                       |
| Bibliografia selecionada..................................                                                      | Bibliografia selecionada..................................                                                      | Bibliografia selecionada..................................                                                      |
| Parte 7: Estruturas de arquivo, indexa√ß√£o e                                                                     | Parte 7: Estruturas de arquivo, indexa√ß√£o e                                                                     | Parte 7: Estruturas de arquivo, indexa√ß√£o e                                                                     |
|                                                                                                                 | hashing...................................... 17                                                                | Armazenamentodedisco, estruturas dearquivo b√°sicas ehashing.....389                                             |
|                                                                                                                 |                                                                                                                 |                                                                                                                 |
| 17.1 Introdu√ß√£o........................................... 17.2 Dispositivos de armazenamento                   | secund√°rios..........................................                                                           | 17.1 Introdu√ß√£o........................................... 17.2 Dispositivos de armazenamento                   |
| 17.3 Buffering de blocos..............................                                                          | 17.3 Buffering de blocos..............................                                                          | 17.3 Buffering de blocos..............................                                                          |
|                                                                                                                 |                                                                                                                 |                                                                                                                 |
| 17.4 Gravando registros de arquivo no disco..                                                                   | arquivos                                                                                                        | Opera√ß√µes em                                                                                                    |
| 17.6 Arquivos de registros desordenados                                                                         | 17.6 Arquivos de registros desordenados                                                                         | 17.6 Arquivos de registros desordenados                                                                         |
| (arquivos de heap)...............................                                                               | (arquivos de heap)...............................                                                               | (arquivos de heap)...............................                                                               |
| 17.7 Arquivos de registros ordenados                                                                            | classificados)........................................                                                          | 17.7 Arquivos de registros ordenados                                                                            |
| 17.9 Outras organiza√ß√µes de arquivo                                                                             | 17.9 Outras organiza√ß√µes de arquivo                                                                             | 17.9 Outras organiza√ß√µes de arquivo                                                                             |
| prim√°rias.............................................                                                          | prim√°rias.............................................                                                          | prim√°rias.............................................                                                          |
| 17.10 Paralelizando o acesso de disco usando tecnologia RAID................................                    | 17.10 Paralelizando o acesso de disco usando tecnologia RAID................................                    | 17.10 Paralelizando o acesso de disco usando tecnologia RAID................................                    |
|                                                                                                                 |                                                                                                                 |                                                                                                                 |
| 17.11 Novos sistemas de armazenamento ... Resumo..........................................................      | 17.11 Novos sistemas de armazenamento ... Resumo..........................................................      | 17.11 Novos sistemas de armazenamento ... Resumo..........................................................      |
|                                                                                                                 |                                                                                                                 |                                                                                                                 |
| Perguntas de revis√£o.......................................                                                     | Perguntas de revis√£o.......................................                                                     | Perguntas de revis√£o.......................................                                                     |
| Bibliografia selecionada..................................                                                      | Bibliografia selecionada..................................                                                      | Bibliografia selecionada..................................                                                      |

| Cap√≠tulo 18                                                       | Cap√≠tulo 18                                                                                   | Estruturas de indexa√ß√£o para arquivos................................                                     | 424                  |
|-------------------------------------------------------------------|-----------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------|----------------------|
| 18.1                                                              | Tipos de √≠ndices ordenados de √∫nico n√≠vel..424                                                | Tipos de √≠ndices ordenados de √∫nico n√≠vel..424                                                            |                      |
| 18.2                                                              | √çndices multin√≠veis...............................                                            | √çndices multin√≠veis...............................                                                        | 433                  |
| 18.3                                                              | √çndices multin√≠veis din√¢micos usando B-trees e B + -trees..................................   | √çndices multin√≠veis din√¢micos usando B-trees e B + -trees..................................               | 435                  |
| 18.4                                                              | √çndices em chaves m√∫ltiplas.................                                                  | √çndices em chaves m√∫ltiplas.................                                                              | 445                  |
| 18.5                                                              | Outros tipos de √≠ndices........................                                               | Outros tipos de √≠ndices........................                                                           | 447                  |
| 18.6                                                              | Algumas quest√µes gerais referentes √† indexa√ß√£o............................................    | Algumas quest√µes gerais referentes √† indexa√ß√£o............................................                | 450                  |
| Resumo..........................................................  | Resumo..........................................................                              | Resumo..........................................................                                          | 452                  |
| Perguntas de revis√£o.......................................       | Perguntas de revis√£o.......................................                                   | Perguntas de revis√£o.......................................                                               | 453                  |
| Exerc√≠cios....................................................... | Exerc√≠cios.......................................................                             | Exerc√≠cios.......................................................                                         | 453                  |
| Bibliografia selecionada..................................        | Bibliografia selecionada..................................                                    | Bibliografia selecionada..................................                                                | 455                  |
| Parte 8:                                                          | Parte 8:                                                                                      | Processamento de consulta, otimiza√ß√£o e ajuste de banco de dados......................................... | 456                  |
| Cap√≠tulo 19                                                       | Cap√≠tulo 19                                                                                   | Algoritmos para processamento otimiza√ß√£o de consulta...........457                                        | e                    |
| 19.1 19.2                                                         | Traduzindo consultas SQL para √°lgebra relacional............................................. | Algoritmos para ordena√ß√£o                                                                                 | 459 externa..... 459 |
| 19.3                                                              | Algoritmos para opera√ß√µes SELE√á√ÉO JUN√á√ÉO ..............................................       | Algoritmos para opera√ß√µes SELE√á√ÉO JUN√á√ÉO ..............................................                   | e 461                |
| 19.4                                                              | Algoritmos para opera√ß√µes PROJE√á√ÉO de conjunto .........................................      | Algoritmos para opera√ß√µes PROJE√á√ÉO de conjunto .........................................                  | e 469                |
| 19.5                                                              | Implementando opera√ß√µes de agrega√ß√£o JUN√á√ÉO EXTERNA .............................             | Implementando opera√ß√µes de agrega√ß√£o JUN√á√ÉO EXTERNA .............................                         | e 470                |
| 19.6                                                              | Combinando opera√ß√µes com pipelining ..                                                        | Combinando opera√ß√µes com pipelining ..                                                                    | 472                  |
| 19.7                                                              | Usando a heur√≠stica na otimiza√ß√£o da consulta...............................................  | Usando a heur√≠stica na otimiza√ß√£o da consulta...............................................              | 472                  |
| 19.8                                                              | Usando seletividade e estimativas de                                                          | Usando seletividade e estimativas de                                                                      | custo 479            |
| 19.9                                                              | Vis√£o geral da otimiza√ß√£o da consulta                                                         | Vis√£o geral da otimiza√ß√£o da consulta                                                                     | no 487               |
| Oracle ................................................. 19.10    | Oracle ................................................. 19.10                                | Otimiza√ß√£o de consulta                                                                                    | sem√¢ntica..... 487   |
| Resumo..........................................................  | Resumo..........................................................                              | Resumo..........................................................                                          | 488                  |
| Perguntas de revis√£o.......................................       | Perguntas de revis√£o.......................................                                   | Perguntas de revis√£o.......................................                                               | 488                  |
| Exerc√≠cios....................................................... | Exerc√≠cios.......................................................                             | Exerc√≠cios.......................................................                                         | 488                  |
| Bibliografia selecionada..................................        | Bibliografia selecionada..................................                                    | Bibliografia selecionada..................................                                                | 489                  |
| Cap√≠tulo 20                                                       | Cap√≠tulo 20                                                                                   | Projeto f√≠sico e ajuste de banco de dados ..............................                                  | 490                  |
| 20.1                                                              | Projeto f√≠sico em bancos de dados relacionais ...........................................     | Projeto f√≠sico em bancos de dados relacionais ...........................................                 | 490                  |
| 20.2                                                              | Vis√£o geral do ajuste de banco de dados sistemas relacionais .............................    | Vis√£o geral do ajuste de banco de dados sistemas relacionais .............................                | em 494               |
|                                                                   | Resumo..........................................................                              | Resumo..........................................................                                          | 498                  |

| Perguntas de revis√£o.......................................                            | Perguntas de revis√£o.......................................                                                                        | Perguntas de revis√£o.......................................                                                                        | 498                                                                                            |
|----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------|
| Bibliografia selecionada..................................                             | Bibliografia selecionada..................................                                                                         | Bibliografia selecionada..................................                                                                         | 498                                                                                            |
| Parte 9:                                                                               | Processamento detransa√ß√µes, controle deconcorr√™ncia erecupera√ß√£o........499                                                        | Processamento detransa√ß√µes, controle deconcorr√™ncia erecupera√ß√£o........499                                                        | Processamento detransa√ß√µes, controle deconcorr√™ncia erecupera√ß√£o........499                    |
| Cap√≠tulo 21 Introdu√ß√£o aosconceitos eteoria processamento detransa√ß√µes                 | Cap√≠tulo 21 Introdu√ß√£o aosconceitos eteoria processamento detransa√ß√µes                                                             | Cap√≠tulo 21 Introdu√ß√£o aosconceitos eteoria processamento detransa√ß√µes                                                             | de ...500                                                                                      |
| 21.1                                                                                   | Introdu√ß√£o ao processamento de transa√ß√µes............................................                                              | Introdu√ß√£o ao processamento de transa√ß√µes............................................                                              | 500                                                                                            |
| 21.2                                                                                   | Conceitos de transa√ß√£o e sistema.........                                                                                          | Conceitos de transa√ß√£o e sistema.........                                                                                          | 506                                                                                            |
| 21.3                                                                                   | Propriedades desej√°veis das transa√ß√µes                                                                                             | Propriedades desej√°veis das transa√ß√µes                                                                                             | 508                                                                                            |
| 21.4                                                                                   | Caracterizando schedules com base na facilidade de recupera√ß√£o ....................                                                | Caracterizando schedules com base na facilidade de recupera√ß√£o ....................                                                | 509                                                                                            |
| 21.5                                                                                   | Caracterizando schedules com base na facilidade de serializa√ß√£o .....................                                              | Caracterizando schedules com base na facilidade de serializa√ß√£o .....................                                              | 511                                                                                            |
| 21.6                                                                                   | Suporte para transa√ß√£o em SQL..........                                                                                            | Suporte para transa√ß√£o em SQL..........                                                                                            | 519                                                                                            |
| Resumo..........................................................                       | Resumo..........................................................                                                                   | Resumo..........................................................                                                                   | 520                                                                                            |
| Perguntas de revis√£o.......................................                            | Perguntas de revis√£o.......................................                                                                        | Perguntas de revis√£o.......................................                                                                        | 520                                                                                            |
| Exerc√≠cios.......................................................                      | Exerc√≠cios.......................................................                                                                  | Exerc√≠cios.......................................................                                                                  | 521                                                                                            |
| Bibliografia selecionada..................................                             | Bibliografia selecionada..................................                                                                         | Bibliografia selecionada..................................                                                                         | 522                                                                                            |
| Cap√≠tulo 22 T√©cnicas de controle de                                                    | Cap√≠tulo 22 T√©cnicas de controle de                                                                                                | Cap√≠tulo 22 T√©cnicas de controle de                                                                                                |                                                                                                |
| concorr√™ncia..........................523 22.1 T√©cnicas de bloqueio em duas fases para | concorr√™ncia..........................523 22.1 T√©cnicas de bloqueio em duas fases para                                             | concorr√™ncia..........................523 22.1 T√©cnicas de bloqueio em duas fases para                                             |                                                                                                |
|                                                                                        | controle de concorr√™ncia ..................... 523                                                                                 | controle de concorr√™ncia ..................... 523                                                                                 | controle de concorr√™ncia ..................... 523                                             |
|                                                                                        | Controle deconcorr√™ncia baseadonaordena√ß√£o de r√≥tulo de tempo (timestamp)................. 531                                     | Controle deconcorr√™ncia baseadonaordena√ß√£o de r√≥tulo de tempo (timestamp)................. 531                                     | Controle deconcorr√™ncia baseadonaordena√ß√£o de r√≥tulo de tempo (timestamp)................. 531 |
| 22.3                                                                                   | T√©cnicas de controle de concorr√™ncia multivers√£o..........................................                                         | T√©cnicas de controle de concorr√™ncia multivers√£o..........................................                                         | 533                                                                                            |
| 22.4                                                                                   | T√©cnicas de controle de concorr√™ncia de valida√ß√£o (otimista).............................                                          | T√©cnicas de controle de concorr√™ncia de valida√ß√£o (otimista).............................                                          | 535                                                                                            |
| 22.6                                                                                   | bloqueio de granularidade m√∫ltiplo.....                                                                                            | Usando bloqueios                                                                                                                   | 539                                                                                            |
|                                                                                        | concorr√™ncia em √≠ndices....................... Outras quest√µes de controle de concorr√™ncia........................................ | concorr√™ncia em √≠ndices....................... Outras quest√µes de controle de concorr√™ncia........................................ |                                                                                                |
| 22.7                                                                                   |                                                                                                                                    |                                                                                                                                    | 539                                                                                            |
| Resumo..........................................................                       | Resumo..........................................................                                                                   | Resumo..........................................................                                                                   | 540                                                                                            |
| Perguntas de revis√£o.......................................                            | Perguntas de revis√£o.......................................                                                                        | Perguntas de revis√£o.......................................                                                                        | 541                                                                                            |
| Exerc√≠cios.......................................................                      | Exerc√≠cios.......................................................                                                                  | Exerc√≠cios.......................................................                                                                  | 542                                                                                            |
| Bibliografia selecionada..................................                             | Bibliografia selecionada..................................                                                                         | Bibliografia selecionada..................................                                                                         | 542                                                                                            |
| Cap√≠tulo 23                                                                            | Cap√≠tulo 23                                                                                                                        | T√©cnicas de recupera√ß√£o de banco de dados................................543                                                       |                                                                                                |
| 23.1                                                                                   | Conceitos de recupera√ß√£o....................                                                                                       | Conceitos de recupera√ß√£o....................                                                                                       | 543                                                                                            |
| 23.2                                                                                   | Recupera√ß√£o NO-UNDO/REDO baseada                                                                                                   | atualiza√ß√£o                                                                                                                        | 549                                                                                            |
| 23.3                                                                                   | T√©cnicas de recupera√ß√£o baseadas em atualiza√ß√£o imediata............................                                               | T√©cnicas de recupera√ß√£o baseadas em atualiza√ß√£o imediata............................                                               | 550                                                                                            |

| 23.4                                                              | Pagina√ß√£o de sombra...........................                                                                                                  | 552       |
|-------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------|-----------|
| 23.5                                                              | O algoritmo de recupera√ß√£o ARIES.....                                                                                                           | 553       |
| 23.6                                                              | Recupera√ß√£o em sistemas de m√∫ltiplos bancos de dados ..................................                                                         | 556       |
| 23.7                                                              | Backup e recupera√ß√£o de banco de dados contra falhas catastr√≥ficas ...................                                                          | 557       |
| Resumo..........................................................  | Resumo..........................................................                                                                                | 557       |
| Perguntas de revis√£o.......................................       | Perguntas de revis√£o.......................................                                                                                     | 558       |
| Exerc√≠cios....................................................... | Exerc√≠cios.......................................................                                                                               | 558       |
| Bibliografia selecionada..................................        | Bibliografia selecionada..................................                                                                                      | 560       |
| Parte 10:                                                         | T√≥picos adicionais debancodedados: seguran√ßa edistribui√ß√£o................                                                                      | 561       |
| Cap√≠tulo 24 Seguran√ßa debancodedados...562                        | Cap√≠tulo 24 Seguran√ßa debancodedados...562                                                                                                      |           |
| 24.1                                                              | Introdu√ß√£o a quest√µes de seguran√ßa de banco de dados....................................                                                        | 562       |
| 24.2                                                              | Controle de acesso discricion√°rio baseado na concess√£o e revoga√ß√£o de privil√©gios .. 567                                                        |           |
| 24.3                                                              | Controle de acesso obrigat√≥rio e controle de acesso baseado em papel para seguran√ßa multin√≠vel ............................................ 570 |           |
| 24.4                                                              | Inje√ß√£o de SQL....................................                                                                                              | 575       |
| 24.5                                                              | Introdu√ß√£o √† seguran√ßa do banco de estat√≠stico ............................................                                                     | dados 577 |
| 24.6                                                              | Introdu√ß√£o ao controle de fluxo ..........                                                                                                      | 579       |
| 24.7                                                              | Criptografia e infraestruturas de chave p√∫blica ................................................                                                | 580       |
| 24.8                                                              | Quest√µes de privacidade e preserva√ß√£o                                                                                                           | 582       |
| 24.9                                                              | Desafios da seguran√ßa do banco de dados.                                                                                                        | 583       |
| 24.10                                                             | Seguran√ßa baseada em r√≥tulo no Oracle                                                                                                           | . 584     |
| Resumo..........................................................  | Resumo..........................................................                                                                                | 586       |
| Perguntas de revis√£o.......................................       | Perguntas de revis√£o.......................................                                                                                     | 587       |
| Exerc√≠cios....................................................... | Exerc√≠cios.......................................................                                                                               | 587       |
| Bibliografia selecionada..................................        | Bibliografia selecionada..................................                                                                                      | 588       |
| Cap√≠tulo 25 Bancosdedadosdistribu√≠dos....589                      | Cap√≠tulo 25 Bancosdedadosdistribu√≠dos....589                                                                                                    |           |
| 25.1                                                              | Conceitos de banco de dados distribu√≠do..                                                                                                       | 590       |
| 25.2                                                              | Tipos de sistemas de bancos de dados distribu√≠dos .........................................                                                     | 593       |
| 25.3                                                              | Arquiteturas de banco de dados distribu√≠das..........................................                                                           | 596       |
| 25.4                                                              | T√©cnicas de fragmenta√ß√£o, replica√ß√£o e aloca√ß√£o de dados para projeto de banco de dados distribu√≠do............................ 601             |           |
| 25.5                                                              | Processamento e otimiza√ß√£o de consulta bancos de dados distribu√≠dos............... 605                                                          | em        |
| 25.6                                                              | Vis√£o geral do gerenciamento de transa√ß√£o em bancos de dados distribu√≠dos .........                                                             | 611       |

Parte 11:

| 25.7                                                                  | Vis√£o geral do controle de concorr√™ncia e recupera√ß√£o em bancos de dados                          | Vis√£o geral do controle de concorr√™ncia e recupera√ß√£o em bancos de dados                          | Vis√£o geral do controle de concorr√™ncia e recupera√ß√£o em bancos de dados                          |
|-----------------------------------------------------------------------|---------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------|
|                                                                       | distribu√≠dos ......................................... 613                                        | distribu√≠dos ......................................... 613                                        | distribu√≠dos ......................................... 613                                        |
| 25.8                                                                  | Gerenciamento de cat√°logo distribu√≠do .. 615                                                      | Gerenciamento de cat√°logo distribu√≠do .. 615                                                      | Gerenciamento de cat√°logo distribu√≠do .. 615                                                      |
| 25.9                                                                  | Tend√™ncias atuais em bancos de dados distribu√≠dos ......................................... 615   | Tend√™ncias atuais em bancos de dados distribu√≠dos ......................................... 615   | Tend√™ncias atuais em bancos de dados distribu√≠dos ......................................... 615   |
| 25.10                                                                 | Bancos de dados distribu√≠dos em Oracle ..........................................617              | Bancos de dados distribu√≠dos em Oracle ..........................................617              | Bancos de dados distribu√≠dos em Oracle ..........................................617              |
| Resumo.......................................................... 620  | Resumo.......................................................... 620                              | Resumo.......................................................... 620                              | Resumo.......................................................... 620                              |
| Perguntas de revis√£o....................................... 621       | Perguntas de revis√£o....................................... 621                                   | Perguntas de revis√£o....................................... 621                                   | Perguntas de revis√£o....................................... 621                                   |
| Exerc√≠cios....................................................... 622 | Exerc√≠cios....................................................... 622                             | Exerc√≠cios....................................................... 622                             | Exerc√≠cios....................................................... 622                             |
| Bibliografia selecionada.................................. 623        | Bibliografia selecionada.................................. 623                                    | Bibliografia selecionada.................................. 623                                    | Bibliografia selecionada.................................. 623                                    |
| 11: Modelos,                                                          | 11: Modelos,                                                                                      | sistemas e aplica√ß√µes de                                                                          | sistemas e aplica√ß√µes de                                                                          |
| bancos de dados avan√ßados...... 625                                   | bancos de dados avan√ßados...... 625                                                               | bancos de dados avan√ßados...... 625                                                               | bancos de dados avan√ßados...... 625                                                               |
| 26 Modelos de dados avan√ßados para aplica√ß√µes avan√ßadas....           | 26 Modelos de dados avan√ßados para aplica√ß√µes avan√ßadas....                                       | 26 Modelos de dados avan√ßados para aplica√ß√µes avan√ßadas....                                       | 626                                                                                               |
| 26.1                                                                  | Conceitos de banco de dados ativo e triggers ................................................ 627 | Conceitos de banco de dados ativo e triggers ................................................ 627 | Conceitos de banco de dados ativo e triggers ................................................ 627 |
| 26.2                                                                  | Conceitos de banco de dados temporal .. 635                                                       | Conceitos de banco de dados temporal .. 635                                                       | Conceitos de banco de dados temporal .. 635                                                       |
| 26.3                                                                  | Conceitos de banco de dados espacial... 645                                                       | Conceitos de banco de dados espacial... 645                                                       | Conceitos de banco de dados espacial... 645                                                       |
| 26.4                                                                  | Conceitos de banco de dados multim√≠dia . 650                                                      | Conceitos de banco de dados multim√≠dia . 650                                                      | Conceitos de banco de dados multim√≠dia . 650                                                      |
| 26.5                                                                  | Introdu√ß√£o aos bancos de dados dedutivos............................................. 653         | Introdu√ß√£o aos bancos de dados dedutivos............................................. 653         | Introdu√ß√£o aos bancos de dados dedutivos............................................. 653         |
| Resumo.......................................................... 663  | Resumo.......................................................... 663                              | Resumo.......................................................... 663                              | Resumo.......................................................... 663                              |
| Perguntas de revis√£o....................................... 664       | Perguntas de revis√£o....................................... 664                                   | Perguntas de revis√£o....................................... 664                                   | Perguntas de revis√£o....................................... 664                                   |
| Bibliografia selecionada.................................. 667        | Bibliografia selecionada.................................. 667                                    | Bibliografia selecionada.................................. 667                                    | Bibliografia selecionada.................................. 667                                    |
| 27 Introdu√ß√£o √† recupera√ß√£o de informa√ß√µes e busca na Web.. 669       | 27 Introdu√ß√£o √† recupera√ß√£o de informa√ß√µes e busca na Web.. 669                                   | 27 Introdu√ß√£o √† recupera√ß√£o de informa√ß√µes e busca na Web.. 669                                   | 27 Introdu√ß√£o √† recupera√ß√£o de informa√ß√µes e busca na Web.. 669                                   |
| 27.1                                                                  | Conceitos de recupera√ß√£o de informa√ß√µes (RI).................................. 669                | Conceitos de recupera√ß√£o de informa√ß√µes (RI).................................. 669                | Conceitos de recupera√ß√£o de informa√ß√µes (RI).................................. 669                |
| 27.2                                                                  |                                                                                                   |                                                                                                   | 674                                                                                               |
| 27.3                                                                  |                                                                                                   |                                                                                                   | 679                                                                                               |
| 27.4                                                                  | Pr√©-processamento de textos................ 680                                                   | Pr√©-processamento de textos................ 680                                                   | Pr√©-processamento de textos................ 680                                                   |
| 27.5                                                                  | Indexa√ß√£o invertida............................. 682 Medidas de avalia√ß√£o de relev√¢ncia da        | Indexa√ß√£o invertida............................. 682 Medidas de avalia√ß√£o de relev√¢ncia da        | Indexa√ß√£o invertida............................. 682 Medidas de avalia√ß√£o de relev√¢ncia da        |
| 27.6                                                                  | pesquisa............................................... 684                                       | pesquisa............................................... 684                                       | pesquisa............................................... 684                                       |
| 27.7                                                                  | Pesquisa e an√°lise na Web.................... 686                                                 | Pesquisa e an√°lise na Web.................... 686                                                 | Pesquisa e an√°lise na Web.................... 686                                                 |
| 27.8                                                                  | Tend√™ncias na recupera√ß√£o de informa√ß√µes......................................... 693             | Tend√™ncias na recupera√ß√£o de informa√ß√µes......................................... 693             | Tend√™ncias na recupera√ß√£o de informa√ß√µes......................................... 693             |
| Resumo.......................................................... 694  | Resumo.......................................................... 694                              | Resumo.......................................................... 694                              | Resumo.......................................................... 694                              |
| Perguntas de revis√£o....................................... 695       | Perguntas de revis√£o....................................... 695                                   | Perguntas de revis√£o....................................... 695                                   | Perguntas de revis√£o....................................... 695                                   |
| Bibliografia selecionada.................................. 696        | Bibliografia selecionada.................................. 696                                    | Bibliografia selecionada.................................. 696                                    | Bibliografia selecionada.................................. 696                                    |

| Cap√≠tulo 28                                                                                                               | Cap√≠tulo 28                                                                                                               | Cap√≠tulo 28                                                                                                               | Conceitos de minera√ß√£o de dados...................................   |
|---------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------|
| 28.1                                                                                                                      | Vis√£o geral da tecnologia de minera√ß√£o                                                                                    | Vis√£o geral da tecnologia de minera√ß√£o                                                                                    | Vis√£o geral da tecnologia de minera√ß√£o                               |
|                                                                                                                           | de dados..............................................                                                                    | de dados..............................................                                                                    | 698                                                                  |
| 28.2                                                                                                                      | Regras de associa√ß√£o ...........................                                                                          | Regras de associa√ß√£o ...........................                                                                          | 701                                                                  |
| 28.3                                                                                                                      | Classifica√ß√£o........................................                                                                     | Classifica√ß√£o........................................                                                                     | 709                                                                  |
| 28.4                                                                                                                      | Agrupamento ......................................                                                                        | Agrupamento ......................................                                                                        | 712                                                                  |
| 28.5                                                                                                                      | Abordagens para outros problemas de                                                                                       | minera√ß√£o de                                                                                                              | dados............................. 713                               |
| 28.6                                                                                                                      | Aplica√ß√µes de minera√ß√£o de dados.......                                                                                   | Aplica√ß√µes de minera√ß√£o de dados.......                                                                                   | 715                                                                  |
| 28.7                                                                                                                      | Ferramentas comerciais de minera√ß√£o de                                                                                    | Ferramentas comerciais de minera√ß√£o de                                                                                    | 716                                                                  |
| dados................................................... Resumo.......................................................... | dados................................................... Resumo.......................................................... | dados................................................... Resumo.......................................................... | 717                                                                  |
|                                                                                                                           |                                                                                                                           |                                                                                                                           | 718                                                                  |
| Perguntas de revis√£o.......................................                                                               | Perguntas de revis√£o.......................................                                                               | Perguntas de revis√£o.......................................                                                               |                                                                      |
| Exerc√≠cios.......................................................                                                         | Exerc√≠cios.......................................................                                                         | Exerc√≠cios.......................................................                                                         | 718                                                                  |
| Bibliografia selecionada..................................                                                                | Bibliografia selecionada..................................                                                                | Bibliografia selecionada..................................                                                                | 719                                                                  |
| Cap√≠tulo 29 Vis√£o geral de data warehousing                                                                               | Cap√≠tulo 29 Vis√£o geral de data warehousing                                                                               | Cap√≠tulo 29 Vis√£o geral de data warehousing                                                                               | Cap√≠tulo 29 Vis√£o geral de data warehousing                          |
| e OLAP..................................                                                                                  | e OLAP..................................                                                                                  | e OLAP..................................                                                                                  | 720                                                                  |
| 29.1                                                                                                                      | Introdu√ß√£o, defini√ß√µes e terminologia..                                                                                   | Introdu√ß√£o, defini√ß√µes e terminologia..                                                                                   | 720                                                                  |
| 29.2                                                                                                                      | Caracter√≠sticas dos data warehouses....                                                                                   | Caracter√≠sticas dos data warehouses....                                                                                   | 721                                                                  |
| 29.3                                                                                                                      | Modelagem de dados para data warehouses..........................................                                         | Modelagem de dados para data warehouses..........................................                                         | 722                                                                  |
| 29.4                                                                                                                      | Criando um data warehouse................                                                                                 | Criando um data warehouse................                                                                                 | 726                                                                  |
| 29.5                                                                                                                      | Funcionalidade t√≠pica de um data warehouse ...........................................                                    | Funcionalidade t√≠pica de um data warehouse ...........................................                                    | 728                                                                  |
| 29.6                                                                                                                      | Data warehouses versus vis√µes ............                                                                                | Data warehouses versus vis√µes ............                                                                                | 729                                                                  |
| 29.7                                                                                                                      | Dificuldades de implementa√ß√£o de data warehouses..........................................                                | Dificuldades de implementa√ß√£o de data warehouses..........................................                                | 729                                                                  |
| Resumo..........................................................                                                          | Resumo..........................................................                                                          | Resumo..........................................................                                                          | 730                                                                  |
| Perguntas de revis√£o.......................................                                                               | Perguntas de revis√£o.......................................                                                               | Perguntas de revis√£o.......................................                                                               | 731                                                                  |
| Bibliografia selecionada..................................                                                                | Bibliografia selecionada..................................                                                                | Bibliografia selecionada..................................                                                                | 731                                                                  |
| Ap√™ndice A                                                                                                                | Ap√™ndice A                                                                                                                | Nota√ß√µes diagram√°ticas alternativas para modelos ER..732                                                                  | Nota√ß√µes diagram√°ticas alternativas para modelos ER..732             |
| Ap√™ndice B                                                                                                                | Ap√™ndice B                                                                                                                | Par√¢metros de discos.............735                                                                                      |                                                                      |
| Ap√™ndice C Vis√£o geral dalinguagem QBE...737                                                                              | Ap√™ndice C Vis√£o geral dalinguagem QBE...737                                                                              | Ap√™ndice C Vis√£o geral dalinguagem QBE...737                                                                              | Ap√™ndice C Vis√£o geral dalinguagem QBE...737                         |
| C.1                                                                                                                       | Recupera√ß√µes b√°sicas em QBE..............                                                                                 | Recupera√ß√µes b√°sicas em QBE..............                                                                                 | 737                                                                  |
| C.2                                                                                                                       | Agrupamento, agrega√ß√£o e modifica√ß√£o                                                                                      | Agrupamento, agrega√ß√£o e modifica√ß√£o                                                                                      | de                                                                   |
|                                                                                                                           | banco de dados em QBE.......................                                                                              | banco de dados em QBE.......................                                                                              | 740                                                                  |
| Bibliografia.................................................744                                                          | Bibliografia.................................................744                                                          | Bibliografia.................................................744                                                          |                                                                      |
| √çndice remissivo.........................................                                                                 | √çndice remissivo.........................................                                                                 | √çndice remissivo.........................................                                                                 | 766                                                                  |

E ste  livro  √©  uma  introdu√ß√£o aos conceitos fundamentais  necess√°rios  para  projetar,  usar  e  implementar sistemas de banco de dados e aplica√ß√µes de banco  de  dados.  Nossa  apresenta√ß√£o  enfatiza  os fundamentos da modelagem e do projeto de banco de dados, as linguagens e os modelos fornecidos pelos sistemas de gerenciamento de banco de dados e as  t√©cnicas  de  implementa√ß√£o  do  sistema  de  banco de dados. O prop√≥sito do livro √© que ele seja usado como um livro-texto para a disciplina de sistemas de banco de dados e como livro de refer√™ncia.  Nosso objetivo  √©  oferecer  uma  apresenta√ß√£o  profunda  e atualizada dos aspectos mais importantes dos sistemas e aplica√ß√µes de banco de dados, bem como das tecnologias relacionadas. Consideramos que os leitores  estejam  acostumados  aos  conceitos  elementares da programa√ß√£o e estrutura√ß√£o de dados, e que eles tenham tido algum contato com os fundamentos de organiza√ß√£o do computador.

## Novidades

Os recursos-chave a seguir foram acrescentados nessa edi√ß√£o:

- ¬Ñ Uma reorganiza√ß√£o da ordem dos cap√≠tulos, permitindo que os professores comecem com projetos e exerc√≠cios de laborat√≥rio bem mais cedo no curso.
- ¬Ñ O material sobre SQL, padr√£o de banco de dados relacional, foi antecipado no livro para os cap√≠tulos 4 e 5, para permitir que os professores focalizem esse importante assunto no in√≠cio do curso.
- ¬Ñ O  material  sobre  bancos  de  dados  objeto-relacional  e  orientado  a  objeto  foi  atualizado para que se adapte aos padr√µes SQL e

## Pref√°cio

- ODMG mais recentes, e consolidado em um √∫nico cap√≠tulo (Cap√≠tulo 11).
- ¬Ñ A apresenta√ß√£o da XML foi expandida e atualizada, sendo antecipada no livro para o Cap√≠tulo 12.
- ¬Ñ Os cap√≠tulos sobre teoria de normaliza√ß√£o foram reorganizados de modo que o primeiro cap√≠tulo  (Cap√≠tulo  15)  focaliza  os  conceitos de  normaliza√ß√£o  intuitivos,  enquanto  o  segundo cap√≠tulo (Cap√≠tulo 16) aborda as teorias formais e os algoritmos de normaliza√ß√£o.
- ¬Ñ A apresenta√ß√£o das amea√ßas √† seguran√ßa do banco de dados foi atualizada com uma discuss√£o  sobre  ataques  de  Inje√ß√£o  de  SQL  e t√©cnicas de preven√ß√£o no Cap√≠tulo 24, e uma vis√£o geral da seguran√ßa baseada em r√≥tulo, com exemplos.
- ¬Ñ Nossa  apresenta√ß√£o  sobre  bancos  de  dados espaciais e bancos de dados de multim√≠dia foi expandida e atualizada no Cap√≠tulo 26.
- ¬Ñ Um  novo  Cap√≠tulo  27,  sobre  t√©cnicas  de recupera√ß√£o de informa√ß√µes, foi acrescentado, discutindo sobre modelos e t√©cnicas de recupera√ß√£o, consulta, navega√ß√£o e indexa√ß√£o de informa√ß√µes a partir de documentos da Web; apresentamos as etapas de processamento  t√≠picas  em  um  sistema  de recupera√ß√£o de informa√ß√µes, as medidas de avalia√ß√£o e como as t√©cnicas de recupera√ß√£o de informa√ß√£o est√£o relacionadas aos bancos de dados e √† pesquisa na Web.

## Organiza√ß√£o desta edi√ß√£o

Existem mudan√ßas organizacionais significativas nesta edi√ß√£o, bem como melhoria nos cap√≠tulos indi-

viduais. O livro agora √© dividido em onze partes, da seguinte forma:

- ¬Ñ Parte 1 (cap√≠tulos 1 e 2) inclui os cap√≠tulos introdut√≥rios.
- ¬Ñ A  apresenta√ß√£o  sobre  bancos  de  dados  relacionais  e  SQL  foi  movida  para  a  Parte  2 (cap√≠tulos  de  3  a  6)  do  livro;  o  Cap√≠tulo  3 apresenta  o  modelo  relacional  formal  e  as restri√ß√µes  do  banco  de  dados  relacional;  o material sobre SQL (cap√≠tulos 4 e 5) agora √© apresentado antes da nossa apresenta√ß√£o sobre √°lgebra e c√°lculo relacional no Cap√≠tulo 6,  para  permitir  que  os  professores  iniciem projetos em SQL mais cedo em um curso, se desejarem (essa reordena√ß√£o tamb√©m √© baseada em um estudo que sugere que os alunos dominam SQL melhor quando ela √© ensinada antes das linguagens relacionais formais).
- ¬Ñ A apresenta√ß√£o sobre modelagem de entidade-relacionamento  e  projeto  de  banco  de  dados agora est√° na Parte 3 (cap√≠tulos 7 a 10), mas ainda pode ser abordada antes da Parte 2, se o foco do curso for o projeto de banco de dados.
- ¬Ñ A Parte 4 aborda o material atualizado sobre bancos de dados objeto-relacional e orientado a objeto (Cap√≠tulo 11) e XML (Cap√≠tulo 12).
- ¬Ñ A Parte 5 inclui  os  cap√≠tulos  sobre  t√©cnicas de programa√ß√£o de banco de dados (Cap√≠tulo 13) e programa√ß√£o de banco de dados na Web usando PHP (Cap√≠tulo 14, que foi antecipado no livro).
- ¬Ñ A Parte 6 (cap√≠tulos 15 e 16) inclui os cap√≠tulos  sobre  normaliza√ß√£o e teoria de projeto (passamos todos os aspectos formais dos algoritmos de normaliza√ß√£o para o Cap√≠tulo 16).
- ¬Ñ A Parte 7 (cap√≠tulos 17 e 18) cont√©m os cap√≠tulos sobre organiza√ß√µes de arquivo, indexa√ß√£o e hashing.
- ¬Ñ A Parte 8 inclui os cap√≠tulos sobre t√©cnicas de processamento e otimiza√ß√£o de consulta (Cap√≠tulo 19) e ajuste de banco de dados (Cap√≠tulo 20).
- ¬Ñ A Parte 9 inclui o Cap√≠tulo 21 sobre conceitos de processamento de transa√ß√£o; o Cap√≠tulo  22  sobre  controle  de  concorr√™ncia;  e  o Cap√≠tulo 23 sobre recupera√ß√£o do banco de dados contra falhas.
- ¬Ñ A Parte 10, sobre t√≥picos adicionais de banco de dados, inclui o Cap√≠tulo 24 sobre seguran√ßa de banco de dados e o Cap√≠tulo 25 sobre bancos de dados distribu√≠dos.
- ¬Ñ A Parte 11 sobre modelos e aplica√ß√µes avan√ßadas de banco de dados inclui o Cap√≠tulo 26 sobre modelos de dados avan√ßados (bancos de dados ativos, temporais, espaciais, multim√≠dia e dedutivos); o novo Cap√≠tulo 27 sobre recupera√ß√£o de informa√ß√µes e busca na Web; e os cap√≠tulos sobre minera√ß√£o de dados (Cap√≠tulo 28) e data warehousing (Cap√≠tulo 29).

## Conte√∫do desta edi√ß√£o

A  Parte  1  descreve  os  conceitos  introdut√≥rios b√°sicos necess√°rios para um bom conhecimento dos modelos de banco de dados, sistemas e linguagens. Os cap√≠tulos 1 e 2 introduzem bancos de dados, usu√°rios t√≠picos e conceitos, terminologia e arquitetura de SGBD.

A Parte 2 descreve o modelo de dados relacional, o  padr√£o  SQL  e  as  linguagens  relacionais  formais. O Cap√≠tulo 3 descreve o modelo relacional b√°sico, suas restri√ß√µes de integridade e opera√ß√µes de atualiza√ß√£o. O Cap√≠tulo 4 descreve algumas partes b√°sicas do  padr√£o  SQL  para  bancos  de  dados  relacionais, incluindo defini√ß√£o de dados, opera√ß√µes de modifica√ß√£o de dados e consultas SQL simples. O Cap√≠tulo 5 apresenta consultas SQL mais complexas, bem como os conceitos SQL de triggers, asser√ß√µes, vis√µes e modifica√ß√£o de esquema. O Cap√≠tulo 6 descreve as opera√ß√µes da √°lgebra relacional e introduz o c√°lculo relacional.

A Parte 3 aborda v√°rios t√≥picos relacionados √† modelagem conceitual do banco de dados e o projeto de banco de dados. No Cap√≠tulo 7, os conceitos do modelo Entidade-Relacionamento (ER) e diagramas ER s√£o apresentados e usados para ilustrar o projeto conceitual do banco de dados. O Cap√≠tulo 8 focaliza os conceitos de abstra√ß√£o de dados e modelagem sem√¢ntica dos dados, mostrando como o modelo ER pode ser estendido para incorporar essas ideias, levando  ao  modelo  de  dados  ER-Estendido  (EER)  e diagramas EER. Os conceitos apresentados no Cap√≠tulo 8 incluem subclasses, especializa√ß√£o, generaliza√ß√£o e tipos (categorias) de uni√£o. A nota√ß√£o para os diagramas de classe da UML tamb√©m √© apresentada nos cap√≠tulos 7 e 8. O Cap√≠tulo 9 discute o projeto de banco de dados relacional usando o mapeamento ER e EER para relacional. Terminamos a Parte 3 com o Cap√≠tulo 10, que apresenta uma vis√£o geral das diferentes fases do processo de projeto de banco de dados nas empresas para aplica√ß√µes de banco de dados de tamanho m√©dio e grande.

A Parte 4 aborda os modelos de dados orientados a objeto, objeto-relacional e XML, e suas linguagens e padr√µes afiliados. O Cap√≠tulo 11 introduz os

conceitos para bancos de dados de objeto e mostra como eles foram incorporados ao padr√£o SQL a fim de acrescentar capacidades de objeto aos sistemas de bancos de dados relacionais. Depois, aborda o padr√£o do modelo de objeto ODMG e sua defini√ß√£o de objeto e linguagens de consulta. O Cap√≠tulo 12 aborda o modelo e linguagens XML (eXtensible Markup Language), discutindo como a XML est√° relacionada aos sistemas de banco de dados. Apresenta os conceitos e linguagens do modelo XML, comparando-o com modelos de banco de dados tradicionais. Tamb√©m mostra como os dados podem ser convertidos entre a XML e representa√ß√µes relacionais.

A Parte 5 √© sobre t√©cnicas de programa√ß√£o de banco  de  dados.  O  Cap√≠tulo  13  aborda  os  t√≥picos  de programa√ß√£o SQL, como SQL embutida, SQL din√¢mica, ODBC, SQLJ, JDBC e SQL/CLIENTE. O Cap√≠tulo 14 introduz a programa√ß√£o de banco de dados na  Web,  usando  a  linguagem  de  scripting  PHP  em nossos exemplos.

A Parte 6 aborda a teoria da normaliza√ß√£o. Os cap√≠tulos 15 e 16 abordam os formalismos, as teorias e os algoritmos desenvolvidos para o projeto de  banco  de  dados  relacional  por  normaliza√ß√£o. Esse material inclui depend√™ncias funcionais e outros  tipos  de  depend√™ncias  e  formas  normais  das rela√ß√µes.  A  normaliza√ß√£o  intuitiva  passo  a  passo √©  apresentada  no  Cap√≠tulo  15,  que  tamb√©m  define  depend√™ncias  multivaloradas  e  de  jun√ß√£o.  Os algoritmos de projeto relacional baseados na normaliza√ß√£o,  junto  com  o  material  te√≥rico  em  que os  algoritmos  s√£o  baseados,  s√£o  apresentados  no Cap√≠tulo 16.

A Parte 7 descreve as estruturas de arquivo f√≠sicas e os m√©todos de acesso usados nos sistemas de banco de dados. O Cap√≠tulo 17 descreve os principais m√©todos de organiza√ß√£o de arquivos de registros em disco, incluindo o hashing est√°tico e din√¢mico. O Cap√≠tulo 18 descreve as t√©cnicas de indexa√ß√£o para arquivos, incluindo estruturas de dados em √°rvore B e B + e arquivos de grade.

A Parte 8 focaliza o processamento de consulta e o ajuste de desempenho de banco de dados. O Cap√≠tulo 19 apresenta os fundamentos do processamento e otimiza√ß√£o de consulta, e o Cap√≠tulo 20 discute sobre o projeto f√≠sico e ajuste de banco de dados.

A  Parte  9  discute  o  processamento  de  transa√ß√µes,  controle  de  concorr√™ncia  e  t√©cnicas  de recupera√ß√£o,  incluindo  discuss√µes  de  como  esses conceitos s√£o realizados em SQL. O Cap√≠tulo 21 introduz  as  t√©cnicas  necess√°rias  para  os  sistemas de  processamento  de  transa√ß√£o  e  define  os  conceitos  de  facilidade  de  recupera√ß√£o  e  serializa√ß√£o dos  schedules.  O  Cap√≠tulo  22  oferece  uma  vis√£o geral dos v√°rios tipos de protocolos de controle de concorr√™ncia,  com  foco  no  bloqueio  em  duas  fases.  Tamb√©m  trata  das  t√©cnicas  de  ordena√ß√£o  de timestamp (r√≥tulos  de  tempo)  e  controle  de  concorr√™ncia otimista, al√©m do bloqueio de granularidade m√∫ltiplo. Finalmente, o Cap√≠tulo 23 focaliza os  protocolos  de  recupera√ß√£o  de  banco  de  dados e oferece uma vis√£o geral dos conceitos e t√©cnicas que s√£o usadas nessa recupera√ß√£o.

As  partes  10  e  11  abordam  diversos  t√≥picos avan√ßados. O Cap√≠tulo 24 oferece uma vis√£o geral da seguran√ßa do banco de dados, incluindo o modelo do controle de acesso discricion√°rio com comandos SQL para o GRANT e o REVOKE de privil√©gios, o modelo de controle de acesso obrigat√≥rio com categorias de usu√°rios e poli-instancia√ß√£o, uma discuss√£o sobre privacidade de dados e seu relacionamento com seguran√ßa,  e  uma  vis√£o  geral  dos  ataques  de  Inje√ß√£o de SQL. O Cap√≠tulo 25 oferece uma introdu√ß√£o aos bancos de dados distribu√≠dos e discute a arquitetura cliente/servidor em tr√™s camadas. O Cap√≠tulo 26 introduz v√°rios modelos de banco de dados avan√ßados para aplica√ß√µes avan√ßadas. Estes incluem bancos de dados ativos e triggers, al√©m de bancos de dados temporais, espaciais, multim√≠dia e dedutivos. O Cap√≠tulo 27 √© um cap√≠tulo novo, sobre t√©cnicas de recupera√ß√£o de informa√ß√µes e como elas est√£o relacionadas a sistemas de banco de dados e a m√©todos de pesquisa na Web. O Cap√≠tulo 28, sobre minera√ß√£o de dados ( data mining ),  oferece uma vis√£o geral do processo de minera√ß√£o de dados e descoberta de conhecimento, discute algoritmos para minera√ß√£o, classifica√ß√£o e agrupamento de regra de associa√ß√£o, e aborda rapidamente outras t√©cnicas e ferramentas comerciais. O Cap√≠tulo 29 introduz os conceitos de data warehousing e OLAP.

O Ap√™ndice A oferece uma s√©rie de nota√ß√µes diagram√°ticas alternativas para exibir um esquema ER ou EER conceitual. Estas podem ser usadas em substitui√ß√£o √† nota√ß√£o que usamos, se o professor preferir. O Ap√™ndice B oferece alguns par√¢metros f√≠sicos importantes de discos. O Ap√™ndice C oferece uma vis√£o geral da linguagem de consulta gr√°fica QBE. Os ap√™ndices  D  e  E  (dispon√≠veis  no  site  de  apoio  do  livro, http://www.aw.com/elmasri\_br) abordam sistemas de banco de dados legados, com base nos modelos de banco de dados hier√°rquico e de rede. Eles t√™m sido usados h√° mais de trinta anos como base para muitas aplica√ß√µes de banco de dados e sistemas de processamento de transa√ß√µes comerciais. Consideramos importante expor os alunos de gerenciamento de banco de dados a essas t√©cnicas legadas de modo que possam ter uma ideia melhor de como a tecnologia de banco de dados progrediu. O Ap√™ndice A oferece uma s√©rie de nota√ß√µes diagram√°ticas alternativas para exibir um esquema ER ou EER conceitual. Estas podem ser usadas em substitui√ß√£o √† nota√ß√£o que usamos, se o professor preferir. O Ap√™ndice B oferece alguns par√¢metros f√≠sicos importantes de discos. O Ap√™ndice C oferece uma vis√£o geral da linguagem de consulta gr√°fica QBE. Os ap√™ndices D e E (dispon√≠veis na Sala Virtual, sv.pearson.com.br) abordam sistemas de banco de dados legados, com base nos modelos de banco de dados hier√°rquico e de rede. Eles t√™m sido usados h√° mais de trinta anos como base para muitas aplica√ß√µes de banco de dados e sistemas de processamento de transa√ß√µes comerciais. Consideramos importante expor os alunos de gerenciamento de banco de dados a essas t√©cnicas legadas de modo que possam ter uma ideia melhor de como a tecnologia de banco de dados progrediu.

## Orienta√ß√µes

Existem  muitas  maneiras  diferentes  de  ministrar um curso de banco de dados. Os cap√≠tulos das partes 1 a 7 podem ser usados em um curso introdut√≥rio  sobre  sistemas  de  banco  de  dados,  na  ordem em que aparecem ou na ordem preferida dos professores. Cap√≠tulos e se√ß√µes selecionadas podem ser omitidas, e o professor pode acrescentar outros cap√≠tulos do restante do livro, dependendo da √™nfase do curso. Ao final da se√ß√£o inicial de muitos dos cap√≠tulos do livro, listamos se√ß√µes que s√£o candidatas a serem omitidas sempre que uma discuss√£o menos detalhada do assunto for desejada. Sugerimos incluir at√© o Cap√≠tulo 15 em um curso introdut√≥rio de banco de dados e incluir partes selecionadas de outros cap√≠tulos, dependendo da base dos alunos e da cobertura desejada. Para uma √™nfase em t√©cnicas de implementa√ß√£o de sistemas, os cap√≠tulos das partes 7, 8 e 9 devem substituir alguns dos cap√≠tulos anteriores.

Os cap√≠tulos 7 e 8, que abordam a modelagem conceitual usando os modelos ER e EER, s√£o importantes para um bom conhecimento conceitual dos bancos de dados. Por√©m, eles podem ser abordados parcialmente ou mais adiante em um curso ou at√© mesmo omitidos, se a √™nfase for sobre a implementa√ß√£o do SGBD. Os cap√≠tulos 17 e 18, sobre organiza√ß√µes de arquivos e indexa√ß√£o, tamb√©m podem ser abordados mais cedo, mais tarde ou ainda omitidos, se a √™nfase for sobre modelos de banco de dados e linguagens. Para alunos que conclu√≠ram um curso sobre organiza√ß√£o de arquivos, partes desses cap√≠tulos podem ser indicadas como material de leitura ou alguns exerc√≠cios podem ser passados como revis√£o para esses conceitos.

Se a √™nfase de um curso for em projeto de banco de dados, ent√£o o professor dever√° abordar os cap√≠tulos 7 e 8 mais cedo, seguidos pela apresenta√ß√£o dos bancos de dados relacionais. Um curso sobre o ciclo de vida completo do projeto e implementa√ß√£o de bancos de dados incluiria o projeto conceitual (cap√≠tulos 7 e 8), bancos de dados relacionais (cap√≠tulos 3, 4 e 5), mapeamento do modelo de dados (Cap√≠tulo 9), normaliza√ß√£o (Cap√≠tulo 15) e implementa√ß√£o de programas de aplica√ß√£o com SQL (Cap√≠tulo 13). O Cap√≠tulo 14 tamb√©m dever√° ser abordado se a √™nfase for em programa√ß√£o e aplica√ß√µes de banco de dados na Web. A documenta√ß√£o adicional sobre linguagens de programa√ß√£o e SGBDRs espec√≠ficos seria necess√°ria.

O livro foi escrito de modo a possibilitar a abordagem de t√≥picos em v√°rias sequ√™ncias. O gr√°fico de depend√™ncia dos cap√≠tulos, a seguir, mostra as principais depend√™ncias entre os cap√≠tulos. Conforme o diagrama ilustra, √© poss√≠vel come√ßar com v√°rios t√≥- picos diferentes ap√≥s os dois cap√≠tulos introdut√≥rios. Embora o gr√°fico possa parecer complexo, √© importante observar que, se os cap√≠tulos forem usados na ordem, as depend√™ncias n√£o ser√£o perdidas. O gr√°fico pode ser consultado por aqueles que desejam usar uma ordem de apresenta√ß√£o alternativa.

Para  um  curso  de  um  semestre  baseado  neste livro,  cap√≠tulos  selecionados  podem  ser  atribu√≠dos como material de leitura. O livro tamb√©m pode ser usado para uma sequ√™ncia de curso em dois semestres. O primeiro curso, Introdu√ß√£o ao Projeto e Sistemas de Bancos de Dados , pode abranger a maioria dos cap√≠tulos 1 a 15. O segundo curso, Modelos e T√©cnicas  de  Implementa√ß√£o  de  Bancos  de  Dados , pode abranger a maioria dos Cap√≠tulos de 16 a 29. A sequ√™ncia de dois semestres tamb√©m pode ser elaborada de v√°rias outras maneiras, dependendo da prefer√™ncia de cada professor.

## Site de apoio do livro Materiais adicionais



No Companion Website deste livro (www.aw.com/elmasri\_br), professores e estudantes podem acessar materiais adicionais 24 horas por dia. (www.pearson.com.br/elmasri), professores e (www.pearson.com/elmasri), Na Sala Virtual (sv.pearson.com.br), professores e estudantes podem acessar materiais adicionais 24 horas por dia.

## Para professores:

- ¬Ñ Apresenta√ß√µes em PowerPoint.
- ¬Ñ Banco de imagens.
- ¬Ñ Manual de solu√ß√µes (em ingl√™s).

Esse material √© de uso exclusivo para professores e est√° protegido por senha. Para ter acesso a ele, os professores que adotam o livro devem entrar em contato com seu representante Pearson ou enviar e-mail para universitarios@pearson.com.

## Para estudantes:

- ¬Ñ Manual de laborat√≥rio (em ingl√™s).
- ¬Ñ Ap√™ndices D e E (em ingl√™s).

## Agradecimentos

√â  um  grande  prazer  reconhecer  o  aux√≠lio  e  as contribui√ß√µes de muitos indiv√≠duos para este esfor√ßo. Primeiro, gostar√≠amos de agradecer ao nosso editor, Matt Goldstein, por sua orienta√ß√£o, encorajamento e  apoio. Gostar√≠amos de agradecer o excelente trabalho de Gillian Hall, pela ger√™ncia de produ√ß√£o, e Rebecca Greenberg, por uma revis√£o completa do livro. Agradecemos √†s seguintes pessoas da Pearson, que contribu√≠ram para a sexta edi√ß√£o: Jeff Holcomb, Marilyn Lloyd, Margaret Waples e Chelsea Bell.



Sham Navathe gostaria  de  agradecer  a  contribui√ß√£o  significativa  de  Saurav  Sahay  para  o Cap√≠tulo  27.  V√°rios  alunos  atuais  e  do  passado tamb√©m contribu√≠ram para os diversos cap√≠tulos nesta edi√ß√£o: Rafi Ahmed, Liora Sahar, Fariborz Farahmand, Nalini Polavarapu e Wanxia Xie (ex-alunos);  e  Bharath  Rengarajan,  Narsi  Srinivasan,  Parimala  R.  Pranesh,  Neha  Deodhar,  Balaji Palanisamy e Hariprasad Kumar (alunos atuais). Discuss√µes com seus colegas Ed Omiecinski e Leo Mark, da Georgia Tech, e Venu Dasigi, da SPSU, Atlanta, tamb√©m contribu√≠ram para a revis√£o do material.

- ¬Ñ Primeira edi√ß√£o. Alan Apt (editor), Don Batory, Scott Downing,  Dennis  Heimbinger, Julia Hodges, Yannis Ioannidis, Jim Larson, Per-Ake Larson, Dennis McLeod, Rahul Patel,  Nicholas  Roussopoulos, David Stemple, Michael  Stonebraker,  Frank  Tompa  e  Kyu-Young Whang.

Gostar√≠amos  de  repetir  nossos  agradecimentos √†queles que revisaram e contribu√≠ram de alguma maneira para as edi√ß√µes anteriores de Sistemas de banco de dados .

- ¬Ñ Segunda edi√ß√£o. Dan Joraanstad (editor),  Rafi Ahmed,  Antonio  Albano,  David  Beech,  Jose Blakeley, Panos Chrysanthis, Suzanne Dietrich, Vic Ghorpadey, Goetz Graefe, Eric Hanson, Junguk  L.  Kim,  Roger  King,  Vram  Kouramajian, Vijay Kumar, John Lowther, Sanjay Manchanda, Toshimi Minoura, Inderpal Mumick, Ed Omiecinski, Girish Pathak, Raghu Ramakrishnan, Ed Robertson, Eugene Sheng, David Stotts, Marianne Winslett e Stan Zdonick.

- ¬Ñ Terceira  edi√ß√£o. Maite  Suarez-Rivas  e  Katherine  Harutunian (editores); Suzanne Dietrich, Ed Omiecinski, Rafi Ahmed, Francois Bancilhon, Jose Blakeley, Rick Cattell, Ann  Chervenak,  David  W.  Embley,  Henry A. Etlinger, Leonidas Fegaras, Dan Forsyth, Farshad Fotouhi, Michael Franklin, Sreejith Gopinath, Goetz Craefe, Richard Hull, Sushil Jajodia,  Ramesh K. Karne, Harish Kotbagi, Vijay Kumar, Tarcisio Lima, Ramon A. Mata-Toledo,  Jack  McCaw,  Dennis  McLeod, Rokia Missaoui, Magdi Morsi, M. Narayanaswamy,  Carlos  Ordonez,  Joan  Peckham, Betty  Salzberg,  Ming-Chien  Shan,  Junping Sun,  Rajshekhar  Sunderraman,  Aravindan Veerasamy e Emilia E. Villareal.
- ¬Ñ Quarta  edi√ß√£o. Maite  Suarez-Rivas, Katherine Harutunian, Daniel Rausch e Juliet Silveri  (editores);  Phil  Bernhard,  Zhengxin Chen,  Jan  Chomicki,  Hakan  Ferhatosmanoglu,  Len  Fisk,  William  Hankley,  Ali  R. Hurson, Vijay Kumar, Peretz Shoval, Jason T. L. Wang (revisores); Ed Omiecinski (que contribuiu para o Cap√≠tulo 27). Os colaboradores  da  Universidade  do  Texas  em  Arlington s√£o Jack Fu, Hyoil Han, Babak Hojabri, Charley Li, Ande Swathi e Steven Wu;
- os colaboradores da Georgia Tech s√£o Weimin Feng, Dan Forsythe, Angshuman Guin, Abrar Ul-Haque, Bin Liu, Ying Liu, Wanxia Xie e Waigen Yee.
- ¬Ñ Quinta  edi√ß√£o. Matt  Goldstein  e  Katherine  Harutunian  (editores);  Michelle  Brown, Gillian  Hall,  Patty  Mahtani,  Maite  Suarez-Rivas, Bethany Tidd e Joyce Cosentino Wells (da Addison-Wesley); Hani Abu-Salem, Jamal R. Alsabbagh, Ramzi Bualuan, Soon Chung, Sumali Conlon, Hasan Davulcu, James Geller,  Le  Gruenwald,  Latifur  Khan,  Herman Lam, Byung S. Lee, Donald Sanderson, Jamil Saquer, Costas Tsatsoulis e Jack C. Wileden (revisores); Raj Sunderraman (que contribuiu com os projetos de laborat√≥rio); Salman Azar (que contribu√≠ram com alguns exerc√≠cios novos);  Gaurav  Bhatia,  Fariborz  Farahmand, Ying Liu, Ed Omiecinski, Nalini Polavarapu, Liora Sahar, Saurav Sahay e Wanxia Xie (da Georgia Tech).

Por √∫ltimo, mas n√£o menos importante, gostar√≠amos de agradecer nossas fam√≠lias pelo apoio, pelo encorajamento e pela paci√™ncia.

R.E. S.B.N.



Introdu√ß√£o aos bancos de dados



## Bancos de dados e usu√°rios de banco de dados

B ancos de dados e sistemas de banco de dados s√£o um componente  essencial  da  vida  na  sociedade moderna; a maioria de n√≥s encontra diariamente diversas atividades que envolvem alguma intera√ß√£o com um banco de dados. Por exemplo, quando vamos ao banco para depositar ou retirar fundos, fazemos uma reserva de hotel ou de voo, acessamos o cat√°logo de uma biblioteca virtual para procurar uma refer√™ncia bibliogr√°fica,  ou  compramos  algo  on-line  -  como um livro, um brinquedo ou um computador -, provavelmente  essas  atividades  envolver√£o  algu√©m  ou algum programa de computador que acessa um banco de dados. At√© mesmo a compra de produtos em um supermercado atualiza automaticamente o banco de dados que mant√©m o controle de estoque dos itens.

nufatura. Al√©m disso, t√©cnicas de pesquisa de banco de dados est√£o sendo aplicadas √† World Wide Web para melhorar a busca por informa√ß√µes necess√°rias feita pelos usu√°rios que utilizam a Internet.

Essas intera√ß√µes s√£o exemplos do que podemos chamar de aplica√ß√µes de banco de dados tradicionais , em que a maior parte da informa√ß√£o armazenada e acessada √© textual ou num√©rica. Nos √∫ltimos anos,  os  avan√ßos  na  tecnologia  levaram  a  interessantes  novas  aplica√ß√µes  dos  sistemas  de  banco  de dados. A nova tecnologia de m√≠dia tornou poss√≠vel armazenar  imagens,  clipes  de  √°udio  e  streams  de v√≠deo digitalmente. Esses tipos de arquivo est√£o se tornando  um  componente  importante  dos bancos de  dados  de  multim√≠dia .  Os sistemas  de  informa√ß√µes  geogr√°ficas ( GIS -  Geographic  Information Systems)  podem  armazenar  e  analisar  mapas,  dados sobre o clima e imagens de sat√©lite. Sistemas de data warehousing e de processamento anal√≠tico on-line ( OLAP - On-Line Analytical Processing) s√£o usados em muitas empresas para extrair e analisar informa√ß√µes  comerciais  √∫teis  de  bancos  de  dados muito grandes, para ajudar na tomada de decis√£o. A tecnologia de tempo real e banco de dados ativo √© usada para controlar processos industriais e de ma-

No entanto, para entender os fundamentos da tecnologia de banco de dados, devemos come√ßar das aplica√ß√µes  b√°sicas  de  banco  de  dados  tradicional. Na Se√ß√£o 1.1, come√ßamos definindo um banco de dados, e depois explicamos outros termos b√°sicos. Na Se√ß√£o 1.2, oferecemos um simples exemplo de banco de dados UNIVERSIDADE para ilustrar nossa discuss√£o. A Se√ß√£o 1.3 descreve algumas das principais caracter√≠sticas dos sistemas de banco de dados, e as se√ß√µes 1.4 e 1.5 classificam os tipos de pessoas cujas fun√ß√µes envolvem o uso e a intera√ß√£o com sistemas de banco de dados. As se√ß√µes 1.6, 1.7 e 1.8 oferecem uma discuss√£o mais profunda sobre as diversas capacidades oferecidas pelos sistemas de banco de dados e discutem algumas aplica√ß√µes t√≠picas. No final do cap√≠tulo √© apresentado um resumo.

O leitor que quiser uma introdu√ß√£o r√°pida aos sistemas de banco de dados pode estudar as se√ß√µes 1.1 a 1.5, depois pular ou folhear as se√ß√µes 1.6 a 1.8 e seguir para o Cap√≠tulo 2.

## 1.1 Introdu√ß√£o

Os bancos de dados e sua tecnologia t√™m um impacto importante sobre o uso crescente dos computadores. √â correto afirmar que os bancos de dados desempenham  um  papel  cr√≠tico  em  quase  todas  as √°reas em que os computadores s√£o usados, incluindo neg√≥cios, com√©rcio eletr√¥nico, engenharia, medicina, gen√©tica, direito, educa√ß√£o e biblioteconomia. O termo banco de dados (do original database ) √© t√£o utilizado que precisamos come√ßar por sua defini√ß√£o. E nossa defini√ß√£o inicial √© bastante gen√©rica.

Um banco  de  dados √©  uma  cole√ß√£o  de  dados 1 relacionados. Com dados , queremos  dizer  fatos conhecidos que podem ser registrados e possuem significado impl√≠cito. Por exemplo, considere os nomes, n√∫meros  de  telefone  e  endere√ßos  das  pessoas  que voc√™ conhece. Voc√™ pode ter registrado esses dados em uma agenda ou, talvez, os tenha armazenado em um  disco  r√≠gido,  usando  um  computador  pessoal e um software como Microsoft Access ou Excel. Essa cole√ß√£o de dados relacionados, com um significado impl√≠cito, √© um banco de dados.

Essa  defini√ß√£o  de  banco  de  dados  √©  bastante gen√©rica;  por  exemplo,  a  cole√ß√£o  de  palavras  que comp√µem esta p√°gina de texto pode ser considerada dados relacionados e, portanto, constitui um banco de dados. Por√©m, o uso comum do termo banco de dados normalmente √© mais restrito e tem as seguintes propriedades impl√≠citas:

- ¬Ñ Um banco de dados representa algum aspecto do  mundo real,  √†s  vezes  chamado  de minimundo ou de universo de discurso ( UoD -Universe of Discourse). As mudan√ßas no minimundo s√£o refletidas no banco de dados.
- ¬Ñ Um banco  de  dados  √©  uma  cole√ß√£o  logicamente  coerente  de  dados  com  algum  significado  inerente.  Uma  variedade  aleat√≥ria  de dados  n√£o  pode  ser  corretamente  chamada de banco de dados.
- ¬Ñ Um banco de dados √© projetado, constru√≠do e populado com dados para uma finalidade espec√≠fica. Ele possui um grupo definido de usu√°rios e  algumas  aplica√ß√µes  previamente  concebidas nas quais esses usu√°rios est√£o interessados.

Em outras palavras, um banco de dados tem alguma fonte da qual o dado √© derivado, algum grau de intera√ß√£o com eventos no mundo real e um p√∫blico que est√° ativamente interessado em seu conte√∫do. Os usu√°rios finais de um banco de dados podem realizar transa√ß√µes comerciais (por exemplo, um cliente compra uma c√¢mera) ou eventos podem acontecer (por exemplo, uma funcion√°ria tem um filho), fazendo que a informa√ß√£o no banco de dados mude. Para que um banco de dados seja preciso e confi√°vel o tempo todo, ele precisa ser um reflexo verdadeiro do minimundo que representa; portanto, as mudan√ßas precisam ser refletidas no banco de dados o mais breve poss√≠vel.

uma estrutura simples. Por sua vez, o cat√°logo computadorizado de uma grande biblioteca pode conter meio milh√£o de entradas organizadas sob diferentes categorias - por sobrenome do autor principal, por assunto,  por  t√≠tulo  do  livro  -,  com  cada  uma  das categorias organizada  alfabeticamente.  Um  banco de dados de tamanho e complexidade ainda maior √© mantido pela Receita Federal para monitorar formul√°rios de imposto de renda preenchidos pelos contribuintes. Se considerarmos que existem 100 milh√µes de contribuintes e que cada um deles preenche uma m√©dia de cinco formul√°rios com aproximadamente 400 caracteres cada um, ter√≠amos um banco de dados de 100 √ó 10 6 √ó 400 √ó 5 caracteres (bytes) de informa√ß√£o. Se a Receita Federal mant√©m o registro dos tr√™s √∫ltimos anos de cada contribuinte, al√©m do ano atual, ter√≠amos um banco de dados de 8 √ó 10 11 bytes (800 gigabytes).  Essa  imensa  quantidade  de  informa√ß√µes precisa ser organizada e gerenciada de modo que os usu√°rios  possam  consultar,  recuperar  e  atualizar  os dados quando necess√°rio.

Um exemplo de um grande banco de dados comercial √© a Amazon.com. Ela cont√©m dados de mais de 20 milh√µes de livros, CDs, v√≠deos, DVDs, jogos, eletr√¥nicos,  roupas  e  outros  itens.  O  banco  de  dados ocupa mais de dois terabytes (um terabyte √© 10 12 bytes de armazenamento) e est√° armazenado em 200 computadores  diferentes  (denominados  servidores). Cerca de 15 milh√µes de visitantes acessam a Amazon.com todos os dias e utilizam o banco de dados para fazer compras. O banco de dados √© continuamente atualizado √† medida que novos livros e outros itens s√£o acrescentados ao estoque e as quantidades em estoque s√£o atualizadas √† medida que as compras s√£o feitas. Cerca de cem pessoas s√£o respons√°veis por manter o banco de dados da Amazon atualizado.

Um banco de dados pode ser gerado e mantido manualmente, ou pode ser computadorizado. Por exemplo, um cat√°logo de cart√£o de biblioteca √© um banco de dados que pode ser criado e mantido manualmente. Um banco de dados computadorizado pode ser criado e mantido por um grupo de programas de aplica√ß√£o escritos especificamente para essa tarefa ou por um sistema gerenciador de banco de dados. Vamos tratar apenas dos bancos de dados computadorizados neste livro.

Um banco de dados pode ter qualquer tamanho e complexidade. Por exemplo, a lista de nomes e endere√ßos referenciados anteriormente pode consistir em apenas algumas centenas de registros, cada um com

Um sistema  gerenciador  de  banco  de  dados ( SGBD - Database Management System) √© uma cole√ß√£o  de  programas  que  permite  aos  usu√°rios  criar e  manter um banco de dados. O SGBD √© um sistema de software de uso geral que facilita o processo de

1 O livro original utiliza a palavra data em singular e plural, pois isso √© comum na literatura de banco de dados; o contexto determinar√° se ela est√° no singular ou no plural. (Em ingl√™s padr√£o, data √© usado para o plural e datum , para o singular.)

defini√ß√£o , constru√ß√£o , manipula√ß√£o e compartilhamento de bancos de dados entre diversos usu√°rios e aplica√ß√µes. Definir um  banco  de  dados  envolve  especificar  os  tipos,  estruturas  e  restri√ß√µes  dos  dados a  serem  armazenados.  A  defini√ß√£o  ou  informa√ß√£o descritiva do banco de dados tamb√©m √© armazenada pelo SGBD na forma de um cat√°logo ou dicion√°rio, chamado de metadados .  A constru√ß√£o do banco de dados  √©  o  processo  de  armazenar  os  dados  em  algum  meio  controlado  pelo  SGBD.  A manipula√ß√£o de um banco de dados inclui fun√ß√µes como consulta ao banco de dados para recuperar dados espec√≠ficos, atualiza√ß√£o do banco de dados para refletir mudan√ßas no minimundo e gera√ß√£o de relat√≥rios com base nos  dados.  O compartilhamento de  um  banco  de dados  permite  que  diversos  usu√°rios  e  programas acessem-no simultaneamente.

Um programa  de  aplica√ß√£o acessa  o  banco  de dados ao enviar consultas ou solicita√ß√µes de dados ao SGBD. Uma consulta 2 normalmente resulta na recupera√ß√£o de alguns dados; uma transa√ß√£o pode fazer que alguns dados sejam lidos e outros, gravados no banco de dados.

Outras fun√ß√µes importantes fornecidas pelo SGBD incluem prote√ß√£o do banco de dados e sua manuten√ß√£o por um longo per√≠odo. A prote√ß√£o inclui prote√ß√£o  do  sistema contra  defeitos  (ou  falhas)  de hardware ou software e prote√ß√£o de seguran√ßa contra acesso n√£o autorizado ou malicioso. Um banco de dados grande pode ter um ciclo de vida de muitos anos, de modo que o SGBD precisa ser capaz de manter o  sistema,  permitindo  que  ele  evolua  √†  medida que os requisitos mudam com o tempo.

N√£o √© absolutamente necess√°rio utilizar software de SGBD de uso geral para implementar um banco de dados computadorizado. Poder√≠amos escrever nosso  pr√≥prio  conjunto  de  programas  para  criar  e manter o banco de dados, com efeito criando nosso pr√≥prio software de SGBD de uso especial . Em ambos os casos - se usarmos um SGBD de uso geral ou n√£o -, em geral temos de implementar uma quantidade consider√°vel de software complexo. De fato, a maioria dos SGBDs √© constitu√≠da de sistemas de software muito complexos.

Figura 1.1



Diagrama simplificado de um ambiente de sistema de banco de dados.

## 1.2 Um exemplo

Vamos considerar um exemplo simples ao qual a maioria dos leitores pode estar acostumada: um banco de dados UNIVERSIDADE para manter informa√ß√µes referentes a alunos, disciplinas e notas em um ambiente universit√°rio. A Figura 1.2 mostra a estrutura e alguns exemplos de dados para o banco de dados UNIVERSIDADE . O banco de dados est√° organizado como cinco arquivos, e cada um armazena registros de dados do mesmo tipo. 3 O arquivo ALUNO armazena dados sobre cada aluno, o arquivo disciplina armazena dados sobre cada disciplina, o arquivo TURMA armazena dados sobre cada turma de uma disciplina, o arquivo HISTORICO\_ESCO-LAR armazena as notas que os alunos recebem nas v√°rias turmas que eles conclu√≠ram, e o arquivo PRE\_REQUISI-TO armazena os pr√©-requisitos de cada disciplina.

Para completar nossas defini√ß√µes iniciais, chamaremos  a  uni√£o  do  banco  de  dados  com  o software de SGBD de sistema de banco de dados . A Figura 1.1 ilustra alguns dos conceitos que discutimos at√© aqui.

Para definir esse banco de dados, precisamos especificar a estrutura dos registros de cada arquivo, determinando os diferentes tipos de elementos de dados a serem armazenados em cada registro. Na Figura 1.2, cada registro de ALUNO cont√©m os dados que represen-

2 O termo consulta (ou query ), que originalmente significa uma pergunta ou uma pesquisa, √© usado livremente para todos os tipos de intera√ß√µes com bancos de dados, incluindo a modifica√ß√£o dos dados.

3 Usamos o termo arquivo informalmente aqui. Em um n√≠vel conceitual, um arquivo √© uma cole√ß√£o de registros que podem ou n√£o estar ordenados.

## ALUNO

| Nome   |   Numero_aluno |   Tipo_aluno | Curso   |
|--------|----------------|--------------|---------|
| Silva  |             17 |            1 | CC      |
| Braga  |              8 |            2 | CC      |

## DISCIPLINA

| Nome_ disciplina                | Numero_ disciplina   |   Creditos | Departamento   |
|---------------------------------|----------------------|------------|----------------|
| Introd. √† ci√™ncia da computa√ß√£o | CC1310               |          4 | CC             |
| Estruturas de dados             | CC3320               |          4 | CC             |
| Matem√°tica discreta             | MAT2410              |          3 | MAT            |
| Banco de dados                  | CC3380               |          3 | CC             |

## TURMA

|   Identificacao_ turma | Numero_ disciplina   | Semestre   |   Ano | Professor   |
|------------------------|----------------------|------------|-------|-------------|
|                     85 | MAT2410              | Segundo    |    07 | Kleber      |
|                     92 | CC1310               | Segundo    |    07 | Anderson    |
|                    102 | CC3320               | Primeiro   |    08 | Carlos      |
|                    112 | MAT2410              | Segundo    |    08 | Chang       |
|                    119 | CC1310               | Segundo    |    08 | Anderson    |
|                    135 | CC3380               | Segundo    |    08 | Santos      |

## HISTORICO\_ESCOLAR

|   Numero_aluno |   Identificacao_turma | Nota   |
|----------------|-----------------------|--------|
|             17 |                   112 | B      |
|             17 |                   119 | C      |
|              8 |                    85 | A      |
|              8 |                    92 | A      |
|              8 |                   102 | B      |
|              8 |                   135 | A      |

## PRE\_REQUISITO

Figura 1.2

| Numero_disciplina   | Numero_pre_requisito   |
|---------------------|------------------------|
| CC3380              | CC3320                 |
| CC3380              | MAT2410                |
| CC3320              | CC1310                 |

Exemplo de banco de dados que armazena informa√ß√µes de aluno e disciplina.

tam o Nome Numero\_aluno , , Tipo\_aluno (como novato igual a '1', segundo ano igual a '2', e assim por diante) e Curso (como matem√°tica igual a 'MAT' e ci√™ncia da computa√ß√£o igual a 'CC'); cada registro de DISCIPLINA

cont√©m os dados que representam o Nome\_disciplina , Numero\_disciplina , Creditos e Departamento (o  departamento que oferece a disciplina); e assim por diante. Tamb√©m precisamos especificar um tipo de dado para cada elemento de dado em um registro. Por exemplo, podemos  especificar  que  o Nome de ALUNO √©  uma sequ√™ncia de caracteres alfab√©ticos; Numero\_aluno de ALUNO √© um inteiro, e Nota de HISTORICO\_ESCOLAR √© um √∫nico caractere do conjunto {'A', 'B', 'C', 'D', 'F'}. Tamb√©m podemos usar  um  esquema  de  codifica√ß√£o para representar os valores de um item de dados. Por exemplo, na Figura 1.2, representamos Tipo\_aluno de um ALUNO como 1 para novato, 2 para segundo ano, 3 para j√∫nior, 4 para s√™nior e 5 para aluno formado.

Para construir o banco de dados UNIVERSIDADE , armazenamos  dados  para  representar  cada  aluno, disciplina,  turma,  hist√≥rico  escolar  e  pr√©-requisito como um registro no arquivo apropriado. Observe que  os  registros  nos  diversos  arquivos  podem  estar relacionados. Por exemplo, o registro para Silva no arquivo ALUNO est√°  relacionado a dois registros no arquivo HISTORICO\_ESCOLAR, que especifica as notas  de Silva em duas turmas. De modo semelhante, cada registro no arquivo PRE\_REQUISITO relaciona-se a dois registros de disciplina; um representando a disciplina e o outro representando o pr√©-requisito. A maioria dos bancos de dados de tamanho m√©dio e grande inclui muitos tipos de registros e possui muitos relacionamentos entre os registros.

A manipula√ß√£o do banco de dados envolve consulta  e  atualiza√ß√£o.  Alguns  exemplos  de  consultas s√£o os seguintes:

- ¬Ñ Recuperar uma lista de todas as disciplinas e notas de 'Silva'.
- ¬Ñ Listar os nomes dos alunos que realizaram a disciplina 'Banco de dados' oferecida no segundo semestre de 2008 e suas notas nessa turma.
- ¬Ñ Listar os pr√©-requisitos do curso de 'Banco de dados'.

Alguns exemplos de atualiza√ß√µes incluem:

- ¬Ñ Alterar o tipo de aluno de 'Silva' para segundo ano.
- ¬Ñ Criar outra turma para a disciplina 'Banco de dados' para este semestre.
- ¬Ñ Inserir  uma  nota  'A'  para  'Silva'  na  turma 'Banco de dados' do √∫ltimo semestre.

Essas  consultas  e  atualiza√ß√µes  informais  precisam ser especificadas corretamente na linguagem de consulta do SGBD antes de serem processadas.

Nesse est√°gio, √© √∫til descrever o banco de dados como parte de uma tarefa maior conhecida como sistema de informa√ß√£o dentro de qualquer organiza√ß√£o.

O departamento de Tecnologia da Informa√ß√£o (TI) de uma empresa projeta e mant√©m um sistema de informa√ß√µes que consiste em v√°rios computadores, sistemas de armazenamento, software de aplica√ß√£o e bancos de dados. O projeto de uma nova aplica√ß√£o para um banco de dados existente ou de um novo banco de dados come√ßa com uma fase chamada especifica√ß√£o e an√°lise de requisitos . Esses requisitos s√£o documentados com detalhes e transformados em um projeto conceitual ,  que  pode ser representado e manipulado usando algumas ferramentas computadorizadas para que possa ser facilmente mantido, modificado e transformado em uma implementa√ß√£o de banco de dados. (Apresentaremos um modelo denominado Entidade-Relacionamento,  no  Cap√≠tulo  7,  que  √©  usado  para essa finalidade.) O projeto √© ent√£o traduzido para um projeto l√≥gico ,  que pode ser expresso em um modelo de dados implementado em um SGBD comercial. (Neste  livro,  vamos  enfatizar  um  modelo  de  dados conhecido como Modelo de Dados Relacional a partir  do  Cap√≠tulo  3.  Essa  √©  atualmente  a  t√©cnica  mais popular para projetar e implementar bancos de dados usando SGBDs relacionais.) O est√°gio final √© o projeto f√≠sico , durante o qual outras especifica√ß√µes s√£o fornecidas para armazenar e acessar o banco de dados. O projeto de banco de dados √© implementado, alimentado com dados reais e mantido continuamente para refletir o estado do minimundo.

## 1.3 Caracter√≠sticas da abordagem de banco de dados

Diversas  caracter√≠sticas  distinguem  a  abordagem de  banco  de  dados  da  abordagem  muito  mais  antiga de  programa√ß√£o  com  arquivos.  No processamento  de arquivo tradicional,  cada  usu√°rio  define  e  implementa os arquivos necess√°rios para uma aplica√ß√£o de software espec√≠fica como parte da programa√ß√£o da aplica√ß√£o. Por exemplo, um usu√°rio, o departamento de registro acad√™mico , pode manter arquivos sobre os alunos e suas notas. Os programas para imprimir o hist√≥rico escolar de um aluno e inserir novas notas s√£o implementados como parte da aplica√ß√£o. Um segundo usu√°rio, o departamento de finan√ßas , pode registrar as mensalidades dos alunos e seus pagamentos. Embora ambos os usu√°rios estejam interessados em dados sobre alunos, cada um mant√©m arquivos separados - e programas para manipular esses arquivos -, pois cada usu√°rio requer dados n√£o dispon√≠veis nos arquivos do outro. Essa redund√¢ncia na defini√ß√£o e no armazenamento de dados resulta em desperd√≠cio no espa√ßo de armazenamento e em esfor√ßos redundantes para manter os dados comuns atualizados.

Na abordagem de banco de dados, um √∫nico reposit√≥rio  mant√©m  dados  que  s√£o  definidos  uma vez e depois acessados por v√°rios usu√°rios. Nos sis- temas de arquivo, cada aplica√ß√£o √© livre para nomear  os  elementos  de  dados  independentemente. Ao contr√°rio, em um banco de dados, os nomes ou r√≥tulos de dados s√£o definidos uma vez, e usados repetidamente por consultas, transa√ß√µes e aplica√ß√µes. As principais caracter√≠sticas da abordagem de banco de dados versus a abordagem de processamento de arquivo s√£o as seguintes:

- ¬Ñ Natureza de autodescri√ß√£o de um sistema de banco de dados.
- ¬Ñ Isolamento entre programas e dados, e abstra√ß√£o de dados.
- ¬Ñ Suporte de m√∫ltiplas vis√µes dos dados.
- ¬Ñ Compartilhamento de dados e processamento de transa√ß√£o multiusu√°rio.

Descrevemos cada uma dessas caracter√≠sticas em uma se√ß√£o distinta. Discutiremos caracter√≠sticas adicionais  dos  sistemas  de  banco  de  dados  nas  se√ß√µes 1.6 a 1.8.

## 1.3.1 Natureza de autodescri√ß√£o de um sistema de banco de dados

Uma caracter√≠stica  fundamental  da  abordagem de  banco  de  dados  √©  que  seu  sistema  cont√©m  n√£o apenas o pr√≥prio banco de dados, mas tamb√©m uma defini√ß√£o  ou  descri√ß√£o  completa  de  sua  estrutura  e restri√ß√µes. Essa defini√ß√£o √© armazenada no cat√°logo do SGBD, que possui informa√ß√µes como a estrutura de  cada  arquivo,  o  tipo  e  o  formato  de  armazenamento de cada item de dados e diversas restri√ß√µes sobre os dados. A informa√ß√£o armazenada no cat√°logo √© chamada de metadados , e descreve a estrutura do banco de dados principal (Figura 1.1).

O cat√°logo √© usado pelo software de SGBD e tamb√©m pelos usu√°rios do banco de dados que precisam de informa√ß√µes sobre a estrutura do banco de dados. Um pacote de software de SGBD de uso geral n√£o √© escrito para uma aplica√ß√£o de banco de dados espec√≠fica. Portanto, ele precisa consultar o cat√°logo para conhecer a estrutura dos arquivos em um banco de dados espec√≠fico, como o tipo e o formato dos dados que ele acessar√°. O software de SGBD precisa trabalhar de forma satisfat√≥ria com qualquer quantidade de aplica√ß√µes de banco de dados - por exemplo, um banco de dados de universidade, de banco ou de uma empresa -, desde que sua defini√ß√£o esteja armazenada no cat√°logo.

No processamento de arquivos tradicional, a defini√ß√£o de dados normalmente faz parte dos pr√≥prios programas  de  aplica√ß√£o.  Logo,  esses  programas  s√£o for√ßados a trabalhar com apenas um banco de dados espec√≠fico ,  cuja  estrutura  √©  declarada  nos  programas de aplica√ß√£o. Por exemplo, um programa de aplica√ß√£o

escrito em C ++ pode ter declara√ß√µes de estrutura ou classe, e um programa em COBOL tem instru√ß√µes da divis√£o de dados para definir seus arquivos. Enquanto o software de processamento de arquivos pode acessar apenas bancos de dados espec√≠ficos, o software de SGBD pode acessar diversos bancos de dados extraindo e usando as defini√ß√µes do cat√°logo de banco de dados.

Para o exemplo mostrado na Figura 1.2, o cat√°logo do SGBD armazenar√° as defini√ß√µes de todos os arquivos mostrados. A Figura 1.3 mostra alguns exemplos de entradas em um cat√°logo de banco de dados. Essas defini√ß√µes s√£o especificadas pelo projetista antes da cria√ß√£o do banco de dados real e armazenadas no cat√°logo. Sempre que √© feita uma solicita√ß√£o para acessar, digamos, o Nome de um registro de ALUNO , o software de SGBD consulta o cat√°logo para determinar a estrutura do arquivo ALUNO e a posi√ß√£o e o tamanho do item de dado Nome dentro do registro de ALUNO . Ao contr√°rio, em uma aplica√ß√£o t√≠pica de processamento de arquivo, a estrutura do arquivo e, no caso extremo, a localiza√ß√£o exata do Nome dentro de um  registro  de ALUNO j√°  est√£o  codificadas  dentro de cada programa que acessa esse item de dados.

## RELACOES

| Nome_relacao      |   Numero_de_colunas |
|-------------------|---------------------|
| ALUNO             |                   4 |
| DISCIPLINA        |                   4 |
| TURMA             |                   5 |
| HISTORICO_ESCOLAR |                   3 |
| PRE_REQUISITO     |                   2 |

## COLUNAS

| Nome_coluna          | Tipo_de_dado   | Pertence_a_relacao   |
|----------------------|----------------|----------------------|
| Nome                 | Caractere (30) | ALUNO                |
| Numero_aluno         | Caractere (4)  | ALUNO                |
| Tipo_aluno           | Inteiro (1)    | ALUNO                |
| Curso                | Tipo_curso     | ALUNO                |
| Nome_disciplina      | Caractere (10) | DISCIPLINA           |
| Numero_disciplina    | XXXXNNNN       | DISCIPLINA           |
| ....                 | ....           | ....                 |
| ....                 | ....           | ....                 |
| ....                 | ....           | ....                 |
| Numero_pre_requisito | XXXXNNNN       | PRE-REQUISITO        |

## Figura 1.3

Exemplo de um cat√°logo para o banco de dados na Figura 1.2.

Nota: Tipo\_curso √© definido como um tipo enumerado com todas as mat√©rias conhecidas. XXXXNNNN √© usado para definir um tipo com quatro caracter√≠sticas alfanum√©ricas seguidas por quatro d√≠gitos.

## 1.3.2 solamento entre programas e I dados, e abstra√ß√£o de dados

No processamento de arquivos tradicional, a estrutura dos arquivos de dados est√° embutida nos programas de aplica√ß√£o, de modo que quaisquer mudan√ßas em sua estrutura podem exigir altera√ß√£o em todos os programas que  acessam  esse  arquivo.  Ao  contr√°rio,  os programas que acessam o SGBD n√£o exigem tais mudan√ßas na maioria dos casos. A estrutura dos arquivos de  dados  √©  armazenada  no  cat√°logo  do  SGBD  separadamente dos programas de acesso. Chamamos essa propriedade de independ√™ncia de dados do programa.

Por exemplo, um programa de acesso a arquivo  pode  ser  escrito  para  acessar  apenas  registros de ALUNO da estrutura mostrada na Figura 1.4. Se quisermos acrescentar outro dado a cada registro de ALUNO , digamos Data\_nascimento , esse  programa n√£o  funcionar√°  mais,  e  precisar√°  ser  alterado.  Ao contr√°rio, em um ambiente de SGBD, s√≥ precisamos mudar  a  descri√ß√£o  dos  registros  de ALUNO no  cat√°logo (Figura 1.3) para refletir a inclus√£o do novo item de dado Data\_nascimento ; nenhum programa √© alterado. Da pr√≥xima vez que o programa de SGBD consultar o cat√°logo, a nova estrutura dos registros de ALUNO ser√° acessada e usada.

Em alguns tipos de sistemas de banco de dados, como os orientados a objeto e objeto-relacional (ver Cap√≠tulo  11),  os  usu√°rios  podem  definir  opera√ß√µes sobre dados como parte das defini√ß√µes do banco de dados. Uma opera√ß√£o (tamb√©m chamada de fun√ß√£o ou m√©todo ) √© especificada em duas partes. A interface (ou assinatura )  de  uma  opera√ß√£o inclui o nome da opera√ß√£o e os tipos de dados de seus argumentos (ou par√¢metros). A implementa√ß√£o (ou m√©todo ) da opera√ß√£o √© especificada separadamente e pode ser alterada sem afetar a interface. Os programas de aplica√ß√£o do usu√°rio podem operar sobre os dados invocando essas opera√ß√µes por meio de seus nomes e argumentos,  independentemente  de  como  as  opera√ß√µes  s√£o implementadas. Isso pode ser chamado de independ√™ncia da opera√ß√£o do programa .

| Nome do item de dados   |   Posicionamento inicial no registro |   Tamanho em caracteres (bytes) |
|-------------------------|--------------------------------------|---------------------------------|
| Nome                    |                                    1 |                              30 |
| Numero_aluno            |                                   31 |                               4 |
| Tipo_aluno              |                                   35 |                               1 |
| Curso                   |                                   36 |                               4 |

## Figura 1.4

Formato de armazenamento interno para um registro de ALUNO, baseado no cat√°logo do banco de dados da Figura 1.3.

A caracter√≠stica que permite a independ√™ncia de dados do programa e a independ√™ncia da opera√ß√£o do programa √© chamada de abstra√ß√£o de dados . Um SGBD oferece aos usu√°rios uma representa√ß√£o conceitual de dados que n√£o inclui muitos dos detalhes de como os dados s√£o armazenados ou como as opera√ß√µes s√£o implementadas. De maneira informal, um modelo de dados √©  um tipo de abstra√ß√£o de dados usado para oferecer essa representa√ß√£o conceitual. O modelo de dados usa conceitos l√≥gicos, como objetos, suas propriedades e seus inter-relacionamentos, que podem ser mais f√°ceis para os usu√°rios entenderem do que os conceitos de armazenamento de computador. Logo, o modelo de dados oculta os detalhes de armazenamento e implementa√ß√£o que n√£o s√£o do interesse da maioria dos usu√°rios de banco de dados.

Por  exemplo,  reconsidere  as  figuras  1.2  e  1.3. A  implementa√ß√£o  interna  de  um  arquivo  pode  ser definida por seu tamanho de registro - o n√∫mero de caracteres  (bytes)  em  cada  registro  -  e  cada  item de  dados  pode  ser  especificado  pelo  byte  inicial  dentro  de um  registro  e  seu  tamanho  em  bytes.  O  registro de ALUNO , assim, seria representado como mostra a Figura 1.4. Mas um t√≠pico usu√°rio de banco de dados n√£o est√° preocupado com a localiza√ß√£o de cada item de dados dentro de um registro ou em seu tamanho; em vez disso, o usu√°rio se preocupa se o valor √© retornado corretamente, quando for feita uma refer√™ncia ao Nome do ALUNO .  Uma  representa√ß√£o  conceitual dos registros de ALUNO aparece na Figura 1.2. Muitos outros detalhes da organiza√ß√£o do armazenamento do arquivo - como os caminhos de acesso especificados em um arquivo - podem ser ocultados dos usu√°rios do banco de dados pelo SGBD. Discutiremos detalhes de armazenamento nos cap√≠tulos 17 e 18.

Na abordagem de banco de dados, a estrutura detalhada e a organiza√ß√£o de cada arquivo s√£o armazenadas no cat√°logo. Os usu√°rios do banco de dados e os programas de aplica√ß√£o se referem √† representa√ß√£o conceitual dos arquivos, e o SGBD extrai os detalhes do armazenamento do arquivo do cat√°logo quando  estes  s√£o  necess√°rios  para  os  m√≥dulos  de acesso a arquivo do SGBD. Muitos modelos de dados podem ser usados para oferecer essa abstra√ß√£o aos usu√°rios do banco de dados. A primeira parte deste livro √© dedicada √† apresenta√ß√£o dos v√°rios modelos de dados e dos conceitos que eles utilizam para abstrair a representa√ß√£o dos dados.

Nos bancos de dados orientados a objeto e objeto-relacional,  o  processo  de  abstra√ß√£o  inclui  n√£o apenas a estrutura dos dados, mas tamb√©m as opera√ß√µes sobre os dados. Essas opera√ß√µes oferecem uma abstra√ß√£o das atividades do minimundo comumente entendidas  pelos  usu√°rios.  Por  exemplo,  uma  ope- ra√ß√£o CALCULA\_MEDIA pode ser aplicada ao objeto ALUNO para calcular a m√©dia das notas. Essas opera√ß√µes podem ser solicitadas pelas consultas do usu√°rio ou por programas de aplica√ß√£o sem ter que saber os detalhes de como as opera√ß√µes s√£o implementadas. Nesse  sentido,  uma  abstra√ß√£o  da  atividade  do  minimundo se torna dispon√≠vel ao usu√°rio como uma opera√ß√£o abstrata .

## 1.3.3 Suporte para m√∫ltiplas vis√µes dos dados

Um banco de dados em geral tem muitos usu√°rios, cada um podendo exigir um ponto de vista ou vis√£o diferente  do  banco  de  dados.  Uma  vis√£o  (ou view ) pode ser um subconjunto do banco de dados ou conter dado virtual que √© derivado dos arquivos do banco de dados, mas n√£o est√£o armazenados explicitamente.  Alguns  usu√°rios  n√£o  precisam  saber se os dados a que se referem est√£o armazenados ou se s√£o derivados. Um SGBD multiusu√°rio, cujos usu√°rios  t√™m  uma  s√©rie  de  aplica√ß√µes  distintas,  precisa oferecer facilidades para definir m√∫ltiplas vis√µes. Por exemplo, um usu√°rio do banco de dados da Figura 1.2 pode estar interessado apenas em acessar e imprimir o hist√≥rico escolar de cada aluno; a vis√£o para esse usu√°rio  √©  mostrada  na  Figura  1.5(a).  Um  segundo usu√°rio, que est√° interessado apenas em verificar se os  alunos  possuem  todos  os  pr√©-requisitos  de  cada disciplina para a qual se inscreveram, pode requerer a vis√£o apresentada na Figura 1.5(b).

## 1.3.4 Compartilhamento de dados e processamento de transa√ß√£o multiusu√°rio

Um  SGBD  multiusu√°rio,  como  o  nome  sugere, precisa  permitir  que  m√∫ltiplos  usu√°rios  acessem o  banco  de  dados  ao  mesmo  tempo.  Isso  √©  essencial se  o  dado  para  m√∫ltiplas  aplica√ß√µes  est√°  sendo  integrado  e  mantido  em  um  √∫nico  banco  de  dados.  O SGBD precisa incluir um software de controle de concorr√™ncia para  garantir  que  v√°rios  usu√°rios  tentando atualizar o mesmo dado fa√ßa isso de uma maneira controlada, de modo que o resultado dessas atualiza√ß√µes seja correto. Por exemplo, quando v√°rios agentes de viagem tentam reservar um assento em um voo de uma companhia a√©rea,  o  SGBD  precisa  garantir  que  cada  assento  s√≥ possa  ser  acessado  por  um  agente  de  cada  vez  para  que  seja atribu√≠do a um √∫nico passageiro. Esses tipos de aplica√ß√µes geralmente s√£o chamados de aplica√ß√µes de processamento de transa√ß√£o on-line  OLPT ( - On-Line Transaction Processing). Um papel fundamental do software SGBD multiusu√°rio √© garantir que as transa√ß√µes concorrentes operem de maneira correta e eficiente.

## DADO\_ESCOLAR

PRE\_REQUISITO\_DISCIPLINA

| Nome_ aluno   | Historico_escolar_aluno   | Historico_escolar_aluno   | Historico_escolar_aluno   | Historico_escolar_aluno   | Historico_escolar_aluno   |
|---------------|---------------------------|---------------------------|---------------------------|---------------------------|---------------------------|
| Nome_ aluno   | Numero_ disciplina        | Nota                      | Semestre                  | Ano                       | Identificacao_ turma      |
| Silvah        | CC1310                    | C                         | Segundo                   | 08                        | 119                       |
|               | MAT2410                   | B                         | Segundo                   | 08                        | 112                       |
| Braga         | MAT2410                   | A                         | Segundo                   | 07                        | 85                        |
|               | CC1310                    | A                         | Segundo                   | 07                        | 92                        |
|               | CC3320                    | B                         | Primeiro                  | 08                        | 102                       |
|               | CC3380                    | A                         | Segundo                   | 08                        | 135                       |

Figura 1.5

| Nome_disciplina    | Numero_disciplina   | Pre_requisitos   |
|--------------------|---------------------|------------------|
| Banco de dados     | CC3380              | CC3320           |
|                    |                     | MAT2410          |
| Estrutura de dados | CC3320              | CC1310           |

Duas vis√µes derivadas do banco de dados da Figura 1.2. (a) A vis√£o do HISTORICO\_ESCOLAR. (b) A vis√£o do PRE\_ REQUISITO\_DISCIPLINA.

O conceito de transa√ß√£o tem  se  tornado fundamental  para  muitas  aplica√ß√µes  de  banco  de  dados. Uma  transa√ß√£o  √©  um programa  em  execu√ß√£o ou processo que inclui um ou mais acessos ao banco de dados, como a leitura ou atualiza√ß√£o de seus registros. Uma transa√ß√£o executa um acesso logicamente correto a um banco de dados quando ela √© executada de forma completa e sem interfer√™ncia de outras transa√ß√µes. O SGBD precisa impor v√°rias propriedades da transa√ß√£o. A propriedade de isolamento garante que cada transa√ß√£o pare√ßa executar isoladamente das demais, embora centenas  de  transa√ß√µes  possam  estar  executando concorrentemente. A propriedade de atomicidade garante que todas as opera√ß√µes em uma transa√ß√£o sejam executadas ou que nenhuma seja. Discutiremos sobre transa√ß√µes em detalhes na Parte 9.

As  caracter√≠sticas  anteriores  s√£o  importantes para distinguir um SGBD de um software tradicional de processamento de arquivo. Na Se√ß√£o 1.6, discutiremos recursos adicionais  que  caracterizam  um SGBD. Primeiro, por√©m, vamos categorizar os diferentes  tipos  de  pessoas  que  trabalham  em  um  ambiente de sistema de banco de dados.

## 1.4 Atores em cena

Para um pequeno banco de dados pessoal, como a  lista  de  endere√ßos  discutida  na  Se√ß√£o  1.1,  uma pessoa  normalmente  define,  constr√≥i  e  manipula o  banco  de  dados,  sem  compartilhamento.  Por√©m, em grandes organiza√ß√µes, muitas pessoas est√£o envolvidas no projeto, no uso e na manuten√ß√£o de um grande banco de dados, com centenas de usu√°rios. Nesta se√ß√£o, identificamos as pessoas cujas fun√ß√µes envolvem o uso di√°rio de um grande banco de dados; n√≥s os chamamos de atores em cena . Na Se√ß√£o 1.5, consideraremos as pessoas que podem ser chamadas de trabalhadores dos bastidores - aqueles que trabalham para manter o ambiente do sistema de banco de dados, mas que n√£o est√£o ativamente interessados em seu conte√∫do como parte de sua fun√ß√£o di√°ria.

## 1.4.1 Administradores de banco de dados

Em qualquer  organiza√ß√£o  onde  muitas  pessoas utilizam os mesmos recursos, h√° uma necessidade de um administrador principal para supervisionar e gerenciar tais recursos. Em um ambiente de banco de dados, o recurso principal √© o pr√≥prio banco de dados, e o recurso secund√°rio √© o SGBD e os softwares relacionados.  A  administra√ß√£o  desses  recursos  √©  de responsabilidade do administrador de banco de dados ( DBA database administrator ). O DBA √© respons√°vel por autorizar o acesso ao banco de dados, coordenar e monitorar seu uso e adquirir recursos de software e hardware conforme a necessidade. Tamb√©m √© respons√°vel por problemas como falhas na seguran√ßa e demora no tempo de resposta do sistema. Em grandes  organiza√ß√µes,  ele  √©  auxiliado  por  uma equipe que executa essas fun√ß√µes.

## 1.4.2 Projetistas de banco de dados

Os projetistas  de  banco  de  dados s√£o  respons√°veis  por  identificar  os  dados  a  serem  armazenados e escolher estruturas apropriadas para representar e armazenar esses dados. Essas tarefas s√£o realizadas principalmente antes que o banco de dados esteja real  mente implementado e populado com dados. √â responsabilidade dos projetistas de banco de dados se comunicar com  todos  os  potenciais  usu√°rios  a  fim  de  entender suas necessidades e criar um projeto que as atenda. Em muitos casos, os projetistas est√£o na equipe de DBAs e podem receber outras responsabilidades ap√≥s o projeto do banco de dados estar conclu√≠do. Os projetistas de banco de dados normalmente interagem com cada potencial grupo de usu√°rios e desenvolvem vis√µes do banco de dados que cumprem os requisitos de dados e processamento desses grupos. Cada vis√£o √© ent√£o analisada e integrada √†s vis√µes de outros grupos de usu√°rios.

O projeto final do banco de dados precisa ser capaz de atender √†s necessidades de todos os grupos de usu√°rios.

## 1.4.3 Usu√°rios finais

Os usu√°rios finais s√£o pessoas cujas fun√ß√µes exigem acesso ao banco de dados para consultas, atualiza√ß√µes e gera√ß√£o de relat√≥rios. O banco de dados existe primariamente para atender os usu√°rios finais. Existem v√°rias categorias de usu√°rios finais:

- ¬Ñ Usu√°rios finais casuais ocasionalmente acessam o banco de dados, mas podem precisar de  diferentes  informa√ß√µes  a  cada  vez.  Utilizam uma linguagem sofisticada  de  consulta ao banco de dados para especificar suas necessidades  e  normalmente  s√£o  gerentes  de n√≠vel intermedi√°rio ou alto, ou outros usu√°rios ocasionais.
- ¬Ñ Usu√°rios  finais iniciantes ou param√©tricos comp√µem uma grande parte dos usu√°rios finais do banco de dados. Sua fun√ß√£o principal gira em torno de consultar e atualizar o banco de dados constantemente, usando tipos padr√£o de consultas e atualiza√ß√µes - denominadas transa√ß√µes programadas - que foram cuidadosamente programadas e testadas. As tarefas que esses usu√°rios realizam s√£o variadas:
- ¬Ñ ¬Ñ Caixas de banco verificam saldos de conta e realizam saques, dep√≥sitos, pagamentos etc.
- ¬Ñ ¬Ñ Agentes  de  companhias  a√©reas,  hot√©is  e locadoras de autom√≥veis verificam a disponibilidade de determinada solicita√ß√£o e fazem reservas.
- ¬Ñ ¬Ñ Funcion√°rios nas esta√ß√µes de recebimento de transportadoras inserem identifica√ß√µes de pacotes por c√≥digos de barra e informa√ß√µes descritivas por meio de etiquetas para atualizar um banco de dados central de pacotes recebidos e em tr√¢nsito.
- ¬Ñ Usu√°rios  finais  sofisticados incluem  engenheiros,  cientistas,  analistas  de  neg√≥cios  e outros que est√£o profundamente familiarizados com as facilidades do SGBD a ponto de implementar as pr√≥prias aplica√ß√µes para que atendam a suas necessidades complexas.
- ¬Ñ Usu√°rios isolados mant√™m bancos de dados pessoais usando pacotes de programas prontos,  que  oferecem  interfaces  de  f√°cil  utiliza√ß√£o,  baseadas  em  menus  ou  gr√°ficos.  Um exemplo √© o usu√°rio de um pacote de c√°lculos de impostos, que armazena uma s√©rie de dados financeiros pessoais para fins de declara√ß√£o de imposto.

Um  SGBD  t√≠pico  oferece  m√∫ltiplas  facilidades para acessar um banco de dados. Usu√°rios iniciantes precisam aprender muito pouco sobre as facilidades oferecidas pelo SGBD; eles simplesmente t√™m de entender as interfaces de usu√°rio das transa√ß√µes padr√£o projetadas  e  implementadas  para  seu  uso.  Os  usu√°rios  casuais  aprendem  apenas  algumas  facilidades que podem usar repetidamente. Usu√°rios sofisticados tentam aprender a maioria das facilidades do SGBD para  satisfazer  suas  necessidades  complexas.  Usu√°rios isolados costumam se tornar especialistas no uso de um pacote de software espec√≠fico.

## 1.4.4 Analistas de sistemas e programadores de aplica√ß√µes (engenheiros de software)

Analistas de sistemas identificam as necessidades dos usu√°rios finais, especialmente os iniciantes e param√©tricos, e definem as especifica√ß√µes das transa√ß√µes padr√£o  que  atendam  a  elas.  Os programadores  de aplica√ß√µes implementam  essas  especifica√ß√µes  como programas; depois, eles testam, depuram, documentam e mant√™m essas transa√ß√µes programadas. Esses analistas  e  programadores  -  tamb√©m  conhecidos como engenheiros de software e desenvolvedores de sistemas de software - devem estar familiarizados com todo o conjunto de capacidades fornecido pelo SGBD para realizarem suas tarefas.

## 1.5 Trabalhadores dos bastidores

Al√©m daqueles que projetam, usam e administram um banco de dados, h√° outros associados ao projeto, desenvolvimento e opera√ß√£o do software e ambiente de sistema do  SGBD.  Essas  pessoas  normalmente  n√£o  est√£o  interessadas  no  conte√∫do  do banco de dados em si. Vamos cham√°-las de trabalhadores  dos  bastidores ,  e  elas  est√£o  inclu√≠das  nas seguintes categorias:

- ¬Ñ Projetistas e implementadores de sistema de SGBD projetam e implementam os m√≥dulos e as interfaces do SGBD como um pacote de software. Um SGBD √© um sistema muito complexo, que consiste em muitos componentes, ou m√≥dulos ,  incluindo m√≥dulos para implementa√ß√£o  do  cat√°logo,  processamento  de linguagem de consulta, processamento de interface, acesso e buffering de dados, controle de concorr√™ncia e tratamento de recupera√ß√£o e seguran√ßa de dados. O SGBD precisa realizar a interface com outros sistemas de software, como o sistema operacional, e compiladores para diversas linguagens de programa√ß√£o.

- ¬Ñ Desenvolvedores de ferramentas projetam e implantam ferramentas - os pacotes de software que facilitam a modelagem e o projeto do banco de dados, o projeto do sistema de banco de dados e a melhoria no desempenho. Ferramentas s√£o pacotes opcionais que, em geral, s√£o adquiridos separadamente. Elas incluem pacotes para projeto de banco de dados, monitoramento de desempenho, linguagem natural ou interfaces  gr√°ficas,  prot√≥tipo,  simula√ß√£o  e  gera√ß√£o de dados de teste. Em muitos casos, fornecedores  de  software  independentes  desenvolvem  e comercializam essas ferramentas.
- ¬Ñ Operadores e pessoal de manuten√ß√£o (pessoal de administra√ß√£o de sistemas) s√£o respons√°veis pela execu√ß√£o e manuten√ß√£o do ambiente de hardware e software para o sistema de banco de dados.

Embora  essas  categorias  de  trabalhadores  dos bastidores sejam instrumento para tornar o sistema de banco de dados dispon√≠vel aos usu√°rios finais, eles n√£o costumam utilizar o conte√∫do do banco de dados para fins pessoais.

## 1.6 Vantagens de usar a abordagem de SGBD

Nesta  se√ß√£o,  discutiremos  algumas  das  vantagens de usar um bom SGBD e as capacidades que ele deve possuir. Essas capacidades est√£o al√©m das quatro principais caracter√≠sticas discutidas na Se√ß√£o 1.3. O DBA deve utiliz√°-las para cumprir uma s√©rie de objetivos relacionados ao projeto, √† administra√ß√£o e ao uso de um grande banco de dados multiusu√°rio.

## 1.6.1 Controlando a redund√¢ncia

No  desenvolvimento  de  software  tradicional, utilizando  processamento  de  arquivo,  cada  grupo de usu√°rios mant√©m os pr√≥prios arquivos para tratamento de suas aplica√ß√µes de processamento de dados. Por exemplo, considere o exemplo do banco de dados UNIVERSIDADE da Se√ß√£o 1.2; aqui, dois grupos de usu√°rios podem ser o pessoal do departamento de registro acad√™mico e departamento de finan√ßas. Na t√©cnica tradicional, cada grupo mant√©m de maneira independente os  arquivos  sobre  os  alunos.  O  departamento  financeiro  mant√©m  dados  sobre  o  registro  e  informa√ß√µes relacionadas  a  faturas,  enquanto  o  departamento  de registro acad√™mico acompanha as disciplinas e as notas dos alunos. Outros grupos podem duplicar ainda mais alguns ou todos os dados nos pr√≥prios arquivos.

Essa redund√¢ncia causada ao armazenar os mesmos dados v√°rias vezes gera diversos problemas. Primeiro, √© preciso realizar uma √∫nica atualiza√ß√£o l√≥gica - como a entrada de dados sobre um novo aluno - v√°rias vezes: uma para cada arquivo onde o dado do aluno √© registrado. Isso ocasiona uma duplica√ß√£o de esfor√ßo . Segundo, o espa√ßo de armazenamento √© desperdi√ßado quando o mesmo dado √© armazenado repetidamente, e esse problema pode ser s√©rio para grandes bancos de dados. Terceiro, os arquivos que representam os mesmos dados podem tornar-se inconsistentes . Isso porque uma atualiza√ß√£o √© aplicada a alguns dos arquivos, mas n√£o a outros. Mesmo que uma atualiza√ß√£o - como a inclus√£o de um novo aluno - seja aplicada a todos os arquivos apropriados, os dados referentes ao aluno ainda podem ser inconsistentes porque as atualiza√ß√µes s√£o aplicadas de maneira independente pelos grupos de usu√°rios. Por exemplo, um grupo de usu√°rios pode entrar com a data de nascimento de um aluno incorretamente como '19/01/1988', enquanto outros grupos de usu√°rios podem inserir o valor correto '29/01/1988'.

Na abordagem de banco de dados, as vis√µes de diferentes grupos de usu√°rios s√£o integradas durante o projeto. O ideal √© que tenhamos um projeto que armazena cada item de dados l√≥gico - como o nome ou a data de nascimento de um aluno - em apenas um lugar no banco de dados. Isso √© conhecido como normaliza√ß√£o de dados ,  e  garante  consist√™ncia  e  economia  de  espa√ßo de armazenamento (a normaliza√ß√£o de dados √© descrita na Parte 6 do livro). Por√©m, na pr√°tica, √†s vezes √© necess√°rio usar a redund√¢ncia controlada para  melhorar o  desempenho  das  consultas.  Por  exemplo,  podemos armazenar Nome\_aluno e Numero\_disciplina redundantemente em um arquivo HISTORICO\_ESCOLAR [Figura 1.6(a)] porque, sempre que recuperamos um registro de HISTORICO\_ESCOLAR , queremos recuperar o nome do aluno e o n√∫mero da disciplina juntamente com a nota, o n√∫mero do aluno e o identificador de turma. Colocando todos os dados juntos, n√£o precisamos pesquisar v√°rios arquivos para coletar esses dados. Isso √© conhecido como desnormaliza√ß√£o . Nesses casos, o SGBD deve ter a capacidade de controlar essa redund√¢ncia a fim de proibir inconsist√™ncias entre os arquivos. Isso pode ser feito verificando automaticamente se os valores de Nome\_aluno--Numero\_aluno em qualquer registro de HISTORICO\_ES-COLAR na Figura 1.6(a) combinam com um dos valores de Nome-Numero\_aluno de  um registro de ALUNO (Figura 1.2). De modo semelhante, os valores de Identifica -cao\_turma-Numero\_disciplina de HISTORICO\_ESCOLAR podem ser verificados em registros de TURMA . Essas verifica√ß√µes podem ser especificadas no SGBD durante o projeto do banco de dados e impostas automaticamente pelo  SGBD sempre que o arquivo HISTORICO\_ESCO-LAR for atualizado. A Figura 1.6(b) mostra um registro de HISTORICO\_ESCOLAR incoerente  com  o  arquivo ALUNO na Figura 1.2; esse tipo de erro pode ser inserido se a redund√¢ncia n√£o for controlada . Voc√™ consegue identificar a parte inconsistente?

(a)

## HISTORICO\_ESCOLAR

|   Numero_ aluno | Nome_ aluno   |   Identificacao_ turma | Numero_ disciplina   | Nota   |
|-----------------|---------------|------------------------|----------------------|--------|
|              17 | Silva         |                    112 | MAT2410              | B      |
|              17 | Silva         |                    119 | CC1310               | C      |
|               8 | Braga         |                     85 | MAT2410              | A      |
|               8 | Braga         |                     92 | CC1310               | A      |
|               8 | Braga         |                    102 | CC3320               | B      |
|               8 | Braga         |                    135 | CC3380               | A      |

## HISTORICO\_ESCOLAR

Figura 1.6

|     |   Numero_ aluno | Nome_ aluno   |   Identificacao_ turma | Numero_ disciplina   | Nota   |
|-----|-----------------|---------------|------------------------|----------------------|--------|
| (b) |              17 | Braga         |                    112 | MAT2410              | B      |

Armazenamento redundante de Nome\_aluno e Nome\_disciplina em HISTORICO\_ESCOLAR. (a) Dados consistentes. (b) Registro inconsistente.

## 1.6.2 Restringindo o acesso n√£o autorizado

Quando v√°rios usu√°rios compartilham um grande banco de dados, √© prov√°vel que a maioria deles n√£o esteja autorizada a acessar todas as informa√ß√µes nele contidas. Por exemplo, dados financeiros normalmente  s√£o  considerados  confidenciais,  e  somente  pessoas  autorizadas  t√™m  permiss√£o  para  acess√°-los.  Al√©m disso,  alguns  usu√°rios  s√≥  podem  ter  permiss√£o  para recuperar dados, enquanto outros podem recuperar e atualizar. Logo, o tipo de opera√ß√£o de acesso - recupera√ß√£o  ou  atualiza√ß√£o  -  tamb√©m  deve  ser  controlado. Em geral, os usu√°rios ou grupos de usu√°rios recebem n√∫meros de conta protegidos por senhas, que podem usar para acessar o banco de dados. Um SGBD deve oferecer um subsistema de seguran√ßa e autoriza√ß√£o , que o DBA utiliza para criar contas e especificar suas restri√ß√µes. Ent√£o, o SGBD deve impor essas restri√ß√µes automaticamente. Observe que podemos aplicar controles semelhantes ao software de SGBD. Por exemplo, somente o DBA est√° autorizado a usar certo software privilegiado , como o software para criar contas. De modo semelhante, usu√°rios param√©tricos podem ter permiss√£o para acessar o banco de dados apenas por meio de transa√ß√µes programadas predefinidas, desenvolvidas para seu uso.

## 1.6.3 Oferecendo armazenamento persistente para objetos do programa

Os bancos de dados podem ser usados para oferecer armazenamento persistente para objetos e estruturas de dados do programa. Esse √© um dos principais motivos para a exist√™ncia de sistemas de banco de dados orientados a objeto . Linguagens de programa√ß√£o normalmente possuem estruturas de dados complexas, como tipos de registro em Pascal ou defini√ß√µes de classe em C ++ ou Java. Os valores das vari√°veis de programa ou estruturas dos objetos s√£o descartados quando um programa termina, a menos que o programador os armazene explicitamente em arquivos permanentes, o que, em geral, envolve  converter  essas  estruturas  complexas  em  um formato  adequado  para  armazenamento  de  arquivo. Quando  surge  a  necessidade  de  ler  esses  dados  mais uma vez, o programador precisa converter do formato de arquivo para a vari√°vel de programa ou estrutura de objeto. Os sistemas de banco de dados orientados a objeto s√£o compat√≠veis com linguagens de programa√ß√£o, como C ++ e Java, e o software de SGBD realiza automaticamente quaisquer convers√µes necess√°rias. Assim, um objeto complexo em C ++ pode ser armazenado de forma permanente em um SGBD orientado a objeto. Esse objeto √© considerado persistente , pois sobrevive ao t√©rmino da execu√ß√£o e pode ser recuperado mais tarde diretamente por outro programa C ++ .

O armazenamento persistente de objetos de programa e estruturas  de  dados  √©  uma  fun√ß√£o  importante dos sistemas de banco de dados. Os sistemas tradicionais  sofrem  com  frequ√™ncia  do  chamado problema de diverg√™ncia de imped√¢ncia ,  pois as estruturas de dados fornecidas pelo SGBD s√£o incompat√≠veis com as estruturas de dados da linguagem de programa√ß√£o. Os sistemas de banco de dados orientados a objeto em geral oferecem compatibilidade da estrutura de dados com uma ou mais linguagens de programa√ß√£o orientadas a objeto.

## 1.6.4 Oferecendo estruturas de armazenamento e t√©cnicas de pesquisa para o processamento eficiente de consulta

Os sistemas de banco de dados precisam oferecer capacidades  para executar  consultas  e  atualiza√ß√µes de modo eficiente . Como o banco de dados costuma ser armazenado em disco, o SGBD precisa oferecer estruturas de dados e t√©cnicas de pesquisa especializadas para agilizar a busca dos registros desejados no disco. Arquivos auxiliares, denominados √≠ndices , s√£o usados para essa finalidade. Os √≠ndices normalmente  s√£o  baseados  em  estruturas  de  dados  em  √°rvore ou estrutura de dados em hash , que s√£o modificadas de maneira adequada para a pesquisa no disco. Para processar os registros de banco de dados necess√°rios por uma consulta em particular, eles precisam ser copiados do disco para a mem√≥ria principal. Portanto,

o SGBD frequentemente tem um m√≥dulo de buffering ou caching que mant√©m partes do banco de dados nos buffers de mem√≥ria principais. Em geral, o sistema operacional √© respons√°vel pelo buffering do disco para a mem√≥ria. Contudo, como o buffering de dados √© essencial para o desempenho do SGBD, a maioria desses sistemas realiza o pr√≥prio buffering de dados.

O  m√≥dulo  de processamento  e  otimiza√ß√£o  de consulta do  SGBD  √©  respons√°vel  por  escolher  um plano de execu√ß√£o eficiente para cada consulta, com base nas estruturas de armazenamento existentes. A escolha de quais √≠ndices criar e manter faz parte do projeto e ajuste de banco de dados f√≠sico , que √© uma das responsabilidades da equipe de DBAs. Discutiremos sobre processamento de consulta, otimiza√ß√£o e ajuste na Parte 8 do livro.

## 1.6.5 Oferecendo backup e recupera√ß√£o

Um SGBD precisa oferecer recursos para recuperar-se de falhas de hardware ou software. Seu subsistema de backup e recupera√ß√£o √© respons√°vel por isso. Por exemplo, se o sistema do computador falhar no meio de uma transa√ß√£o de atualiza√ß√£o complexa, o subsistema de recupera√ß√£o √© respons√°vel por garantir que o banco de dados seja restaurado ao estado em que estava antes da transa√ß√£o ser executada. Como alternativa, o subsistema de recupera√ß√£o poderia garantir que a transa√ß√£o seja reiniciada no ponto em que foi interrompida, de modo que seu efeito completo  seja  registrado  no  banco  de  dados.  O  backup de disco tamb√©m √© necess√°rio no caso de uma falha de disco catastr√≥fica. Discutiremos a respeito do backup e recupera√ß√£o no Cap√≠tulo 23.

## 1.6.6 Oferecendo m√∫ltiplas interfaces do usu√°rio

Uma vez que muitos tipos de usu√°rios, com diversos n√≠veis de conhecimento t√©cnico, utilizam um banco de dados, um SGBD deve oferecer uma variedade de interfaces de usu√°rio. Essas incluem linguagens de consulta para usu√°rios casuais, interfaces de linguagem de programa√ß√£o para programadores de aplica√ß√£o, formul√°rios e c√≥digos de comando para usu√°rios param√©tricos e interfaces controladas por menu e de linguagem natural para usu√°rios isolados. As interfaces no estilo de formul√°rios e de menus normalmente s√£o conhecidas como interfaces gr√°ficas do usu√°rio (GUIs - Graphical User Interfaces). Existem muitas linguagens e ambientes especializados para especificar GUIs. Recursos para oferecer interfaces GUI para um banco de dados na Web - ou habilitar um banco de dados para a Web - tamb√©m s√£o muito comuns.

## 1.6.7 Representando relacionamentos complexos entre dados

Um banco de dados pode incluir muitas variedades de dados que est√£o inter-relacionados de diversas maneiras. Considere o exemplo mostrado na Figura 1.2. O registro de 'Braga' no arquivo ALUNO est√° relacionado  a  quatro  registros  no  arquivo HISTORICO\_ES-COLAR .  De  modo  semelhante,  cada  registro  de  turma est√°  relacionado  a  um  registro  de  disciplina  e  a uma s√©rie de registros de HISTORICO\_ESCOLAR - um para cada aluno que concluiu a turma. Um SGBD precisa ter a capacidade de representar uma s√©rie de relacionamentos complexos entre os dados, definir novos relacionamentos √† medida que eles surgem e recuperar e atualizar dados relacionados de modo f√°cil e eficaz.

## 1.6.8 Impondo restri√ß√µes de integridade

A maioria das aplica√ß√µes de banco de dados possui certas restri√ß√µes de integridade que devem ser mantidas para os dados. Um SGBD deve oferecer capacidades para definir e impor tais restri√ß√µes. O tipo mais simples de restri√ß√£o de integridade envolve especificar um tipo de dado para cada item de dado. Por exemplo, na Figura 1.3, especificamos que o valor do item de dados Tipo\_aluno em cada registro de ALUNO deve ser um inteiro de um d√≠gito e que o valor de Nome precisa ser um alfanum√©rico de at√© 30 caracteres. Para restringir o valor de Tipo\_aluno entre 1 e 5, seria preciso uma restri√ß√£o adicional, que n√£o aparece no cat√°logo atual. Um tipo de restri√ß√£o mais complexo, que ocorre com frequ√™ncia, envolve especificar que um registro em um arquivo deve estar  relacionado a registros em outros arquivos. Por exemplo, na Figura 1.2, podemos especificar que cada registro de turma deve estar relacionado a um registro de disciplina . Isso √© conhecido como restri√ß√£o de integridade referencial . Outro tipo de restri√ß√£o especifica a exclusividade sobre valores de item de dados, como cada registro de disciplina dever√° ter um valor exclusivo para Numero\_disciplina .  Isso √© conhecido como uma restri√ß√£o de chave ou singularidade .  Tais  restri√ß√µes  s√£o derivadas do significado ou da sem√¢ntica dos dados e do minimundo que eles representam. √â responsabilidade dos projetistas do banco de dados identificar restri√ß√µes de integridade durante o projeto. Algumas restri√ß√µes podem ser especificadas ao SGBD e impostas automaticamente.  Outras  podem  ter  que  ser  verificadas  por programas de atualiza√ß√£o ou no momento da entrada de dados. Em geral, para grandes aplica√ß√µes, √© comum chamar essas restri√ß√µes de regras de neg√≥cio .

Um item de dados pode ser inserido erroneamente e ainda satisfazer as restri√ß√µes de integridade especificadas. Por exemplo, se um aluno recebe uma nota 'A', mas uma nota 'C' √© inserida no banco de dados, o SGBD n√£o pode descobrir esse erro automaticamente,

pois 'C' √© um valor v√°lido para o tipo de dados Nota . Esses erros de entrada de dados s√≥ podem ser descobertos manualmente (quando o aluno recebe a nota e reclama) e  corrigidos  posteriormente,  atualizando  o  banco  de dados. Por√©m, uma nota 'Z' seria rejeitada automaticamente pelo SGBD, pois 'Z' n√£o √© um valor v√°lido para o tipo de dado Nota .  Quando discutirmos cada modelo de dados nos pr√≥ximos cap√≠tulos, vamos apresentar regras que pertencem a esse modelo de maneira impl√≠cita. Por exemplo, no modelo Entidade-Relacionamento, no Cap√≠tulo 7, um relacionamento deve envolver pelo menos duas entidades. Essas regras s√£o regras inerentes do modelo de dados e assumidas de maneira autom√°tica, para garantir a validade do modelo.

## 1.6.9 Permitindo dedu√ß√£o e a√ß√µes usando regras

Alguns sistemas oferecem capacidades para definir regras de dedu√ß√£o (ou infer√™ncia ) para deduzir novas informa√ß√µes com base nos fatos armazenados no banco de dados. Esses sistemas s√£o chamados de sistemas de banco de dados dedutivos . Por exemplo, pode haver regras  complexas na aplica√ß√£o do minimundo para determinar quando um aluno est√° em √©poca de prova. Estas podem ser especificadas declarativamente como regras que, quando compiladas e mantidas pelo SGBD, podem determinar todos os alunos em √©poca de prova. Em um SGBD tradicional, um c√≥digo de programa de procedimento expl√≠cito  teria  de  ser  escrito para dar suporte a tais aplica√ß√µes. Mas, se as regras do minimundo mudarem, geralmente √© mais conveniente mudar as regras de dedu√ß√£o declaradas do que recodificar  programas de procedimento. Nos sistemas de banco de dados relacionais de hoje √© poss√≠vel associar gatilhos (ou triggers ) a tabelas. Um gatilho √© uma forma de regra ativada por atualiza√ß√µes na tabela, que resulta na realiza√ß√£o de algumas opera√ß√µes adicionais em algumas outras tabelas, envio de mensagens, e assim por diante. Procedimentos mais elaborados para impor regras s√£o popularmente chamados de procedimentos armazenados (ou stored  procedures );  eles  se  tornam parte da defini√ß√£o geral de banco de dados e s√£o chamados de forma apropriada quando certas condi√ß√µes s√£o  atendidas.  A  funcionalidade  mais  poderosa  √© fornecida por sistemas de banco de dados ativos , que oferecem regras ativas que podem automaticamente iniciar a√ß√µes quando ocorrem certos eventos e condi√ß√µes.

## 1.6.10 mplica√ß√µes adicionais do uso da I abordagem de banco de dados

Esta  se√ß√£o  discute  algumas  implica√ß√µes  adicionais  do  uso  da  abordagem de banco de dados que pode beneficiar a maioria das organiza√ß√µes.

Potencial  para  garantir  padr√µes. A  t√©cnica  de banco de dados permite que o DBA defina e imponha o uso de padr√µes entre os usu√°rios de banco de dados  em  uma  grande  organiza√ß√£o.  Isso  facilita  a comunica√ß√£o e a coopera√ß√£o entre seus v√°rios departamentos, projetos e usu√°rios dentro da organiza√ß√£o. Podem ser definidos padr√µes para nomes e formatos dos elementos de dados, formatos de exibi√ß√£o, estruturas de relat√≥rio, terminologia, e assim por diante. O DBA pode impor padr√µes em um ambiente de banco de dados centralizado mais facilmente do que em um ambiente onde cada grupo de usu√°rios tem controle sobre os pr√≥prios arquivos de dados e software.

Tempo reduzido para desenvolvimento de aplica√ß√£o Um importante recurso de venda da abordagem de banco de dados √© que o desenvolvimento de uma nova aplica√ß√£o - como a recupera√ß√£o de certos dados para impress√£o de um novo relat√≥rio - leva muito pouco tempo. Projetar e implementar um grande banco de dados multiusu√°rio do zero pode levar mais tempo do que escrever uma √∫nica aplica√ß√£o de arquivo  especializada.  Por√©m,  quando  um  banco de  dados  est√°  pronto  e  funcionando,  geralmente  √© preciso  muito  menos  tempo  para  criar  outras  aplica√ß√µes usando as facilidades do SGBD. O tempo de desenvolvimento usando um SGBD √© estimado como sendo um sexto a um quarto daquele para um sistema de arquivo tradicional.

Flexibilidade. Pode ser necess√°rio mudar a estrutura de um banco de dados √† medida que as necessidades  mudam. Por exemplo, pode aparecer um novo grupo de usu√°rios precisando de informa√ß√µes atualmente n√£o inclu√≠das no banco de dados. Em resposta, pode  ser  preciso  acrescentar  um  arquivo  ao  banco de dados ou estender os elementos de dados em um arquivo  existente.  Os  SGBDs  modernos  permitem certos tipos de mudan√ßas evolucion√°rias na estrutura do banco de dados sem afetar os dados armazenados e os programas de aplica√ß√£o existentes.

Disponibilidade de informa√ß√µes atualizadas. Um SGBD torna o banco de dados dispon√≠vel a todos os usu√°rios. Assim que a atualiza√ß√£o de um usu√°rio √© aplicada ao banco de dados, todos os outros usu√°rios podem v√™-la imediatamente. Essa disponibilidade de informa√ß√µes atualizadas √© essencial para muitas aplica√ß√µes de processamento de transa√ß√£o, como sistemas de reserva ou bancos de dados banc√°rios, e ela √© possibilitada pelos subsistemas de controle de concorr√™ncia e recupera√ß√£o de um SGBD.

Economias de escala. A t√©cnica  de  SGBD  permite a consolida√ß√£o de dados e aplica√ß√µes, reduzindo assim a quantidade de sobreposi√ß√£o desperdi√ßada entre as atividades do pessoal de processamento de dados em diferen-

tes projetos ou departamentos, bem como as redund√¢ncias entre as aplica√ß√µes. Isso permite que a organiza√ß√£o inteira invista em processadores, dispositivos de armazenamento ou mecanismos de comunica√ß√£o mais poderosos, em vez de cada departamento ter de comprar o pr√≥prio equipamento (menor desempenho), o que reduz os custos gerais de opera√ß√£o e gerenciamento.

## 1.7 Uma breve hist√≥ria das aplica√ß√µes de banco de dados

Agora, vamos apresentar uma breve vis√£o hist√≥rica das aplica√ß√µes que usam SGBDs e como elas motivaram o desenvolvimento de novos tipos de sistemas de banco de dados.

## 1.7.1 Antigas aplica√ß√µes de banco de dados usando sistemas hier√°rquicos e de rede

Muitas  aplica√ß√µes  de  banco  de  dados  antigas mantinham  os  registros  em  grandes  organiza√ß√µes, como corpora√ß√µes, universidades, hospitais e bancos. Em muitas delas, existia grande quantidade de registros com estrutura semelhante. Por exemplo, em uma aplica√ß√£o de universidade, informa√ß√µes semelhantes seriam  mantidas  para  cada  aluno,  cada  disciplina, cada hist√≥rico escolar, e assim por diante. Tamb√©m existiam muitos tipos de registros e muitos inter-relacionamentos entre eles.

Um dos principais  problemas  com  os  sistemas de banco de dados antigos era a mistura de relacionamentos conceituais com o armazenamento e posicionamento f√≠sico dos registros no disco. Logo, esses sistemas n√£o ofereciam capacidades suficientes para abstra√ß√£o  de  dados e independ√™ncia  entre  dados  e programas .  Por  exemplo,  as  notas  de  determinado aluno poderiam ser armazenadas fisicamente pr√≥ximas do registro do aluno. Embora isso fornecesse um acesso muito eficiente para as consultas e transa√ß√µes originais com as quais o banco de dados foi projetado para lidar, n√£o oferecia flexibilidade suficiente para acessar registros de modo eficiente quando novas consultas e transa√ß√µes fossem identificadas. Em particular, novas consultas que exigiam uma organiza√ß√£o de armazenamento diferente para o processamento eficiente eram muito dif√≠ceis de implementar de  modo eficaz.  Tamb√©m  era  muito  trabalhoso  reorganizar o banco de dados quando eram feitas mudan√ßas nos requisitos da aplica√ß√£o.

Outra defici√™ncia dos sistemas antigos era que eles ofereciam apenas interfaces da linguagem de programa√ß√£o. Isso tornava demorada e cara a implementa√ß√£o de novas consultas e transa√ß√µes, pois novos programas tinham de ser escritos, testados e depurados. A maioria desses sistemas de banco de dados era implantada em computadores mainframes grandes e caros, come√ßando em meados da d√©cada de 1960 e continuando nos anos 1970 e 1980. Os principais tipos dos primeiros sistemas eram baseados em tr√™s paradigmas principais: sistemas hier√°rquicos, sistemas baseados em modelo de rede e sistemas de arquivo invertidos.

## 1.7.2 Oferecendo abstra√ß√£o de dados e flexibilidade de aplica√ß√£o com bancos de dados relacionais

Os bancos de dados relacionais foram propostos originalmente  para  separar  o  armazenamento  f√≠sico dos dados de sua representa√ß√£o conceitual e para fornecer uma base matem√°tica para a representa√ß√£o e a consulta dos dados. O modelo de dados relacional tamb√©m introduziu linguagens de consulta de alto n√≠vel, que ofereciam uma alternativa √†s interfaces de linguagem  de  programa√ß√£o,  tornando  muito  mais r√°pida a escrita de novas consultas. A representa√ß√£o relacional  dos  dados  √©  semelhante  ao  exemplo  que apresentamos na Figura 1.2. Os sistemas relacionais visavam  inicialmente  atender  √†s  mesmas  aplica√ß√µes dos  sistemas  mais  antigos,  e  forneciam  flexibilidade para desenvolver rapidamente novas consultas e reorganizar o banco de dados √† medida que os requisitos mudavam. Logo, a abstra√ß√£o de dados e a independ√™ncia entre dados e programas eram mais desenvolvidas em compara√ß√£o com os sistemas anteriores.

Os  sistemas  relacionais  experimentais,  desenvolvidos no final da d√©cada de 1970, e os sistemas de gerenciamento de bancos de dados relacionais (SGBDR),  introduzidos  na  d√©cada  de  1980,  eram muito lentos, pois n√£o usavam ponteiros de armazenamento f√≠sico ou posicionamento de registro para acessar registros de dados relacionados. Com o desenvolvimento de novas t√©cnicas de armazenamento houve uma melhora no desempenho do processamento e otimiza√ß√£o de consulta. Por fim, os bancos de dados relacionais se tornaram o tipo de sistema de banco de dados dominante para aplica√ß√µes tradicionais. Eles agora existem em quase todos os tipos de computadores,  desde  os  menores  modelos  pessoais  at√© grandes servidores.

## 1.7.3 Aplica√ß√µes orientadas a objeto e a necessidade de bancos de dados mais complexos

O  surgimento  de  linguagens  de  programa√ß√£o orientadas a objeto no final da d√©cada de 1980 e a necessidade  de  armazenar  e  compartilhar  objetos complexos e estruturados levou ao desenvolvimento

de Bancos de Dados Orientados a Objeto (BDOOs). Inicialmente, os BDOOs eram considerados um concorrente dos bancos de dados relacionais, pois forneciam estruturas de dados mais gerais. Eles tamb√©m incorporavam  muitos  dos  paradigmas  √∫teis  orientados a objeto, como tipos de dados abstratos, encapsulamento de opera√ß√µes, heran√ßa e identidade de objeto.  Por√©m,  a  complexidade  do  modelo  e  a  falta  de  um  padr√£o inicial  contribu√≠ram para seu uso limitado.  Eles  agora  s√£o  usados  principalmente  em aplica√ß√µes especializadas, como projeto de engenharia, publica√ß√£o de multim√≠dia e sistemas de manufatura.  Apesar  das  expectativas  de  que  eles  causar√£o um grande impacto, atualmente sua penetra√ß√£o geral no mercado de produtos de banco de dados permanece abaixo dos cinco por cento. Al√©m disso, muitos conceitos  orientados  a  objeto  foram  incorporados nas vers√µes mais recentes dos SGBDs relacionados, levando a sistemas de gerenciamento de banco de dados objeto-relacional, conhecidos como SGBDORs.

## 1.7.4 nterc√¢mbio de dados na Web para I com√©rcio eletr√¥nico usando XML

A World Wide Web oferece uma grande rede de computadores interconectados.  Os  usu√°rios  podem criar  documentos usando uma linguagem de publica√ß√£o na Web, como HyperText Markup Language (HTML ou, em portugu√™s, linguagem de marca√ß√£o de hipertexto), e armazenar esses documentos em servidores Web, onde outros usu√°rios (clientes) podem acess√°-los. Os documentos podem ser vinculados por meio de hyperlinks , que s√£o indicadores para outros documentos. Na d√©cada de 1990, o com√©rcio eletr√¥nico (e-commerce) surgiu como uma importante aplica√ß√£o da Web. Rapidamente ficou vis√≠vel que partes da informa√ß√£o nas p√°ginas Web de e-commerce eram, com  frequ√™ncia, dados  extra√≠dos dinamicamente de  SGBDs.  Diversas  t√©cnicas  foram  desenvolvidas para  permitir  o  interc√¢mbio  de  dados  na  Web. Atualmente, a eXtended Markup Language (XML, em portugu√™s, linguagem de marcadores extens√≠vel) √©  considerada  o  principal  padr√£o  para  interc√¢mbio entre  diversos  tipos  de  bancos  de  dados  e  p√°ginas Web. A XML combina conceitos dos modelos usados nos sistemas de documentos com os conceitos de modelagem de banco de dados. O Cap√≠tulo 12 √© dedicado √† discuss√£o sobre a XML.

## 1.7.5 Estendendo as capacidades do banco de dados para novas aplica√ß√µes

O sucesso dos sistemas de banco de dados nas aplica√ß√µes tradicionais encorajou os desenvolvedores de outros tipos de aplica√ß√µes a tentarem utiliz√°-los.

Essas aplica√ß√µes tradicionalmente usavam suas pr√≥prias  estruturas  especializadas  de  arquivo  e  dados. Os sistemas de banco de dados agora oferecem extens√µes para dar melhor suporte √†s necessidades especializadas para algumas dessas aplica√ß√µes. A seguir est√£o alguns exemplos dessas aplica√ß√µes:

- ¬Ñ Aplica√ß√µes cient√≠ficas que armazenam grande quantidade  de  dados  resultantes  de  experimentos cient√≠ficos em √°reas como a f√≠sica de alta energia, o mapeamento do genoma humano e a descoberta de estruturas de prote√≠nas.
- ¬Ñ Armazenamento e recupera√ß√£o de imagens , incluindo not√≠cias escaneadas e fotografias pessoais,  imagens  fotogr√°ficas  de  sat√©lite  e  imagens de procedimentos m√©dicos, como raios X e IRMs (imagens por resson√¢ncia magn√©tica).
- ¬Ñ Armazenamento  e  recupera√ß√£o  de v√≠deos , como filmes, e clipes de v√≠deo de not√≠cias ou de c√¢meras digitais pessoais.
- ¬Ñ Aplica√ß√µes de minera√ß√£o de dados (ou data mining ), que analisam grande quantidade de dados procurando as ocorr√™ncias de padr√µes ou  relacionamentos  espec√≠ficos,  e  identifica√ß√£o de padr√µes incomuns em √°reas como uso de cart√£o de cr√©dito.
- ¬Ñ Aplica√ß√µes espaciais , que armazenam a localiza√ß√£o espacial de dados, como informa√ß√µes de clima, mapas usados em sistemas de informa√ß√µes geogr√°ficas e em sistemas de navega√ß√£o de autom√≥veis.
- ¬Ñ Aplica√ß√µes  de s√©rie  temporais ,  que  armazenam  informa√ß√µes  como  dados  econ√¥micos em pontos regulares no tempo, como vendas di√°rias e valores mensais do Produto Interno Bruto (PIB).

Logo ficou aparente que os sistemas relacionais b√°sicos n√£o eram muito adequados para muitas dessas aplica√ß√µes, em geral por um ou mais dos seguintes motivos:

- ¬Ñ Estruturas de dados mais complexas eram necess√°rias para modelar a aplica√ß√£o do que a representa√ß√£o relacional simples.
- ¬Ñ Novos tipos de dados eram necess√°rios al√©m dos tipos b√°sicos num√©ricos e alfanum√©ricos.
- ¬Ñ Novas opera√ß√µes e construtores de linguagem de consulta eram necess√°rios para manipular os novos tipos de dados.
- ¬Ñ Novas estruturas de armazenamento e indexa√ß√£o eram necess√°rias para a pesquisa eficiente sobre os novos tipos de dados.

Isso levou os desenvolvedores de SGBD a acrescentarem  funcionalidade  a  seus  sistemas.  Alguma funcionalidade era de uso geral, como a incorpora√ß√£o de conceitos dos bancos de dados orientados a objeto aos  sistemas  relacionais.  Outras  eram  de  uso  especial, na forma de m√≥dulos opcionais que poderiam ser usados para aplica√ß√µes espec√≠ficas. Por exemplo, os usu√°rios poderiam comprar um m√≥dulo de s√©ries temporal para usar com seu SGBD relacional para aplica√ß√µes de s√©ries temporais.

Muitas  organiza√ß√µes  de  grande  porte  utilizam v√°rios pacotes de aplica√ß√£o de software que trabalham intimamente com o banco de dados de back-ends . O banco de dados do back-end. representa um ou mais bancos de dados, possivelmente de diferentes fornecedores e usando diferentes modelos de dados, que mant√™m dados manipulados por esses pacotes para dar suporte a transa√ß√µes, gerar relat√≥rios e responder a consultas ocasionais. Um dos sistemas mais utilizados  inclui  o ERP ( Enterprise  Resource  Planning, planejamento  de  recursos  empresariais ,  que  serve ) para consolidar diversas √°reas funcionais dentro de uma organiza√ß√£o, incluindo produ√ß√£o, vendas, distribui√ß√£o, marketing, finan√ßas, recursos humanos, e assim por diante. Outro tipo de sistema popular √©  o CRM  ( Customer  Relationship  Management, gerenciamento do relacionamento com o cliente , ) que compreende fun√ß√µes de processamento de pedido,  bem  como  marketing  e  suporte  ao  cliente. Essas  aplica√ß√µes  s√£o  habilitadas  para  Web  porque usu√°rios internos e externos recebem uma s√©rie de interfaces de portal Web para interagir com os bancos de dados de back-end.

## 1.7.6 Bancos de dados versus recupera√ß√£o de informa√ß√µes

Tradicionalmente,  a  tecnologia  de  banco  de dados se aplica a dados estruturados e formatados, que  surgem  em  aplica√ß√µes  de  rotina  no  governo, no com√©rcio e na ind√∫stria. Ela √© bastante utilizada nos setores de manufatura, varejo, bancos, seguros, finan√ßas  e  sa√∫de,  onde  dados  estruturados  s√£o  coletados  por  meio  de  formul√°rios,  como  faturas  ou documentos de registro de paciente. Uma √°rea relacionada √† tecnologia de banco de dados √© a Recupera√ß√£o de Informa√ß√£o (RI) ,  que lida com livros, manuscritos e diversas formas de artigos baseados em biblioteca. O dado √© indexado, catalogado e anotado usando palavras-chave. A RI est√° relacionada √† busca  por  conte√∫  do  com  base  nessas  palavras-chave  e a  muitos  problemas que lidam com processamento de documento e processamento de texto em forma livre. Muito trabalho tem sido feito sobre busca em texto baseada em palavras-chave, localiza√ß√£o de do- cumentos e sua classifica√ß√£o conforme a relev√¢ncia, categoriza√ß√£o  autom√°tica  de  texto,  classifica√ß√£o  de documentos de texto por t√≥picos, e assim por diante. Com o advento da Web e a prolifera√ß√£o de p√°ginas HTML na faixa dos bilh√µes, √© preciso aplicar muitas t√©cnicas de RI para processar os dados na Web. Os dados dessas p√°ginas normalmente cont√™m imagens, texto e objetos que s√£o ativos e mudam de maneira din√¢mica. A recupera√ß√£o de informa√ß√µes na Web √© um problema novo que exige que t√©cnicas de bancos de dados e RI sejam aplicadas a uma s√©rie de combina√ß√µes novas. Discutiremos os conceitos relacionados √† recupera√ß√£o de informa√ß√µes e p√°ginas Web no Cap√≠tulo 27.

## 1.8 Quando n√£o usar um SGBD

Apesar das vantagens de usar um SGBD, existem algumas situa√ß√µes em que esse sistema pode envolver custos adicionais desnecess√°rios, que n√£o aconteceriam no processamento de arquivos tradicional. Os custos adicionais do uso de um SGBD devem-se aos seguintes fatores:

- ¬Ñ Alto investimento inicial em hardware, software e treinamento.
- ¬Ñ A generalidade que um SGBD oferece para a defini√ß√£o e o processamento de dados.
- ¬Ñ Esfor√ßo  adicional  para  oferecer  fun√ß√µes  de seguran√ßa, controle de concorr√™ncia, recupera√ß√£o e integridade.

Portanto, pode ser mais desej√°vel usar arquivos comuns sob as seguintes circunst√¢ncias:

- ¬Ñ Aplica√ß√µes de banco de dados simples e bem definidas, para as quais n√£o se espera muitas mudan√ßas.
- ¬Ñ Requisitos rigorosos, de tempo real, para alguns programas de aplica√ß√£o, que podem n√£o ser atendidos devido as opera√ß√µes extras executadas pelo SGBD.
- ¬Ñ Sistemas embarcados com capacidade de armazenamento  limitada,  onde  um  SGBD  de uso geral n√£o seria apropriado.
- ¬Ñ Nenhum acesso de m√∫ltiplos usu√°rios aos dados.

Certos setores e aplica√ß√µes decidiram n√£o utilizar SGBDs de uso geral. Por exemplo, muitas ferramentas de projeto auxiliado por computador (CAD) usadas  por  engenheiros  civis  e  mec√¢nicos  possuem software propriet√°rio para gerenciamento de arquivos e dados, preparado para as manipula√ß√µes internas dos desenhos e objetos 3D. De modo semelhante, sistemas  de  comunica√ß√£o  e  comuta√ß√£o  projetados por  empresas  como  a  AT&amp;T  foram  manifesta√ß√µes

iniciais  do  software  de  banco  de  dados  preparado para executar de forma muito r√°pida com dados organizados hierarquicamente, para agilizar o acesso e o roteamento das chamadas. De modo semelhante, implementa√ß√µes  dos  sistemas  de  informa√ß√µes  geogr√°ficas (SIG) normalmente usam os pr√≥prios esquemas de organiza√ß√£o de dados, a fim de implantar, de modo eficiente, fun√ß√µes relacionadas a processamento de mapas, contornos f√≠sicos, linhas, pol√≠gonos, e assim por diante. Os SGBDs de uso geral s√£o inadequados para essa finalidade.

## Resumo

Neste cap√≠tulo, definimos um banco de dados como uma cole√ß√£o de dados relacionados, onde dados significam fatos gravados. Um banco de dados t√≠pico representa algum aspecto do mundo real e √© usado para fins espec√≠ficos por um ou mais grupos de usu√°rios. Um SGBD √© um pacote de software generalizado para implementar e manter um banco de dados computadorizado. Juntos, o banco de dados e o software formam um sistema de banco de dados. Identificamos v√°rias caracter√≠sticas que distinguem a t√©cnica de banco de dados das aplica√ß√µes tradicionais de processamento de arquivo, e discutimos as principais categorias de usu√°rios de banco de dados, ou os atores em cena . Observamos que, al√©m dos usu√°rios em ambiente de banco de dados, existem v√°rias categorias de pessoal de suporte, ou trabalhadores de bastidores , em um ambiente de banco de dados.

Apresentamos uma lista de capacidades que devem ser fornecidas pelo software de SGBD ao DBA, aos projetistas de banco de dados e aos usu√°rios finais para ajud√°-los a projetar, administrar e usar um banco de dados. Depois, mostramos uma r√°pida perspectiva hist√≥rica da evolu√ß√£o das aplica√ß√µes de banco de dados. Indicamos o casamento da tecnologia de banco de dados com a tecnologia da recupera√ß√£o de informa√ß√µes, que desempenhar√° um papel importante devido √† popularidade da Web. Finalmente, discutimos os custos adicionais do uso de um SGBD e algumas situa√ß√µes em que sua utiliza√ß√£o pode n√£o ser vantajosa.

## Perguntas de revis√£o

- 1.1. Defina os seguintes termos: dados , banco de dados , SGBD sistema de banco de dados , , cat√°logo de banco de dados , independ√™ncia entre dados e programas , vis√£o do usu√°rio , DBA usu√°rio fi-, nal , transa√ß√£o programada , sistema de banco de dados dedutivo , objeto persistente , metadados e aplica√ß√£o para processamento de transa√ß√£o.
- 1.2. Quais  os  quatro  tipos  principais  de  a√ß√µes  que envolvem  bancos  de  dados?  Discuta  cada  tipo rapidamente.
- 1.3. Discuta as principais caracter√≠sticas da abordagem de banco de dados e como ela difere dos sistemas de arquivo tradicionais.
- 1.4. Quais  s√£o  as  responsabilidades  do  DBA  e  dos projetistas de banco de dados?
- 1.5. Quais s√£o os diferentes tipos de usu√°rios finais de banco de dados? Discuta as principais atividades de cada um.
- 1.6. Discuta as capacidades que devem ser fornecidas por um SGBD.
- 1.7. Discuta as diferen√ßas entre sistemas de banco de dados e sistemas de recupera√ß√£o de informa√ß√µes.

## Exerc√≠cios

- 1.8. Identifique algumas opera√ß√µes informais de consulta e atualiza√ß√£o que voc√™ esperaria aplicar ao banco de dados mostrado na Figura 1.2.
- 1.9. Qual √© a diferen√ßa entre redund√¢ncia controlada e n√£o controlada? D√™ exemplos.
- 1.10. Especifique todos os relacionamentos entre os registros do banco de dados mostrado na Figura 1.2.
- 1.11. Mostre algumas vis√µes adicionais que podem ser necess√°rias a outros grupos de usu√°rios do banco de dados mostrado na Figura 1.2.
- 1.12. Cite alguns exemplos de restri√ß√µes de integridade que voc√™ acredita que possam se aplicar ao banco de dados mostrado na Figura 1.2.
- 1.13. D√™ exemplos de sistemas em que pode fazer sentido usar o processamento de arquivos tradicional em vez da t√©cnica de banco de dados.
- 1.14. Considere a Figura 1.2.
- a. Se o nome do departamento 'CC' (Ci√™ncia da computa√ß√£o)  mudar  para  'CCES'  (Ci√™ncia da computa√ß√£o e engenharia de software) e o prefixo correspondente para o n√∫mero da disciplina tamb√©m mudar, identifique as colunas no banco de dados que precisariam ser atualizadas.
- b. Voc√™ consegue reestruturar as colunas nas tabelas DISCIPLINA , TURMA e PRE\_REQUISI-TO de modo que somente uma delas precise de atualiza√ß√£o?

## Bibliografia selecionada

A edi√ß√£o de outubro de 1991 de Communications of the ACM e Kim (1995) incluem v√°rios artigos que descrevem SGBDs da pr√≥xima gera√ß√£o. Muitos dos recursos de banco de dados discutidos no in√≠cio agora est√£o dispon√≠veis comercialmente. A edi√ß√£o de mar√ßo de 1976 de ACM Computing Surveys oferece  uma  introdu√ß√£o  aos sistemas de banco de dados, e pode fornecer uma perspectiva hist√≥rica para o leitor interessado.



## Conceitos e arquitetura do sistema de banco de dados

A arquitetura  dos  SGBDs  tem  evolu√≠do  desde  os primeiros sistemas monol√≠ticos, nos quais todo o software SGBD era um sistema altamente integrado, at√©  os  mais  modernos,  que  t√™m  um  projeto  modular, com arquitetura de sistema cliente/servidor. Essa evolu√ß√£o espelha as tend√™ncias na computa√ß√£o, em que grandes computadores mainframes centralizados est√£o sendo substitu√≠dos por centenas de esta√ß√µes de trabalho  distribu√≠das  e  computadores  pessoais,  conectados por redes de comunica√ß√µes a v√°rios tipos de m√°quinas servidoras - servidores Web, servidores de banco de dados, servidores de arquivos, servidores de aplica√ß√µes, e assim por diante.

Em  uma  arquitetura  b√°sica  de  SGBD  cliente/ servidor  a  funcionalidade  do  sistema  √©  distribu√≠da entre dois tipos de m√≥dulos. 1  O m√≥dulo cliente normalmente √© projetado  para  executar  em  uma  esta√ß√£o de trabalho ou computador pessoal. Em geral, os programas de aplica√ß√£o e interfaces com o usu√°rio que acessam o banco de dados executam no m√≥dulo cliente.  Logo,  esse  m√≥dulo  se  encarrega  da  intera√ß√£o do usu√°rio e oferece interfaces amig√°veis, como formul√°rios ou GUIs (interfaces gr√°ficas do usu√°rio) baseadas  em  menu.  O  outro  tipo  de  m√≥dulo,  chamado m√≥dulo servidor ,  √©  normalmente respons√°vel pelo armazenamento de dados, acesso, pesquisa e outras fun√ß√µes. Discutiremos sobre arquiteturas cliente/ servidor com mais detalhes na Se√ß√£o 2.5. Primeiro, temos de estudar mais os conceitos b√°sicos, que nos dar√£o um melhor conhecimento das arquiteturas de banco de dados modernas.

fine  os  conceitos  de  esquemas  e  inst√¢ncias,  que  s√£o fundamentais  para  o  estudo  dos  sistemas  de  banco de dados. Depois, discutimos a arquitetura do SGBD de tr√™s esquemas e a independ√™ncia de dados na Se√ß√£o 2.2; isso  oferece  um  ponto  de  vista  do  usu√°rio sobre o que um SGBD deve realizar. Na Se√ß√£o 2.3, descrevemos os tipos de interfaces e linguagens que, normalmente, s√£o fornecidas por um SGBD. A Se√ß√£o 2.4  discute  o  ambiente  do  software  de  um  sistema de banco de dados. A Se√ß√£o 2.5 oferece uma vis√£o geral de v√°rios tipos de arquiteturas cliente/servidor. Finalmente, a Se√ß√£o 2.6 apresenta uma classifica√ß√£o dos tipos de pacotes de SGBD. No final do cap√≠tulo √© apresentado um resumo.

O material nas se√ß√µes 2.4 a 2.6 oferece conceitos mais detalhados, que podem ser considerados suplementares ao material introdut√≥rio b√°sico.

## 2.1 Modelos de dados, esquemas e inst√¢ncias

Neste  cap√≠tulo,  apresentamos  a  terminologia  e os conceitos b√°sicos que ser√£o usados no decorrer do livro. A Se√ß√£o 2.1 discute os modelos de dados e de-

Uma caracter√≠stica fundamental da abordagem de banco de dados √© que ela oferece algum n√≠vel de abstra√ß√£o  de  dados.  A abstra√ß√£o  de  dados ,  geralmente, se refere √† supress√£o de detalhes da organiza√ß√£o e armazenamento dos dados, destacando recursos essenciais para um melhor conhecimento desses dados. Uma das principais caracter√≠sticas da abordagem de banco de dados √© possibilitar a abstra√ß√£o de dados, de modo que diferentes usu√°rios possam perceb√™-los em seu n√≠vel de detalhe preferido. Um modelo de dados - uma cole√ß√£o de conceitos que podem ser usados para descrever a estrutura de um banco de dados - oferece os meios necess√°rios para

1 Conforme veremos na Se√ß√£o 2.5, existem varia√ß√µes sobre essa simples arquitetura cliente/servidor em duas camadas.

alcan√ßar essa abstra√ß√£o. 2  Com estrutura de um banco de dados , queremos dizer os tipos, relacionamentos e restri√ß√µes que se aplicam aos dados. A maioria dos modelos de dados tamb√©m inclui um conjunto de opera√ß√µes b√°sicas para especificar recupera√ß√µes e atualiza√ß√µes no banco de dados.

Al√©m  das  opera√ß√µes  b√°sicas  fornecidas  pelo modelo  de  dados,  est√°  se  tornando  mais  comum incluir  conceitos  no  modelo  de  dados  para  especificar  o aspecto  din√¢mico ou comportamento de uma aplica√ß√£o de banco de dados. Isso permite ao projetista  do  banco  de  dados  especificar  um  conjunto de opera√ß√µes v√°lidas, definidas pelo usu√°rio, sobre os objetos do banco de dados. 3  Um exemplo de uma opera√ß√£o definida pelo usu√°rio poderia ser CALCULA\_MEDIA , que pode ser aplicada a um objeto ALUNO . Por sua vez, opera√ß√µes gen√©ricas para inserir, excluir, modificar ou recuperar qualquer tipo de objeto normalmente est√£o inclu√≠das nas opera√ß√µes b√°sicas do modelo de dados. Conceitos para especificar o comportamento s√£o fundamentais para os modelos de dados orientados a objeto (ver Cap√≠tulo 11), mas tamb√©m est√£o sendo incorporados em modelos de dados mais tradicionais. Por exemplo, modelos objeto-relacional (ver Cap√≠tulo 11) estendem o modelo relacional b√°sico para incluir tais conceitos, entre outros. No modelo de dados relacional b√°sico, existe um recurso para conectar um comportamento √†s rela√ß√µes, na forma de m√≥dulos de armazenamento persistente, popularmente conhecidos como procedimentos armazenados ou stored procedures (ver Cap√≠tulo 13).

## 2.1.1 Categorias de modelos de dados

Muitos modelos de dados foram propostos, e podemos classific√°-los de acordo com os tipos de conceitos que eles utilizam para descrever a estrutura do banco de dados. Modelos de dados de alto n√≠vel ou conceituais oferecem conceitos que s√£o pr√≥ximos ao modo como muitos usu√°rios percebem os dados, enquanto os modelos de dados de baixo n√≠vel ou f√≠sicos oferecem conceitos que descrevem os detalhes de como os dados s√£o armazenados no computador, em geral, em discos magn√©ticos. Os conceitos oferecidos pelos modelos de dados de baixo n√≠vel costumam ser voltados para especialistas de computadores, n√£o para usu√°rios finais. Entre esses dois extremos est√° uma classe de modelos de dados representativos (ou de implementa√ß√£o ), 4 que oferece conceitos que podem ser facilmente entendidos pelos usu√°rios finais, mas que n√£o est√° muito longe do modo como os dados s√£o organizados e armazenados no  computador.  Modelos  de  dados  representativos ocultam muitos detalhes do armazenamento de dados em disco, mas podem ser implementados diretamente em um sistema de computador.

Os modelos de dados conceituais utilizam conceitos como entidades, atributos e relacionamentos. Uma entidade representa  um  objeto  ou  conceito do  mundo  real,  como  um  funcion√°rio  ou  um  projeto  do minimundo que √© descrito no banco de dados. Um atributo representa alguma propriedade de interesse que descreve melhor uma entidade, como o nome ou o sal√°rio do funcion√°rio. Um relacionamento entre duas  ou  mais  entidades  representa  uma  associa√ß√£o entre elas - por exemplo, um relacionamento trabalha-em entre um funcion√°rio e um projeto. O Cap√≠tulo 7 apresentar√° o modelo Entidade-Relacionamento - um modelo de dados conceitual popular de alto n√≠vel. O Cap√≠tulo 8 descrever√° abstra√ß√µes adicionais usadas para a modelagem avan√ßada, como generaliza√ß√£o, especializa√ß√£o e categorias (tipos de uni√£o).

Os modelos de dados representativos ou de implementa√ß√£o s√£o os usados com mais frequ√™ncia nos SGBDs comerciais tradicionais. Estes incluem o amplamente utilizado modelo de dados relacional ,  bem como os chamados modelos de dados legados - os modelos de rede e hier√°rquicos - que foram bastante usados no passado. A Parte 2 √© dedicada ao modelo de dados relacional e suas restri√ß√µes, opera√ß√µes e linguagens. 5 O padr√£o SQL para bancos de dados relacionais ser√° descrito nos cap√≠tulos 4 e 5. Os modelos de dados representativos mostram os dados usando estruturas de registro e, portanto, √†s vezes s√£o denominados modelos de dados baseados em registro .

Podemos considerar o modelo de dados de objeto como um exemplo de uma nova fam√≠lia de modelos de dados de implementa√ß√£o de n√≠vel mais alto e que s√£o mais pr√≥ximos dos modelos de dados conceituais. Um padr√£o para bancos de dados de objeto,  chamado modelo de objeto ODMG, foi proposto pelo grupo de gerenciamento de dados objeto  ODMG ( -Object  Data  Management  Group).  O  Cap√≠tulo  11 descreve as caracter√≠sticas gerais dos bancos de dados  de  objeto  e  o  padr√£o  proposto  do  modelo  de

2 √Äs vezes, a palavra modelo √© usada para indicar uma descri√ß√£o de banco de dados espec√≠fica, ou esquema - por exemplo, o modelo de dados de marketing . N√£o usaremos essa interpreta√ß√£o.

3 A inclus√£o de conceitos para descrever um comportamento reflete uma tend√™ncia por meio da qual as atividades do projeto do banco de dados e do projeto de software est√£o, cada vez mais, sendo combinadas em uma √∫nica atividade. Tradicionalmente, especificar um comportamento √© algo associado ao projeto de software.

4 O termo modelo de dados de implementa√ß√£o n√£o √© um termo padr√£o; ele foi apresentado para nos referirmos aos modelos de dados dispon√≠veis nos sistemas de banco de dados comerciais.

5 Um resumo dos modelos de dados hier√°rquico e de rede consta dos ap√™ndices D e E (em ingl√™s). Eles podem ser acessados no site de apoio do livro.

objeto. Os modelos de dados de objeto tamb√©m s√£o frequentemente utilizados como modelos conceituais de alto n√≠vel, em particular no dom√≠nio da engenharia de software.

Os modelos de dados f√≠sicos descrevem o armazenamento dos dados como arquivos no computador,  com  informa√ß√µes  como formatos de registro, ordena√ß√µes  de  registro  e  caminhos  de  acesso.  Um caminho de acesso √©  uma  estrutura  que  torna  eficiente a busca por registros de um banco de dados em particular. Discutiremos as t√©cnicas de armazenamento f√≠sico e as estruturas de acesso nos cap√≠tulos 17 e 18. Um √≠ndice √© um exemplo de um caminho que permite o acesso direto aos dados usando um  termo  de  √≠ndice  ou  uma  palavra-chave.  Ele  √© semelhante ao √≠ndice no final deste livro, com a exce√ß√£o de que pode ser organizado de forma linear, hier√°rquica (estruturada em √°rvore) ou de alguma outra maneira.

## 2.1.2 Esquemas, inst√¢ncias e estado do banco de dados

Em  qualquer  modelo  de  dados,  √©  importante distinguir entre a descri√ß√£o do banco de dados e o pr√≥prio banco de dados .  Tal  descri√ß√£o √© chamada de esquema do banco de dados , que √© especificado durante o projeto do banco de dados e n√£o se espera que mude com frequ√™ncia. 6  A maioria dos modelos de dados tem certas conven√ß√µes para representar esquemas como diagramas. 7  A representa√ß√£o de um esquema √© chamada de diagrama de esquema . A Figura 2.1 mostra um diagrama de esquema para o banco de dados da Figura 1.2; o diagrama apresenta a estrutura de cada tipo de registro, mas n√£o as inst√¢ncias reais dos registros. Chamamos cada objeto no esquema - por exemplo, ALUNO ou DISCIPLINA - de construtor do esquema .

Um diagrama de esquema representa apenas alguns aspectos de um esquema, como os nomes de tipos de registro e itens de dados, e alguns tipos de restri√ß√µes. Outros aspectos n√£o s√£o especificados nele; por exemplo, a Figura 2.1 n√£o mostra nem o tipo de dado de cada item de dados nem os relacionamentos entre os diversos arquivos. Muitos tipos de restri√ß√µes n√£o  s√£o  apresentados  nos  diagramas  de  esquema. Uma restri√ß√£o do tipo alunos prestes a se formarem em ci√™ncia da computa√ß√£o precisam realizar o curso CC1310 antes do final de seu segundo ano √© muito dif√≠cil de representar em forma de diagrama.

## ALUNO

## DISCIPLINA

## PRE\_REQUISITO

## TURMA

## HISTORICO\_ESCOLAR

Figura 2.1

Diagrama de esquema para o banco de dados da Figura 1.2.

Os dados reais  armazenados  em  um  banco  de dados  podem  mudar  com  muita  frequ√™ncia.  Por exemplo, o banco de dados mostrado na Figura 1.2 muda toda vez que acrescentamos um novo aluno ou inserimos uma nova nota. Os dados no banco de dados em determinado momento no tempo s√£o chamados de estado ou instante do banco de dados . Tamb√©m s√£o chamados de conjunto atual de ocorr√™ncias ou inst√¢ncias no banco de dados. Em determinado estado  do  banco  de  dados,  cada  construtor  de  esquema tem o pr√≥prio conjunto de inst√¢ncias atuais ; por  exemplo,  o  construtor ALUNO ter√°  o  conjunto de entidades de cada aluno (registros) como suas inst√¢ncias.  Muitos  estados  de  banco  de  dados  podem ser constru√≠dos para corresponder a um esquema de banco de dados em particular. Toda vez que inserimos ou exclu√≠mos um registro ou alteramos o valor de um item de dados em um registro, mudamos de um estado do banco de dados para outro.

A distin√ß√£o entre esquema e estado de banco de dados  √©  muito  importante.  Quando definimos um novo banco de dados, especificamos seu esquema apenas para o SGBD. Nesse ponto, o estado do banco de dados  correspondente  √©  o estado  vazio ,  sem  dados. Obtemos o estado inicial do banco de dados quando ele √© populado ou carregado com os dados iniciais. Da√≠ em diante, toda vez que uma opera√ß√£o de atualiza√ß√£o

6 Mudan√ßas no esquema normalmente s√£o necess√°rias √† medida que os requisitos das aplica√ß√µes do banco de dados mudam. Sistemas de banco de dados mais novos incluem opera√ß√µes para permitir mudan√ßas de esquema, embora esse processo seja mais complicado do que as simples atualiza√ß√µes no banco de dados.

7 Em terminologia de banco de dados, em ingl√™s, √© comum usar schemas como plural para schema , embora schemata seja a forma no plural apropriada. A palavra scheme tamb√©m √© usada para se referir a um esquema.

√© aplicada, obtemos outro estado do banco de dados. Em qualquer ponto no tempo, o banco de dados tem um estado atual . 8 O SGBD √© parcialmente respons√°vel por garantir que todo estado do banco de dados seja um estado v√°lido - ou seja, um estado que satisfa√ßa a  estrutura  e  as  restri√ß√µes  especificadas  no  esquema. Logo, especificar um esquema correto para o SGBD √© extremamente importante, e o esquema deve ser projetado  com extremo cuidado. O SGBD armazena as descri√ß√µes das constru√ß√µes e restri√ß√µes do esquema tamb√©m denominadas metadados - no cat√°logo do SGBD, de modo que o software do SGBD possa recorrer ao esquema sempre que precisar. O esquema √†s vezes √© chamado de inten√ß√£o , e um estado do banco de dados √© chamado de extens√£o do esquema.

Embora, como j√° mencionamos, o esquema n√£o deva mudar com frequ√™ncia, n√£o √© raro que as mudan√ßas,  ocasionalmente,  precisem  ser  aplicadas  ao esquema,  √†  medida  que  os  requisitos  da  aplica√ß√£o mudam.  Por  exemplo,  podemos  decidir  que  outro item  de  dados  precisa  ser  armazenado  para  cada registro em um arquivo, como a inclus√£o de Data\_ nascimento ao esquema ALUNO da Figura 2.1. Isso √© conhecido como evolu√ß√£o do esquema . A maioria dos SGBDs modernos possui algumas opera√ß√µes para evolu√ß√£o  de  esquema  que  podem  ser  aplicadas  enquanto o banco de dados est√° em funcionamento.

## 2.2 Arquitetura de tr√™s esquemas e independ√™ncia de dados

Tr√™s  das  quatro  caracter√≠sticas  importantes  da abordagem de banco de dados, listadas na Se√ß√£o 1.3, s√£o (1) uso de um cat√°logo para armazenar a descri√ß√£o (esquema) do banco de dados de modo a torn√°-lo autodescritivo, (2) isolamento de programas e dados (independ√™ncia entre dados do programa e opera√ß√£o do programa) e (3) suporte para m√∫ltiplas vis√µes do usu√°rio. Nesta se√ß√£o, especificamos uma arquitetura para sistemas de banco de dados, chamada arquitetura de tr√™s esquemas , 9 que foi proposta para ajudar a alcan√ßar e visualizar essas caracter√≠sticas. Depois, vamos discutir melhor o conceito de independ√™ncia de dados.

## 2.2.1 A arquitetura de tr√™s esquemas

O  objetivo  da  arquitetura  de  tr√™s  esquemas, ilustrada  na  Figura  2.2,  √©  separar  as  aplica√ß√µes  do usu√°rio do banco de dados f√≠sico. Nessa arquitetura, os esquemas podem ser definidos nos tr√™s n√≠veis a seguir:

- 1. O n√≠vel interno tem um esquema interno , que descreve a estrutura do armazenamento f√≠sico do banco de dados. O esquema interno usa um modelo de dados f√≠sico e descreve os detalhes completos do armazenamento de dados e caminhos de acesso para o banco de dados.
- 2. O n√≠vel conceitual tem um esquema conceitual ,  que  descreve  a  estrutura  do  banco  de dados inteiro para uma comunidade de usu√°rios. O esquema conceitual oculta os detalhes das estruturas de armazenamento f√≠sico e se concentra na descri√ß√£o de entidades, tipos de dados, relacionamentos, opera√ß√µes do usu√°rio e restri√ß√µes. Normalmente, um modelo de dados representativo √© usado para descrever o esquema conceitual quando um sistema de banco de dados √© implementado. Esse esquema conceitual de implementa√ß√£o costuma estar baseado em um projeto de esquema conceitual em um modelo de dados de alto n√≠vel.
- 3. O n√≠vel externo ou de vis√£o inclui uma s√©rie de esquemas externos ou vis√µes do usu√°rio . Cada esquema externo descreve a parte do banco de dados em que um grupo de usu√°rios em particular est√° interessado e oculta o restante do banco de dados do grupo de usu√°rios. Como no n√≠vel anterior, cada esquema externo √© comumente  implementado  usando  um  modelo de dados representativo, possivelmente baseado em um projeto de esquema externo em um modelo de dados de alto n√≠vel.

Figura 2.2



A arquitetura de tr√™s esquemas.

8 O estado atual tamb√©m √© chamado de instante atual do banco de dados e de inst√¢ncia do banco de dados , mas preferimos usar o termo inst√¢ncia para nos referir a registros individuais.

9 Isso tamb√©m √© conhecido como arquitetura ANSI/SPARC, mesmo nome do comit√™ que a prop√¥s (Tsichritzis e Klug, 1978).

A arquitetura de tr√™s esquemas √© uma ferramenta com a qual o usu√°rio pode visualizar os n√≠veis de esquema em um sistema de banco de dados. A maioria  dos  SGBDs  n√£o  separa  os  tr√™s  n√≠veis  completa e  explicitamente,  mas  d√°  suporte  a  eles  de  alguma forma. Alguns sistemas mais antigos podem incluir detalhes de n√≠vel f√≠sico no esquema conceitual. A arquitetura ANSI de tr√™s n√≠veis tem um lugar importante no desenvolvimento da tecnologia de banco de dados, pois separa, claramente, o n√≠vel externo dos usu√°rios, o n√≠vel conceitual do banco de dados e o n√≠vel  de  armazenamento  interno  no  projeto  de  um banco de dados. Ainda hoje ela √© bastante aplic√°vel no projeto de SGBDs. Na maioria dos SGBDs que t√™m suporte a vis√µes do usu√°rio, os esquemas externos  s√£o  especificados  no  mesmo  modelo  de  dados que descreve a informa√ß√£o no n√≠vel conceitual (por exemplo, um SGBD relacional como o Oracle utiliza SQL para isso). Alguns SGBDs permitem que diferentes modelos de dados sejam usados nos n√≠veis conceitual e externo. Um exemplo √© a Base de Dados Universal  (Universal Data Base - UDB), um SGBD da IBM que utiliza o modelo relacional para descrever o esquema conceitual, mas que pode usar um modelo orientado a objeto para descrever um esquema externo.

Observe que os tr√™s esquemas s√£o apenas descri√ß√µes dos dados; os dados armazenados que realmente existem est√£o apenas no n√≠vel f√≠sico. Em um SGBD baseado na arquitetura de tr√™s esquemas, cada grupo de  usu√°rios  recorre  ao  seu  pr√≥prio  esquema  externo. Assim, o SGBD precisa transformar uma solicita√ß√£o especificada em um esquema externo em uma solicita√ß√£o no esquema conceitual, e depois em uma solicita√ß√£o no esquema interno para o processamento no banco de dados armazenado. Se a solicita√ß√£o for uma recupera√ß√£o, os dados extra√≠dos do banco de dados armazenado devem ser reformatados para corresponder √† vis√£o externa do usu√°rio. Os processos de transforma√ß√£o de requisi√ß√µes e os resultados entre os n√≠veis s√£o chamados de mapeamentos . Esses mapeamentos podem ser demorados, de modo que alguns SGBDs - especialmente aqueles que servem para dar suporte a pequenos bancos de dados - n√£o suportam vis√µes externas. Por√©m, mesmo em tais sistemas, uma certa quantidade de mapeamento √© necess√°ria para transformar solicita√ß√µes entre os n√≠veis conceitual e interno.

## 2.2.2 Independ√™ncia de dados

A  arquitetura  de  tr√™s  esquemas  pode  ser  usada para explicar melhor o conceito de independ√™ncia de dados ,  que  pode  ser  definida  como a capacidade de alterar o esquema em um n√≠vel do sistema de banco de dados sem ter de alterar o esquema no n√≠vel mais alto. Podemos definir dois tipos de independ√™ncia de dados:

- 1. Independ√™ncia l√≥gica de dados √©  a  capacidade de alterar o esquema conceitual sem ter de alterar  os  esquemas  externos  ou  os  programas de aplica√ß√£o. Podemos alterar o esquema conceitual  para  expandir  o  banco  de  dados (acrescentando um tipo de registro ou item de dado), para alterar restri√ß√µes ou para reduzir o banco de dados (removendo um tipo de registro ou item de dado). No √∫ltimo caso, esquemas externos que se referem apenas aos dados restantes n√£o seriam afetados. Por exemplo, o esquema externo da Figura 1.5(a) n√£o dever√° ser afetado pela altera√ß√£o do arquivo HISTO -RICO\_ESCOLAR (ou tipo de registro), mostrado  na  Figura  1.2,  para  aquele  mostrado  na Figura  1.6(a).  Somente  a  defini√ß√£o  da  vis√£o e os mapeamentos precisam ser alterados em um SGBD que suporta a independ√™ncia l√≥gica de  dados.  Depois  que  o  esquema  conceitual passa por uma reorganiza√ß√£o l√≥gica, os programas de aplica√ß√£o que referenciam as constru√ß√µes do esquema externo devem trabalhar da mesma forma que antes. As mudan√ßas nas restri√ß√µes  podem  ser  aplicadas  ao  esquema conceitual  sem  afetar  os  esquemas  externos ou os programas de aplica√ß√£o.
- 2. Independ√™ncia f√≠sica de dados √© a capacidade de alterar o esquema interno sem ter de alterar o esquema conceitual. Logo, os esquemas externos tamb√©m n√£o precisam ser alterados. Mudan√ßas no esquema interno podem ser necess√°rias porque alguns arquivos f√≠sicos foram reorganizados - por exemplo, ao criar estruturas de acesso adicionais - para melhorar o desempenho da recupera√ß√£o ou atualiza√ß√£o. Se os mesmos dados de antes permanecerem no  banco  de  dados,  provavelmente  n√£o  teremos  de  alterar  o  esquema  conceitual.  Por exemplo, oferecer um caminho de acesso para melhorar a velocidade de recupera√ß√£o dos registros de turma (Figura 1.2) por semestre e ano n√£o dever√° exigir que uma consulta como listar todas as turmas oferecidas no segundo semestre de 2008 seja alterada, embora a consulta seja executada com mais efici√™ncia pelo SGBD ao utilizar o novo caminho de acesso.

Em geral, a independ√™ncia f√≠sica de dados existe na maioria dos bancos de dados e ambientes de arquivo, nos quais detalhes f√≠sicos, como a localiza√ß√£o exata  dos  dados  no  disco,  e  detalhes  de  hardware sobre codifica√ß√£o do armazenamento, posicionamento, compacta√ß√£o, divis√£o, mesclagem de registros, e

assim por diante, s√£o ocultados do usu√°rio. As demais aplica√ß√µes ignoram esses detalhes. Por sua vez, a independ√™ncia l√≥gica de dados √© mais dif√≠cil de ser alcan√ßada porque permite altera√ß√µes estruturais e de restri√ß√£o sem afetar os programas de aplica√ß√£o - um requisito muito mais estrito.

Sempre que temos um SGBD de m√∫ltiplos n√≠veis, seu cat√°logo deve ser expandido para incluir informa√ß√µes sobre como mapear solicita√ß√µes e dados entre os diversos n√≠veis. O SGBD usa software adicional para realizar  esses  mapeamentos,  recorrendo  √†  informa√ß√£o de mapeamento no cat√°logo. A independ√™ncia de dados ocorre porque, quando o esquema √© alterado em algum n√≠vel, o esquema no pr√≥ximo n√≠vel mais alto  permanece inalterado; somente o mapeamento entre os dois n√≠veis √© alterado. Logo, os programas de aplica√ß√£o que fazem refer√™ncia ao esquema de n√≠vel mais alto n√£o precisam ser alterados.

A arquitetura de tr√™s esquemas pode tornar mais f√°cil  obter  a  verdadeira  independ√™ncia  de  dados, tanto f√≠sica quanto l√≥gica. Por√©m, os dois n√≠veis de mapeamentos criam uma sobrecarga durante a compila√ß√£o ou execu√ß√£o de uma consulta ou programa, levando a baixa efici√™ncia do SGBD. Por causa disso, poucos  SGBDs  implementaram  a  arquitetura  completa de tr√™s esquemas.

## 2.3 Linguagens e interfaces do banco de dados

Na Se√ß√£o 1.4, discutimos a variedade de usu√°rios  atendidos  por  um  SGBD.  O  sistema  precisa oferecer  linguagens  e  interfaces  apropriadas  para cada categoria de usu√°rio. Nesta se√ß√£o, discutimos os  tipos  de  linguagens  e  interfaces  oferecidas  por um SGBD e as categorias de usu√°rio alvo de cada interface.

## 2.3.1 Linguagens do SGBD

Quando o projeto de um banco de dados √© finalizado e um SGBD √© escolhido para implement√°-lo, o primeiro passo √© especificar esquemas conceituais e  internos  para  o  banco  de  dados  e  quaisquer  mapeamentos entre  os  dois.  Em  muitos  SGBDs,  onde n√£o √© mantida nenhuma separa√ß√£o estrita de n√≠veis, uma linguagem, chamada linguagem de defini√ß√£o de dados ( DDL - Data Definition Language), √© usada pelo DBA e pelos projetistas de banco de dados para definir os dois esquemas. O SGBD ter√° um compilador da DDL cuja fun√ß√£o √© processar instru√ß√µes da DDL a fim de identificar as descri√ß√µes dos construtores de esquema e armazenar a descri√ß√£o de esquema no cat√°logo do SGBD.

Nos SGBDs que mant√™m uma separa√ß√£o clara entre os n√≠veis conceitual e interno, a DDL √© usada para  especificar  apenas  o  esquema  conceitual.  Outra  linguagem,  a linguagem  de  defini√ß√£o  de  armazenamento ( SDL -  Storage  Definition  Language), √©  utilizada  para  especificar  o  esquema  interno.  Os mapeamentos entre os dois esquemas podem ser especificados em qualquer uma dessas linguagens. Na maioria dos SGBDs relacionais, n√£o existe uma linguagem espec√≠fica que  realiza  o  papel  de  SDL.  Em vez disso, o esquema interno √© especificado por uma combina√ß√£o de fun√ß√µes, par√¢metros e especifica√ß√µes relacionadas ao armazenamento, que permitem aos DBAs controlar op√ß√µes de indexa√ß√£o e mapeamentos dos dados que ser√£o armazenados. Para uma verdadeira arquitetura de tr√™s esquemas, precisar√≠amos de uma terceira linguagem, a linguagem de defini√ß√£o de vis√£o ( VDL - View Definition Language), para especificar  vis√µes  do  usu√°rio  e  seus  mapeamentos  ao esquema  conceitual,  mas  na  maioria  dos  SGBDs a DDL √© usada para definir tanto o esquema conceitual como o externo . Nos SGBDs relacionais, a SQL √© usada pela VDL para definir vis√µes do usu√°rio ou da aplica√ß√£o como resultados de consultas predefinidas (ver cap√≠tulos 4 e 5).

Quando os esquemas s√£o compilados e o banco  de  dados  √©  populado,  os  usu√°rios  precisam  de alguma forma de manipul√°-lo. As manipula√ß√µes t√≠picas incluem recupera√ß√£o, inser√ß√£o, exclus√£o e modifica√ß√£o dos dados. O SGBD oferece um conjunto de  opera√ß√µes  ou  uma  linguagem  chamada linguagem  de manipula√ß√£o de dados  DML ( - Data Manipulation Language) para essas finalidades.

Nos SGBDs atuais, esses tipos de linguagens normalmente n√£o s√£o considerados linguagens distintas ; ao contr√°rio, uma linguagem integrada e abrangente √© usada na defini√ß√£o do esquema conceitual, defini√ß√£o de vis√£o e manipula√ß√£o de dados. A defini√ß√£o do armazenamento, em geral, √© mantida em separado, pois serve para definir estruturas de armazenamento f√≠sicas, para ajustar o desempenho do sistema de banco de dados, o que √© normalmente feito pelos DBAs. Um exemplo t√≠pico de linguagem de banco de dados abrangente √© a linguagem de banco de dados relacional SQL (ver cap√≠tulos 4 e 5), que representa uma combina√ß√£o  de  DDL,  VDL  e  DML,  bem  como  as instru√ß√µes para especifica√ß√£o de restri√ß√£o, evolu√ß√£o de esquema e outros recursos. A SDL era um componente nas primeiras vers√µes da SQL, mas foi removida da linguagem para mant√™-la apenas nos n√≠veis conceitual e externo.

Existem dois tipos de DMLs. Uma DML de alto n√≠vel ou n√£o procedural pode ser utilizada para espe-

cificar opera√ß√µes de banco de dados complexas de forma concisa. Muitos SGBDs permitem que instru√ß√µes DML de alto n√≠vel sejam inseridas  interativamente em um monitor ou terminal ou sejam embutidas em uma linguagem de programa√ß√£o de uso geral. Nesse √∫ltimo caso, as instru√ß√µes DML precisam ser identificadas dentro do programa, de modo que possam ser extra√≠das por um pr√©-compilador e processadas por um SGBD. Uma DML de baixo n√≠vel ou procedural deve ser embutida em uma linguagem de programa√ß√£o de uso geral. Esse tipo de DML, em geral, recupera registros individuais ou objetos do banco de dados e processa cada um deles separadamente. Portanto, precisa  de  constru√ß√µes  de  linguagem  de  programa√ß√£o, como o looping, para recuperar e processar cada registro de um conjunto de registros. DMLs de baixo n√≠vel tamb√©m s√£o chamadas de DMLs que tratam um registro de cada vez , devido a essa propriedade. A DL/1, uma DML projetada para o modelo hier√°rquico, √© uma DML de baixo n√≠vel que emprega comandos como GET UNIQUE , GET NEXT ou GET NEXT WITHIN PARENT para navegar de um registro para outro em uma hierarquia de registros no banco de dados. As DMLs de alto n√≠vel, como a SQL, podem especificar e recuperar muitos registros em uma √∫nica instru√ß√£o DML; portanto, elas s√£o chamadas de DMLs de um conjunto de cada vez ou orientadas a conjunto . Uma consulta  em  uma  DML  de  alto  n√≠vel  normalmente especifica quais dados  recuperar,  em  vez  de como recuper√°-los; portanto, essas linguagens tamb√©m s√£o chamadas declarativas .

Sempre que comandos DML, sejam eles de alto ou de baixo n√≠vel, s√£o incorporados em uma linguagem de programa√ß√£o de uso geral, ela √© chamada de linguagem hospedeira e a DML √© chamada de sublinguagem de dados . 10 Por sua vez, uma DML de alto n√≠vel  usada  em  uma  maneira  interativa  √©  chamada linguagem de consulta .  Em  geral,  comandos  de  recupera√ß√£o e atualiza√ß√£o de uma DML de alto n√≠vel podem ser usados de maneira interativa e, portanto, s√£o considerados parte da linguagem de consulta. 11

Usu√°rios finais casuais costumam usar uma linguagem  de  consulta  de  alto  n√≠vel  para  especificar suas solicita√ß√µes, enquanto os programadores usam a DML em sua forma embutida. Para usu√°rios comuns e param√©tricos, normalmente existem interfaces amig√°veis ao usu√°rio para interagir com o banco de dados; estas tamb√©m podem ser usadas por usu√°rios casuais ou outros que n√£o querem aprender os detalhes de uma linguagem de consulta de alto n√≠vel. Discutiremos esses tipos de interfaces a seguir.

## 2.3.2 Interfaces de SGBD

As  interfaces  amig√°veis  ao  usu√°rio  oferecidas por um SGBD podem incluir:

Interfaces  baseadas  em  menu  para  clientes Web ou de navega√ß√£o. Essas interfaces apresentam ao  usu√°rio  uma  lista  de  op√ß√µes  (chamadas menus ) que acompanham o usu√°rio na formula√ß√£o de uma solicita√ß√£o. Os menus acabam com a necessidade de memorizar os comandos espec√≠ficos e a sintaxe de uma linguagem  de  consulta;  em  vez  disso,  a  consulta  √© composta passo a passo ao escolher op√ß√µes de um menu  que  √©  exibido  pelo  sistema.  Os  menus  pull-down s√£o uma t√©cnica muito popular nas interfaces  de  usu√°rio  baseadas  na  Web .  Eles  tamb√©m  s√£o usados com frequ√™ncia em interfaces de navega√ß√£o , que permitem a um usu√°rio examinar o conte√∫do de um banco de dados de uma maneira explorat√≥ria e desestruturada.

Interfaces baseadas em formul√°rio. Uma interface baseada em formul√°rio apresenta um formul√°rio para cada usu√°rio. Os usu√°rios podem preencher todas as entradas do formul√°rio para inserir novos dados ou preencher apenas certas entradas, neste caso o SGBD recuperar√° os dados correspondentes para as entradas restantes. Os formul√°rios, normalmente, s√£o projetados e programados para usu√°rios finais como interfaces  para  transa√ß√µes  j√°  programadas.  Muitos SGBDs possuem linguagens de especifica√ß√£o de formul√°rios , que s√£o linguagens especiais que ajudam os programadores a especificar tais formul√°rios. A SQL*Forms √©  uma  linguagem  baseada  em  formul√°rio  que  especifica consultas usando um formul√°rio projetado em conjunto com o esquema de banco de dados relacional. O Oracle Forms √© um componente do pacote de produtos da Oracle que oferece um extenso conjunto de recursos para projetar e montar aplica√ß√µes usando formul√°rios. Alguns sistemas possuem utilit√°rios para definir um formul√°rio, permitindo que o usu√°rio final construa  interativamente  um  formul√°rio  de  amostra na tela.

Interfaces gr√°ficas com o usu√°rio. Uma GUI normalmente apresenta um esquema para o usu√°rio em formato de diagrama. O usu√°rio pode ent√£o especificar uma consulta manipulando o diagrama. Em

10 Em bancos de dados de objeto, as sublinguagens hospedeiras e de dados formam uma linguagem integrada - por exemplo, C++ com algumas extens√µes, para dar suporte √† funcionalidade de banco de dados. Alguns sistemas relacionais tamb√©m oferecem linguagens integradas - por exemplo, a PL/SQL do Oracle.

11 De acordo com seu significado em ingl√™s, a palavra consulta  query ( ), na realidade, deveria ser usada para descrever apenas leituras, e n√£o atualiza√ß√µes.

muitos casos, as GUIs utilizam menus e formul√°rios. A maioria delas utiliza um dispositivo de apontamento , como um mouse, para selecionar certas partes do diagrama de esquema apresentado.

Interfaces de linguagem natural. Essas interfaces aceitam solicita√ß√µes escritas em ingl√™s, ou em outro idioma, e tentam entend√™-las .  Uma interface de linguagem natural costuma ter o pr√≥prio esquema , que √© semelhante ao esquema conceitual do banco de dados, bem como um dicion√°rio  de  palavras  importantes.  Essa  interface recorre √†s palavras em seu esquema, bem como ao conjunto de palavras-padr√£o em seu dicion√°rio, para interpretar a solicita√ß√£o. Se a interpreta√ß√£o for bem-sucedida, a interface gera uma consulta de alto n√≠vel correspondente √† solicita√ß√£o de linguagem natural e a submete ao SGBD para processamento; caso contr√°rio, um di√°logo √© iniciado com o usu√°rio para esclarecer a solicita√ß√£o. As funcionalidades das interfaces de linguagem natural n√£o t√™m avan√ßado rapidamente. Hoje, vemos mecanismos de busca que aceitam sequ√™ncias de palavras de linguagem natural (como ingl√™s) e as combinam com documentos em sites espec√≠ficos (para mecanismos de busca locais) ou p√°ginas na Web em geral (para mecanismos como Google ou Ask). Eles utilizam √≠ndices pr√©-definidos sobre palavras e fun√ß√µes de pontua√ß√£o (ranking) para recuperar e apresentar documentos resultantes em um grau decrescente de combina√ß√£o. Essas interfaces de consulta textual 'em forma livre' ainda n√£o s√£o comuns nos bancos de dados de modelo relacional estruturado ou legado, embora uma √°rea de pesquisa chamada consulta baseada em palavra-chave tenha  surgido  recentemente  para  os bancos de dados relacionais.

Entrada e sa√≠da de voz. O uso limitado da voz como  entrada  para  uma  consulta  e  como  resposta para uma pergunta ou resultado de uma solicita√ß√£o est√° se tornando comum. Aplica√ß√µes com vocabul√°rios limitados, como consultas do cat√°logo telef√¥nico, chegada/sa√≠da de voo e informa√ß√µes de conta de cart√£o de cr√©dito, est√£o permitindo que a voz, para entrada e sa√≠da, facilite o acesso a essas informa√ß√µes pelos clientes. A entrada de voz √© detectada usando uma  biblioteca  de  palavras  predefinidas  e  usadas para  configurar  os  par√¢metros  fornecidos  para  as consultas. Para a sa√≠da, acontece uma convers√£o semelhante de texto ou de n√∫meros para voz.

Interfaces  para  usu√°rios  param√©tricos. Os usu√°rios param√©tricos, como caixas de banco, em geral possuem um pequeno conjunto de opera√ß√µes que precisam  realizar  repetidamente.  Por  exemplo,  um caixa pode usar teclas de fun√ß√£o isoladas para fazer transa√ß√µes de rotina e repetitivas, como dep√≥sitos em conta ou saques, ou consultas de saldo. Os analistas de sistemas e programadores projetam e implemen- tam uma interface especial para cada classe conhecida de usu√°rios finais. Normalmente, um pequeno conjunto de comandos abreviados √© inclu√≠do, com o objetivo de minimizar o n√∫mero de toques de teclas exigidos para cada solicita√ß√£o. Por exemplo, as teclas de fun√ß√£o em um terminal podem ser programadas para iniciar diversos comandos. Isso permite que o usu√°rio param√©trico prossiga com um n√∫mero m√≠nimo de toques de teclas.

Interfaces para o DBA. A maioria dos sistemas de banco de dados cont√©m comandos privilegiados que  podem  ser  usados  apenas  pelos  DBAs.  Estes incluem  comandos  para  criar  contas,  definir  par√¢metros  do  sistema,  conceder  autoriza√ß√£o  de  conta, alterar  um  esquema  e  reorganizar  as  estruturas  de armazenamento de um banco de dados.

## 2.4 O ambiente do sistema de banco de dados

Um SGBD √© um sistema de software complexo. Nesta se√ß√£o, vamos discutir os tipos de componentes de software que constituem um SGBD e os tipos de software de sistemas de computa√ß√£o com os quais ele interage.

## 2.4.1 M√≥dulos componentes do SGBD

A Figura 2.3 ilustra,  de  uma  forma  simplificada, os componentes t√≠picos do SGBD. A figura est√° dividida em duas partes. A parte superior refere-se aos v√°rios usu√°rios do ambiente de banco de dados e suas interfaces. A parte inferior mostra os detalhes internos do SGBD, respons√°veis pelo armazenamento de dados e processamento de transa√ß√µes.

O banco de dados e o cat√°logo do SGBD, habitualmente, s√£o armazenados em disco. O acesso ao disco √© controlado, em especial, pelo sistema operacional (SO) , que escalona a leitura/escrita em disco. Muitos SGBDs possuem o pr√≥prio m√≥dulo de gerenciamento de buffer para planejar a leitura/escrita em disco, pois isso tem um efeito consider√°vel sobre o desempenho. A redu√ß√£o da leitura/escrita em disco melhora o desempenho de maneira consider√°vel. Um m√≥dulo gerenciador de dados armazenados controla o acesso √†s informa√ß√µes do SGBD que s√£o armazenadas em disco, n√£o importando se elas fazem parte do banco de dados ou do cat√°logo.

Primeiramente,  vamos  considerar  a  parte  superior da Figura 2.3. Ela mostra as interfaces para DBAs, usu√°rios casuais que trabalham com interfaces interativas para formular consultas, programadores de aplica√ß√£o que criam programas usando algumas linguagens  de  programa√ß√£o  hospedeira,  e  usu√°rios

Figura 2.3 M√≥dulos componentes de um SGBD e suas intera√ß√µes.



param√©tricos que realizam a entrada dos dados fornecendo  par√¢metros  para  transa√ß√µes  predefinidas. Os DBAs definem o banco de dados e realizam ajustes, alterando sua defini√ß√£o por meio da DDL e de outros comandos privilegiados.

O compilador da DDL processa as defini√ß√µes de esquema especificadas e armazena as descri√ß√µes dos esquemas (metadados) no cat√°logo do SGBD. O cat√°logo inclui informa√ß√µes como os nomes e os tamanhos dos arquivos, nomes e tipos de dados dos itens de dados, detalhes de armazenamento de cada arquivo, informa√ß√µes de mapeamento entre esquemas e restri√ß√µes. Al√©m disso, o cat√°logo armazena muitos outros tipos de informa√ß√µes essenciais para os m√≥dulos do SGBD, que podem, ent√£o, utilizar as informa√ß√µes do cat√°logo, conforme a necessidade.

Usu√°rios casuais do banco de dados interagem usando  alguma  forma  de  interface,  que  chamamos de interface de consulta interativa, na Figura 2.3. N√£o mostramos explicitamente qualquer intera√ß√£o baseada em menu ou baseada em formul√°rio que possa ser usada para gerar a consulta interativa de maneira autom√°tica. Essas consultas s√£o analisadas e validadas pela exatid√£o da sintaxe da consulta, os nomes de arquivos e elementos de dados, e assim por diante, por um compilador de consulta , que as compila para um formato interno. Essa consulta interna est√° sujeita √† otimiza√ß√£o de consultas (discutida nos cap√≠tulos 19 e 20). Entre outras coisas, o otimizador de consulta preocupa-se com o rearranjo e a poss√≠vel reordena√ß√£o de opera√ß√µes, com a elimina√ß√£o de redund√¢ncias e uso dos algoritmos e √≠ndices corretos durante a execu√ß√£o. Ele consulta o cat√°logo do sistema em busca de informa√ß√µes estat√≠sticas e outras informa√ß√µes f√≠sicas sobre os dados armazenados, gerando um c√≥digo execut√°vel que realiza as opera√ß√µes necess√°rias para

a consulta e faz chamadas ao processador em tempo de execu√ß√£o.

Os  programadores  de  aplica√ß√£o  escrevem  programas em linguagens hospedeiras, como Java, C ou C++, que s√£o submetidas a um pr√©-compilador. O pr√©-compilador extrai comandos DML do programa de aplica√ß√£o escrito em uma linguagem de programa√ß√£o hospedeira. Esses comandos s√£o enviados ao compilador DML para serem compilados em c√≥digo objeto para o acesso ao banco de dados. O restante do programa √© enviado ao compilador da linguagem hospedeira.  Os  c√≥digos  objeto  para  os  comandos DML e o restante do programa s√£o ligados ('linkados'), formando uma transa√ß√£o programada, cujo c√≥digo execut√°vel inclui chamadas para o processador de banco de dados em tempo de execu√ß√£o. As transa√ß√µes programadas s√£o executadas repetidamente pelos usu√°rios param√©tricos, que apenas fornecem os par√¢metros para as transa√ß√µes. Cada execu√ß√£o √© considerada uma transa√ß√£o separada. Um exemplo √© uma transa√ß√£o de saque banc√°rio, no qual o n√∫mero da conta e o valor podem ser fornecidos como par√¢metros.

Na parte inferior da Figura 2.3, o processador de banco de dados em tempo de execu√ß√£o executa (1) os comandos privilegiados, (2) os planos de consulta execut√°veis e (3) as transa√ß√µes programadas  com  par√¢metros  em  tempo  de  execu√ß√£o.  Ele trabalha com o cat√°logo do sistema e  pode atualiz√°-lo  com  estat√≠sticas.  Tamb√©m  trabalha  com  o gerenciador de dados armazenados ,  que,  por  sua vez,  utiliza  os  servi√ßos  b√°sicos  do  sistema  operacional  para  executar  opera√ß√µes  de  entrada/sa√≠da (leitura/escrita) de baixo n√≠vel entre o disco e a mem√≥ria principal. O processador de banco de dados em tempo de execu√ß√£o cuida de outros aspectos da transfer√™ncia de dados, como o gerenciamento de buffers na mem√≥ria principal. Alguns SGBDs t√™m o pr√≥prio m√≥dulo de gerenciamento de buffer, enquanto outros dependem do SO para faz√™-lo. Mostramos os sistemas de controle de concorr√™ncia e backup  e  recupera√ß√£o separadamente  como  um m√≥dulo nessa figura. Eles s√£o integrados ao processador de banco de dados em tempo de execu√ß√£o para fins de gerenciamento de transa√ß√£o.

Agora, √© comum que o programa cliente acesse o SGBD executando em um computador separado do computador em que o banco de dados reside. O primeiro  √©  chamado computador cliente ,  que  executa um software cliente do SGBD, e o segundo √© chamado servidor de banco de dados . Em alguns casos, o cliente acessa um computador intermedi√°rio, conhecido como servidor de aplica√ß√µes , que, por sua vez, acessa o servidor de banco de dados. Abordaremos melhor esse assunto na Se√ß√£o 2.5.

A Figura 2.3 n√£o pretende descrever um SGBD espec√≠fico; ao contr√°rio, ela ilustra os m√≥dulos b√°sicos de SGBD. O SGBD interage com o sistema operacional quando os acessos ao disco - ao banco de dados ou ao cat√°logo - s√£o necess√°rios. Se o computador for compartilhado por muitos usu√°rios, o SO escalonar√° as solicita√ß√µes de acesso ao disco do SGBD e o processamento do SGBD juntamente com outros processos. Al√©m disso, se o computador estiver, principalmente, dedicado a executar o servidor de banco de  dados,  o  SGBD  controlar√°  a  mem√≥ria  principal buferizando das p√°ginas do disco. O sistema tamb√©m realiza  a  interface  com  compiladores  das  linguagens de programa√ß√£o hospedeiras de uso geral, e com os servidores de aplica√ß√£o e programas cliente rodando em m√°quinas separadas, por meio da interface de rede do sistema.

## 2.4.2 Utilit√°rios do sistema de banco de dados

Al√©m dos componentes de software que descrevemos,  a  maioria  dos  SGBDs  possui utilit√°rios  de banco de dados que ajudam o DBA a gerenciar o sistema.  Os  utilit√°rios  t√™m,  basicamente,  os  seguintes tipos de fun√ß√µes:

- ¬Ñ Carga. Um utilit√°rio de carga √© usado para carregar os arquivos de dados existentes - como arquivos de texto ou arquivos sequenciais no banco de dados. Normalmente o formato atual do arquivo de dado (origem) e a estrutura do arquivo do banco de dados desejado (destino) s√£o especificados pelo utilit√°rio que reformata automaticamente os dados e os armazena no banco de dados. Com a prolifera√ß√£o de SGBDs, a transfer√™ncia de dados de um SGBD para outro est√° se tornando comum em muitas organiza√ß√µes. Alguns fornecedores de SGBDs est√£o oferecendo produtos que geram os programas de carga apropriados, tendo como base descri√ß√µes de armazenamento de banco de dados de origem e destino (esquemas internos). Essas  ferramentas  tamb√©m  s√£o  chamadas  de ferramentas de convers√£o .  Para  o  SGBD hier√°rquico chamado IMS (da IBM) e para muitos SGBDs de rede, incluindo o IDMS (da Computer Associates), SUPRA (da Cincom) e Image  (da  HP),  os  fornecedores  ou  empresas  de terceiros  est√£o  disponibilizando  uma  s√©rie  de ferramentas de convers√£o (por exemplo, o SUPRA Server SQL da Cincom) para transformar os dados para o modelo relacional.
- ¬Ñ Backup. Um  utilit√°rio  de  backup  cria  uma c√≥pia de seguran√ßa do banco de dados, nor-

malmente copiando o banco de dados inteiro para  fita  ou  outro  meio  de  armazenamento em  massa.  A  c√≥pia  backup  pode  ser  usada para restaurar o banco de dados no caso de uma falha catastr√≥fica no disco. Os backups incrementais  tamb√©m  costumam  ser  utilizados,  e  registram  apenas  as  mudan√ßas  ocorridas ap√≥s o backup anterior. O backup incremental √© mais complexo, mas economiza espa√ßo de armazenamento.

- ¬Ñ Reorganiza√ß√£o do armazenamento do banco de dados. Esse utilit√°rio pode ser usado para reorganizar um conjunto de arquivos do banco de dados em diferentes organiza√ß√µes de arquivo, e cria novos caminhos de acesso para melhorar o desempenho.
- ¬Ñ Monitora√ß√£o de desempenho. Esse utilit√°rio monitora o uso do banco de dados e oferece estat√≠sticas ao DBA. O DBA usa as estat√≠sticas para tomar decis√µes se deve ou n√£o reorganizar arquivos ou se deve incluir ou remover √≠ndices para melhorar o desempenho.

Podem estar dispon√≠veis outros utilit√°rios  para classificar arquivos, tratar da compacta√ß√£o de dados, monitorar o acesso pelos usu√°rios, realizar a interface com a rede e desempenhar outras fun√ß√µes.

## 2.4.3 erramentas, ambientes de aplica√ß√£o F e facilidades de comunica√ß√µes

Outras ferramentas est√£o frequentemente dispon√≠veis  aos  projetistas  de  bancos  de  dados,  usu√°rios e ao SGBD. Ferramentas CASE 12  s√£o usadas na fase de  projeto  dos  sistemas  de  banco  de  dados.  Outra ferramenta que pode ser muito √∫til em grandes organiza√ß√µes √© um sistema de dicion√°rio de dados (ou de reposit√≥rio de dados ) expandido. Al√©m de armazenar informa√ß√µes de cat√°logo sobre esquemas e restri√ß√µes, o dicion√°rio de dados armazena decis√µes do projeto, padr√µes  de  uso,  descri√ß√µes  de  programa  de  aplica√ß√£o e informa√ß√µes do usu√°rio. Esse sistema tamb√©m √© chamado de reposit√≥rio de informa√ß√£o . Essa informa√ß√£o pode ser acessada diretamente pelos usu√°rios ou  pelo  DBA,  quando  necess√°rio.  Um  utilit√°rio  de dicion√°rio  de  dados  √©  semelhante  ao  cat√°logo  do SGBD, mas inclui uma variedade maior de informa√ß√µes e √© acessado principalmente pelos usu√°rios, em vez de ser acessada pelo software de SGBD.

um ambiente para desenvolver aplica√ß√µes de banco de dados e incluem facilidades que ajudam em muitas facetas dos sistemas, incluindo projeto de banco de dados, desenvolvimento GUI, consulta e atualiza√ß√£o, e desenvolvimento de programas de aplica√ß√£o.

- O  SGBD  tamb√©m  precisa  realizar  a  interface com o software de comunica√ß√µes , cuja fun√ß√£o √© permitir que os usu√°rios em locais remotos do sistema de  banco  de  dados  acessem  o  banco  de  dados  por meio de terminais de computador, esta√ß√µes de trabalho ou computadores pessoais. Estes s√£o conectados ao local do banco de dados por meio de hardware de comunica√ß√µes de dados, como roteadores da Internet, linhas telef√¥nicas, redes de longa dist√¢ncia, redes locais  ou  dispositivos  de  comunica√ß√£o  por  sat√©lite. Muitos sistemas de banco de dados do mercado possuem pacotes de comunica√ß√£o que trabalham com o SGBD. O sistema integrado de SGBD e comunica√ß√µes de dados √© chamado de sistema DB/DC . Al√©m disso,  alguns  SGBDs  est√£o  fisicamente  distribu√≠dos em v√°rias m√°quinas. Nesse caso, redes de comunica√ß√µes  s√£o  necess√°rias  para  conectar  as  m√°quinas. Estas, com frequ√™ncia, s√£o redes locais  LANs ( - Local Area Networks), mas tamb√©m podem ser outros tipos de redes.

## 2.5 Arquiteturas centralizadas e cliente/servidor para SGBDs

## 2.5.1 Arquitetura de SGBDs centralizada

As arquiteturas para SGBDs t√™m seguido tend√™ncias semelhantes √†quelas dos sistemas de computa√ß√£o em geral. As arquiteturas anteriores usavam computadores  mainframe  para  oferecer  o  processamento principal para todas as fun√ß√µes do sistema, incluindo programas de aplica√ß√£o do usu√°rio e programas de interface  com  o  usu√°rio,  bem  como  toda  a  funcionalidade do SGBD. O motivo √© que a maioria dos usu√°rios acessava tais sistemas por terminais de computador, que n√£o tinham poder de processamento e apenas ofereciam capacidades de exibi√ß√£o. Portanto, todo o processamento era realizado remotamente no computador central, e somente informa√ß√µes de exibi√ß√£o e controles eram enviados do computador para os terminais de v√≠deo, que eram conectados ao computador central por meio de v√°rios tipos de redes de comunica√ß√µes.

Ambientes  de  desenvolvimento  de  aplica√ß√£o , como o PowerBuilder (Sybase) ou o JBuilder (Borland), s√£o muito populares. Esses sistemas oferecem

√Ä medida que os pre√ßos do hardware ca√≠ram, a maioria dos usu√°rios substituiu seus terminais com PCs  e  esta√ß√µes  de  trabalho.  No  in√≠cio,  os  sistemas

12 Embora CASE signifique engenharia de software auxiliada por computador, muitas de suas ferramentas s√£o usadas, principalmente, para o projeto de banco de dados.

Figura 2.4 Uma arquitetura f√≠sica centralizada.



de  banco  de  dados  usavam  esses  computadores  de modo semelhante √† forma que usavam terminais de v√≠deo, de maneira que o SGBD em si ainda era um SGBD centralizado , em que toda sua funcionalidade, execu√ß√£o de programas de aplica√ß√£o e processamento de interface do usu√°rio eram executados em uma m√°quina. A Figura 2.4 ilustra os componentes f√≠sicos em uma arquitetura centralizada. Gradualmente, os sistemas de SGBD come√ßaram a explorar o poder de processamento dispon√≠vel no lado do usu√°rio, o que levou √†s arquiteturas de SGBD cliente/servidor.

## 2.5.2 Arquiteturas cliente/servidor b√°sicas

Primeiro,  vamos  discutir  a  arquitetura  cliente/servidor  em  geral,  e  depois  veremos  como  ela se  aplica  aos  SGBDs.  A arquitetura  cliente/servidor foi desenvolvida para lidar com ambientes de computa√ß√£o  em  que  um  grande  n√∫mero  de  PCs, esta√ß√µes  de  trabalho,  servidores  de  arquivos,  impressoras, servidores de banco de dados, servidores  Web,  servidores  de  correio  (e-mail)  e  outros softwares e equipamentos s√£o conectados por uma rede.  A  ideia  √©  definir servidores  especializados com  funcionalidades  espec√≠ficas.  Por  exemplo,  √© poss√≠vel  conectar  uma  s√©rie  de  PCs  ou  pequenas esta√ß√µes de trabalho como clientes a um servidor de arquivos que mant√©m os arquivos das m√°quinas clientes. Outra m√°quina pode ser designada como servidor  de  impress√£o ,  sendo  conectada  a  v√°rias impressoras; todas as solicita√ß√µes de impress√£o pelos clientes s√£o encaminhadas a essa m√°quina. Os servidores Web ou servidores de correio tamb√©m se encontram na categoria de servidor especializado. Os recursos fornecidos pelos servidores especializados podem ser acessados por muitas m√°quinas cliente.  As m√°quinas cliente oferecem  ao  usu√°rio as  interfaces  apropriadas  para  utilizar  esses  servidores, bem como poder de processamento local para executar aplica√ß√µes locais. Esse conceito pode ser transportado para outros pacotes de software, com  programas  especializados  -  como  o  CAD (Computer-Aided  Design)  -  sendo  armazenados em m√°quinas servidoras espec√≠ficas e acess√≠veis  a m√∫ltiplos clientes. A Figura 2.5 ilustra a arquitetura cliente/servidor no n√≠vel l√≥gico; a Figura 2.6 √© um diagrama simplificado que mostra a arquitetura f√≠sica. Algumas m√°quinas seriam apenas locais do cliente (por exemplo, esta√ß√µes de trabalho sem disco ou esta√ß√µes de trabalho/PCs com discos, que t√™m apenas software cliente instalado). Outras m√°quinas seriam servidores dedicados, e outras ainda teriam funcionalidade de cliente e servidor.

Figura 2.5 Arquitetura cliente/servidor l√≥gica em duas camadas.



Figura 2.6 Arquitetura cliente/servidor f√≠sica em duas camadas.



O conceito de arquitetura cliente/servidor assume uma estrutura b√°sica composta por muitos PCs e esta√ß√µes de trabalho, al√©m de um n√∫mero menor de m√°quinas de grande porte (mainframes), conectados por LANs e outros tipos de redes de computadores. Um cliente nessa estrutura normalmente √© uma m√°quina que oferece capacidades de interface com o usu√°rio e processamento local. Quando um cliente requer acesso a alguma funcionalidade adicional  -  como acesso ao banco de dados - que n√£o existe nessa m√°quina, ele se conecta a um servidor que oferece a funcionalidade necess√°ria. Um servidor √© um sistema com hardware e software que pode  oferecer  servi√ßos  √†s  m√°quinas  cliente,  como acesso a arquivo, impress√£o, arquivamento ou acesso a banco de dados. Em geral, algumas m√°quinas t√™m  instalados  apenas  softwares  cliente,  outras, apenas software servidor, e ainda outras podem incluir software cliente e servidor, conforme ilustrado na Figura 2.6. Por√©m, √© mais comum que o software cliente  e  servidor  seja  executado  em  m√°quinas  separadas.  Dois  tipos  principais  de  arquiteturas  de SGBD foram criados  nessa  estrutura  cliente/servidor b√°sica: duas camadas e tr√™s camadas . 13 Vamos explicar esses dois tipos a seguir.

## 2.5.3 Arquiteturas cliente/servidor de duas camadas para SGBDs

Em sistemas de gerenciamento de banco de dados relacional (SGBDRs), muitos dos quais come√ßaram como sistemas centralizados, os componentes do sistema movidos inicialmente para o lado do cliente foram a interface com o usu√°rio e os programas de aplica√ß√£o. Como a SQL (ver cap√≠tulos 4 e 5) fornecia uma linguagem-padr√£o para os SGBDRs, isso criou um ponto de divis√£o l√≥gico entre cliente e servidor. Assim, as funcionalidades de consulta e de transa√ß√£o relacionadas ao processamento da SQL permaneceram no lado do servidor. Em tal arquitetura, o servidor frequentemente √© chamado servidor de consulta ou servidor de transa√ß√£o , pois oferece essas duas funcionalidades. Em um SGBDR, o servidor tamb√©m √© chamado de servidor SQL .

Os  programas  da  interface  com  o  usu√°rio  e os  programas  de  aplica√ß√£o  podem  ser  executados no lado do cliente. Quando √© necess√°rio acessar o SGBD,  o  programa  estabelece  uma  conex√£o  com o SGBD (que est√° no lado do servidor); quando a conex√£o √© criada, o programa cliente pode se comunicar  com  o  SGBD.  Um  padr√£o  denominado Conectividade de Banco de Dados Aberta (ODBC Open Database Connectivity  oferece uma ) interface de programa√ß√£o de aplica√ß√µes (API - Application Programming Interface , que permite que os progra-) mas do cliente chamem o SGBD, desde que as m√°quinas cliente e servidor tenham o software necess√°rio instalado. A maioria dos vendedores de SGBD oferece drivers ODBC para seus sistemas. Um programa cliente pode se conectar a v√°rios SGBDRs e enviar solicita√ß√µes de consulta e transa√ß√£o usando a API da ODBC, que s√£o processadas nos servidores. Quaisquer resultados de consulta s√£o enviados de  volta  ao  programa  cliente,  que  pode  processar e exibir os resultados conforme a necessidade. Foi definido  tamb√©m um padr√£o para a linguagem de programa√ß√£o  Java,  chamado JDBC .  Isso  permite que programas cliente em Java acessem um ou mais SGBDs por meio de uma interface-padr√£o.

A abordagem diferente para a arquitetura cliente/servidor em duas camadas foi seguida por alguns SGBDs orientados a objeto, em que os m√≥dulos de software  do  sistema  foram  divididos  entre  cliente  e  servidor  de  uma  maneira  mais  integrada.  Por exemplo, o n√≠vel do servidor pode incluir a parte do software do SGBD respons√°vel por tratar do armazenamento de dados nas p√°ginas do disco, controle  de  concorr√™ncia local e recupera√ß√£o, buffering e caching  de  p√°ginas  do  disco,  e  outras  fun√ß√µes  semelhantes.  Enquanto  isso,  o n√≠vel  do  cliente pode tratar da interface com o usu√°rio; fun√ß√µes de dicion√°rio de dados; intera√ß√µes do SGBD com os compiladores  da  linguagem  de  programa√ß√£o;  otimiza√ß√£o global  da  consulta,  controle  de  concorr√™ncia  e  recupera√ß√£o  entre  v√°rios  servidores;  estrutura√ß√£o  de objetos complexos com base nos dados dos buffers; e  outras fun√ß√µes semelhantes. Nessa abordagem, a intera√ß√£o cliente/servidor √© mais acoplada e √© feita internamente pelos m√≥dulos de SGBD - alguns dos quais residem no cliente e alguns no servidor -, e n√£o pelos usu√°rios/programadores. A divis√£o exata da funcionalidade pode variar de um sistema para outro.  Em  tal  arquitetura  cliente/servidor,  o  servidor  √©  chamado  de servidor  de  dados ,  pois  oferece dados organizados em p√°ginas de disco ao cliente. Esses dados podem ent√£o ser estruturados pelos programas clientes pelo software cliente do SGBD em objetos.

As arquiteturas descritas aqui s√£o chamadas arquiteturas de duas camadas porque os componentes de software s√£o distribu√≠dos por dois sistemas: cliente e servidor. As vantagens dessa arquitetura s√£o sua simplicidade e compatibilidade transparente com os sistemas existentes. O surgimento da Web mudou os pap√©is de clientes e servidores, levando √† arquitetura de tr√™s camadas.

13 Existem muitas outras varia√ß√µes de arquiteturas cliente/servidor. Discutiremos aqui as duas mais b√°sicas.

## 2.5.4 Arquiteturas de tr√™s camadas e n camadas para aplica√ß√µes Web

Muitas aplica√ß√µes Web utilizam uma arquitetura chamada arquitetura de tr√™s camadas , que acrescenta uma camada intermedi√°ria entre o cliente e o servidor de banco de dados, conforme ilustrado na Figura 2.7(a).

Essa camada intermedi√°ria √© chamada de servidor de aplica√ß√£o ou servidor  Web ,  dependendo da aplica√ß√£o. Esse servidor desempenha um papel intermedi√°rio pela execu√ß√£o de programas de aplica√ß√£o e armazenamento de regras de neg√≥cios (procedimentos ou restri√ß√µes), que s√£o usados para acessar os dados do servidor de banco de dados. Ela tamb√©m pode melhorar a seguran√ßa do banco de dados, verificando as credenciais de um cliente antes de encaminhar uma solicita√ß√£o ao servidor de banco de dados. Os clientes t√™m interfaces GUI e algumas regras de neg√≥cios adicionais, espec√≠ficas da aplica√ß√£o. O servidor intermedi√°rio aceita e processa solicita√ß√µes do cliente, e envia consultas e comandos do banco de dados ao servidor de banco de dados, e depois atua como um canal para passar (parcialmente) dados processados do servidor de banco de dados aos clientes, onde podem ainda ser processados e filtrados para serem apresentados aos usu√°rios no formato da GUI. Assim, a interface com o usu√°rio , as regras da aplica√ß√£o e o acesso aos dados atuam como tr√™s camadas. A Figura 2.7(b) mostra outra arquitetura usada pelos fornecedores de bancos de dados e de outras aplica√ß√µes. A camada de apresenta√ß√£o exibe informa√ß√µes ao usu√°rio e permite a entrada de dados. A camada de  l√≥gica  de  neg√≥cios  cuida  das  regras  e  restri√ß√µes

Figura 2.7



Arquitetura cliente/servidor l√≥gica de tr√™s camadas, com algumas nomenclaturas comumente utilizadas.

intermedi√°rias antes dos dados serem passados para o usu√°rio ou devolvidos ao SGBD. A camada inferior inclui todos os servi√ßos de gerenciamento de dados. A camada do meio tamb√©m pode atuar como um servidor Web, que recupera resultados das consultas do servidor de banco de dados e os formata para as p√°ginas Web din√¢micas, que s√£o vistas pelo navegador Web no lado do cliente.

Outras arquiteturas tamb√©m foram propostas. √â poss√≠vel dividir as camadas entre o usu√°rio e os dados armazenados em outros componentes mais detalhados, resultando, assim, em arquiteturas de n camadas, onde n pode ser quatro ou cinco camadas. Em geral, a camada da l√≥gica de neg√≥cios √© dividida em v√°rias camadas. Al√©m de distribuir a programa√ß√£o e os dados pela rede, as aplica√ß√µes de n camadas t√™m a vantagem de que qualquer camada poder ser executada em um processador  ou  plataforma  de  sistema  operacional adequado e ser tratada independentemente. Os fornecedores de pacotes de ERP (Enterprise Resource Planning) e CRM (Customer Relationship Management) costumam utilizar uma camada de middleware , que √© respons√°vel pelos m√≥dulos de front-end (clientes) que se comunicam com uma s√©rie de bancos de dados de back-end (servidores).

Os avan√ßos na tecnologia de criptografia tornam mais seguro transferir dados confidenciais em formato codificado do servidor ao cliente, onde ser√° decodificado.  Isso  pode  ser  feito  pelo  hardware  ou  por um software avan√ßado. Essa tecnologia oferece n√≠veis mais altos de seguran√ßa de dados, mas as quest√µes de seguran√ßa da rede continuam sendo uma preocupa√ß√£o constante. Diversas tecnologias de compacta√ß√£o de dados tamb√©m ajudam a transferir grande quantidade de dados dos servidores aos clientes por redes com e sem fio.

## 2.6 Classifica√ß√£o dos sistemas gerenciadores de banco de dados

V√°rios crit√©rios s√£o normalmente utilizados para classificar os SGBDs. O primeiro √© o modelo de dados no qual o SGBD √© baseado. O principal modelo de  dados  usado  atualmente  em  muitos  SGBDs  comercial √© o modelo de dados relacional .  O modelo de dados de objeto foi implementado em alguns sistemas comerciais, mas n√£o tem seu uso generalizado. Muitas aplica√ß√µes legadas ainda rodam em sistemas de banco de dados baseados nos modelos de dados hier√°rquico e  de rede .  Alguns  exemplos  de  SGBDs hier√°rquicos s√£o o IMS (da IBM) e alguns outros sistemas, como o System 2K (da SAS Inc.) e o TDMS.

O IMS ainda √© usado em instala√ß√µes do governo e industriais, incluindo hospitais e bancos, embora muitos de seus usu√°rios tenham passado para sistemas relacionais.  O  modelo  de  dados  de  rede  foi  usado por muitos fornecedores, e os produtos resultantes, como IDMs (da Cullinet - atualmente, Computer Associates),  DMS  1100  (da  Univac  -  atualmente, Unisys), IMAGE (da Hewlett-Packard), VAX-SGBD (da  Digital  -  depois  Compaq  e  atualmente  HP)  e SUPRA  (da  Cincom),  ainda  t√™m  seguidores  e  seus grupos de usu√°rios est√£o ativamente organizados. Se acrescentarmos a eles o popular sistema de arquivos VSAM da IBM, podemos facilmente dizer que uma porcentagem razo√°vel dos dados computadorizados do mundo inteiro ainda est√£o nesses chamados sistemas de banco de dados legados .

Os SGBDs relacionais est√£o evoluindo continuamente e, em particular, t√™m incorporado muitos dos conceitos que foram desenvolvidos nos bancos de dados de objeto. Isso tem levado a uma nova classe de SGBDs, chamada SGBDs objeto-relacionais .  Assim, podemos categorizar os SGBDs com base no modelo de dados: relacionais, objeto, objeto-relacional, hier√°rquico, rede, entre outros.

Mais  recentemente,  alguns  SGBDs  experimentais se baseiam no modelo XML (eXtended Markup Language), que √© um modelo de dados estruturado em √°rvore (hier√°rquico). Estes t√™m sido chamados de SGBDs XML nativos . V√°rios SGBDs relacionais comerciais acrescentaram interfaces e armazenamento XML a seus produtos.

O segundo crit√©rio usado para classificar SGBDs √© o n√∫mero de usu√°rios suportados pelo sistema. Sistemas monousu√°rio admitem apenas um usu√°rio de cada vez, e s√£o usados principalmente com PCs. Sistemas multiusu√°rio , que incluem a maioria dos SGBDs, admitem m√∫ltiplos usu√°rios simultaneamente.

O terceiro crit√©rio √© o n√∫mero de locais sobre os quais o banco de dados est√° distribu√≠do. Um SGBD √© centralizado se os dados estiverem armazenados em um √∫nico computador. Um SGBD centralizado pode atender a v√°rios usu√°rios, mas o SGBD e o banco de dados residem integralmente em um √∫nico computador. Um SGBD distribu√≠do (SGBDD) pode ter o banco de dados real e o software de SGBD distribu√≠dos por v√°rios locais, conectados por uma rede de computadores. Os SGBDDs homog√™neos usam o mesmo software de SGBD em todos os locais, ao passo que SGBDDs heterog√™neos podem usar um software de SGBD diferente em cada local. Tamb√©m √© poss√≠vel desenvolver software de middleware para acessar v√°rios bancos de dados aut√¥nomos pr√©-existentes, armazenados sob SGBDs heterog√™neos. Isso leva a um SGBD federado (ou sistema  multibanco  de  dados ), em que os sistemas participantes s√£o fracamente acoplados e possuem um certo grau de autonomia local. Muitos  SGBDDs  utilizam  arquitetura  cliente/servidor, conforme descrito na Se√ß√£o 2.5.

O quarto crit√©rio √© o custo. √â dif√≠cil propor uma classifica√ß√£o  dos  SGBDs  com  base  no  custo.  Hoje, temos  SGBDs  de  c√≥digo  aberto  (gratuito),  como MySQL e PostgreSQL, que t√™m suporte de fornecedores terceirizados com servi√ßos adicionais. Os principais SGBDRs est√£o dispon√≠veis em vers√µes gratuitas para testes durante 30 dias, al√©m de vers√µes pessoais, que podem custar menos de US$ 100 e permitir uma funcionalidade muito maior. Os sistemas gigantes est√£o sendo vendidos em formato modular, com componentes para lidar com distribui√ß√£o, replica√ß√£o, processamento paralelo, capacidade m√≥vel, e assim por diante, e com um grande n√∫mero de par√¢metros que precisam ser definidos para configura√ß√£o. Al√©m do mais, eles s√£o vendidos na forma de licen√ßas - as licen√ßas  por  local  permitem  uso  ilimitado  do  sistema de banco de dados com qualquer n√∫mero de c√≥pias rodando na instala√ß√£o definida pelo comprador. Outro tipo de licen√ßa limita o n√∫mero de usu√°rios simult√¢neos ou o n√∫mero total de usu√°rios em determinado local. As vers√µes de alguns sistemas para um √∫nico usu√°rio isolado, como Microsoft Access, s√£o vendidas por c√≥pia ou inclu√≠das na configura√ß√£o geral do computador desktop ou laptop. Al√©m disso, recursos de data warehousing e minera√ß√£o de dados, bem como o suporte para tipos de dados adicionais, est√£o dispon√≠veis a um custo extra. √â poss√≠vel pagar milh√µes de d√≥lares anualmente pela instala√ß√£o e manuten√ß√£o de grandes sistemas de banco de dados.

Tamb√©m  podemos  classificar  um  SGBD  com base nas op√ß√µes de tipos de caminho de acesso para armazenar arquivos. Uma fam√≠lia bem conhecida de SGBDs √© baseada em estruturas invertidas de arquivo. Por fim, um SGBD pode ser de uso geral ou de uso  especial .  Quando  o  desempenho  √©  um  aspecto importante, um SGBD de uso especial pode ser projetado  e  constru√≠do  para  uma  aplica√ß√£o  espec√≠fica; esse sistema n√£o pode ser usado para outras aplica√ß√µes  sem  mudan√ßas  relevantes.  Muitos  sistemas  de reservas  a√©reas  e  cat√°logo  telef√¥nico  desenvolvidos no passado s√£o SGBDs de uso especial. Eles se encontram na categoria de sistemas de processamento de transa√ß√£o on-line ( OLTP - Online Transaction Processing), que precisam dar suporte a um grande n√∫mero de transa√ß√µes simult√¢neas sem causar atrasos excessivos.

Vamos detalhar rapidamente o crit√©rio principal para classificar SGBDs: o modelo de dados. O modelo de dados relacional b√°sico representa um banco de dados como uma cole√ß√£o de tabelas, onde cada

tabela pode ser armazenada como um arquivo separado. O banco de dados na Figura 1.2 se assemelha a uma representa√ß√£o relacional. A maior parte dos bancos de dados relacionais utiliza a linguagem de consulta de alto n√≠vel, chamada SQL, e admite uma forma limitada de vis√µes do usu√°rio. Discutiremos o modelo relacional e suas linguagens e opera√ß√µes nos cap√≠tulos 3 a 6, e as t√©cnicas para programar aplica√ß√µes relacionais nos cap√≠tulos 13 e 14.

O modelo de dados de objeto define um banco de  dados  em  termos  de  objetos,  suas  propriedades e opera√ß√µes. Os objetos com a mesma estrutura e comportamento pertencem a uma classe ,  e  as classes  s√£o  organizadas  em hierarquias (ou grafos ac√≠clicos ). As opera√ß√µes de cada classe s√£o especificadas  com  procedimentos  predefinidos,  chamados m√©todos . Os SGBDs relacionais t√™m estendido seus modelos para incorporar conceitos de banco de dados de objeto e outras funcionalidades; esses sistemas s√£o chamados de sistemas objeto-relacional ou relacional  estendido .  Discutiremos  os  sistemas  de bancos  de  dados  de  objeto  e  objeto-relacional  no Cap√≠tulo 11.

de SGBD comercial. Apresentaremos uma vis√£o geral da XML no Cap√≠tulo 12.

Dois  modelos  de  dados  mais  antigos,  historicamente importantes, agora conhecidos como modelos de dados legados ,  s√£o  os  modelos  de  rede  e hier√°rquico.  O modelo  de  rede representa  dados como tipos de registro e tamb√©m representa um tipo limitado  de  relacionamento  1:N,  chamado tipo  de conjunto . Um relacionamento 1:N, ou um-para-muitos, relaciona uma inst√¢ncia de um registro a muitas inst√¢ncias de registros usando algum mecanismo de liga√ß√£o com ponteiros nesses modelos. A Figura 2.8 mostra um diagrama de esquema de rede para o banco de dados da Figura 2.1, em que os tipos de registros aparecem como ret√¢ngulos e os tipos de conjuntos aparecem como setas direcionadas e rotuladas.

O modelo  XML surgiu  como  um  padr√£o  para troca de dados pela Web, e foi usado como base para implementar v√°rios prot√≥tipos de sistemas com XML nativa. A XML utiliza estruturas de √°rvore hier√°rquicas e combina conceitos de banco de dados com conceitos dos modelos de representa√ß√£o de documentos. Os  dados  s√£o  representados  como  elementos;  com o uso de tags, os dados podem ser aninhados para criar estruturas hier√°rquicas complexas. Esse modelo √© conceitualmente semelhante ao modelo de objeto, mas usa uma terminologia diferente. Funcionalidades XML t√™m sido acrescentadas a muitos produtos

O modelo de rede, tamb√©m conhecido como modelo CODASYL DBTG, 14  possui uma linguagem que trata um registro por vez e que deve estar embutida em uma linguagem de  programa√ß√£o  hospedeira.  A DML do modelo de rede foi proposta no Database Task Group (DBTG) Report de 1971 como uma extens√£o da linguagem COBOL. Ela oferece comandos para  localizar  registros  diretamente  (por  exemplo, FIND ANY &lt;tipo-registro&gt; USING &lt;lista-de-campos&gt; ou FIND  DUPLICATE &lt;tipo-registro&gt; USING &lt;lista-de-campos&gt;). Tem comandos para navegar dentro dos tipos conjunto (por exemplo, GET OWNER GET , { FIRST , NEXT LAST , } MEMBER WITHIN &lt;tipo-conjunto&gt; WHERE &lt;condi√ß√£o&gt;).  Tem  tamb√©m  comandos para armazenar novos dados (por exemplo, STORE &lt;tipo-registro&gt;)  e  torn√°-los  parte  de  um  tipo  conjunto  (por  exemplo, CONNECT &lt;tipo-registro&gt; TO &lt;tipo-conjunto&gt;). A linguagem tamb√©m trata diversos aspectos adicionais, como a posi√ß√£o dos tipos de

Figura 2.8 O esquema da Figura 2.1 na nota√ß√£o de modelo de rede.



14 CODASYL DBTG significa Conference on Data Systems Languages Database Task Group, que √© o nome do comit√™ que especificou o modelo de rede

e sua linguagem.

registro  e  dos  tipos  de  conjunto,  que  s√£o  definidos pela posi√ß√£o atual do processo de navega√ß√£o no banco de dados. Ela √© usada predominantemente pelos sistemas IDMS, IMAGE e SUPRA nos dias de hoje.

O modelo hier√°rquico representa os dados como estruturas  de  √°rvore  hier√°rquicas.  Cada  hierarquia simboliza uma s√©rie de registros relacionados. N√£o existe uma linguagem-padr√£o para o modelo hier√°rquico. Uma DML hier√°rquica popular √© a DL/1 do sistema IMS. Ela dominou o mercado de SGBD por mais de 20 anos, entre 1965 e 1985, e ainda √© um sistema muito usado no mundo inteiro, gerenciando uma grande porcentagem dos dados dos bancos de dados do governo, de servi√ßos de sa√∫de, de bancos e do setor de seguros. Sua DML, chamada DL/1, foi um padr√£o de fato na ind√∫stria por um longo tempo. Ela  tem  comandos  para  localizar  um  registro  (por exemplo, GET UNIQUE NEXT { , } &lt;tipo-registro&gt; WHE -RE &lt;condi√ß√£o&gt;) e facilidades para navegar nas hierarquias  (por  exemplo, GET NEXT WITHIN PARENT ou GET {FIRST, NEXT  PATH } &lt;especifica√ß√£o-caminho-hier√°rquico&gt; WHERE &lt;condi√ß√£o&gt;).  Possui  funcionalidades  para  armazenar  e  atualizar  registros  (por exemplo, INSERT &lt;tipo-registro&gt;, REPLACE &lt;tipo-registro&gt;).  As  quest√µes  relacionadas  √†  posi√ß√£o  do registro  durante  a  navega√ß√£o  tamb√©m  s√£o  tratadas com outros recursos na linguagem.

## Resumo

Neste cap√≠tulo, apresentamos os principais conceitos usados em sistemas de banco de dados. Definimos um modelo de dados e destacamos tr√™s categorias principais:

- ¬Ñ Modelos de dados de alto n√≠vel ou conceituais (baseados em entidades e relacionamentos).
- ¬Ñ Modelos de dados de baixo n√≠vel ou f√≠sicos.
- ¬Ñ Modelos de dados representativos ou de implementa√ß√£o  (baseados  em  registro,  orientados  a objeto).

Destacamos a separa√ß√£o do esquema, ou descri√ß√£o de um banco de dados, do pr√≥prio banco de dados. O esquema n√£o muda com muita frequ√™ncia, enquanto o estado do banco de dados muda todas as vezes em que dados s√£o inseridos, exclu√≠dos ou modificados. Depois, descrevemos a arquitetura de SGBD, que permite tr√™s n√≠veis de esquema:

- ¬Ñ Um esquema interno que descreve a estrutura f√≠sica do armazenamento do banco de dados.
- ¬Ñ Um esquema conceitual que √© uma descri√ß√£o de alto n√≠vel do banco de dados inteiro.
- ¬Ñ Esquemas externos que descrevem as vis√µes de diferentes grupos de usu√°rios.

Um SGBD que separa nitidamente os tr√™s n√≠veis precisa ter mapeamentos entre os esquemas para transformar solicita√ß√µes e resultados das consultas de um n√≠vel para o seguinte. A maioria dos SGBDs n√£o separa os tr√™s n√≠veis completamente. Usamos a arquitetura de tr√™s esquemas para definir os conceitos de independ√™ncia l√≥gica e f√≠sica dos dados.

Depois, discutimos os principais tipos de linguagens e interfaces que os SGBDs possuem. Uma linguagem de defini√ß√£o de dados (DDL) √© usada para definir o esquema conceitual do banco de dados. Na maioria dos SGBDs, a DDL tamb√©m define vis√µes do usu√°rio e, √†s vezes, estruturas de armazenamento; em outros, existem linguagens ou fun√ß√µes separadas para especificar estruturas de armazenamento.  Atualmente,  essa  distin√ß√£o  est√°  desaparecendo nas implementa√ß√µes relacionais, com a SQL servindo como uma linguagem geral para realizar v√°rios pap√©is, incluindo defini√ß√£o de vis√µes. A parte de defini√ß√£o de armazenamento (SDL) foi inclu√≠da nas primeiras vers√µes da SQL, mas agora costuma ser implementada como comandos especiais para o DBA nos SGBDs relacionais. O SGBD compila todas as defini√ß√µes do esquema e armazena suas descri√ß√µes no cat√°logo do sistema.

Uma linguagem de manipula√ß√£o de dados (DML) √© usada para especificar leituras e atualiza√ß√µes no banco de dados. As DMLs podem ser de alto n√≠vel (orientada a conjunto, n√£o procedural) ou de baixo n√≠vel (orientada a registro, procedural). Uma DML de alto n√≠vel pode ser  embutida em uma linguagem de programa√ß√£o hospedeira, ou pode ser usada como uma linguagem independente; nesse √∫ltimo caso, ela costuma ser chamada de linguagem de consulta.

Discutimos os diferentes tipos de interfaces fornecidas pelos SGBDs e os tipos de usu√°rios com os quais cada interface est√° associada. Depois, abordamos o ambiente do sistema de banco de dados, m√≥dulos de software de  SGBD t√≠picos  e  utilit√°rios  de  SGBD  para  ajudar  os usu√°rios e os DBAs a realizar suas tarefas. Continuamos com uma vis√£o geral das arquiteturas de duas e tr√™s camadas para aplica√ß√µes de banco de dados, progressivamente passando para n camadas, que agora s√£o comuns em muitas aplica√ß√µes, em especial nas aplica√ß√µes de banco de dados da Web.

Por  fim,  classificamos  os  SGBDs  de  acordo  com v√°rios crit√©rios: modelo de dados, n√∫mero de usu√°rios, n√∫mero de locais, tipos de caminhos de acesso e custo. Discutimos a disponibilidade dos SGBDs e m√≥dulos adicionais - desde nenhum custo, na forma de software de c√≥digo aberto, at√© configura√ß√µes que custam anualmente milh√µes de d√≥lares para serem mantidas. Tamb√©m indicamos um conjunto vari√°vel de licen√ßa para os SGBDs e  produtos  relacionados.  A  principal  classifica√ß√£o  dos SGBDs √© baseada no modelo de dados. Discutimos rapidamente os principais  modelos  de  dados  usados  nos SGBDs dispon√≠veis atualmente no mercado.

## Perguntas de revis√£o

- 2.1. Defina os seguintes termos: modelo de dados  es-, quema de banco de dados  estado de banco de , dados  esquema interno  esquema conceitual  es-, , , quema externo  independ√™ncia de dados  DDL , , , DML  SDL  VDL  linguagem de consulta  lin-, , , , guagem hospedeira  sublinguagem de dados  uti-, , lit√°rio de banco de dados  cat√°logo  arquitetura , , cliente/servidor   arquitetura  de  tr√™s  camadas , e arquitetura de n camadas .
- 2.2. Discuta as principais categorias de modelos de dados.  Quais  s√£o  as  diferen√ßas  b√°sicas  entre  o modelo relacional, o de objeto e a XML?
- 2.3. Qual √© a diferen√ßa entre um esquema de banco de dados e um estado de banco de dados?
- 2.4. Descreva a arquitetura de tr√™s camadas. Por que precisamos de mapeamentos entre os n√≠veis de esquema? Como diferentes linguagens de defini√ß√£o de esquema d√£o suporte a essa arquitetura?
- 2.5. Qual √© a diferen√ßa entre a independ√™ncia l√≥gica e a independ√™ncia f√≠sica dos dados? Qual √© a mais dif√≠cil de se alcan√ßar? Por qu√™?
- 2.6. Qual  √©  a  diferen√ßa  entre  DMLs  procedurais  e n√£o procedurais?
- 2.7. Discuta os diferentes tipos de interfaces de f√°cil utiliza√ß√£o e os tipos de usu√°rios que normalmente utilizam cada tipo.
- 2.8. Com que outro software um SGBD interage?
- 2.9. Qual √© a diferen√ßa entre as arquiteturas cliente/ servidor de duas e tr√™s camadas?
- 2.10. Discuta alguns tipos de utilit√°rios e ferramentas de banco de dados e suas fun√ß√µes.
- 2.11. Qual √© a funcionalidade adicional na arquitetura de n camadas ( n &gt; 3)?

## Exerc√≠cios

- 2.12. Pense nos diferentes usu√°rios para o banco de dados  mostrado  na  Figura  1.2.  De  que  tipos  de aplica√ß√µes cada usu√°rio precisaria? A que categoria de usu√°rio cada um pertenceria e de que tipo de interface cada um precisaria?
- 2.13. Escolha uma aplica√ß√£o de banco de dados com a qual voc√™ esteja acostumado. Crie um esquema e  mostre um exemplo de banco de dados para
- essa  aplica√ß√£o,  usando  a  nota√ß√£o  das  figuras 1.2 e 2.1. Que tipos de informa√ß√µes e restri√ß√µes adicionais voc√™ gostaria de representar no esquema? Pense nos diversos usu√°rios de seu banco de dados e crie uma vis√£o para cada tipo.
- 2.14. Se voc√™ estivesse criando um sistema baseado na Web para fazer reservas e vender passagens a√©reas, qual  arquitetura  de  SGBD  voc√™  escolheria,  com base na Se√ß√£o 2.5? Por qu√™? Por que as outras arquiteturas n√£o seriam uma boa escolha?
- 2.15. Considere a Figura 2.1. Al√©m das restri√ß√µes relacionando os valores das colunas de uma tabela √†s colunas de outra tabela, tamb√©m existem restri√ß√µes que imp√µem limita√ß√µes sobre valores de uma coluna ou uma combina√ß√£o de colunas de uma tabela. Uma restri√ß√£o desse tipo imp√µe que uma coluna ou um grupo de colunas deva ser exclusivo em todas as linhas na tabela. Por exemplo, na tabela ALUNO , a coluna numero\_aluno deve ser exclusiva (para impedir que dois alunos diferentes tenham o mesmo numero\_aluno ). Identifique a coluna ou o grupo de colunas das outras tabelas que precisam ser exclusivos em todas as linhas na tabela.

## Bibliografia selecionada

Muitos  livros-texto  de  banco  de  dados,  incluindo Date (2004), Silberschatz et al. (2006), Ramakrishnan e Gehrke (2003), Garcia-Molina et al. (2000, 2009) e Abiteboul  et  al.  (1995),  oferecem  uma  discuss√£o  sobre  os diversos conceitos de banco de dados apresentados aqui. Tsichritzis e Lochovsky (1982) √© o livro-texto mais antigo sobre modelos de dados. Tsichritzis e Klug (1978) e Jardine (1977) apresentam a arquitetura de tr√™s esquemas, que foi sugerida inicialmente no relat√≥rio CODASYL DBTG de 1971 e, mais tarde, em um relat√≥rio do American National Standards Institute (ANSI, instituto norte-americano de padr√µes) de 1975. Uma an√°lise profunda do modelo de dados relacional e algumas de suas poss√≠veis extens√µes s√£o apresentadas em Codd (1990). O padr√£o proposto para bancos de dados orientados a objeto √© descrito em Cattell et al. (2000). Muitos documentos descrevendo XML est√£o dispon√≠veis na Web, como XML (2005).

Alguns exemplos de utilit√°rios de banco de dados s√£o  as  ferramentas  Connect,  Analyze  e  Transform,  da ETI (&lt;http://www.eti.com&gt;), e a ferramenta de administra√ß√£o de banco de dados, DBArtisan, da Embarcadero Technologies (&lt;http://www.embarcadero.com&gt;).



Modelo de dados relacional e SQL



## O modelo de dados relacional e as restri√ß√µes em bancos de dados relacionais

E ste cap√≠tulo abre a Parte 2 do livro, que aborda os bancos de dados relacionais. O modelo de dados relacional foi introduzido inicialmente por Ted Codd, da IBM Research, em 1970, em um artigo cl√°ssico (Codd, 1970), que atraiu aten√ß√£o imediata devido a sua simplicidade e base matem√°tica. O modelo usa o conceito de rela√ß√£o matem√°tica - que se parece com uma tabela de valores - como seu bloco de montagem b√°sico, e sua base te√≥rica reside em uma teoria de conjunto e l√≥gica de predicado de primeira ordem. Neste cap√≠tulo, discutiremos as caracter√≠sticas b√°sicas do modelo e suas restri√ß√µes.

O c√°lculo relacional √© considerado a base para a linguagem SQL, e a √°lgebra relacional √© usada nos detalhes internos de muitas implementa√ß√µes de banco de dados para processamento e otimiza√ß√£o de consulta (ver Parte 8 do livro).

As primeiras implementa√ß√µes comerciais do modelo relacional se tornaram dispon√≠veis no in√≠cio da d√©cada de 1980, como o sistema SQL/DS no sistema operacional MVS, da IBM, e o SGBD, da Oracle. Desde ent√£o, o modelo foi implantado em uma grande quantidade de sistemas comerciais. Os SGBDs relacionais (SGBDRs) populares atuais incluem o DB2 e Informix Dynamic Server (da IBM), o Oracle e Rdb (da Oracle), o Sybase SGBD (da Sybase) e o SQLServer e Access (da Microsoft). Al√©m disso, v√°rios sistemas de c√≥digo aberto, como MySQL e PostgreSQL, est√£o dispon√≠veis.

Por causa da import√¢ncia do modelo relacional, toda a Parte 2 √© dedicada a esse modelo e algumas das linguagens associadas a ele. Nos cap√≠tulos 4 e 5, descreveremos a linguagem de consulta SQL, que √© o padr√£o para SGBDs relacionais comerciais. O Cap√≠tulo 6 abordar√° as opera√ß√µes da √°lgebra relacional e introduzir√° o c√°lculo relacional - essas s√£o duas linguagens formais associadas ao modelo relacional.

Outros  aspectos  do  modelo  relacional  s√£o apresentados  em  outras  partes  do  livro.  O  Cap√≠tulo 9 abordar√° as estruturas de dados do modelo relacional para constru√ß√µes dos modelos ER e EER (apresentados  nos  cap√≠tulos  7  e  8),  e  apresentar√° algoritmos para projetar um esquema de banco de dados relacional mapeando um esquema conceitual no modelo ER ou EER para uma representa√ß√£o relacional. Esses mapeamentos s√£o incorporados em muitas ferramentas de projeto de banco de dados e CASE. 1  Os cap√≠tulos 13 e 14, na Parte 5, discutir√£o as t√©cnicas de programa√ß√£o usadas para acessar sistemas de banco de dados e a no√ß√£o de conex√£o com bancos de dados relacionais por meio dos protocolos-padr√£o ODBC e JDBC. O Cap√≠tulo 14 tamb√©m apresentar√° o t√≥pico de programa√ß√£o de banco de dados na Web. Os cap√≠tulos 15 e 16, na Parte 6, apresentar√£o outro aspecto do modelo relacional, a saber, as restri√ß√µes formais das depend√™ncias funcionais  e  multivaloradas.  Essas  depend√™ncias  s√£o usadas para desenvolver uma teoria de projeto de banco de dados relacional baseada no conceito conhecido como normaliza√ß√£o .

Os modelos de dados que precederam o relacional incluem os modelos hier√°rquico e de rede. Eles foram propostos na d√©cada de 1960 e implementados nos primeiros SGBDs durante o final da d√©cada

de 1960 e in√≠cio da d√©cada de 1970. Por causa de sua import√¢ncia hist√≥rica e da exist√™ncia da base de usu√°rios para esses SGBDs, inclu√≠mos um resumo dos destaques desses modelos nos ap√™ndices D e E, que est√£o dispon√≠veis no site de apoio do livro (em ingl√™s). Esses modelos e sistemas agora s√£o conhecidos como sistemas de banco de dados legados .

Neste  cap√≠tulo,  concentramo-nos  em  descrever os princ√≠pios b√°sicos do modelo de dados relacional. Come√ßamos definindo os conceitos de modelagem e a nota√ß√£o do modelo relacional na Se√ß√£o 3.1. A Se√ß√£o 3.2 √© dedicada a uma discuss√£o das restri√ß√µes relacionais que s√£o consideradas uma parte importante do modelo relacional e automaticamente impostas na maioria dos SGBDs relacionais. A Se√ß√£o 3.3 define as opera√ß√µes de atualiza√ß√£o do modelo relacional, discute como as viola√ß√µes de restri√ß√µes de integridade s√£o tratadas e apresenta o conceito de uma transa√ß√£o. No final h√° um resumo do cap√≠tulo.

## 3.1 Conceitos do modelo relacional

O modelo relacional representa o banco de dados como uma cole√ß√£o de rela√ß√µes .  Informalmente, cada rela√ß√£o √© semelhante a uma tabela de valores ou, at√© certo ponto, a um arquivo plano de registros. Ele √© chamado de arquivo plano porque cada registro tem uma simples estrutura linear ou plana .  Por exemplo, o banco de dados de arquivos mostrado na Figura  1.2  √©  semelhante  √†  representa√ß√£o  do  modelo relacional b√°sico. No entanto, existem diferen√ßas importantes entre rela√ß√µes e arquivos, conforme veremos em breve.

Quando uma rela√ß√£o √© considerada uma tabela de valores,  cada linha na tabela representa uma cole√ß√£o de valores de dados relacionados. Uma linha representa um fato que normalmente corresponde a uma entidade ou relacionamento do mundo real. Os nomes da tabela e de coluna s√£o usados para ajudar a interpretar o significado dos valores em cada linha. Por exemplo, a primeira tabela da Figura 1.2 √© chamada de ALUNO porque cada linha representa fatos sobre uma entidade particular de aluno. Os nomes de coluna Nome, Numero\_aluno, Tipo\_aluno e Curso - especificam como interpretar os valores de dados em cada linha, com base na coluna em que cada valor se encontra. Todos os valores em uma coluna s√£o do mesmo tipo de dado.

Na terminologia formal do modelo relacional, uma linha √© chamada de tupla , um cabe√ßalho da coluna  √©  chamado  de atributo e  a  tabela  √©  chamada de rela√ß√£o . O tipo de dado que descreve os tipos de valores que podem aparecer em cada coluna √© representado por um dom√≠nio de valores poss√≠veis. Agora,  vamos  definir  esses  termos  dom√≠nio , tupla , atributo e rela√ß√£o - de maneira formal.

## 3.1.1 Dom√≠nios, atributos, tuplas e rela√ß√µes

Um dom√≠nio D √© um conjunto de valores at√¥micos. Com at√¥mico , queremos dizer que cada valor no dom√≠nio √© indivis√≠vel em se tratando do modelo relacional formal. Um m√©todo comum de especifica√ß√£o um dom√≠nio √© definir um tipo de dado do qual s√£o retirados os valores de dados que formam o dom√≠nio. Tamb√©m √© √∫til especificar um nome para o dom√≠nio, para ajudar na interpreta√ß√£o de seus valores. Alguns exemplos de dom√≠nios s√£o:

- ¬Ñ Numeros\_telefone\_nacional .  O conjunto de n√∫meros de telefone com dez d√≠gitos v√°lidos no Brasil.
- ¬Ñ Numeros\_telefone\_local .  O  conjunto  de  n√∫meros de telefone de oito d√≠gitos v√°lidos dentro de um c√≥digo de √°rea em particular no Brasil. O uso de n√∫meros de telefone locais est√° rapidamente se tornando obsoleto, sendo substitu√≠do por n√∫meros padr√£o de dez d√≠gitos.
- ¬Ñ Cadastro\_pessoa\_fisica .  O  conjunto  de  n√∫meros do CPF com onze d√≠gitos. (Esse √© um identificador exclusivo atribu√≠do a cada pessoa no Brasil para fins de emprego, imposto e benef√≠cios.)
- ¬Ñ Nomes .  O  conjunto  de  cadeia  de  caracteres que representam nomes de pessoas.
- ¬Ñ Medias\_nota . Poss√≠veis valores para calcular a m√©dia das notas; cada um deve ser um n√∫mero real (ponto flutuante) entre 0 e 4.
- ¬Ñ Idades\_funcionario .  Idades  poss√≠veis  dos  funcion√°rios em uma empresa; cada um deve ser um valor inteiro entre 15 e 80.
- ¬Ñ Nomes\_departamento\_academico .  O  conjunto  de  nomes  de  departamentos  acad√™micos em uma universidade, como Ci√™ncia da Computa√ß√£o, Economia e F√≠sica.
- ¬Ñ Codigos\_departamento\_academico . O conjunto de c√≥digos de departamentos acad√™micos, como 'CC', 'ECON' e 'FIS'.

Estas  s√£o  chamadas  defini√ß√µes l√≥gicas de  dom√≠nios. Um tipo de dado ou formato tamb√©m √© especificado para cada dom√≠nio. Por exemplo, o tipo de dado para o dom√≠nio Numeros\_telefone\_nacional pode ser declarado como uma sequ√™ncia de caracteres na forma ( dd dddd dddd ) -, onde cada d √© um d√≠gito num√©rico (decimal) e os dois primeiros d√≠gitos formam um c√≥digo de √°rea de telefone v√°lido. O tipo de dado para Idades\_funcionario √© um n√∫mero inteiro entre 15 e 80. Para Nomes\_departamento\_academico , o tipo de dado √© o conjunto de todas as cadeias de

caracteres que representam nomes de departamento v√°lidos.  Um  dom√≠nio,  portanto,  recebe  um  nome, tipo de dado e formato. Informa√ß√µes adicionais para interpretar os valores de um dom√≠nio tamb√©m podem ser dadas; por exemplo, um dom√≠nio num√©rico como Pesos\_pessoa deveria  ter  as  unidades  de  medida, como gramas ou quilos.

Um esquema 2 relacional R ,  indicado por R A ( 1 , A 2 , ..., A ), √© composto de um nome de rela√ß√£o n R e uma lista de atributos, A 1 , A 2 , ..., A n . Cada atributo A i √© o nome de um papel desempenhado por algum dom√≠nio D no esquema de rela√ß√£o R D . √© chamado de dom√≠nio de A i , e indicado por dom A ( i )  Um esque-. ma de rela√ß√£o √© usado para descrever uma rela√ß√£o; R √© chamado de nome dessa rela√ß√£o. O grau (ou aridade ) de uma rela√ß√£o √© o n√∫mero de atributos n desse esquema de rela√ß√£o.

Uma rela√ß√£o de grau sete, que armazena informa√ß√µes sobre alunos universit√°rios, teria sete atributos descrevendo cada aluno, da seguinte forma:

ALUNO(Nome, Cpf, Telefone\_residencial, Endereco, Telefone\_comercial, Idade, Media)

Usando o tipo de dado de cada atributo, a defini√ß√£o √†s vezes √© escrita como:

ALUNO(Nome:  string,  Cpf:  string,  Telefone\_re-sidencial:  string,  Endereco:  string,  Telefone\_co-mercial: string, Idade: integer, Media: real)

Para este esquema de rela√ß√£o, ALUNO √© o nome da rela√ß√£o, que tem sete atributos. Na defini√ß√£o anterior, mostramos a atribui√ß√£o de tipos gen√©ricos, como string ou inteiro, aos atributos. Mais precisamente, podemos  especificar  os  seguintes  dom√≠nios  j√°  definidos para alguns dos atributos da rela√ß√£o ALUNO : dom (Nome) = Nomes ; dom( Cpf ) = Cadastro\_pessoa\_ fisica ;  dom( Telefone\_residencial ) = Numeros\_telefone\_ nacional , 3 dom( Endereco ),  dom (Telefone\_comercial) = Numeros\_telefone\_nacional e dom (Media) =  Media. Tamb√©m √© poss√≠vel referenciar atributos de um esquema de rela√ß√£o por sua posi√ß√£o dentro da rela√ß√£o; assim, o segundo atributo da rela√ß√£o ALUNO √© Cpf , enquanto o quarto atributo √© Endereco .

Uma rela√ß√£o (ou estado de rela√ß√£o ) 4 r do esquema de rela√ß√£o R A ( 1 , A 2 , ..., A n ), tamb√©m indicada por r R ( ),  √©  um  conjunto  de n tuplas r =  { t 1 , t 2 ,  ..., t m }. Cada n tuplas t √© uma lista ordenada de n valores   = t &lt;v , v , ..., v &gt; 1 2 n , em que cada valor v, i 1 ‚â§ i ‚â§ n , √© um elemento de dom( A i ) ou √© um valor especial NULL. (Valores NULL ser√£o discutidos mais adiante, na Se√ß√£o 3.1.2.) O valor i -√©simo na tupla  , que corresponde t ao atributo A i , √© referenciado como  [ t A i ] ou  . t A i (ou t [ ] se usarmos a nota√ß√£o posicional). Os termos i inten√ß√£o da rela√ß√£o para o esquema R e extens√£o da rela√ß√£o para  o  estado  de  rela√ß√£o r R ( )  tamb√©m  s√£o comumente utilizados.

A Figura 3.1 mostra um exemplo de uma rela√ß√£o ALUNO , que corresponde ao esquema ALUNO j√° espe-

Figura 3.1 Os atributos e tuplas de uma rela√ß√£o ALUNO.



2 Um esquema de rela√ß√£o √†s vezes √© chamado de scheme de rela√ß√£o .

3 Nos EUA, com o grande aumento nos n√∫meros de telefone causado pela prolifera√ß√£o dos telefones m√≥veis, a maioria das √°reas metropolitanas agora possui v√°rios c√≥digos de √°rea, de modo que a discagem local com sete d√≠gitos foi descontinuada na maioria das √°reas. Mudamos esse dom√≠nio para Numeros\_telefone\_nacional em vez de Numeros\_telefones\_local, que seria uma op√ß√£o mais geral. Isso ilustra como os requisitos do banco de dados podem mudar com o tempo.

4 Isso tamb√©m tem sido chamado de inst√¢ncia da rela√ß√£o . N√£o usaremos esse termo porque inst√¢ncia tamb√©m √© usado para se referir a uma √∫nica tupla ou linha.

cificado. Cada tupla na rela√ß√£o representa uma entidade de aluno em particular (ou objeto). Apresentamos a rela√ß√£o como uma tabela, onde cada tupla aparece como uma linha e cada atributo corresponde a um cabe√ßalho de coluna , indicando um papel ou interpreta√ß√£o dos valores nesta coluna. Valores NULL representam atributos cujos valores s√£o desconhecidos ou n√£o existem para alguma tupla individual de ALUNO .

A  defini√ß√£o  anterior  de  uma  rela√ß√£o  pode  ser refeita de maneira mais formal usando os conceitos da teoria de conjunto, como se segue. Uma rela√ß√£o (ou estado de rela√ß√£o)  ( r R ) √© uma rela√ß√£o matem√°tica de grau n sobre os dom√≠nios dom( A 1 ), dom( A 2 ), ..., dom( A n ),  que  √©  um subconjunto do produto cartesiano (indicado por √ó ) dos dom√≠nios que definem R :

<!-- formula-not-decoded -->

O produto cartesiano especifica todas as combina√ß√µes poss√≠veis de valores dos dom√≠nios subjacentes. Logo, se indicarmos o n√∫mero total de valores, ou cardinalidade , em um dom√≠nio D como | D | (considerando que todos os dom√≠nios s√£o finitos), o n√∫mero total de tuplas no produto cartesiano √©

<!-- formula-not-decoded -->

Esse produto de cardinalidades de todos os dom√≠nios  representa  o  n√∫mero  total  de  poss√≠veis  inst√¢ncias  ou  tuplas  que  poder√£o  existir  em  qualquer estado  de  rela√ß√£o r R ( ).  De  todas  as  combina√ß√µes poss√≠veis, um estado de rela√ß√£o em determinado momento - o estado  de  rela√ß√£o  atual -  reflete  apenas as tuplas v√°lidas que representam um estado em particular do mundo real. Em geral, √† medida que o estado do mundo real muda, tamb√©m muda o estado de rela√ß√£o, sendo transformado em outro estado de rela√ß√£o. Contudo, o esquema R √©  relativamente est√°tico e muda com muito pouca frequ√™ncia - por exemplo, como resultado da inclus√£o de um atributo para representar novas informa√ß√µes que n√£o estavam armazenadas originalmente na rela√ß√£o.

√â poss√≠vel que v√°rios atributos tenham o mesmo dom√≠nio .  Os  nomes  de  atributo  indicam  diferentes pap√©is , ou interpreta√ß√µes, do dom√≠nio. Por exemplo, na rela√ß√£o ALUNO ,  o  mesmo  dom√≠nio Numeros\_te-lefone\_nacional desempenha  o  papel  de Telefone\_re-sidencial ,  referindo-se ao telefone residencial de um aluno ,  e  o  papel  de Telefone\_comercial ,  referindo-se ao telefone comercial do aluno . Um terceiro atributo poss√≠vel (n√£o mostrado) com o mesmo dom√≠nio poderia ser Telefone\_celular .

## 3.1.2 Caracter√≠sticas das rela√ß√µes

A defini√ß√£o dada de rela√ß√µes implica certas caracter√≠sticas que tornam uma rela√ß√£o diferente de um arquivo ou uma tabela. Agora, discutiremos algumas dessas caracter√≠sticas.

Ordena√ß√£o  de  tuplas  em  uma  rela√ß√£o. Uma rela√ß√£o √© definida como um conjunto de tuplas. Matematicamente,  os  elementos  de  um  conjunto n√£o possuem ordem entre  eles;  logo,  as  tuplas  em  uma rela√ß√£o  n√£o  possuem  nenhuma  ordem  em  particular. Em outras palavras, uma rela√ß√£o n√£o √© sens√≠vel √† ordena√ß√£o das tuplas. Por√©m, em um arquivo, os registros est√£o fisicamente armazenados no disco (ou na mem√≥ria), de modo que sempre existe uma ordem entre eles. Essa ordena√ß√£o indica o primeiro, segundo, i-n√©simo e √∫ltimo registros no arquivo. De modo semelhante,  quando  exibimos  uma  rela√ß√£o  como uma tabela, as linhas s√£o exibidas em certa ordem.

A ordena√ß√£o da tupla n√£o faz parte da defini√ß√£o da rela√ß√£o porque uma rela√ß√£o tenta representar fatos em um n√≠vel l√≥gico ou abstrato. Muitas ordens de tupla podem ser especificadas na mesma rela√ß√£o. Por exemplo, as tuplas na rela√ß√£o ALUNO da Figura 3.1 poderiam ser ordenadas pelos valores de Nome, Cpf, Idade ou  algum  outro  atributo.  A  defini√ß√£o  de  uma rela√ß√£o n√£o especifica ordem alguma: n√£o existe prefer√™ncia para  ordena√ß√£o  de  qualquer  outra  rela√ß√£o. Logo, a rela√ß√£o apresentada na Figura 3.2 √© conside-

## ALUNO

| Nome            | Cpf            | Telefone_ residencial   | Endereco                | Telefone_ comercial   |   Idade | Media   |
|-----------------|----------------|-------------------------|-------------------------|-----------------------|---------|---------|
| Daniel Davidson | 422.111.232-70 | NULL                    | Avenida da Paz, 3452    | (17)4749-1253         |      25 | 3,53    |
| Barbara Benson  | 533.690.123-80 | (17)3239-8461           | Rua Jardim, 7384        | NULL                  |      19 | 3,25    |
| Roberta Passos  | 489.220.110-08 | (17)3476-9821           | Rua da Consola√ß√£o, 265  | (17)3749-6492         |      28 | 3,93    |
| Carlos Kim      | 381.620.124-45 | (17)3785-4409           | Rua das Goiabeiras, 125 | NULL                  |      18 | 2,89    |
| Bruno Braga     | 305.610.243-51 | (17)3783-1616           | Rua das Paineiras, 2918 | NULL                  |      19 | 3,21    |

## Figura 3.2

rada id√™ntica √†quela mostrada na Figura 3.1. Quando uma rela√ß√£o √© implementada como um arquivo ou exibida como uma tabela, uma ordena√ß√£o em particular pode ser especificada sobre os registros do arquivo ou das linhas da tabela.

Ordem dos valores dentro de uma tupla e uma defini√ß√£o  alternativa  de  uma  rela√ß√£o. De  acordo com a defini√ß√£o anterior de uma rela√ß√£o, uma tupla n √© uma lista ordenada de n valores, de modo que a ordem dos valores em uma tupla - e, portanto, dos atributos em um esquema de rela√ß√£o - √© importante. No entanto, em um n√≠vel mais abstrato, a ordem dos atributos e seus valores n√£o √© t√£o importante, desde que a correspond√™ncia entre atributos e valores seja mantida.

Uma defini√ß√£o alternativa de uma rela√ß√£o pode ser dada, tornando a ordem dos valores em uma tupla desnecess√°ria .  Nessa  defini√ß√£o,  um  esquema  de rela√ß√£o R =  { A 1 , A 2 ,  ..., A n }  √©  um conjunto de  atributos (em vez de uma lista), e um estado de rela√ß√£o r R ( )  √©  um  conjunto  finito  de  mapeamentos r =  { t 1 , t 2 ,  ..., t m },  onde cada tupla t i √©  um mapeamento de R para D , e D √© a uni√£o (indicada por ‚à™ ) dos dom√≠nios de atributo; ou seja, D = dom( A 1 ) ‚à™ dom( A 2 ) ‚à™ ... ‚à™ dom( A n ).  Nessa  defini√ß√£o, t A [ i ]  deve  estar  em dom( A i ) para 1 ‚â§ i ‚â§ n para cada mapeamento t em r . Cada mapeamento t i √© chamado de tupla.

De  acordo  com  essa  defini√ß√£o  de  tupla  como um  mapeamento,  uma tupla pode  ser  considerada um conjunto de pares (&lt;atributo&gt;, &lt;valor&gt;), em que cada par d√° o valor do mapeamento a partir de um atributo A i para um valor v i de  dom( A i ).  A  ordem dos atributos n√£o √© importante, pois o nome do atributo aparece com seu valor .  Por  essa  defini√ß√£o, as duas tuplas mostradas na Figura 3.3 s√£o id√™nticas.

- t =   &lt;(Nome, Daniel Davidson),(Cpf,422.111.232-70),(Telefone\_residencial, NULL),(Endereco, Avenida da Paz, 3452), (Telefone\_comercial, (17)4749-1253),(Idade, 25),(Media, 3,53)&gt;

t =   &lt;(Endereco, Avenida da Paz, 3452),(Nome, Daniel Davidson),(Cpf, 422.111.232-70),(Idade, 25), (T elefone\_comercial,(17)4749-1253),(Media, 3,53),(T elefone\_residencial, NULL)&gt;

Figura 3.3

Duas tuplas id√™nticas quando a ordem dos atributos e valores n√£o faz parte da defini√ß√£o da rela√ß√£o.

Isso faz sentido em um n√≠vel abstrato, j√° que n√£o h√° realmente motivo para preferir ter um valor de atributo aparecendo antes de outro em uma tupla.

Quando uma rela√ß√£o √© implementada como um arquivo, os atributos s√£o fisicamente ordenados como campos dentro de um registro. Geralmente, usaremos a primeira defini√ß√£o da rela√ß√£o, onde os atributos e os valores dentro das tuplas s√£o ordenados , porque isso simplifica grande parte da nota√ß√£o. Por√©m, a defini√ß√£o alternativa dada aqui √© mais geral. 5

Valores  e  NULLs  nas  tuplas. Cada  valor  em uma tupla √© um valor at√¥mico ; ou seja, ele n√£o √© divis√≠vel em componentes dentro da estrutura do modelo relacional b√°sica. Logo, atributos compostos ou multivalorados (ver Cap√≠tulo 7) n√£o s√£o permitidos. Esse modelo √†s vezes √© chamado de modelo relacional plano .  Grande parte da teoria por tr√°s do modelo relacional foi desenvolvida com essa suposi√ß√£o em mente, que √© chamada pressuposto da primeira forma normal . 6 Assim, atributos multivalorados precisam ser representados por rela√ß√µes separadas, e os atributos  compostos  s√£o  representados  apenas  por seus  atributos  de  componentes  simples  no  modelo relacional b√°sico. 7

Um conceito importante √© o dos valores NULL , que s√£o usados para representar os valores de atributos que podem ser desconhecidos ou n√£o se aplicam a  uma tupla.  Um valor especial,  chamado NULL ,  √© usado nesses casos. Por exemplo, na Figura 3.1, algumas tuplas ALUNO t√™m NULL para seus telefones comerciais, pois eles n√£o trabalham (ou seja, o telefone comercial n√£o se aplica a esses alunos). Outro aluno tem um NULL para o telefone residencial, talvez porque ele n√£o tenha um telefone residencial ou ele tem, mas n√≥s n√£o o conhecemos (o valor √© desconhecido ). Em geral, podemos ter v√°rios significados para valores NULL ,  como valor  desconhecido , valor  existe mas n√£o est√° dispon√≠vel ou atributo n√£o se aplica a esta tupla (tamb√©m conhecido como valor indefinido ). Um exemplo do √∫ltimo tipo de NULL ocorrer√° se acrescentarmos um atributo Tipo\_visto (tipo  do visto) √† rela√ß√£o ALUNO ,  que se aplica apenas a tuplas que representam alunos estrangeiros. √â poss√≠vel criar diferentes c√≥digos para diversos significados de valores NULL . A incorpora√ß√£o de diferentes tipos de valores NULL nas opera√ß√µes do modelo relacional (ver Cap√≠tulo 6) provou ser muito dif√≠cil e, portanto, est√° fora do escopo de nossa apresenta√ß√£o.

5 Como veremos, a defini√ß√£o alternativa da rela√ß√£o ser√° √∫til quando discutirmos o processamento e a otimiza√ß√£o da consulta no Cap√≠tulo 19.

6

Discutiremos esse pressuposto da primeira forma normal com mais detalhes no Cap√≠tulo 15.

7 Extens√µes do modelo relacional removem essas restri√ß√µes. Por exemplo, os sistemas objeto-relacional (Cap√≠tulo 11) permitem atributos estruturados complexos, assim como os modelos relacionais n√£o de primeira forma normal ou aninhados .

O significado exato de um valor NULL determina como ele ser√° aplicado durante agrega√ß√µes aritm√©ticas ou compara√ß√µes com outros valores. Por exemplo,  uma  compara√ß√£o  de  dois  valores NULL leva  a ambiguidades - se os Clientes A e B t√™m endere√ßos NULL , isso n√£o significa que eles t√™m o mesmo endere√ßo. Durante o projeto do banco de dados, √© melhor evitar  ao  m√°ximo  valores NULL .  Discutiremos  isso melhor nos cap√≠tulos 5 e 6, no contexto de opera√ß√µes e consultas, e no Cap√≠tulo 15, no contexto do projeto e normaliza√ß√£o de banco de dados.

Interpreta√ß√£o (significado) de uma rela√ß√£o. O esquema de rela√ß√£o pode ser interpretado como uma declara√ß√£o ou um tipo de afirma√ß√£o (ou asser√ß√£o ). Por exemplo, o esquema da rela√ß√£o ALUNO da Figura 3.1 afirma que, em geral, uma entidade de aluno tem um Nome, Cpf, Telefone\_residencial, Endereco, Telefone\_co-mercial, Idade e Media . Cada tupla na rela√ß√£o pode ent√£o ser interpretada como um fato ou uma inst√¢ncia em particular da afirma√ß√£o. Por exemplo, a primeira tupla na Figura 3.1 afirma que existe um ALUNO cujo Nome √© Bruno Braga, o Cpf √© 305.610.243-51, a Idade √© 19, e assim por diante.

Observe que algumas rela√ß√µes podem representar fatos sobre entidades , enquanto outras podem representar fatos sobre relacionamentos . Por exemplo, um esquema de rela√ß√£o CURSAR ( Cpf\_aluno,  Codi-go\_disciplina ) afirma que os alunos cursaram disciplinas acad√™micas. Uma tupla nessa rela√ß√£o relaciona um aluno a disciplina cursada. Logo, o modelo relacional representa fatos sobre entidades e relacionamentos uniformemente como rela√ß√µes. Isso √†s vezes compromete a compreens√£o, pois √© preciso descobrir se  uma  rela√ß√£o  representa  um  tipo  de  entidade  ou um tipo de relacionamento. Apresentaremos o modelo Entidade-Relacionamento (ER) com detalhes no Cap√≠tulo 7, no qual os conceitos de entidade e relacionamento ser√£o descritos minuciosamente. Os procedimentos de mapeamento no Cap√≠tulo 9 mostram como diferentes constru√ß√µes dos modelos de dados conceituais ER e EER (modelo ER estendido, abordado no Cap√≠tulo 8, na Parte 3) s√£o convertidas em rela√ß√µes.

Uma interpreta√ß√£o  alternativa  de  um  esquema de rela√ß√£o √© como um predicado ; nesse caso, os valores em cada tupla s√£o interpretados como valores que satisfazem o predicado. Por exemplo, o predicado ALUNO ( Nome Cpf , , ...) √© verdadeiro para as cinco tuplas na rela√ß√£o ALUNO da Figura 3.1. Essas tuplas representam cinco proposi√ß√µes ou fatos diferentes no mundo real. Essa interpreta√ß√£o √© muito √∫til no contexto das linguagens de programa√ß√£o l√≥gicas, como

Prolog,  pois  permite  que  o  modelo  relacional  seja usado nessas linguagens (ver Se√ß√£o 26.5). Um pressuposto, chamado pressuposto do mundo fechado , afirma que os √∫nicos fatos verdadeiros no universo s√£o aqueles presentes dentro da extens√£o (estado) da(s) rela√ß√£o(√µes). Qualquer outra combina√ß√£o de valores torna o predicado falso.

## 3.1.3 Nota√ß√£o do modelo relacional

Usaremos a seguinte nota√ß√£o em nossa representa√ß√£o:

- ¬Ñ Um esquema de rela√ß√£o R de grau n √© indicado por R A ( 1 , A 2 , ..., A n ).
- ¬Ñ As letras mai√∫sculas Q R S , , indicam nomes de rela√ß√£o.
- ¬Ñ As letras min√∫sculas q , r , s indicam estados de rela√ß√£o.
- ¬Ñ As letras  , t u , v indicam tuplas.
- ¬Ñ Em geral, o nome de um esquema de rela√ß√£o, como ALUNO , tamb√©m indica o conjunto atual de tuplas nessa rela√ß√£o - o estado de rela√ß√£o atual -, enquanto ALUNO ( Nome Cpf , , ...) refere-se apenas ao esquema de rela√ß√£o.
- ¬Ñ Um  atributo A pode  ser  qualificado  com  o nome de rela√ß√£o R ao qual pertence usando a nota√ß√£o de ponto RA . - por exemplo, ALUNO . Nome ou ALUNO.Idade . Isso porque o mesmo nome pode ser usado para dois atributos em rela√ß√µes diferentes. Contudo, todos os nomes de  atributo em  uma  rela√ß√£o  em  particular precisam ser distintos.
- ¬Ñ Uma n -tupla   em uma rela√ß√£o  ( t r R ) √© indicada por   = &lt; t v 1 , v 2 ,  ..., v n &gt;, onde v i √©  o valor correspondente ao atributo A i .  A  nota√ß√£o a seguir refere-se a valores componentes de tuplas:
- ¬Ñ Tanto  [ t A i ] quanto  . t A i (e √†s vezes t i [ ]) referem-se ao valor v i em   para o atributo t A i .
- ¬Ñ Tanto  [ t A u , A w ,  ..., A z ]  quanto t .( A u , A w ,  ..., A z ), onde A u , A w , ..., A z √© uma lista de atributos de R , que referem-se √† subtupla de valores &lt; v u , v w , ..., v z &gt; de   correspondentes aos atrit butos especificados na lista.

Como um exemplo, considere a tupla   = &lt;'Bart bara  Benson',  '533.690.123-80',  '(17)3239-8461', 'Rua  Jardim,  7384',  NULL,  19,  3,25&gt;  da  rela√ß√£o ALUNO na  Figura  3.1;  temos t [Nome] =  &lt;'Barbara Benson'&gt; e t [Cpf, Media, Idade] = &lt;'533.690.123-80', 3,25, 19&gt;.

## 3.2 Restri√ß√µes em modelo relacional e esquemas de bancos de dados relacionais

At√© aqui, discutimos as caracter√≠sticas de rela√ß√µes isoladas. No banco de dados relacional, normalmente haver√° muitas rela√ß√µes, e as tuplas nessas rela√ß√µes costumam estar relacionadas de v√°rias maneiras. O estado do banco de dados inteiro corresponder√° aos estados  de  todas  as  suas  rela√ß√µes  em  determinado ponto no tempo. Em geral, existem muitas restri√ß√µes (ou constraints ) sobre os valores reais em um estado do banco de dados. Essas restri√ß√µes s√£o derivadas das regras no minimundo que o banco de dados representa, conforme discutimos na Se√ß√£o 1.6.8.

Nesta se√ß√£o, discutiremos as diversas restri√ß√µes sobre os dados que podem ser especificadas em um banco de dados relacional na forma de restri√ß√µes. As restri√ß√µes nos bancos de dados geralmente podem ser divididas em tr√™s categorias principais:

- 1. Restri√ß√µes que s√£o inerentes no modelo de dados.  Chamamos  estas  de restri√ß√µes  inerentes baseadas no modelo ou restri√ß√µes impl√≠citas .
- 2. Restri√ß√µes  que  podem  ser  expressas  diretamente nos esquemas do modelo de dados, em geral especificando-as na DDL (linguagem de defini√ß√£o de dados; ver Se√ß√£o 2.3.1). Chamamos estas de restri√ß√µes baseadas em esquema ou restri√ß√µes expl√≠citas .
- 3. Restri√ß√µes que n√£o podem ser expressas diretamente nos esquemas do modelo de dados, e,  portanto, devem ser expressas e impostas pelos  programas  de  aplica√ß√£o.  Chamamos estas de restri√ß√µes baseadas na aplica√ß√£o ou restri√ß√µes sem√¢nticas ou regras de neg√≥cios .

As  caracter√≠sticas  das  rela√ß√µes  que  discutimos na Se√ß√£o 3.1.2 s√£o as restri√ß√µes inerentes do modelo  relacional  e  pertencem √† primeira categoria. Por exemplo, a restri√ß√£o de que uma rela√ß√£o n√£o pode ter  tuplas  duplicadas  √©  uma  restri√ß√£o  inerente.  As restri√ß√µes que discutimos nesta se√ß√£o s√£o da segunda categoria, a saber, restri√ß√µes que podem ser expressas no esquema do modelo relacional por meio da DDL. As  restri√ß√µes  da  terceira  categoria  s√£o  mais  gerais, relacionam-se ao significado e tamb√©m ao comportamento dos atributos, e s√£o dif√≠ceis de expressar e impor dentro do modelo de dados, de modo que normalmente s√£o verificadas nos programas de aplica√ß√£o que realizam as atualiza√ß√µes no banco de dados.

Outra categoria importante de restri√ß√µes √© a de depend√™ncias  de  dados ,  que  incluem depend√™ncias funcionais e depend√™ncias multivaloradas .  Elas  s√£o usadas principalmente para testar a 'virtude' do pro- jeto de um banco de dados relacional e em um processo chamado normaliza√ß√£o , que ser√° discutido nos cap√≠tulos 15 e 16.

As restri√ß√µes baseadas em esquema incluem restri√ß√µes de dom√≠nio, restri√ß√µes de chave, restri√ß√µes sobre NULLs, restri√ß√µes de integridade de entidade e restri√ß√µes de integridade referencial.

## 3.2.1 Restri√ß√µes de dom√≠nio

As restri√ß√µes de dom√≠nio especificam que, dentro de cada tupla, o valor de cada atributo A deve ser um valor indivis√≠vel do dom√≠nio dom( A ).  J√°  discutimos as  maneiras  como  os  dom√≠nios  podem  ser  especificados na Se√ß√£o 3.1.1. Os tipos de dados associados aos dom√≠nios normalmente incluem os tipos de dados num√©ricos padr√£o para inteiros (como short integer, integer e long integer) e n√∫meros reais (float e double). Caracteres, booleanos, cadeia de caracteres de tamanho fixo e cadeia de caracteres de tamanho vari√°vel tamb√©m est√£o dispon√≠veis, assim como data, hora, marcador de tempo, moeda ou outros tipos de dados  especiais.  Outros  dom√≠nios  poss√≠veis  podem ser descritos por um subintervalo dos valores de um tipo de dados ou como um tipo de dado enumerado, em que todos os valores poss√≠veis s√£o explicitamente listados. Em vez de descrev√™-los com detalhes aqui, discutiremos  os  tipos  de  dados  oferecidos  pelo  padr√£o relacional SQL na Se√ß√£o 4.1.

## 3.2.2 Restri√ß√µes de chave e restri√ß√µes sobre valores NULL

No modelo relacional formal, uma rela√ß√£o √© definida como um conjunto de tuplas . Por defini√ß√£o, todos os elementos de um conjunto s√£o distintos; logo, todas as tuplas em uma rela√ß√£o tamb√©m precisam ser distintas. Isso significa que duas tuplas n√£o podem ter a mesma combina√ß√£o de valores para todos os seus atributos. Normalmente, existem outros subconjuntos de atributos de um esquema de rela√ß√£o R com a propriedade de que duas tuplas em qualquer estado de rela√ß√£o r de R n√£o dever√£o ter a mesma combina√ß√£o de valores para esses atributos. Suponha que indiquemos um subconjunto de atributos desse tipo como SCh; ent√£o, para duas tuplas distintas quaisquer t 1 e t 2 em um estado de rela√ß√£o   de r R , temos a restri√ß√£o de que:

<!-- formula-not-decoded -->

Qualquer conjunto de atributos SCh desse tipo √© chamado de superchave do  esquema de rela√ß√£o R .  Uma superchave SCh especifica uma restri√ß√£o de exclusividade de que duas tuplas distintas em qualquer estado r de R n√£o podem ter o mesmo valor de SCh. Cada rela√ß√£o tem pelo menos uma superchave padr√£o - o

conjunto de todos os seus atributos. Contudo, uma superchave pode ter atributos redundantes, de modo que um conceito mais √∫til √© o de uma chave , que n√£o tem redund√¢ncia. Uma chave Ch de um esquema de rela√ß√£o R √© uma superchave de R com a propriedade adicional de que a remo√ß√£o de qualquer atributo A de Ch deixa um conjunto de atributos Ch ' que n√£o √© mais uma superchave de R . Logo, uma chave satisfaz duas propriedades:

- 1. Duas tuplas distintas em qualquer estado da rela√ß√£o n√£o podem ter valores id√™nticos para (todos) os atributos na chave. Essa primeira propriedade tamb√©m se aplica a uma superchave.
- 2. Ela √© uma superchave m√≠nima - ou seja, uma superchave da qual n√£o podemos remover nenhum atributo e ainda mantemos uma restri√ß√£o de exclusividade na condi√ß√£o 1. Essa propriedade n√£o √© exigida por uma superchave.

Embora a primeira propriedade se aplique a chaves e superchaves, a segunda propriedade √© exigida apenas  para  chaves.  Assim,  uma  chave  tamb√©m  √© uma superchave, mas n√£o o contr√°rio. Considere a rela√ß√£o ALUNO da Figura 3.1. O conjunto de atributos { Cpf } √© uma chave de ALUNO porque duas tuplas de aluno n√£o podem ter o mesmo valor para Cpf . 8 Qualquer  conjunto  de  atributos  que  inclua Cpf -por exemplo, {Cpf, Nome, Idade} - √© uma superchave. No entanto, a superchave {Cpf, Nome, Idade} n√£o √© uma chave de ALUNO , pois remover Nome ou Idade , ou ambos, do conjunto ainda nos deixa com uma superchave. Em geral, qualquer superchave formada com base em um √∫nico atributo tamb√©m √© uma chave. Uma chave com m√∫ltiplos atributos precisa exigir que todos os seus atributos juntos tenham uma propriedade de exclusividade.

O valor de um atributo de chave pode ser usado para identificar exclusivamente cada tupla na rela√ß√£o. Por exemplo, o valor de Cpf 305.610.243-51 identifica exclusivamente a tupla correspondente a Bruno Braga na rela√ß√£o ALUNO .  Observe  que  um conjunto  de  atributos  constituindo  uma  chave  √© uma propriedade do esquema de rela√ß√£o; essa √© uma restri√ß√£o  que  deve  ser  mantida  sobre cada estado de rela√ß√£o v√°lido do esquema. Uma chave √© determinada com base no significado dos atributos, e a propriedade √© invari√°vel no tempo : ela precisa permanecer verdadeira quando inserimos novas tuplas na rela√ß√£o. Por exemplo, n√£o podemos e n√£o deve-

CARRO

| Placa             | Numero_chassi   | Marca      | Modelo   |   Ano |
|-------------------|-----------------|------------|----------|-------|
| Itatiaia ABC-7039 | A6935207586     | Volkswagen | Gol      |    02 |
| Itu TVP-3470      | B4369668697     | Chevrolet  | Corsa    |    05 |
| Santos MPO-2902   | X8355447376     | Fiat       | Uno      |    01 |
| Itanhaem TFY-6858 | C4374268458     | Chevrolet  | Celta    |    99 |
| Itatiba RSK-6279  | Y8293586758     | Renault    | Clio     |    04 |
| Atibaia RSK-6298  | U0283657858     | Volkswagen | Parati   |    04 |

Figura 3.4 A rela√ß√£o CARRO, com duas chaves candidatas: Placa e Numero\_chassi.

mos designar o atributo Nome da rela√ß√£o ALUNO da Figura 3.1 como uma chave porque √© poss√≠vel que dois alunos com nomes id√™nticos existam em algum ponto em um estado v√°lido. 9

Em geral, um esquema de rela√ß√£o pode ter mais de uma chave. Nesse caso, cada uma das chaves √© chamada de chave candidata . Por exemplo, a rela√ß√£o CARRO na Figura 3.4 tem duas chaves candidatas: Placa e Numero\_chassi .  √â  comum  designar uma  das  chaves  candidatas  como chave  prim√°ria da rela√ß√£o. Essa √© a chave candidata cujos valores s√£o usados para identificar tuplas na rela√ß√£o. Usamos a conven√ß√£o de que os atributos que formam a chave prim√°ria de um esquema de rela√ß√£o s√£o sublinhados, como mostra a Figura 3.4. Observe que, quando um esquema de rela√ß√£o tem v√°rias chaves candidatas, a escolha de uma para se tornar a chave prim√°ria √© um tanto quanto arbitr√°ria; por√©m, normalmente  √©  melhor  escolher  uma  chave  prim√°ria com um √∫nico atributo ou um pequeno n√∫mero de atributos.  As  outras  chaves  candidatas  s√£o  designadas como chaves √∫nicas ( unique keys ), e n√£o s√£o sublinhadas.

Outra restri√ß√£o sobre os atributos especifica se valores NULL s√£o  permitidos ou n√£o. Por exemplo, se cada tupla de ALUNO precisar ter um valor v√°lido, diferente de NULL , para o atributo Nome , ent√£o Nome de ALUNO √© restrito a ser NOT NULL .

## 3.2.3 Bancos de dados relacionais e esquemas de banco de dados relacional

As defini√ß√µes e restri√ß√µes que discutimos at√© aqui se aplicam a rela√ß√µes isoladas e seus atributos. Um

8 Observe que Cpf tamb√©m √© uma superchave.

9 Os nomes √†s vezes s√£o usados como chaves, mas, nesse caso, algum artefato - como anexar um n√∫mero ordinal - precisa ser usado para distinguir esses nomes id√™nticos.

banco de dados relacional costuma conter muitas rela√ß√µes, com tuplas nas rela√ß√µes que est√£o relacionadas de v√°rias maneiras. Nesta se√ß√£o, definimos um banco de dados relacional e um esquema de banco de dados relacional.

Um esquema de  banco  de  dados  relacional S √© um conjunto de esquemas de rela√ß√£o S = { R 1 , R 2 , ..., R m } e um conjunto de restri√ß√µes de integridade R I. Um estado de banco de dados relacional 10 DB de S √© um conjunto de estados de rela√ß√£o DB = { r 1 , r 2 ,  ..., r m }, tal que cada r i √© um estado de R i e tal que os estados da rela√ß√£o r i satisfazem as restri√ß√µes de integridade especificadas em RI. A Figura 3.5 mostra um esquema de banco de dados relacional que chamamos de EM -PRESA =  { FUNCIONARIO , DEPARTAMENTO , LOCA -LIZACAO\_DEP   PROJETO   TRABALHA\_EM , , , DEPEN -DENTE }. Os atributos sublinhados representam chaves prim√°rias. A Figura 3.6 mostra um estado de banco de dados relacional correspondente ao esquema EM -PRESA . Usaremos esse esquema e estado de banco de dados neste cap√≠tulo e nos cap√≠tulos 4 a 6 para desenvolver consultas de exemplo em diferentes linguagens relacionais.

Quando nos referimos a um banco de dados relacional, implicitamente inclu√≠mos seu esquema e seu estado atual. Um estado de banco de dados que n√£o obedece a todas as restri√ß√µes de integridade √© chamado de estado inv√°lido , e um estado que satisfaz a todas as restri√ß√µes no conjunto definido de restri√ß√µes de integridade RI √© chamado de estado v√°lido .

Na Figura 3.5, o atributo Dnumero em DEPAR -TAMENTO e LOCALIZACAO\_DEP significa o conceito do mundo real - o n√∫mero dado a um departamento. O mesmo conceito √© chamado Dnr em FUNCIONARIO e Dnum em PROJETO .  Os  atributos  que  representam o mesmo conceito do mundo real podem ou n√£o ter nomes id√™nticos em diferentes rela√ß√µes. Como alternativa, os atributos que representam diferentes conceitos podem ter o mesmo nome em diferentes rela√ß√µes. Por exemplo, poder√≠amos ter usado o nome de atributo Nome para Projnome de PROJETO e Dnome de DEPARTAMENTO ;  nesse  caso,  ter√≠amos dois atributos compartilhando o mesmo nome, mas representando diferentes conceitos do mundo real nomes de projeto e nomes de departamento.

## FUNCIONARIO

Figura 3.5



Diagrama de esquema para o esquema de banco de dados relacional EMPRESA.

10 Um estado de banco de dados relacional √†s vezes √© chamado de inst√¢ncia de banco de dados relacional. No entanto, como mencionamos anteriormente, n√£o usaremos o termo inst√¢ncia porque ele tamb√©m se aplica a tuplas isoladas.

Em algumas vers√µes antigas do modelo relacional,  era  feita  uma  suposi√ß√£o  de  que  o  mesmo conceito do mundo real, quando representado por um atributo, teria nomes de atributo id√™nticos em todas as  rela√ß√µes.  Isso  cria  problemas  quando  o  mesmo conceito do mundo real √© usado em diferentes pap√©is (significados) na mesma rela√ß√£o. Por exemplo, o conceito de Cadastro de Pessoa F√≠sica aparece duas vezes na rela√ß√£o FUNCIONARIO da Figura 3.5: uma no papel do CPF do funcion√°rio e outra no papel do CPF do supervisor. Precisamos dar-lhes nomes de atributo distintos Cpf e Cpf\_supervisor , respectivamente porque eles aparecem na mesma rela√ß√£o e a fim de distinguir seu significado.

Cada SGBD relacional precisa ter uma linguagem de defini√ß√£o de dados (DDL) para estabelecer um esquema de banco de dados relacional. Os SGBDs relacionais atuais costumam usar principalmente SQL para essa finalidade. Apresentaremos a DDL SQL nas se√ß√µes 4.1 e 4.2.

Restri√ß√µes  de  integridade  s√£o  especificadas  em um esquema de banco de dados e espera-se que sejam mantidas em cada estado de banco de dados v√°lido desse esquema. Al√©m das restri√ß√µes de dom√≠nio, chave e NOT NULL ,  dois  outros  tipos  de  restri√ß√µes  s√£o considerados parte do modelo relacional: integridade de entidade e integridade referencial.

## 3.2.4 ntegridade, integridade referencial I e chaves estrangeiras

A restri√ß√£o  de  integridade  de  entidade afirma que nenhum valor de chave prim√°ria pode ser NULL . Isso porque o valor da chave prim√°ria √© usado para identificar tuplas individuais em uma rela√ß√£o. Ter valores NULL para  a  chave  prim√°ria  implica  que  n√£o podemos identificar algumas tuplas. Por exemplo, se duas ou mais tuplas tivessem NULL para suas chaves prim√°rias, n√£o conseguir√≠amos distingui-las ao tentar referenci√°-las por outras rela√ß√µes.

As  restri√ß√µes  de  chave  e  as  restri√ß√µes  de  integridade de entidade s√£o especificadas sobre rela√ß√µes individuais. A restri√ß√£o de integridade referencial √© especificada entre duas rela√ß√µes e usada para manter a consist√™ncia entre tuplas nas duas rela√ß√µes. Informalmente, a restri√ß√£o de integridade referencial afirma que uma tupla em uma rela√ß√£o que referencia outra rela√ß√£o precisa se referir a uma tupla existente nessa  rela√ß√£o.  Por  exemplo,  na  Figura  3.6,  o atributo Dnr de FUNCIONARIO fornece o n√∫mero de departamento para o qual cada funcion√°rio trabalha; logo, seu valor em cada tupla FUNCIONARIO precisa combinar com o valor de Dnumero de alguma tupla na rela√ß√£o DEPARTAMENTO .

Para definir a integridade referencial de maneira mais formal,  primeiro  estabelecemos  o  conceito  de uma chave estrangeira ( ChE -foreign key ). As condi√ß√µes para uma chave estrangeira, dadas a seguir, especificam a restri√ß√£o de integridade referencial entre os dois esquemas de rela√ß√£o R 1 e R 2 . Um conjunto de atributos ChE no esquema de rela√ß√£o R 1 √©  uma chave estrangeira de R 1 que referencia a rela√ß√£o R 2 se ela satisfizer as seguintes regras:

- 1. Os atributos em ChE t√™m o mesmo dom√≠nio (ou dom√≠nios) que os atributos de chave prim√°ria ChP de R 2 ; diz-se que os atributos ChE referenciam ou referem-se √† rela√ß√£o R 2 .
- 2. Um valor de ChE em uma tupla t 1 do estado atual r 1 ( R 1 )  ocorre  como  um  valor  de  ChE para alguma tupla t 2 no  estado  atual r 2 ( R 2 ) ou √© NULL . No primeiro caso, temos t 1 [ChE] = t 2 [ChP], e dizemos que a tupla t 1 referencia ou refere-se √† tupla t 2 .

Nessa defini√ß√£o, R 1 √©  chamada  de rela√ß√£o  que referencia e R 2 √© a rela√ß√£o referenciada . Se essas condi√ß√µes se mantiverem, diz-se que √© mantida uma restri√ß√£o de integridade referencial de R 1 para R 2 .  Em um banco de dados de muitas rela√ß√µes, normalmente existem muitas restri√ß√µes de integridade referencial.

Para  especificar  essas  restri√ß√µes,  primeiro  devemos ter um conhecimento claro do significado ou papel que cada atributo, ou conjunto de atributos, que fazem parte nos diversos esquemas de rela√ß√£o do banco de dados. As restri√ß√µes de integridade referencial surgem com frequ√™ncia dos relacionamentos entre as entidades representadas  pelos  esquemas  de  rela√ß√£o. Por exemplo, considere o banco de dados mostrado na Figura 3.6. Na rela√ß√£o FUNCIONARIO , o atributo Dnr refere-se  ao  departamento  para  o  qual  um  funcion√°rio trabalha; portanto, designamos Dnr para ser a chave estrangeira de FUNCIONARIO que referencia a rela√ß√£o DEPARTAMENTO . Isso significa que um valor de Dnr em qualquer tupla t 1 da rela√ß√£o FUNCIONARIO precisa combinar com um valor da chave prim√°ria de DEPARTAMENTO - o atributo Dnumero - em alguma tupla t 2 da  rela√ß√£o DEPARTAMENTO ,  ou  o  valor de Dnr pode ser NULL se o funcion√°rio n√£o pertencer a  um departamento ou for atribu√≠do a um departamento mais tarde. Por exemplo, na Figura 3.6, a tupla para o funcion√°rio 'Jo√£o Silva' referencia a tupla para o departamento 'Pesquisa', indicando que 'Jo√£o Silva' trabalha para esse departamento.

Observe que uma chave estrangeira pode se  referir  a  sua  pr√≥pria  rela√ß√£o .  Por  exemplo, o atributo Cpf\_supervisor em FUNCIONARIO refere-se  ao  supervisor de um funcion√°rio; este √© outro funcion√°rio, representado por uma tupla na rela√ß√£o FUNCIONARIO .

## FUNCIONARIO

| Pnome    | Minicial   | Unome   |         Cpf | Datanasc   | Endereco                                | Sexo   |   Salario | Cpf_supervisor   |   Dnr |
|----------|------------|---------|-------------|------------|-----------------------------------------|--------|-----------|------------------|-------|
| Jo√£o     | B          | Silva   | 12345678966 | 09-01-1965 | Rua das Flores, 751, S√£o Paulo, SP      | M      |        30 | 33344555587      |     5 |
| Fernando | T          | Wong    | 33344555587 | 08-12-1955 | Rua da Lapa, 34, S√£o Paulo, SP          | M      |        40 | 88866555576      |     5 |
| Alice    | J          | Zelaya  | 99988777767 | 19-01-1968 | Rua Souza Lima, 35, Curitiba, PR        | F      |        25 | 98765432168      |     4 |
| Jennifer | S          | Souza   | 98765432168 | 20-06-1941 | Av. Arthur de Lima, 54, Santo Andr√©, SP | F      |        43 | 88866555576      |     4 |
| Ronaldo  | K          | Lima    | 66688444476 | 15-09-1962 | Rua Rebou√ßas, 65, Piracicaba, SP        | M      |        38 | 33344555587      |     5 |
| Joice    | A          | Leite   | 45345345376 | 31-07-1972 | Av. Lucas Obes, 74, S√£o Paulo, SP       | F      |        25 | 33344555587      |     5 |
| Andr√©    | V          | Pereira | 98798798733 | 29-03-1969 | Rua Timbira, 35, S√£o Paulo, SP          | M      |        25 | 98765432168      |     4 |
| Jorge    | E          | Brito   | 88866555576 | 10-11-1937 | Rua do Horto, 35, S√£o Paulo, SP         | M      |        55 | NULL             |     1 |

## depARtAmeNtO

## LOCALIZACAO\_dep

| Dnome         |   Dnumero |   Cpf_gerente | Data_inicio_gerente   |
|---------------|-----------|---------------|-----------------------|
| Pesquisa      |         5 |   33344555587 | 22-05-1988            |
| Administra√ß√£o |         4 |   98765432168 | 01-01-1995            |
| Matriz        |         1 |   88866555576 | 19-06-1981            |

## tRABALHA\_em

|   Dnumero | Dlocal      |
|-----------|-------------|
|         1 | S√£o Paulo   |
|         4 | Mau√°        |
|         5 | Santo Andr√© |
|         5 | Itu         |
|         5 | S√£o Paulo   |

## pROJetO

|        Fcpf |   Pnr | Horas   |
|-------------|-------|---------|
| 12345678966 |     1 | 32,5    |
| 12345678966 |     2 | 7,5     |
| 66688444476 |     3 | 40,0    |
| 45345345376 |     1 | 20,0    |
| 45345345376 |     2 | 20,0    |
| 33344555587 |     2 | 10,0    |
| 33344555587 |     3 | 10,0    |
| 33344555587 |    10 | 10,0    |
| 33344555587 |    20 | 10,0    |
| 99988777767 |    30 | 30,0    |
| 99988777767 |    10 | 10,0    |
| 98798798733 |    10 | 35,0    |
| 98798798733 |    30 | 5,0     |
| 98765432168 |    30 | 20,0    |
| 98765432168 |    20 | 15,0    |
| 88866555576 |    20 | NULL    |

| Projnome        |   Projnumero | Projlocal   |   Dnum |
|-----------------|--------------|-------------|--------|
| ProdutoX        |            1 | Santo Andr√© |      5 |
| ProdutoY        |            2 | Itu         |      5 |
| ProdutoZ        |            3 | S√£o Paulo   |      5 |
| Informatiza√ß√£o  |           10 | Mau√°        |      4 |
| Reorganiza√ß√£o   |           20 | S√£o Paulo   |      1 |
| Novosbenef√≠cios |           30 | Mau√°        |      4 |

## depeNdeNte

|        Fcpf | Nome_dependente   | Sexo   | Datanasc   | Parentesco   |
|-------------|-------------------|--------|------------|--------------|
| 33344555587 | Alicia            | F      | 05-04-1986 | Filha        |
| 33344555587 | Tiago             | M      | 25-10-1983 | Filho        |
| 33344555587 | Jana√≠na           | F      | 03-05-1958 | Esposa       |
| 98765432168 | Antonio           | M      | 28-02-1942 | Marido       |
| 12345678966 | Michael           | M      | 04-01-1988 | Filho        |
| 12345678966 | Alicia            | F      | 30-12-1988 | Filha        |
| 12345678966 | Elizabeth         | F      | 05-05-1967 | Esposa       |

## Figura 3.6

Um estado de banco de dados poss√≠vel para o esquema de banco de dados relacional EMPRESA.

Logo, Cpf\_supervisor √© uma chave estrangeira que referencia  a  pr√≥pria  rela√ß√£o FUNCIONARIO . Na Figura 3.6, a tupla que o funcion√°rio 'Jo√£o Silva' referencia √© a tupla do funcion√°rio 'Fernando Wong', indicando que 'Fernando Wong' √© o supervisor de 'Jo√£o Silva'.

Podemos exibir em forma de diagrama as restri√ß√µes de integridade referencial , desenhando um arco direcionado de cada chave estrangeira para a rela√ß√£o que ela referencia. Para ficar mais claro, a ponta da seta pode apontar para a chave prim√°ria da rela√ß√£o referenciada. A Figura 3.7 mostra o esquema da Fi-

## FUNCIONARIO

Figura 3.7



Restri√ß√µes de integridade referencial exibidas no esquema de banco de dados relacional EMPRESA.

gura 3.5 com as restri√ß√µes de integridade referencial mostradas dessa maneira.

Todas as restri√ß√µes de integridade dever√£o ser especificadas no esquema de banco de dados relacional (ou  seja,  definidas  como  parte  de  sua  defini√ß√£o)  se quisermos impor essas restri√ß√µes sobre os estados do banco de dados. Logo, a DDL inclui meios para especificar os diversos tipos de restri√ß√µes de modo que o SGBD possa imp√¥-las automaticamente. A maioria dos SGBDs relacionais admite restri√ß√µes de chave, integridade de entidade e integridade referencial. Essas restri√ß√µes s√£o especificadas como uma parte da defini√ß√£o de dados na DDL.

## 3.2.5 Outros tipos de restri√ß√µes

As restri√ß√µes de integridade anteriores est√£o inclu√≠das na linguagem de defini√ß√£o de dados porque ocorrem na maioria das aplica√ß√µes de banco de dados. No entanto, elas n√£o incluem uma grande classe de restri√ß√µes gerais, tamb√©m chamadas de restri√ß√µes de integridade sem√¢ntica , que podem ter de ser especificadas e impostas em um banco de dados relacional. Alguns exemplos dessas restri√ß√µes s√£o o sal√°rio de um funcion√°rio n√£o deve ser superior ao sal√°rio de seu supervisor e o n√∫mero m√°ximo de horas que um funcion√°rio pode trabalhar em todos os projetos por semana √© 56 . Essas restri√ß√µes podem ser especificadas e impostas em programas de aplica√ß√£o que atualizam o banco de dados, ou usando uma linguagem de especifica√ß√£o  de  restri√ß√£o de  uso  geral.  Mecanismos chamados triggers (gatilhos) e assertions (afirma√ß√µes) podem ser usados. Em SQL, os comandos CREATE ASSERTION e CREATE TRIGGER podem ser usados para essa finalidade (ver Cap√≠tulo 5). √â mais comum verificar esses tipos de restri√ß√µes em programas de aplica√ß√£o  do  que  usar  linguagens  de  especifica√ß√£o de restri√ß√£o, pois estas √†s vezes s√£o dif√≠ceis e complexas de se usar, conforme discutiremos na Se√ß√£o 26.1.

Outro tipo de restri√ß√£o √© a de depend√™ncia funcional , que estabelece um relacionamento funcional

entre dois conjuntos de atributos X e Y . Essa restri√ß√£o especifica que o valor de X determina um valor exclusivo de Y em todos os estados de uma rela√ß√£o; isso  √©  indicado  como  uma  depend√™ncia  funcional X ‚Üí Y . Usaremos depend√™ncias funcionais e outros tipos  de  depend√™ncias  nos  cap√≠tulos  15  e  16  como ferramentas para analisar a qualidade dos projetos relacionais e 'normalizar' rela√ß√µes para melhorar sua qualidade.

Os tipos de restri√ß√µes que discutimos at√© aqui podem ser chamados de restri√ß√µes de estado , pois definem as restri√ß√µes √†s quais um estado v√°lido do banco de dados precisa satisfazer. Outro tipo de restri√ß√£o, chamadas restri√ß√µes de transi√ß√£o ,  pode ser definido para lidar com mudan√ßas de estado no banco de dados. 11 Um exemplo de uma restri√ß√£o de transi√ß√£o √©: 'o sal√°rio de um funcion√°rio s√≥ pode aumentar'. Tais restri√ß√µes  costumam  ser  impostas  pelos  programas de aplica√ß√£o ou especificadas usando regras ativas e triggers, conforme discutiremos na Se√ß√£o 26.1.

## 3.3 Opera√ß√µes de atualiza√ß√£o, transa√ß√µes e tratamento de viola√ß√µes de restri√ß√£o

As opera√ß√µes do modelo relacional podem ser categorizadas em recupera√ß√µes e atualiza√ß√µes . As opera√ß√µes da √°lgebra relacional, que podem ser usadas para  especificar recupera√ß√£o ,  ser√£o  discutidas  com detalhes  no  Cap√≠tulo  6.  Uma  express√£o  da  √°lgebra relacional forma uma nova rela√ß√£o ap√≥s a aplica√ß√£o de uma s√©rie de operadores alg√©bricos a um conjunto existente  de  rela√ß√µes;  seu  uso  principal  √©  consultar um banco de dados a fim de recuperar informa√ß√µes. O usu√°rio formula uma consulta que especifica os dados de interesse, e uma nova rela√ß√£o √© formada aplicando operadores relacionais para recuperar esses dados. Esta rela√ß√£o resultado torna-se a resposta para a (ou resultado da) consulta do usu√°rio. O Cap√≠tulo 6 tamb√©m introduz a linguagem chamada c√°lculo relacional, que √© usada para definir a nova rela√ß√£o de forma declarativa sem dar uma ordem espec√≠fica das opera√ß√µes.

tuplas, e Update (ou Modify ) √© usado para alterar os valores de alguns atributos nas tuplas existentes. Sempre que essas opera√ß√µes s√£o aplicadas, as restri√ß√µes de integridade especificadas sobre o esquema de banco de dados relacional n√£o devem ser violadas. Nesta se√ß√£o, discutimos os tipos de restri√ß√µes que podem ser violadas por cada uma dessas opera√ß√µes e os tipos de a√ß√µes que podem ser tomados se uma opera√ß√£o causar uma viola√ß√£o. Usamos o banco de dados mostrado na Figura 3.6 para os exemplos e discutimos apenas as restri√ß√µes  de  chave,  restri√ß√µes  de  integridade de entidade e as restri√ß√µes de integridade referencial, mostradas na Figura 3.7. Para cada tipo de opera√ß√£o, damos alguns exemplos e discutimos as restri√ß√µes que cada opera√ß√£o pode violar.

## 3.3.1 A opera√ß√£o Inserir

A opera√ß√£o Inserir oferece uma lista de valores de atributo para que uma nova tupla   possa ser int serida em uma rela√ß√£o R .  Ela pode violar qualquer um dos quatro tipos de restri√ß√µes discutidos na se√ß√£o anterior. As restri√ß√µes de dom√≠nio podem ser violadas se for dado um valor de atributo que n√£o aparece no dom√≠nio correspondente ou n√£o √© do tipo de dado apropriado. As restri√ß√µes de chave podem ser violadas se um valor de chave na nova tupla   j√° existir t em outra tupla na rela√ß√£o  ( r R ). A integridade de entidade pode ser violada se qualquer parte da chave prim√°ria  da  nova  tupla t for NULL .  A  integridade referencial pode ser violada se o valor de qualquer chave estrangeira em t se referir a uma tupla que n√£o existe  na  rela√ß√£o  referenciada.  Aqui  est√£o  alguns exemplos para ilustrar essa discuss√£o.

- ¬Ñ Opera√ß√£o :

Inserir &lt;'Cecilia', 'F', 'Ribeiro', NULL , '05-041960', 'Rua Esmeraldas, 35, Bueno Brand√£o, MG', F, 28.000, NULL , 4&gt; em FUNCIONARIO .

Resultado : Esta inser√ß√£o viola a restri√ß√£o de integridade de entidade ( NULL para a chave prim√°ria Cpf ), de modo que √© rejeitada.

## ¬Ñ Opera√ß√£o :

Nesta se√ß√£o, concentramo-nos nas opera√ß√µes de modifica√ß√£o ou atualiza√ß√£o do banco de dados. Existem tr√™s opera√ß√µes b√°sicas que podem mudar os estados das rela√ß√µes no banco de dados: Inserir, Excluir e Alterar (ou Modificar). Elas inserem novos dados, excluem dados antigos ou modificam registros de dados existentes. Insert √© usado para inserir uma ou mais novas tuplas em uma rela√ß√£o, Delete √© usado para excluir

Inserir &lt;'Alice', 'J', 'Zelaya', '99988777767', '05-04-1960', 'Rua Souza Lima, 35, Curitiba,  PR',  F,  28.000,  '98765432168',  4&gt;  em FUNCIONARIO .

Resultado : Esta inser√ß√£o viola a restri√ß√£o de chave porque outra tupla com o mesmo valor de Cpf j√° existe na rela√ß√£o FUNCIONARIO , e, portanto, √© rejeitada.

11 As restri√ß√µes de estado tamb√©m podem ser chamadas de restri√ß√µes est√°ticas , e as restri√ß√µes de transi√ß√£o tamb√©m s√£o chamadas de restri√ß√µes din√¢micas .

## ¬Ñ Opera√ß√£o :

Inserir  &lt;'Cecilia',  'F',  'Ribeiro',  '67767898976', '05-04-1960',  'Rua  Esmeraldas,  35,  Bueno Brand√£o,  MG',  F,  28.000,  '98765432168', 7&gt; em FUNCIONARIO .

Resultado : Esta inser√ß√£o viola a restri√ß√£o de integridade referencial especificada sobre Dnr em FUNCIONARIO porque n√£o existe uma tupla referenciada correspondente em DEPAR -TAMENTO com Dnumero = 7.

- ¬Ñ Opera√ß√£o :

Inserir  &lt;'Cecilia',  'F',  'Ribeiro',  '67767898976', '05-04-1960',  'Rua  Esmeraldas,  35,  Bueno Brand√£o, MG', F, 28.000, NULL , 4&gt; em FUNCIONARIO .

Resultado : Esta inser√ß√£o satisfaz todas as restri√ß√µes, de modo que √© aceit√°vel.

Se  uma  inser√ß√£o  violar  uma  ou  mais  restri√ß√µes, a op√ß√£o padr√£o √© rejeitar a inser√ß√£o . Nesse caso,  seria  √∫til  se  o  SGBD  pudesse  oferecer  um motivo  ao  usu√°rio  sobre  a  rejei√ß√£o  da  inser√ß√£o. Outra op√ß√£o √© tentar corrigir o motivo da rejei√ß√£o da inser√ß√£o ,  mas  isso  normalmente  n√£o  √©  usado para viola√ß√µes causadas pela opera√ß√£o Inserir; em vez disso, √© usado com mais frequ√™ncia na corre√ß√£o de viola√ß√µes das opera√ß√µes Excluir e Alterar. Na primeira opera√ß√£o, o SGBD poderia pedir ao usu√°rio  para  oferecer  um  valor  para Cpf ,  e  poderia ent√£o aceitar a inser√ß√£o se um valor de Cpf v√°lido  fosse  fornecido.  Na  opera√ß√£o  3,  o  SGBD poderia pedir que o usu√°rio mudasse o valor de Dnr para  algum  valor  v√°lido  (ou  defini-lo  como NULL ),  ou  poderia  pedir  ao  usu√°rio  para  inserir uma tupla DEPARTAMENTO com Dnumero =  7  e poderia aceitar a inser√ß√£o original somente depois que uma opera√ß√£o fosse aceita. Observe que, no √∫ltimo caso, a viola√ß√£o de inser√ß√£o pode se propagar de volta √† rela√ß√£o FUNCIONARIO se o usu√°rio tentar inserir uma tupla para o departamento 7 com um valor para Cpf\_gerente que n√£o existe na rela√ß√£o FUNCIONARIO .

## 3.3.2 A opera√ß√£o Excluir

A opera√ß√£o Excluir pode violar apenas a integridade referencial. Isso ocorre se a tupla que est√° sendo exclu√≠da for referenciada por chaves estrangeiras de outras tuplas no banco de dados. Para especificar a exclus√£o, uma condi√ß√£o sobre os atributos da rela√ß√£o seleciona a tupla (ou tuplas) a ser(em) exclu√≠da(s). Aqui est√£o alguns exemplos.

- ¬Ñ Opera√ß√£o :

Excluir a tupla em TRABALHA\_EM com Fcpf = '99988777767' e Pnr = 10.

Resultado : Esta exclus√£o √© aceit√°vel e exclui exatamente uma tupla.

- ¬Ñ Opera√ß√£o :

Excluir a tupla em FUNCIONARIO com Cpf = '99988777767'.

Resultado : Esta exclus√£o n√£o √© aceit√°vel, pois existem tuplas em TRABALHA\_EM que se referenciam a esta tupla. Logo, se a tupla em FUNCIONARIO for exclu√≠da, haver√° viola√ß√µes de integridade referencial.

- ¬Ñ Opera√ß√£o :

Excluir a tupla em FUNCIONARIO com Cpf = '33344555587'.

Resultado :  Esta  exclus√£o  resultar√°  em  ainda mais viola√ß√µes de integridade referencial, pois a tupla envolvida √© referenciada por tuplas  das  rela√ß√µes FUNCIONARIO , DEPARTAMENTO  TRABALHA\_EM , e DEPENDENTE .

V√°rias op√ß√µes est√£o dispon√≠veis se uma opera√ß√£o de exclus√£o causar uma viola√ß√£o. A primeira op√ß√£o, chamada restrict , √© rejeitar a exclus√£o . A segunda op√ß√£o, chamada cascade , √© tentar propagar (ou gerar em cascata ) a exclus√£o excluindo tuplas que referenciam aquela que est√° sendo exclu√≠da. Por exemplo, na opera√ß√£o  2,  o  SGBD  poderia  excluir  automaticamente as tuplas problem√°ticas de TRABALHA\_EM com Fcpf = '99988777767'. Uma terceira op√ß√£o, chamada set null ou set default , √© modificar os valores de atributo que referenciam a causa da viola√ß√£o; cada valor desse tipo √© definido para NULL ou alterado para referenciar outra tupla de valor v√°lido. Observe que, se um atributo referenciando que causa uma viola√ß√£o faz parte da chave prim√°ria , ele n√£o pode ser definido como NULL ; caso contr√°rio, ele violaria a integridade de entidade.

Combina√ß√µes  dessas  tr√™s  op√ß√µes  tamb√©m  s√£o poss√≠veis. Por exemplo, para evitar que a opera√ß√£o 3  cause  uma  viola√ß√£o,  o  SGBD  pode  excluir  automaticamente  todas  as  tuplas  de TRABALHA\_EM e DEPENDENTE com Fcpf = '33344555587'. As tuplas em FUNCIONARIO com Cpf\_supervisor e  a  tupla  em DEPARTAMENTO com Cpf\_gerente = '33344555587' podem ter seus valores Cpf\_supervisor e Cpf\_gerente alterados para outros valores v√°lidos ou para NULL . Embora possa fazer sentido excluir automaticamente as tuplas de TRABALHA\_EM   DEPENDENTE e que se referem a uma tupla de FUNCIONARIO , pode n√£o fazer sentido excluir outras tuplas de FUNCIONARIO ou uma tupla de DEPARTAMENTO .

Em geral, quando uma restri√ß√£o de integridade referencial  √©  especificada  na  DDL,  o  SGBD  permitir√°  que o projetista de banco de dados especifique qual das op√ß√µes se aplica no caso de uma viola√ß√£o da restri√ß√£o. Discutiremos como especificar essas op√ß√µes na DDL SQL no Cap√≠tulo 4.

## 3.3.3 A opera√ß√£o Alterar

A opera√ß√£o Alterar (ou Modificar ) √© usada para alterar os valores de um ou mais atributos em uma tupla (ou tuplas) de alguma rela√ß√£o R . √â necess√°rio especificar uma condi√ß√£o sobre os atributos da rela√ß√£o para selecionar a tupla ou tuplas a serem modificadas. Aqui est√£o alguns exemplos.

- ¬Ñ Opera√ß√£o :

Alterar o sal√°rio da tupla em FUNCIONARIO com Cpf = '99988777767' para 28.000.

Resultado : Aceit√°vel.

- ¬Ñ Opera√ß√£o :

Alterar o Dnr da tupla em FUNCIONARIO com Cpf = '99988777767' para 1.

Resultado : Aceit√°vel.

- ¬Ñ Opera√ß√£o :

Alterar o Dnr da tupla em FUNCIONARIO com Cpf = '99988777767' para 7.

Resultado : Inaceit√°vel, pois viola a integridade referencial.

- ¬Ñ Opera√ß√£o :

Alterar o Cpf da tupla em FUNCIONARIO com Cpf = '99988777767' para '98765432168'.

Resultado :  Inaceit√°vel,  pois  viola  a  restri√ß√£o  de chave prim√°ria, repetindo um valor que j√° existe como chave prim√°ria em outra tupla; isso viola as  restri√ß√µes  de  integridade  referencial  porque existem outras rela√ß√µes que se referem ao valor existente de Cpf .

Atualizar um atributo que nem faz parte de uma chave prim√°ria nem de uma chave estrangeira em geral n√£o causa problemas; o SGBD s√≥ precisa verificar para confirmar se o novo valor √© do tipo de dado e dom√≠nio corretos. Modificar um valor de chave prim√°ria √© semelhante a excluir uma tupla e inserir outra em seu lugar, pois usamos a chave prim√°ria para identificar tuplas.  Logo,  as  quest√µes  discutidas  anteriormente  nas se√ß√µes 3.3.1 (Opera√ß√£o Inserir) e 3.3.2 (Opera√ß√£o Excluir) entram em cena. Se um atributo de chave estrangeira for modificado, o SGBD dever√° garantir que o novo valor referencia a uma tupla existente na rela√ß√£o referenciada (ou que seja definido como NULL ). Existem op√ß√µes semelhantes para lidar com as viola√ß√µes de integridade referencial causadas pela opera√ß√£o Alterar, como as op√ß√µes discutidas  para  a  opera√ß√£o  Excluir. De fato, quando uma restri√ß√£o de integridade referencial for especificada na DDL, o SGBD permitir√° que o usu√°  rio escolha op√ß√µes separadas para lidar com uma viola√ß√£o causada pela opera√ß√£o Excluir e uma viola√ß√£o causada pela opera√ß√£o Alterar (ver a Se√ß√£o 4.2).

## 3.3.4 O conceito de transa√ß√£o

Um programa de aplica√ß√£o de banco de dados que executa com um banco de dados relacional normalmente  executa  uma  ou  mais transa√ß√µes . Uma transa√ß√£o √©  um  programa  em  execu√ß√£o  que  inclui algumas opera√ß√µes de banco de dados, como fazer a leitura do banco de dados ou aplicar inser√ß√µes, exclus√µes ou atualiza√ß√µes a ele. Ao final da transa√ß√£o, ela precisa deixar o banco de dados em um estado v√°lido ou coerente, que satisfa√ßa todas as restri√ß√µes especificadas no esquema do banco de dados. Uma √∫nica transa√ß√£o pode envolver qualquer n√∫mero de opera√ß√µes de recupera√ß√£o (a serem discutidas como parte da √°lgebra e c√°lculo relacional no Cap√≠tulo 6, e como uma parte da linguagem SQL nos cap√≠tulos 4 e 5) e qualquer n√∫mero de opera√ß√µes de atualiza√ß√£o. Essas recupera√ß√µes e atualiza√ß√µes juntas formar√£o uma unidade at√¥mica de trabalho no banco de dados. Por exemplo, uma transa√ß√£o para aplicar um saque banc√°rio costuma ler o registro da conta do usu√°rio, verificar  se  existe  saldo  suficiente  e  depois atualizar o registro pelo valor do saque.

Um grande n√∫mero de aplica√ß√µes comerciais, que executam com bancos de dados relacionais em sistemas de processamento de transa√ß√£o on-line ( OLTP Online  Transaction  Processing ),  executa  transa√ß√µes que atingem taxas de centenas por segundo. Os conceitos de processamento de transa√ß√£o, execu√ß√£o concorrente de transa√ß√µes e recupera√ß√£o de falhas ser√£o discutidos nos cap√≠tulos 21 a 23.

## Resumo

Neste cap√≠tulo, apresentamos os conceitos de modelagem, estruturas de dados e restri√ß√µes, fornecidos pelo modelo relacional de dados. Come√ßamos apresentando os conceitos de dom√≠nios, atributos e tuplas. Depois, definimos um esquema de rela√ß√£o como uma lista de atributos que descrevem a estrutura de uma rela√ß√£o. Uma rela√ß√£o, ou estado de rela√ß√£o, √© um conjunto de tuplas que correspondem ao esquema.

V√°rias caracter√≠sticas diferenciam rela√ß√µes das tabelas ou arquivos comuns. A primeira √© que uma rela√ß√£o n√£o √© sens√≠vel  √†  ordem  das  tuplas.  A  segunda  envolve a  ordem dos atributos em um esquema de rela√ß√£o e a ordem correspondente dos valores dentro de uma tupla. Oferecemos  uma  defini√ß√£o  alternativa  de  rela√ß√£o  que n√£o exige essas duas ordens, mas continuamos a usar a

primeira defini√ß√£o, que requer que atributos e valores de tupla sejam ordenados, por conveni√™ncia. Depois, discutimos  os  valores  nas  tuplas  e  apresentamos  os  valores NULL para representar informa√ß√µes faltantes ou desconhecidas. Enfatizamos que valores NULL devem ser evitados ao m√°ximo.

Classificamos as restri√ß√µes  do  banco  de  dados  em restri√ß√µes inerentes baseadas no modelo, restri√ß√µes expl√≠citas baseadas no esquema e restri√ß√µes baseadas na aplica√ß√£o,  tamb√©m  conhecidas  como  restri√ß√µes  sem√¢nticas ou regras de neg√≥cios. Depois, discutimos as restri√ß√µes de  esquema  pertencentes  ao  modelo  relacional,  come√ßando com as restri√ß√µes de dom√≠nio, depois as restri√ß√µes de  chave,  incluindo  os  conceitos  de  superchave,  chave candidata e chave prim√°ria, e a restri√ß√£o NOT NULL sobre atributos. Definimos bancos de dados relacionais e esquemas de banco de dados relacionais. Outras restri√ß√µes relacionais incluem a restri√ß√£o de integridade de entidade, que pro√≠be que atributos de chave prim√°ria sejam NULL . Descrevemos a restri√ß√£o de integridade referencial entre rela√ß√µes, que √© usada para manter a consist√™ncia das refer√™ncias entre tuplas de diferentes rela√ß√µes.

As  opera√ß√µes  de  modifica√ß√£o  no  modelo  relacional s√£o Inserir, Excluir e Alterar. Cada opera√ß√£o pode violar certos tipos de restri√ß√µes (consulte a Se√ß√£o 3.3). Sempre que uma opera√ß√£o √© aplicada, o estado do banco de dados ap√≥s a opera√ß√£o ser executada deve ser verificado para garantir que nenhuma restri√ß√£o seja violada. Finalmente, apresentamos o conceito de transa√ß√£o, que √©  importante  nos  SGBDs  relacionais  porque  permite  o agrupamento de v√°rias opera√ß√µes de banco de dados em uma √∫nica a√ß√£o at√¥mica sobre o banco de dados.

## Perguntas de revis√£o

- 3.1. Defina os termos a seguir quando se aplicam ao modelo de dados relacional: dom√≠nio , atributo , tupla n , esquema de rela√ß√£o , estado de rela√ß√£o , grau da rela√ß√£o , esquema de banco de dados relacional e estado de banco de dados relacional .
- 3.2. Por que as tuplas em uma rela√ß√£o n√£o s√£o ordenadas?
- 3.3. Por que as tuplas duplicadas n√£o s√£o permitidas em uma rela√ß√£o?
- 3.4. Qual √© a diferen√ßa entre uma chave e uma superchave?
- 3.5. Por que designamos uma das chaves candidatas de uma rela√ß√£o como sendo a chave prim√°ria?
- 3.6. Discuta as caracter√≠sticas de rela√ß√µes que as tornam diferentes das tabelas e arquivos comuns.
- 3.7. Discuta os diversos motivos que levam √† ocorr√™ncia de valores NULL nas rela√ß√µes.
- 3.8. Discuta as restri√ß√µes de integridade de entidade e integridade referencial. Por que s√£o consideradas importantes?
- 3.9. Defina a chave estrangeira . Para que esse conceito √© usado?
- 3.10. O que √© uma transa√ß√£o? Como ela difere de uma opera√ß√£o atualiza√ß√£o?

## Exerc√≠cios

- 3.11. Suponha que cada uma das seguintes opera√ß√µes de atualiza√ß√£o seja aplicada diretamente ao estado do banco de dados mostrado na Figura 3.6. Discuta todas as restri√ß√µes de integridade violadas por cada opera√ß√£o, se houver, e as diferentes maneiras de lidar com essas restri√ß√µes.
- a. Inserir  &lt;'Roberto',  'F',  'Santos',  '94377554355', '21-06-1972',  'Rua  Benjamin,  34,  Santo  Andr√©,  SP',  M,  58.000,  '88866555576',  1&gt;  em FUNCIONARIO .
- b. Inserir &lt;'ProdutoA', 4, 'Santo Andr√©', 2&gt; em PROJETO .
- c. Inserir &lt;'Producao', 4, '94377554355', '0110-2007'&gt; em DEPARTAMENTO .
- d. Inserir  &lt;'67767898944', NULL ,  '40,0'&gt;  em TRABALHA\_EM .
- e. Inserir &lt;'45345345376', 'Jo√£o', 'M', '12-121990', 'marido'&gt; em DEPENDENTE .
- f. Excluir  as  tuplas  de TRABALHA\_EM com Fcpf = '33344555587'.
- g. Excluir a tupla de FUNCIONARIO com Cpf = '98765432168'.
- h. Excluir a tupla de PROJETO com Projnome = 'ProdutoX'.
- i. Modificar Cpf\_gerente e Data\_inicio\_gerente da tupla DEPARTAMENTO com Dnumero = 5  para  '12345678966'  e  '01-10-2007',  respectivamente.
- j. Modificar o atributo Cpf\_supervisor da tupla FUNCIONARIO com Cpf =  '99988777767' para '94377554355'.
- k. Modificar o atributo Horas da tupla TRABA-LHA\_EM com Fcpf = '99988777767' e Pnr = 10 para '5,0'.
- 3.12. Considere o esquema do banco de dados relacional COMPANHIA AEREA mostrado na Figura 3.8, que descreve um banco de dados para informa√ß√µes de voo. Cada VOO √© identificado por um Numero\_voo ,  e  consiste  em  um  ou  mais TRE-CHOs\_VOO com Numero\_trecho 1, 2, 3, e assim por diante. Cada TRECHO\_VOO tem agendados hor√°rios de chegada e sa√≠da, aeroportos e uma ou  mais INSTANCIAs\_TRECHO -  uma  para cada Data em  que  o  voo  ocorre. TARIFA s  s√£o mantidas  para  cada VOO .  Para  cada  inst√¢ncia de TRECHO\_VOO , RESERVAs\_ASSENTO s√£o mantidas, assim como a AERONAVE usada  no trecho e os hor√°rios de chegada e sa√≠da e aeroportos reais. Uma AERONAVE √© identificada por um Codigo\_aeronave e tem um TIPO\_AERONA-VE em particular. PODE\_POUSAR relaciona os

TIPOs\_AERONAVE aos AEROPORTO s  em  que eles podem aterrissar. Um AEROPORTO √© identificado  por  um Codigo\_aeroporto. Considere uma atualiza√ß√£o para o banco de dados COM -PANHIA AEREA entrar com uma reserva em um voo em particular ou trecho de voo em determinada data.

- a. Indique as opera√ß√µes para esta atualiza√ß√£o.

## AeROpORtO

## VOO

Numero\_voo

Companhia aerea

Dias da semana

## tReCHO\_VOO

| Numero_voo   | Numero_trecho   | Codigo_aeroporto_partida   | Horario_partida_previsto   |
|--------------|-----------------|----------------------------|----------------------------|
|              |                 | Codigo_aeroporto_chegada   | Horario_chegada_previsto   |

## INStANCIA\_tReCHO

| Numero_voo               | Numero_trecho Data       | Numero_trecho Data   |                          | Numero_assentos_disponiveis Codigo_aeronave   |
|--------------------------|--------------------------|----------------------|--------------------------|-----------------------------------------------|
| Codigo_aeroporto_partida | Codigo_aeroporto_partida | Horario_partida      | Codigo_aeroporto_chegada | Horario_chegada                               |

## tARIFA

## tIpO\_AeRONAVe

## pOde\_pOUSAR

Nome\_tipo\_aeronave

Codigo\_aeroporto

## AeRONAVe

Codigo\_aeronave

Numero\_total\_assentos

Tipo\_aeronave

## ReSeRVA\_ASSeNtO

Numero\_voo

Numero\_trecho

Data

Numero\_assento

Nome\_cliente

Telefone\_cliente

- b. Que tipos de restri√ß√µes voc√™ esperaria verificar?
- c. Quais dessas restri√ß√µes s√£o de chave, de integridade de entidade e de integridade referencial, e quais n√£o s√£o?
- d. Especifique todas as restri√ß√µes de integridade referencial que se mant√™m no esquema mostrado na Figura 3.8.

- 3.13. Considere a rela√ß√£o AULA ( Num\_disciplina , Num\_ turma , Nome\_professor , Semestre , Codigo\_ edificio , Num\_Sala   Turno   Dias\_da\_semana , , , Creditos ). Isso representa as aulas lecionadas em uma universidade, com Num\_Turma √∫nica. Identifique quais voc√™ acha que devem ser as diversas chaves candidatas e escreva, com suas palavras, as condi√ß√µes ou suposi√ß√µes sob as quais as chaves candidatas seriam v√°lidas.
- 3.14. Considere as seis rela√ß√µes a seguir para uma aplica√ß√£o de banco de dados de processamento de pedido em uma empresa:

CLIENTE(Num\_cliente, Nome\_cliente, Num\_

cidade) PEDIDO(Num\_pedido, Data\_pedido, Num\_ cliente, Num\_pedido) ITEM\_PEDIDO(Num\_pedido, Num\_item, Quantidade) ITEM(Num\_item, Preco\_unitario) EXPEDICAO(Num\_pedido, Num\_deposito, Data\_envio)

DEPOSITO(Num\_deposito#, Cidade)

Aqui, Valor\_pedido refere-se ao valor total em reais  de  um  pedido; Data\_pedido √©  a  data em que  o  pedido  foi  feito;  e Data\_envio √©  a  data  em que um pedido (ou parte de um pedido) √© despachado do dep√≥sito. Suponha que um pedido possa ser despachado de v√°rios dep√≥sitos. Especifique chaves estrangeiras para esse esquema, indicando quaisquer suposi√ß√µes que voc√™ fa√ßa. Que outras restri√ß√µes voc√™ imagina para esse banco de dados?

3.15. Considere as seguintes rela√ß√µes para um banco de  dados  que  registra  viagens  de  neg√≥cios  de vendedores em um escrit√≥rio de vendas:

VENDEDOR(Cpf, Nome, Ano\_inicio, Numero\_ departamento)

VIAGEM(Cpf, Cidade\_origem, Cidade\_destino,

Data\_partida, Data\_retorno, Cod\_viagem) DESPESA(Cod\_viagem, Num\_conta, Valor)

Uma viagem pode ser cobrada de uma ou mais contas  ( Num\_conta ).  Especifique  as  chaves  estrangeiras para esse esquema, indicando quaisquer suposi√ß√µes que voc√™ fa√ßa.

3.16. Considere as seguintes rela√ß√µes para um banco de dados que registra a matr√≠cula do aluno nas disciplinas e os livros adotados para cada disciplina:

ALUNO(Cpf, Nome, Curso, Datanasc) DISCIPLINA(Num\_Disciplina, Dnome, Dept)

INSCRICAO(Cpf, Num\_disciplina, Semestre, Nota) LIVRO\_ADOTADO(Num\_disciplina, Semestre, ISBN\_livro) LIVRO(ISBN\_livro, Titulo\_livro, Editora, Autor) que

Especifique as chaves estrangeiras para este esquema,  indicando quaisquer suposi√ß√µes voc√™ fa√ßa.

- 3.17. Considere as seguintes rela√ß√µes para um banco de dados que registra vendas de autom√≥veis em um  revendedor  de  carros  ( OPCAO refere-se  a algum  equipamento  opcional  instalado  em  um autom√≥vel):

CARRO(Numero\_chassi, Modelo, Fabricante, Preco)

OPCAO(Numero\_chassi, Nome\_opcional, Preco)

VENDA(Cod\_vendedor, Numero\_chassi, Data, Preco\_venda)

VENDEDOR(Cod\_vendedor, Nome, Telefone)

Primeiro, especifique as chaves estrangeiras para este  esquema,  indicando  quaisquer  suposi√ß√µes que voc√™ fa√ßa. Depois, preencha as rela√ß√µes com algumas tuplas de exemplo, e ent√£o mostre um exemplo de uma inser√ß√£o nas rela√ß√µes VENDA e VENDEDOR que viola as restri√ß√µes de integridade referencial e de outra inser√ß√£o que n√£o viola.

- 3.18. O projeto de banco de dados normalmente envolve decis√µes sobre o armazenamento de atributos. Por exemplo, o Cadastro de Pessoa F√≠sica pode ser  armazenado  como  um  atributo  ou  dividido em quatro atributos (um para cada um dos quatro  grupos  separados  por  h√≠fen  em  um  Cadastro  de  Pessoa  F√≠sica  -  XXX-XXX-XXX-XX). Por√©m, os n√∫meros do Cadastro de Pessoa F√≠sica costumam ser representados como apenas um atributo. A decis√£o √© baseada em como o banco de  dados  ser√°  usado.  Este  exerc√≠cio  pede  para voc√™ pensar nas situa√ß√µes espec√≠ficas onde a divis√£o do CPF √© √∫til.
- 3.19. Considere  uma  rela√ß√£o ALUNO em  um  banco  de  dados UNIVERSIDADE com  os  seguintes atributos (Nome Cpf Telefone\_local , , , Endereco , Telefone\_celular , Idade , Media ).  Observe que o telefone celular pode ser de uma cidade e estado diferentes do telefone local. Uma tupla poss√≠vel da rela√ß√£o √© mostrada a seguir:

| Nome            | Cpf          | Telefone_local   | Endereco         | Telefone_celular   | Idade   | Media   |
|-----------------|--------------|------------------|------------------|--------------------|---------|---------|
| Jorge Pereira   | 123-459-678- | 5555-1234        | Rua Cambar√°, 33, | 8555-4321          | 19      | 3,75    |
| William Ribeiro | 97           |                  | Bauru, SP        |                    |         |         |

3.20.

- a. Identifique a informa√ß√£o cr√≠tica que falta nos atributos Telefone\_local e Telefone\_celular . ( Dica: Como voc√™ liga para algu√©m que mora em um estado diferente?)
- b. Voc√™ armazenaria essa informa√ß√£o adicional nos atributos Telefone\_local e Telefone\_celu-lar ou  incluiria  novos  atributos  ao  esquema para ALUNO ?
- c. Considere  o  atributo Nome .  Quais  s√£o  as vantagens e desvantagens de dividir esse campo de um atributo em tr√™s atributos (primeiro nome, nome do meio e sobrenome)?
- d. Que orienta√ß√£o geral voc√™ daria para decidir quando armazenar informa√ß√µes em um √∫nico atributo e quando separar a informa√ß√£o?
- e. Suponha que o aluno possa ter entre 0 e 5 telefones. Sugira dois projetos diferentes que permitam esse tipo de informa√ß√£o.

Mudan√ßas  recentes  nas  leis  de  privacidade  dos EUA n√£o permitiram que as organiza√ß√µes usem n√∫meros de Seguro social (SSN) para identificar indiv√≠duos, a menos que certas restri√ß√µes sejam satisfeitas.  Como  resultado,  a  maioria  das  universidades nos EUA n√£o pode usar SSNs como chaves prim√°rias (exceto para dados financeiros). Na pr√°tica, Cod\_aluno ,  um identificador exclusivo atribu√≠do a cada aluno, provavelmente ser√° usado como chave prim√°ria, em vez do Ssn, pois Cod\_aluno pode ser usado por todo o sistema.

- a. Alguns projetistas de banco de dados s√£o relutantes em usar chaves geradas (tamb√©m conhecidas como chaves substitutas ) para chaves  prim√°rias  (como Cod\_aluno ),  pois  elas s√£o artificiais. Voc√™ consegue propor algumas escolhas  naturais  de  chaves  que  podem  ser usadas para identificar o registro do aluno no banco de dados UNIVERSIDADE ?
- b. Suponha que voc√™ consiga garantir a exclusividade de uma chave natural que inclua sobrenome. Voc√™ tem garantias de que ele n√£o mudar√° durante o tempo de vida do banco de dados? Se o sobrenome puder mudar, quais solu√ß√µes √≥bvias voc√™ pode propor para criar
- uma chave prim√°ria que ainda o inclua, mas permane√ßa exclusiva?
- c. Quais  s√£o  as  vantagens  e  desvantagens  de usar chaves geradas (substitutas)?

## Bibliografia selecionada

O  modelo  relacional  foi  introduzido  por  Codd (1970)  em  um  artigo  cl√°ssico.  Codd  tamb√©m  introduziu  a  √°lgebra  relacional  e  estabeleceu  as  bases  te√≥ricas para o modelo relacional em uma s√©rie de artigos (Codd, 1971, 1972, 1972a, 1974); mais tarde, ele recebeu o Turing Award, a honra mais alta da ACM (Association for Computing Machinery) por seu trabalho sobre o modelo relacional. Em um artigo posterior, Codd (1979) discutiu a extens√£o do modelo relacional para incorporar mais metadados e sem√¢ntica sobre as rela√ß√µes. Ele tamb√©m prop√¥s uma l√≥gica de tr√™s valores para lidar com a incerteza nas rela√ß√µes e incorporar NULL s na √°lgebra relacional. O modelo resultante  √©  conhecido  como  RM/  T.  Childs  (1968)  usou inicialmente a teoria de conjunto para modelar bancos de dados. Mais tarde, Codd (1990) publicou um livro examinando mais de 300 recursos do modelo de dados relacional e sistemas de banco de dados. Date (2001) oferece uma cr√≠tica e an√°lise retrospectiva do modelo de dados relacional.

Desde o trabalho pioneiro de Codd, muita pesquisa tem sido realizada sobre v√°rios aspectos do modelo relacional. Todd (1976) descreve um SGBD experimental chamado PRTV que implementa diretamente as opera√ß√µes da √°lgebra relacional. Schmidt e Swenson (1975) apresentam sem√¢ntica adicional para o modelo relacional classificando diferentes tipos de rela√ß√µes. O modelo Entidade-Relacionamento de Chen (1976), que ser√° discutido no Cap√≠tulo 7, √© um meio de comunicar a sem√¢ntica do mundo real de um banco de dados relacional no n√≠vel conceitual. Wiederhold e Elmasri (1979) introduzem diversos tipos de conex√µes entre rela√ß√µes para aprimorar suas restri√ß√µes. As extens√µes do modelo relacional ser√£o discutidas nos cap√≠tulos 11 e 26. Notas bibliogr√°ficas adicionais para outros aspectos do modelo relacional e suas linguagens, sistemas, extens√µes e teoria ser√£o apresentados nos cap√≠tulos 4 a 6, 9, 11, 13, 15, 16, 24 e 25. Maier (1983) e Atzeni e De Antonellis  (1993)  oferecem um extenso tratamento te√≥rico do modelo de dados relacional.

4

A linguagem SQL pode ser considerada um dos principais motivos para o sucesso dos bancos de dados relacionais comerciais. Como ela se tornou um padr√£o para esse tipo de bancos de dados, os usu√°rios ficaram menos preocupados com a migra√ß√£o de suas aplica√ß√µes de outros tipos de sistemas de banco de dados - por exemplo, sistemas de rede e hier√°rquicos - para sistemas relacionais. Isso aconteceu porque, mesmo que os usu√°rios estivessem insatisfeitos com o produto de SGBD relacional em particular que estavam usando, a convers√£o para outro produto de SGBD relacional n√£o seria t√£o cara ou demorada, pois os dois sistemas seguiam os mesmos padr√µes de linguagem. Na pr√°tica,  √©  √≥bvio,  existem muitas diferen√ßas entre diversos pacotes de SGBD relacionais comerciais. Por√©m, se o usu√°rio for cuidadoso em usar apenas dos recursos que fazem parte do padr√£o, e se os dois sistemas relacionais admitirem fielmente o padr√£o, ent√£o a convers√£o entre  ambos  dever√°  ser  bastante  simplificada.  Outra vantagem de ter esse padr√£o √© que os usu√°rios podem escrever comandos em um programa de aplica√ß√£o de banco de dados que pode acessar dados armazenados em dois ou mais SGBDs relacionais sem ter de mudar a sublinguagem de banco de dados (SQL) se os sistemas admitirem o padr√£o SQL.

Este cap√≠tulo apresenta os principais recursos do padr√£o  SQL  para  SGBDs  relacionais comerciais ,  enquanto o Cap√≠tulo 3 apresentou os conceitos mais importantes por tr√°s do modelo de dados relacional formal . No Cap√≠tulo 6 (se√ß√µes 6.1 a 6.5), discutiremos as opera√ß√µes da √°lgebra relacional , que s√£o muito importantes para entender os tipos de solicita√ß√µes que podem ser especificadas em um banco de dados relacional. Elas tamb√©m s√£o importantes para processamento e otimiza√ß√£o de consulta em um SGBD relacional, conforme veremos no Cap√≠tulo 19. No entanto, as opera√ß√µes da

## SQL b√°sica

√°lgebra relacional s√£o consideradas muito t√©cnicas para a maioria dos usu√°rios de SGBD comercial, pois uma consulta em √°lgebra relacional √© escrita como uma sequ√™ncia de opera√ß√µes que, quando executadas, produz o resultado exigido. Logo, o usu√°rio precisa especificar como - ou seja, em que ordem - executar as opera√ß√µes de consulta. Por sua vez, a linguagem SQL oferece uma interface de linguagem declarativa de  n√≠vel  mais alto, de modo que o usu√°rio apenas especifica qual deve ser o resultado, deixando a otimiza√ß√£o real e as decis√µes sobre como executar a consulta para o SGBD. Embora a SQL inclua alguns recursos da √°lgebra relacional, ela √© baseada em grande parte no c√°lculo relacional de tupla , que descrevemos na Se√ß√£o 6.6. Por√©m, a sintaxe SQL √© mais f√°cil de ser utilizada do que qualquer uma das duas linguagens formais.

O  nome SQL hoje  √©  expandido  como  Structured Query  Language  (Linguagem  de  Consulta Estruturada).  Originalmente,  SQL  era  chamada  de SEQUEL (Structured English QUEry Language) e foi criada e implementada na IBM Research como a interface para um sistema de banco de dados relacional experimental, chamado SYSTEM R. A SQL agora √© a linguagem padr√£o para SGBDs relacionais comerciais. Um esfor√ßo conjunto entre o American National Standards Institute (ANSI) e a International Standards Organization (ISO) levou a uma vers√£o-padr√£o da SQL (ANSI, 1986), chamada SQL-86 ou SQL1. Um padr√£o revisado e bastante expandido, denominado  SQL-92  (tamb√©m  conhecido  como  SQL2)  foi desenvolvido mais tarde. O pr√≥ximo padr√£o reconhecido foi SQL:1999, que come√ßou como SQL3. Duas atualiza√ß√µes posteriores ao padr√£o s√£o SQL:2003 e SQL:2006, que acrescentaram recursos de XML (ver Cap√≠tulo 12) entre outras atualiza√ß√µes para a linguagem.  Outra  atualiza√ß√£o  em  2008  incorporou  mais

recursos de banco de dados de objeto na SQL (ver Cap√≠tulo 11). Tentaremos abordar a √∫ltima vers√£o da SQL ao m√°ximo poss√≠vel.

SQL √© uma linguagem de banco de dados abrangente: tem instru√ß√µes para defini√ß√£o de dados, consultas  e  atualiza√ß√µes.  Logo,  ela  √©  uma  DDL e uma DML. Al√©m disso,  ela  tem  facilidades  para  definir vis√µes sobre o banco de dados, para especificar seguran√ßa e autoriza√ß√£o, para definir restri√ß√µes de integridade e para especificar controles de transa√ß√£o. Ela tamb√©m possui regras para embutir instru√ß√µes SQL em  uma  linguagem  de  programa√ß√£o  de  uso  geral, como Java, COBOL ou C/C++. 1

Os padr√µes SQL mais recentes (come√ßando com SQL:1999 )  s√£o divididos em uma especifica√ß√£o n√∫cleo mais extens√µes especializadas. O n√∫cleo deve ser implementado por todos os fornecedores de SGBDR que sejam compat√≠veis com SQL. As extens√µes podem ser implementadas como m√≥dulos opcionais a serem adquiridos independentemente para aplica√ß√µes de banco de dados espec√≠ficas, como minera√ß√£o de dados, dados espaciais, dados temporais, data warehousing,  processamento  anal√≠tico  on-line  (OLAP), dados de multim√≠dia e assim por diante.

Como a SQL √© muito importante (e muito grande), dedicamos dois cap√≠tulos para explicar seus recursos. Neste cap√≠tulo, a Se√ß√£o 4.1 descreve os comandos de DDL da SQL para cria√ß√£o de esquemas e tabelas, e oferece uma vis√£o geral dos tipos de dados b√°sicos  em  SQL.  A  Se√ß√£o  4.2  apresenta  como  restri√ß√µes  b√°sicas,  chave  e  integridade  referencial,  s√£o especificadas.  A  Se√ß√£o  4.3  descreve  as  constru√ß√µes b√°sicas da SQL para especificar recupera√ß√£o de consultas, e a Se√ß√£o 4.4 descreve os comandos SQL para inser√ß√£o, exclus√£o e altera√ß√£o de dados.

No  Cap√≠tulo  5,  descreveremos  recupera√ß√£o  de consultas SQL mais complexas, bem como comandos ALTER para alterar o esquema. Tamb√©m descreveremos a instru√ß√£o CREATE ASSERTION , que permite a especifica√ß√£o de restri√ß√µes mais gerais no banco de dados. Tamb√©m apresentamos o conceito de triggers, que  ser√°  abordado  com  mais  detalhes  no  Cap√≠tulo 26,  e  descreveremos  a  facilidade  SQL  para  definir views no banco de dados no Cap√≠tulo 5. As views tamb√©m s√£o conhecidas como tabelas virtuais ou tabelas derivadas porque apresentam ao usu√°rio o que parecem ser tabelas; por√©m, a informa√ß√£o nessas tabelas √© derivada de tabelas previamente definidas.

A  Se√ß√£o  4.5  lista  alguns  dos  recursos  da  SQL que ser√£o apresentados em outros cap√≠tulos do livro; entre eles est√£o o controle de transa√ß√£o no Cap√≠tulo

21,  seguran√ßa/autoriza√ß√£o  no  Cap√≠tulo  24,  bancos de dados ativos (triggers) no Cap√≠tulo 26, recursos orientados a objeto no Cap√≠tulo 11 e recursos de processamento anal√≠tico on-line (OLAP) no Cap√≠tulo 29. No final deste cap√≠tulo h√° um resumo. Os cap√≠tulos 13 e 14 discutem as diversas t√©cnicas de programa√ß√£o em banco de dados para programa√ß√£o com SQL.

## 4.1 Defini√ß√µes e tipos de dados em SQL

A SQL usa os termos tabela , linha e coluna para os termos do modelo relacional formal rela√ß√£o , tupla e atributo , respectivamente. Usaremos os termos correspondentes para indicar a mesma coisa. O principal comando SQL para a defini√ß√£o de dados √© o CREATE , que pode ser usado para criar esquemas, tabelas (rela√ß√µes) e dom√≠nios (bem como outras constru√ß√µes como views, assertions e triggers). Antes de descrevermos a import√¢ncia das instru√ß√µes CREATE , vamos discutir os conceitos de esquema e cat√°logo na Se√ß√£o 4.1.1 para contextualizar nossa discuss√£o. A Se√ß√£o 4.1.2 descreve  como  as  tabelas  s√£o  criadas,  e  a  Se√ß√£o  4.1.3,  os tipos de dados mais importantes dispon√≠veis para especifica√ß√£o de atributo. Como a especifica√ß√£o SQL √© muito grande, oferecemos uma descri√ß√£o dos recursos mais importantes. Outros detalhes poder√£o ser encontrados em diversos documentos dos padr√µes SQL (ver bibliografia selecionada ao final do cap√≠tulo).

## 4.1.1 Conceitos de esquema e cat√°logo em SQL

As primeiras vers√µes da SQL n√£o inclu√≠am o conceito  de  um esquema de banco de dados relacional; todas as tabelas (rela√ß√µes) eram consideradas parte do mesmo esquema. O conceito de um esquema SQL foi incorporado inicialmente com SQL2 a fim de agrupar tabelas  e  outras  constru√ß√µes  que  pertencem  √†  mesma aplica√ß√£o de banco de dados. Um esquema SQL √© identificado por um nome de esquema , e inclui um identificador de autoriza√ß√£o para indicar o usu√°rio ou conta propriet√°rio do esquema, bem como descritores para cada  elemento .  Esses elementos incluem  tabelas,  restri√ß√µes,  views,  dom√≠nios  e  outras  constru√ß√µes (como  concess√µes  grants -  de  autoriza√ß√£o)  que descrevem o esquema que √© criado por meio da instru√ß√£o CREATE SCHEMA . Esta pode incluir todas as defini√ß√µes dos elementos do esquema. Como alternativa, o esquema pode receber um identificador de nome e autoriza√ß√£o, e os elementos podem ser definidos mais tarde. Por exemplo, a instru√ß√£o a seguir cria um esque-

1 Originalmente, a SQL tinha instru√ß√µes para criar e remover √≠ndices nos arquivos que representam as rela√ß√µes, mas estes foram retirados do padr√£o SQL por algum tempo.

ma chamado EMPRESA , pertencente ao usu√°rio com identificador de autoriza√ß√£o 'Jsilva'. Observe que cada instru√ß√£o em SQL termina com um ponto e v√≠rgula.

## CREATE SCHEMA EMPRESA AUTHORIZATION 'Jsilva';

Em geral, nem todos os usu√°rios est√£o autorizados a criar esquemas e elementos do esquema. O privil√©gio para criar esquemas, tabelas e outras constru√ß√µes deve ser concedido explicitamente √†s contas de usu√°rio relevantes pelo administrador do sistema ou DBA.

Al√©m do conceito de um esquema, a SQL usa o conceito de um cat√°logo - uma cole√ß√£o nomeada de esquemas em um ambiente SQL. Um ambiente SQL √© basicamente uma instala√ß√£o de um SGBDR compat√≠vel com SQL em um sistema de computador. 2  Um cat√°logo sempre cont√©m um esquema especial, chamado INFORMATION\_SCHEMA , que oferece informa√ß√µes sobre todos os esquemas no cat√°logo e todos os seus  descritores  de  elemento.  As  restri√ß√µes  de  integridade,  como a integridade referencial, podem ser definidas entre as rela√ß√µes somente se existirem nos esquemas dentro do mesmo cat√°logo. Os esquemas dentro do mesmo cat√°logo tamb√©m podem compartilhar certos elementos, como defini√ß√µes de dom√≠nio.

## 4.1.2 O comando CREATE TABLE em SQL

O  comando CREATE TABLE √©  usado  para  especificar  uma  nova  rela√ß√£o,  dando-lhe  um  nome  e especificando  seus  atributos  e  restri√ß√µes  iniciais.  Os atributos s√£o especificados primeiro, e cada um deles recebe um nome, um tipo de dado para especificar seu dom√≠nio de valores e quaisquer restri√ß√µes de atributo, como NOT NULL . As restri√ß√µes de chave, integridade de entidade e integridade referencial podem ser especificadas na instru√ß√£o CREATE TABLE , depois que os atributos forem declarados, ou acrescentadas depois, usando o comando ALTER TABLE (ver Cap√≠tulo 5). A Figura 4.1 mostra exemplos de instru√ß√µes de defini√ß√£o de dados em SQL para o esquema de banco de dados relacional EMPRESA da Figura 3.7.

Em geral, o esquema SQL em que as rela√ß√µes s√£o declaradas √© especificado implicitamente no ambiente em que as instru√ß√µes CREATE TABLE s√£o executadas. Como alternativa, podemos conectar explicitamente o nome do esquema ao nome da rela√ß√£o, separados por um ponto. Por exemplo, escrevendo

## CREATE TABLE EMPRESA.FUNCIONARIO ...

em vez de

## CREATE TABLE FUNCIONARIO ...

como na Figura 4.1, podemos explicitamente (ao inv√©s de implicitamente) tornar a tabela FUNCIONARIO parte do esquema EMPRESA .

As  rela√ß√µes  declaradas  por  meio  das  instru√ß√µes CREATE TABLE s√£o chamadas de tabelas da base (ou rela√ß√µes da base); isso significa que a rela√ß√£o e suas tuplas s√£o realmente criadas e armazenadas como um arquivo pelo SGBD. As rela√ß√µes da base s√£o distintas das rela√ß√µes virtuais , criadas por meio da instru√ß√£o CREATE VIEW (ver Cap√≠tulo 5), que podem ou n√£o corresponder a um arquivo f√≠sico real. Em SQL, os atributos em uma tabela da base s√£o considerados ordenados na sequ√™ncia em que s√£o especificados no comando CREATE TABLE . No entanto, as linhas (tuplas) n√£o s√£o consideradas ordenadas dentro de uma rela√ß√£o.

√â importante observar que, na Figura 4.1, existem algumas chaves estrangeiras que podem causar erros , pois s√£o especificadas por refer√™ncias circulares ou porque dizem respeito a uma tabela que ainda n√£o foi criada. Por exemplo, a chave estrangeira Cpf\_su-pervisor na tabela FUNCIONARIO √© uma refer√™ncia circular, pois se refere √† pr√≥pria tabela. A chave estrangeira Dnr na tabela FUNCIONARIO se  refere √† tabela DEPARTAMENTO , que ainda n√£o foi criada. Para lidar com esse tipo de problema, essas restri√ß√µes podem ser omitidas inicialmente do comando CREATE TABLE , e depois acrescentadas usando a instru√ß√£o ALTER TABLE (ver Cap√≠tulo 5). Apresentamos todas as chaves estrangeiras na Figura 4.1, para mostrar o esquema EMPRESA completo em um s√≥ lugar.

## 4.1.3 Tipos de dados de atributo e dom√≠nios em SQL

Os tipos de dados b√°sicos dispon√≠veis para atributos s√£o num√©rico, cadeia ou sequ√™ncia de caracteres, cadeia ou sequ√™ncia de bits, booleano, data e hora.

- ¬Ñ Os tipos de dados numerico incluem n√∫meros inteiros de v√°rios tamanhos ( INTEGER ou INT e SMALLINT ) e n√∫meros de ponto flutuante (reais) de v√°rias precis√µes ( FLOAT ou REAL e DOUBLE PRECISION ). O formato dos n√∫meros pode ser declarado usando DECIMAL ( , i j )  - ou DEC ( , i j ) ou NUMERIC ( , i j ) - onde  , a i precis√£o , √© o n√∫mero total de d√≠gitos decimais e  , a j escala , √© o n√∫mero de d√≠gitos ap√≥s o ponto decimal. O valor padr√£o para a escala √© zero, e para a precis√£o, √© definido pela implementa√ß√£o.
- ¬Ñ Tipos de dados de cadeia de caracteres s√£o de tamanho fixo CHAR ( n )  ou CHARACTER ( n ), onde n √©  o  n√∫mero  de  caracteres  -  ou  de tamanho vari√°vel VARCHAR ( n )  ou CHAR

## CREATE TABLE FUNCIONARIO

(Pnome

VARCHAR(15)

NOT NULL,

Minicial

CHAR,

NOT NULL,

Unome

VARCHAR(15)

Cpf

CHAR(11),

NOT NULL,

Datanasc

DATE,

Endere√ßo

VARCHAR(30),

Sexo

CHAR,

Salario

DECIMAL(10,2),

Cpf\_supervisor

CHAR(11),

NOT NULL,

Dnr

INT

PRIMARY KEY (Cpf),

FOREIGN KEY (Cpf\_supervisor) REFERENCES

FUNCIONARIO(Cpf),

FOREIGN KEY (Dnr) REFERENCES DEPARTAMENTO(Dnumero) );

## CREATE TABLE DEPARTAMENTO

( Dnome

VARCHAR(15)

NOT NULL,

Dnumero

INT

NOT NULL,

Cpf\_gerente

CHAR(11),

NOT NULL,

Data\_inicio\_gerente

DATE,

PRIMARY KEY (Dnumero),

UNIQUE (Dnome),

FOREIGN KEY (Cpf\_gerente) REFERENCES FUNCIONARIO(Cpf) );

## CREATE TABLE LOCALIZACAO\_DEP

( Dnumero

INT

NOT NULL,

Dlocal

VARCHAR(15)

NOT NULL,

PRIMARY KEY (Dnumero, Dlocal),

## FOREIGN KEY (Dnumero) REFERENCES DEPARTAMENTO(Dnumero) );

## CREATE TABLE PROJETO

( Projnome

VARCHAR(15)

NOT NULL,

Projnumero

INT

NOT NULL,

Projlocal

VARCHAR(15),

NOT NULL,

Dnum

INT

PRIMARY KEY (Projnumero),

UNIQUE (Projnome),

FOREIGN KEY (Dnum) REFERENCES DEPARTAMENTO(Dnumero) );

## CREATE TABLE TRABALHA\_EM

( Fcpf

CHAR(9)

NOT NULL,

Pnr

INT

NOT NULL,

Horas

DECIMAL(3,1)

NOT NULL,

PRIMARY KEY (Fcpf, Pnr),

FOREIGN KEY (Fcpf)

REFERENCES FUNCIONARIO(Cpf),

FOREIGN KEY (Pnr) REFERENCES

PROJETO(Projnumero) );

## CREATE TABLE DEPENDENTE

( Fcpf

CHAR(11),

NOT NULL,

Nome\_dependente

VARCHAR(15)

NOT NULL,

Sexo

CHAR,

Datanasc

DATE,

Parentesco

VARCHAR(8),

PRIMARY KEY

(Fcpf, Nome\_dependente),

FOREIGN KEY (Fcpf) REFERENCES FUNCIONARIO(Cpf) );

## Figura 4.1

Instru√ß√µes CREATE TABLE da SQL para defini√ß√£o do esquema EMPRESA da Figura 3.7.

VARYING ( n ) ou CHARACTER  VARYING ( n ), onde n √© o n√∫mero m√°ximo de caracteres. Ao especificar  um valor literal  de  cadeia  de  caracteres,  ele  √©  colocado  entre  aspas  simples (ap√≥strofos),  e  √© case  sensitive (diferencia mai√∫sculas de min√∫sculas). 3  Para cadeias de caracteres de tamanho fixo, uma cadeia mais curta √© preenchida com caracteres em branco √† direita. Por exemplo, se o valor 'Silva' for para um atributo do tipo CHAR (10), ele √© preenchido com cinco caracteres em branco para se tornar 'Silva     ', se necess√°rio. Os espa√ßos preenchidos geralmente s√£o ignorados quando as cadeias s√£o comparadas. Para fins de compara√ß√£o, as cadeias de caracteres s√£o consideradas ordenadas em ordem alfab√©tica (ou lexicogr√°fica); se uma cadeia str1 aparecer antes de outra cadeia str2 em ordem alfab√©tica, ent√£o str1 √© considerada menor que str2 . 4 H√° tamb√©m um operador de concatena√ß√£o indicado por || (barra vertical dupla), que pode  concatenar  duas  cadeias  de  caracteres em SQL. Por exemplo, 'abc' || 'XYZ' resulta em uma √∫nica cadeia 'abcXYZ'. Outro tipo de dado de cadeia de caracteres de tamanho vari√°vel, chamado CHARACTER LARGE OBJECT ou CLOB , tamb√©m est√° dispon√≠vel para especificar colunas que possuem grandes valores  de  texto,  como  documentos.  O  tamanho m√°ximo de CLOB pode ser especificado em kilobytes (K), megabytes (M) ou gigabytes (G). Por exemplo, CLOB (20M) especifica um tamanho m√°ximo de 20 megabytes.

- ¬Ñ Tipos de dados de cadeia de bits podem ser de tamanho fixo n -BIT ( n ) - ou de tamanho vari√°vel BIT VARYING ( n ), onde n √© o n√∫mero m√°ximo de bits. O valor padr√£o para n , o tamanho de uma cadeia de caracteres ou cadeia de bits, √© 1. Os literais de cadeia de bits literais s√£o colocados entre ap√≥strofos, mas precedidos por um B para distingui-los das cadeias de caracteres; por exemplo, B '10101'. 5 Outro tipo de dados de cadeia de bits de tamanho vari√°vel, chamado BINARY LARGE OBJECT ou BLOB , tamb√©m est√° dispon√≠vel para especificar colunas que possuem grandes valores bin√°rios, como imagens. Assim como para CLOB ,  o  tamanho m√°ximo de um BLOB pode ser especificado em kilobits (K), megabits

3 Isso n√£o acontece com palavras-chave da SQL, como CREATE ou CHAR. Com as palavras-chave, a SQL √© case insensitive , significando que ela trata letras mai√∫sculas e min√∫sculas como equivalentes nessas palavras.

4 Para caracteres n√£o alfab√©ticos, existe uma ordem definida.

5 Cadeias de bits cujo tamanho √© um m√∫ltiplo de 4 podem ser especificadas em nota√ß√£o hexadecimal , em que a cadeia literal √© precedida por X e cada caractere hexadecimal representa 4 bits.

- (M) ou gigabits (G). Por exemplo, BLOB (30G) especifica um tamanho m√°ximo de 30 gigabits.
- ¬Ñ Um tipo de dado booleano tem os valores tradicionais TRUE  (verdadeiro) ou FALSE  (falso) . Em SQL, devido √† presen√ßa de valores NULL (nulos) , uma l√≥gica de tr√™s valores √© utilizada, de modo que um terceiro valor poss√≠vel para um tipo de dado booleano √© UNKNOWN (indefinido) .  Discutiremos  a  necessidade  de UNKNOWN e a l√≥gica de tr√™s valores no Cap√≠tulo 5.
- ¬Ñ O tipo de dados DATE possui dez posi√ß√µes, e seus componentes s√£o DAY (dia) , MONTH (m√™s) e YEAR (ano) na forma DD-MM-YYYY. O tipo de dado TIME (tempo) tem pelo menos oito posi√ß√µes, com os componentes HOUR (hora) , MINUTE (minuto) e SECOND (segundo) na forma HH:MM:SS. Somente datas e horas v√°lidas devem ser permitidas pela implementa√ß√£o SQL. Isso implica que os meses devem estar entre 1 e 12 e as datas devem estar entre 1 e 31; al√©m disso, uma data deve ser uma data v√°lida para o m√™s correspondente. A compara√ß√£o &lt; (menor que) pode ser usada com datas ou horas uma data anterior √©  considerada  menor  que uma data posterior, e da mesma forma com o tempo. Os valores literais s√£o representados por  cadeias  com  ap√≥strofos  precedidos  pela palavra-chave DATE ou TIME ;  por  exemplo, DATE '27-09-2008' ou TIME '09:12:47'. Al√©m disso, um tipo de dado TIME ( ), onde   √© chai i mado  de precis√£o  em  segundos  fracion√°rios de tempo , especifica   + 1 posi√ß√µes adicionais i para TIME - uma posi√ß√£o para um caractere separador de per√≠odo adicional (.), e   posi√ß√µes i para especificar as fra√ß√µes de um segundo. Um tipo  de  dados TIME  WITH  TIME  ZONE inclui seis posi√ß√µes adicionais para especificar o deslocamento com base no fuso hor√°rio universal padr√£o, que est√° na faixa de +13:00 a -12:59 em  unidades  de HOURS:MINUTES .  Se WITH TIME ZONE n√£o for inclu√≠do, o valor padr√£o √© o fuso hor√°rio local para a sess√£o SQL.

Alguns tipos de dados adicionais s√£o discutidos a seguir. A lista apresentada aqui n√£o est√° completa; diferentes implementa√ß√µes acrescentaram mais tipos de dados √† SQL.

- ¬Ñ Um  tipo  de  dado timestamp (TIMESTAMP ) inclui os campos DATE e TIME , mais um m√≠nimo de seis posi√ß√µes para fra√ß√µes decimais de segundos e um qualificador opcional WITH TIME ZONE . Valores literais s√£o representados por cadeias entre ap√≥strofos precedidos pela palavra-chave TIMESTAMP ,  com  um  espa√ßo
- em branco entre data e hora; por exemplo, TIMESTAMP '27-09-2008 09:12:47.648302'.
- ¬Ñ Outro tipo de dado relacionado a DATE TIME , e TIMESTAMP √©  o INTERVAL .  Este  especifica um intervalo - um valor relativo que pode ser  usado  para  incrementar  ou  decrementar um valor absoluto de uma data, hora ou time  stamp.  Os  intervalos  s√£o  qualificados para serem de YEAR/MONTH ou de DAY/TIME .
- O formato de DATE , TIME e TIMESTAMP pode ser considerado um tipo especial de cadeia. Logo, eles geralmente podem ser usados em compara√ß√µes de cadeias sendo convertidos ( cast ) em cadeias equivalentes.
- √â poss√≠vel especificar o tipo de dado de cada atributo diretamente, como na Figura 4.1; como alternativa, um dom√≠nio pode ser declarado e seu nome, usado com a especifica√ß√£o de atributo. Isso torna mais f√°cil mudar o tipo de dado para um dom√≠nio que √© usado por diversos atributos em um esquema, e melhora a legibilidade do esquema. Por exemplo, podemos criar um dom√≠nio TIPO\_CPF com a seguinte instru√ß√£o:

## CREATE DOMAIN TIPO\_CPF AS CHAR(11);

Podemos usar TIPO\_CPF no lugar de CHAR 11 ( ) na Figura 4.1 para os atributos Cpf e Cpf\_supervisor de FUNCIONARIO  Cpf\_gerente , de DEPARTAMENTO , Fcpf de TRABALHA\_EM e Fcpf de DEPENDENTE . Um dom√≠nio tamb√©m pode ter uma especifica√ß√£o padr√£o opcional por meio de uma cl√°usula DEFAULT , conforme discutiremos mais adiante para os atributos. Observe que os dom√≠nios podem n√£o estar dispon√≠veis em algumas implementa√ß√µes da SQL.

## 4.2 Especificando restri√ß√µes em SQL

Esta se√ß√£o descreve as restri√ß√µes b√°sicas que podem ser especificadas em SQL como parte da cria√ß√£o de tabela. Estas incluem restri√ß√µes de chave e integridade referencial, restri√ß√µes sobre dom√≠nios de atributo e NULL s e restri√ß√µes sobre tuplas individuais dentro de uma rela√ß√£o. Discutiremos a especifica√ß√£o de restri√ß√µes mais gerais, chamadas asser√ß√µes (ou assertions ) no Cap√≠tulo 5.

## 4.2.1 Especificando restri√ß√µes de atributo e defaults de atributo

Como a SQL permite NULL s  como  valores  de atributo, uma restri√ß√£o NOT NULL pode ser especificada se o valor NULL n√£o for permitido para determinado atributo. Isso sempre √© especificado de maneira impl√≠cita para os atributos que fazem parte da chave prim√°ria de cada rela√ß√£o, mas pode ser especificado para  quaisquer  outros  atributos  cujos  valores  n√£o podem ser NULL , como mostra a Figura 4.1.

## CREATE TABLE FUNCIONARIO

(  . . . , Dnr INT NOTNULL DEFAULT 1, CONSTRAINT CHPFUNC PRIMARY KEY (Cpf), CONSTRAINT CHESUPERFUNC FOREIGN KEY (Cpf\_supervisor) REFERENCES FUNCIONARIO(Cpf) ON DELETE SET NULL ON UPDATE CASCADE, CONSTRAINT CHEDEPFUNC FOREIGN KEY (Dnr) REFERENCES DEPARTAMENTO(Dnumero) ON DELETE SET DEFAULT ON UPDATE CASCADE);

## CREATE TABLE DEPARTAMENTO

(  . . . ,

Cpf\_gerente

CHAR(11)

NOT NULL

DEFAULT

'88866555576',

. . . ,

CONSTRAINT

CHPDEP

PRIMARY KEY (Dnumero),

CONSTRAINT CHSDEP

UNIQUE (Dnome),

CONSTRAINT

CHEGERDEP

FOREIGN KEY

(Cpf\_gerente)

REFERENCES

FUNCIONARIO(Cpf)

ON DELETE SET DEFAULT ON UPDATE CASCADE);

CREATE TABLE

LOCALIZACAO\_DEP

(  . . . ,

PRIMARY KEY (Dnumero, Dlocal),

FOREIGN KEY (Dnumero) REFERENCES DEPARTAMENTO(Dnumero) ON DELETE CASCADE ON UPDATE CASCADE);

## Figura 4.2

Exemplo ilustrando como os valores de atributo default e as a√ß√µes disparadas por integridade referencial s√£o especificadas em SQL.

Tamb√©m √© poss√≠vel definir um valor padr√£o para um atributo anexando a cl√°usula DEFAULT &lt;valor&gt; a uma defini√ß√£o de atributo. O valor padr√£o est√° inclu√≠do em qualquer nova tupla se um valor expl√≠cito n√£o for fornecido para esse atributo. A Figura 4.2 ilustra um exemplo de especifica√ß√£o de um gerente default para um novo departamento e um departamento default para um novo funcion√°rio. Se nenhuma cl√°usula default for especificada, o valor padr√£o ser√° NULL para atributos que n√£o possuem a restri√ß√£o NOT NULL .

Outro tipo de restri√ß√£o pode limitar valores de atributo ou dom√≠nio usando a cl√°usula CHECK (verifica√ß√£o) ap√≥s uma defini√ß√£o de atributo ou dom√≠nio. 6  Por exemplo, suponha que n√∫meros de departamento sejam restritos a n√∫meros inteiros entre 1 e 20; ent√£o, podemos mudar a declara√ß√£o de atributo de Dnumero na tabela DEPARTAMENTO (ver Figura 4.1) para o seguinte:

Dnumero INT NOT NULL CHECK (Dnumero &gt; 0 AND Dnumero &lt; 21);

A cl√°usula CHECK tamb√©m pode ser usada em conjunto  com  a  instru√ß√£o CREATE  DOMAIN . Por exemplo, podemos escrever a seguinte instru√ß√£o:

CREATE DOMAIN D\_NUM AS INTEGER CHECK (D\_NUM &gt; 0 AND D\_NUM &lt; 21);

Depois,  podemos  usar  o  dom√≠nio  criado D\_ NUM como o tipo de atributo para todos os atributos que se referem aos n√∫meros de departamento na Figura 4.1, como Dnumero de DEPARTAMENTO , Dnum de PROJETO , Dnr de FUNCIONARIO, e assim por diante.

## 4.2.2 Especificando restri√ß√µes de chave e integridade referencial

Como  chaves  e  restri√ß√µes  de  integridade  referencial  s√£o  muito  importantes,  existem  cl√°usulas especiais  dentro  da  instru√ß√£o CREATE  TABLE para especific√°-las. Alguns exemplos para ilustrar a especifica√ß√£o de chaves e integridade referencial aparecem na Figura 4.1. 7  A cl√°usula PRIMARY KEY especifica um ou mais atributos que comp√µem a chave prim√°ria de uma rela√ß√£o. Se uma chave prim√°ria tiver um √∫nico atributo, a cl√°usula pode acompanhar o atributo diretamente. Por exemplo, a chave prim√°ria de DEPARTAMENTO pode  ser  especificada  da  seguinte forma (em vez do modo como ela √© especificada na Figura 4.1):

## Dnumero INT PRIMARY KEY ;

A cl√°usula UNIQUE especifica chaves alternativas (secund√°rias),  conforme  ilustramos  nas  declara√ß√µes da tabela DEPARTAMENTO e PROJETO na Figura 4.1. A cl√°usula UNIQUE tamb√©m pode ser especificada diretamente para uma chave secund√°ria se esta for um √∫nico atributo, como no exemplo a seguir:

## Dnome VARCHAR(15) UNIQUE ;

A  integridade  referencial  √©  especificada  por meio da cl√°usula FOREIGN KEY (chave estrangeira) ,  como mostra a Figura 4.1. Conforme discutimos na Se√ß√£o 3.2.4, uma restri√ß√£o de integridade referencial  pode  ser  violada  quando  tuplas  s√£o inseridas  ou  exclu√≠das,  ou  quando  um  valor  de atributo de chave estrangeira ou chave prim√°ria √© modificado. A a√ß√£o default que a SQL toma para uma viola√ß√£o de integridade √© rejeitar a opera√ß√£o de atua  liza√ß√£o que causar√° uma viola√ß√£o, o que √© conhecido como op√ß√£o RESTRICT . Por√©m, o projetista do esquema pode especificar uma a√ß√£o alternativa

6 A cl√°usula CHECK tamb√©m pode ser usada para outras finalidades, conforme veremos.

7 As restri√ß√µes de chave e integridade referencial n√£o estavam inclu√≠das nas primeiras vers√µes da SQL. Em algumas implementa√ß√µes iniciais, as chaves eram especificadas implicitamente no n√≠vel interno por meio do comando CREATE INDEX.

para ser tomada conectando uma cl√°usula de a√ß√£o de disparo referencial a qualquer restri√ß√£o de chave estrangeira. As op√ß√µes incluem SET NULL , CASCADE e SET DEFAULT . Uma op√ß√£o deve ser qualificada com ON DELETE ou ON UPDATE . Ilustramos isso com os exemplos mostrados na Figura 4.2. Aqui, o projetista de banco de dados escolhe ON DELETE SET NULL e ON  UPDATE  CASCADE para  a  chave  estrangeira Cpf\_supervisor de FUNCIONARIO . Isso significa que, se a tupla para um funcion√°rio supervisor √© exclu√≠da , o valor de Cpf\_supervisor ser√° automaticamente definido como NULL para todas as tuplas de funcion√°rios que estavam referenciando a tupla do funcion√°rio exclu√≠do. Por sua vez, se o valor de Cpf para um funcion√°rio  supervisor  √© atualizado (digamos, porque foi inserido incorretamente), o novo valor ser√° propagado em cascata de Cpf\_supervisor para todas as tuplas de funcion√°rio que referencia a tupla de funcion√°rio atualizada. 8

Em geral, a a√ß√£o tomada pelo SGBD para SET NULL ou SET DEFAULT √© a mesma para ON DELETE e ON UPDATE :  o  valor  dos  atributos  de  refer√™ncia afetados √© mudado para NULL em caso de SET NULL e  para  o  valor  padr√£o  especificado  do  atributo  de refer√™ncia  em  caso  de SET DEFAULT .  A  a√ß√£o  para CASCADE ON DELETE √©  excluir todas as tuplas de refer√™ncia,  enquanto  a  a√ß√£o  para CASCADE  ON UPDATE √© mudar o valor do(s) atributo(s) de chave estrangeira de refer√™ncia para o (novo) valor de chave prim√°ria atualizado para todas as tuplas de refer√™ncia.  √â  responsabilidade  do  projetista  de  banco de dados escolher a a√ß√£o apropriada e especific√°-la no esquema do banco de dados. Como uma regra geral, a op√ß√£o CASCADE √© adequada para rela√ß√µes de 'relacionamento' (ver Se√ß√£o 9.1), como TRABA-LHA\_EM ;  para  rela√ß√µes  que  representam  atributos multivalorados,  como LOCALIZACAO\_DEP ;  e  para rela√ß√µes que representam tipos de entidades fracas, como DEPENDENTE .

## 4.2.3 Dando nomes a restri√ß√µes

A Figura 4.2 tamb√©m ilustra como uma restri√ß√£o pode receber um nome de restri√ß√£o , seguindo a palavra-chave CONSTRAINT . Os nomes de todas as restri√ß√µes dentro de um esquema em particular precisam ser exclusivos. Um nome de restri√ß√£o √© usado para identificar uma restri√ß√£o em particular caso ela deva ser removida mais tarde e substitu√≠da por outra, conforme discutiremos no Cap√≠tulo 5. Dar nomes a restri√ß√µes √© algo opcional.

## 4.2.4 Especificando restri√ß√µes sobre tuplas usando CHECK

Al√©m das  restri√ß√µes  de  chave  e  integridade  referencial,  que  s√£o  especificadas  por  palavras-chave especiais, outras restri√ß√µes de tabela podem ser especificadas por meio de cl√°usula adicional CHECK ao final de uma instru√ß√£o CREATE TABLE . Estas podem ser chamadas de restri√ß√µes baseadas em tupla , pois se aplicam a cada tupla individualmente e s√£o verificadas sempre que uma tupla √© inserida ou modificada. Por exemplo, suponha que a tabela DEPARTAMENTO da Figura 4.1 tivesse um atributo adicional Dep\_data\_ criacao , que armazena a data em que o departamento foi criado. Ent√£o, poder√≠amos acrescentar a seguinte cl√°usula CHECK ao final da instru√ß√£o CREATE TABLE para a tabela DEPARTAMENTO para  garantir  que  a data de in√≠cio de um gerente seja posterior √† data de cria√ß√£o do departamento.

CHECK (Dep\_data\_criacao &lt;= Data\_inicio\_gerente);

A cl√°usula CHECK tamb√©m pode ser usada para especificar restri√ß√µes mais gerais usando a instru√ß√£o CREATE ASSERTION da  SQL. Discutiremos isso no Cap√≠tulo 5 porque exige o entendimento completo sobre consultas, que s√£o discutidas nas se√ß√µes 4.3 e 5.1.

## 4.3 Consultas de recupera√ß√£o b√°sicas em SQL

A SQL tem uma instru√ß√£o b√°sica para recuperar informa√ß√µes de um banco de dados: a instru√ß√£o SELECT . A instru√ß√£o SELECT n√£o √© o mesmo que a  opera√ß√£o SELECT da  √°lgebra  relacional, que discutiremos no Cap√≠tulo 6. Existem muitas op√ß√µes e tipos de instru√ß√£o SELECT em SQL, de modo que  introduziremos  seus  recursos  gradualmente.  Usaremos  consultas  de  exemplo  especificadas  no  esquema  da  Figura  3.5  e  vamos  nos referir ao exemplo estado de banco de dados mostrado  na  Figura  3.6  para  mostrar  os  resultados de  alguns  exemplos  de  consultas.  Nesta  se√ß√£o, apresentamos os recursos da SQL para consultas de recupera√ß√£o simples . Os recursos da SQL para especificar  consultas  de  recupera√ß√£o  mais  complexas ser√£o apresentados na Se√ß√£o 5.1.

Antes de prosseguir, devemos apontar uma distin√ß√£o importante entre a SQL e o modelo relacional formal discutido no Cap√≠tulo 3: a SQL permite que uma tabela (rela√ß√£o) tenha duas ou mais tuplas

8 Observe que a chave estrangeira Cpf\_supervisor na tabela FUNCIONARIO √© uma refer√™ncia circular e, portanto, pode ter de ser inclu√≠da mais tarde como uma restri√ß√£o nomeada, usando a instru√ß√£o ALTER TABLE, conforme discutimos no final da Se√ß√£o 4.1.2.

que s√£o id√™nticas em todos os seus valores de atributo. Assim, em geral, uma tabela SQL n√£o √© um conjunto  de  tuplas ,  pois  um  conjunto  n√£o  permite dois membros id√™nticos; em vez disso, ela √© um multiconjunto (tamb√©m chamado de bag ) de tuplas. Algumas rela√ß√µes SQL s√£o restritas a serem conjuntos porque uma restri√ß√£o de chave foi declarada ou porque a op√ß√£o DISTINCT foi usada com a instru√ß√£o SELECT (descrita mais adiante nesta se√ß√£o). Precisamos  estar  cientes  dessa  distin√ß√£o  √†  medida  que discutirmos os exemplos.

## 4.3.1 A estrutura SELECT-FROM-WHERE das consultas SQL b√°sicas

As consultas em SQL podem ser muito complexas.  Come√ßaremos  com  consultas  simples,  e depois  passaremos  para  as  mais  complexas  de maneira passo a passo. A forma b√°sica do comando SELECT , √†s vezes chamada de mapeamento ou bloco  select-from-where ,  √©  composta  pelas  tr√™s cl√°usulas SELECT , FROM e WHERE ,  e  tem  a  seguinte forma: 9

SELECT

&lt;lista atributos&gt; &lt;lista tabelas&gt; &lt;condi√ß√£o&gt;;

FROM

WHERE



onde

- ¬Ñ &lt;lista  atributos&gt;  √©  uma  lista  de  nomes  de atributo cujos valores devem ser recuperados pela consulta.
- ¬Ñ &lt;lista tabelas&gt; √© uma lista dos nomes de rela√ß√£o exigidos para processar a consulta.
- ¬Ñ &lt;condi√ß√£o&gt;  √©  uma  express√£o  condicional (booleana)  que  identifica  as  tuplas  a  serem recuperadas pela consulta.

Em SQL, os operadores b√°sicos de compara√ß√£o l√≥gicos para comparar valores de atributo entre si e com constantes literais s√£o =, &lt;, &lt;=, &gt;, &gt;= e &lt;&gt;. Estes correspondem aos operadores da √°lgebra relacional =, &lt;, ‚â§ , &gt;, ‚â• e ‚â† , respectivamente, e aos operadores da linguagem de programa√ß√£o C/C++ =, &lt;, &lt;=, &gt;, &gt;= e !=. A principal diferen√ßa sint√°tica √© o operador diferente . A SQL possui operadores de compara√ß√£o adicional que apresentaremos de maneira gradual.

Ilustramos a instru√ß√£o SELECT b√°sica em SQL com  alguns  exemplos  de  consultas.  As  consultas s√£o  rotuladas  aqui  com  os  mesmos  n√∫meros  de consulta usados no Cap√≠tulo 6 para facilitar a refer√™ncia cruzada.

Consulta 0. Recuperar a data de nascimento e o endere√ßo do(s) funcion√°rio(s) cujo nome seja 'Jo√£o B. Silva'.

C0:

SELECT FROM WHERE

Datanasc  Endereco ,

FUNCIONARIO

Pnome ='Jo√£o' AND Minicial ='B' AND Unome ='Silva';

Esta consulta envolve apenas a rela√ß√£o FUNCIONARIO listada na cl√°usula FROM . A consulta seleciona as  tuplas FUNCIONARIO individuais  que  satisfazem a condi√ß√£o da cl√°usula WHERE , depois projeta o resultado nos atributos Datanasc e Endereco listados na cl√°usula SELECT .

A cl√°usula SELECT da SQL especifica os atributos cujos valores devem ser recuperados, que s√£o chamados atributos de proje√ß√£o , e a cl√°usula WHERE especifica a condi√ß√£o booleana que deve ser verdadeira para qualquer tupla recuperada, que √© conhecida como condi√ß√£o de sele√ß√£o .  A Figura 4.3(a) mostra o resultado da consulta C0 sobre o banco de dados da Figura 3.6.

Podemos pensar em uma vari√°vel de tupla impl√≠cita (ou iterator ) na consulta SQL variando ou repetindo sobre cada tupla individual na tabela FUNCIONARIO e  avaliando  a  condi√ß√£o  na  cl√°usula WHERE . Somente as tuplas que satisfazem a condi√ß√£o - ou seja, aquelas tuplas para as quais a condi√ß√£o √© avaliada como TRUE ap√≥s substituir seus valores de atributo correspondentes - s√£o selecionadas.

Consulta 1. Recuperar o nome e endere√ßo de todos os funcion√°rios que trabalham para o departamento 'Pesquisa'.

C1: SELECT

Pnome  Unome  Endereco , ,

FROM WHERE

FUNCIONARIO  DEPARTAMENTO ,

Dnome ='Pesquisa' AND Dnumero = Dnr ;

Na cl√°usula WHERE de C1 , a condi√ß√£o Dnome = 'Pesquisa' √© uma condi√ß√£o de sele√ß√£o que escolhe a tupla de interesse em particular na tabela DEPARTAMENTO , pois Dnome √© um atributo de DEPARTAMENTO . A condi√ß√£o Dnumero = Dnr √© chamada condi√ß√£o de jun√ß√£o , pois combina duas tuplas: uma de DEPARTAMENTO e uma de FUNCIONARIO , sempre que o valor de Dnumero em DEPARTAMENTO √© igual ao valor de Dnr em FUNCIONARIO .  O  resultado  da  consulta C1 √© mostrado na Figura 4.3(b). Em geral, qualquer n√∫mero de condi√ß√µes de sele√ß√£o e jun√ß√£o pode ser especificado em uma √∫nica consulta SQL.

| (a)   | Datanasc   | Endereco                           |
|-------|------------|------------------------------------|
|       | 09-01-1965 | Rua das Flores, 751, S√£o Paulo, SP |



|   Projnumero |   Dnum | Unome   | Endereco                               | Datanasc   |
|--------------|--------|---------|----------------------------------------|------------|
|           10 |      4 | Souza   | Av. Artur de Lima, 54, Santo Andr√©, SP | 20-06-1941 |
|           30 |      4 | Souza   | Av. Artur de Lima, 54, Santo Andr√©, SP | 20-06-1941 |

(d)

| F.Pnome   | F.Unome   | S.Pnome   | S.Unome   |
|-----------|-----------|-----------|-----------|
| Jo√£o      | Silva     | Fernando  | Wong      |
| Fernando  | Wong      | Jorge     | Brito     |
| Alice     | Zelaya    | Jennifer  | Souza     |
| Jennifer  | Souza     | Jorge     | Brito     |
| Ronaldo   | Lima      | Fernando  | Wong      |
| Joice     | Leite     | Fernando  | Wong      |
| Andr√©     | Pereira   | Jennifer  | Souza     |

(e)

F.Pnome

12345678966

33344555587

99988777767

98765432168

66688444476

45345345376

98798798733

88866555576

| Pnome    | Unome   | Endereco                           |
|----------|---------|------------------------------------|
| Jo√£o     | Silva   | Rua das Flores, 751, S√£o Paulo, SP |
| Fernando | Wong    | Rua da Lapa, 34, S√£o Paulo, SP     |
| Ronaldo  | Lima    | Rua Rebou√ßas, 65, Piracicaba, SP   |
| Joice    | Leite   | Av. Lucas Obes, 74, S√£o Paulo, SP  |



|         Cpf | Dnome         |
|-------------|---------------|
| 12345678966 | Pesquisa      |
| 33344555587 | Pesquisa      |
| 99988777767 | Pesquisa      |
| 98765432168 | Pesquisa      |
| 66688444476 | Pesquisa      |
| 45345345376 | Pesquisa      |
| 98798798733 | Pesquisa      |
| 88866555576 | Pesquisa      |
| 12345678966 | Administra√ß√£o |
| 33344555587 | Administra√ß√£o |
| 99988777767 | Administra√ß√£o |
| 98765432168 | Administra√ß√£o |
| 66688444476 | Administra√ß√£o |
| 45345345376 | Administra√ß√£o |
| 98798798733 | Administra√ß√£o |
| 88866555576 | Administra√ß√£o |
| 12345678966 | Matriz        |
| 33344555587 | Matriz        |
| 99988777767 | Matriz        |
| 98765432168 | Matriz        |
| 66688444476 | Matriz        |
| 45345345376 | Matriz        |
| 98798798733 | Matriz        |
| 88866555576 | Matriz        |

| (g)   | Pnome    | Minicial   | Unome   |         Cpf | Datanasc   | Endereco                           | Sexo   |   Salario |   Cpf_supervisor |   Dnr |
|-------|----------|------------|---------|-------------|------------|------------------------------------|--------|-----------|------------------|-------|
|       | Jo√£o     | B          | Silva   | 12345678966 | 09-01-1965 | Rua das Flores, 751, S√£o Paulo, SP | M      |        30 |      33344555587 |     5 |
|       | Fernando | T          | Wong    | 33344555587 | 08-12-1955 | Rua da Lapa, 34, S√£o Paulo, SP     | M      |        40 |      88866555576 |     5 |
|       | Ronaldo  | K          | Lima    | 66688444476 | 15-09-1962 | Rua Rebou√ßas, 65, Piracicaba, SP   | M      |        38 |      33344555587 |     5 |
|       | Joice    | A          | Leite   | 45345345376 | 31-07-1972 | Av. Lucas Obes, 74, S√£o Paulo, SP  | F      |        25 |      33344555587 |     5 |

## Figura 4.3

Resultados das consultas SQL quando aplicados ao estado do banco de dados EMPRESA mostrado na Figura 3.6. (a) C0. (b) C1. (c) C2. (d) C8. (e) C9. (f) C10. (g) C1C.

Uma consulta que envolve apenas condi√ß√µes de sele√ß√£o e jun√ß√£o mais atributos de proje√ß√£o √© conhecida como uma consulta sele√ß√£o-proje√ß√£o-jun√ß√£o . O pr√≥ximo exemplo √© uma consulta sele√ß√£o-proje√ß√£o-jun√ß√£o com duas condi√ß√µes de jun√ß√£o.

Consulta  2. Para  cada  projeto  localizado  em 'Mau√°',  liste  o  n√∫mero  do  projeto,  o  n√∫mero do departamento que o controla e o sobrenome, endere√ßo  e  data  de  nascimento  do  gerente  do departamento.

C2: SELECT

Projnumero  Dnum  Unome  Endereco , , , , Datanasc

FROM

PROJETO  DEPARTAMENTO , , FUNCIONARIO

WHERE

Dnum Dnumero = AND

Cpf\_gerente = Cpf AND

Projlocal ='Mau√°';

A condi√ß√£o de jun√ß√£o Dnum = Dnumero relaciona uma tupla de projeto a sua tupla de departamento que o controla, enquanto a condi√ß√£o de jun√ß√£o Cpf\_geren-te = Cpf relaciona a tupla do departamento que o controla √† tupla de funcion√°rio que gerencia esse departamento. Cada tupla no resultado ser√° uma combina√ß√£o de um projeto, um departamento e um funcion√°rio, que satisfaz as condi√ß√µes de jun√ß√£o. Os atributos de proje√ß√£o s√£o usados para escolher os atributos a serem exibidos com base em cada tupla combinada. O resultado da consulta C2 aparece na Figura 4.3(c).

## 4.3.2 Nomes de atributos amb√≠guos, apelido, renomea√ß√£o e vari√°veis de tupla

Em SQL, o mesmo nome pode ser usado para dois (ou mais) atributos, desde que estes estejam em rela√ß√µes diferentes . Se isso acontecer, e uma consulta em m√∫ltiplas tabelas se referir a dois ou mais atributos com o mesmo nome, √© preciso qualificar o nome do atributo com o nome da rela√ß√£o, para evitar ambiguidade.  Isso  √©  feito prefixando o  nome  da  rela√ß√£o ao nome do atributo e separando os dois por um ponto.  Para  ilustrar  isso,  suponha  que,  nas  figuras 3.5 e 3.6, os atributos Dnr e Unome da rela√ß√£o FUNCIONARIO fossem chamados de Dnumero e Nome , e o atributo Dnome de DEPARTAMENTO tamb√©m fosse chamado Nome .  Ent√£o, para evitar ambiguidade, a consulta C1 seria reformulada como mostramos em C1A . Devemos prefixar os nomes de atributo Nome e Dnumero em C1A para especificar a quais estamos nos referindo, pois os mesmos nomes de atributo s√£o usados nas duas rela√ß√µes:

C1A: SELECT

Pnome  FUNCIONARIO.Nome , , Endereco

FROM WHERE

FUNCIONARIO  DEPARTAMENTO ,

DEPARTAMENTO.Nome ='Pesquisa' AND DEPARTAMENTO. Dnumero = FUNCIONARIO.Dnumero ;

Nomes de atributo totalmente qualificados podem ser usados por clareza mesmo que n√£o haja ambiguidade nos nomes de atributo. C1 aparece dessa maneira como C1' a seguir. Tamb√©m podemos criar um apelido para cada nome de tabela, para evitar a digita√ß√£o repetida de nomes de tabela longos (ver C8 , a seguir).

C1':

SELECT

FUNCIONARIO.Pnome  FUNCIONARIO.

,

UNome FUNCIONARIO.Endereco

,

FROM WHERE

FUNCIONARIO  DEPARTAMENTO

,

DEPARTAMENTO.DNome ='Pesquisa' AND DEPARTAMENTO.Dnumero = FUNCIONARIO.Dnr ;

A ambiguidade dos nomes de atributo tamb√©m surge no caso de consultas que se referem √† mesma rela√ß√£o duas vezes, como no exemplo a seguir.

Consulta 8. Para cada funcion√°rio, recupere o primeiro e o √∫ltimo nome do funcion√°rio e o primeiro e o √∫ltimo nome de seu supervisor imediato.

C8:

SELECT

FROM

F.Pnome  F.Unome  S.Pnome  S.Unome , , , FUNCIONARIO AS F   FUNCIONARIO , AS S

WHERE

F.Cpf\_supervisor = S.Cpf ;

Neste  caso,  precisamos  declarar  nomes  de  rela√ß√£o alternativos F e S , chamados apelidos ou vari√°veis de tupla , para a rela√ß√£o FUNCIONARIO . Um apelido  pode  vir  ap√≥s  a  palavra-chave AS ,  como mostramos em C8 , ou pode vir diretamente ap√≥s o nome da rela√ß√£o - por exemplo, escrevendo FUNCIONARIO F , FUNCIONARIO S na cl√°usula FROM de C8 .  Tamb√©m  √©  poss√≠vel renomear os  atributos  da rela√ß√£o dentro da consulta em SQL, dando-lhe apelidos. Por exemplo, se escrevermos

FUNCIONARIO AS F(Pn, Mi, Un, Cpf, Dn, End, Sexo, Sal, Scpf, Dnr)

na cl√°usula FROM Pn , torna-se um apelido para Pnome , Mi para Minicial , Un para Unome, e  assim  por diante.

Em C8 ,  podemos  pensar  em F e S como duas c√≥pias diferentes da rela√ß√£o FUNCIONARIO ; a primei-

ra, F , representa funcion√°rios no papel de supervisionados ou subordinados; a segunda, S , representa os funcion√°rios no papel de supervisores. Agora, podemos juntar as duas c√≥pias. Naturalmente, na realidade existe apenas uma rela√ß√£o FUNCIONARIO , e a condi√ß√£o de jun√ß√£o serve para juntar a pr√≥pria rela√ß√£o, combinando as tuplas que satisfazem a condi√ß√£o de jun√ß√£o F.Cpf\_supervisor = S.Cpf .  Observe que este √© um exemplo de uma consulta recursiva de um n√≠vel, conforme discutiremos na Se√ß√£o 6.4.2. Nas vers√µes anteriores da SQL, n√£o era poss√≠vel especificar uma consulta recursiva geral, com um n√∫mero desconhecido  de  n√≠veis,  em  uma  √∫nica  instru√ß√£o  SQL.  Uma constru√ß√£o para especificar  consultas  recursivas  foi incorporada na SQL:1999 (ver Cap√≠tulo 5).

- O  resultado  da  consulta C8 aparece  na  Figura 4.3(d). Sempre que um ou mais apelidos s√£o dados a uma  rela√ß√£o,  podemos  usar  esses  nomes  para  representar diferentes refer√™ncias a essa mesma rela√ß√£o. Isso permite m√∫ltiplas refer√™ncias √† mesma rela√ß√£o dentro de uma consulta.

Podemos usar esse mecanismo de nomea√ß√£o de apelidos em qualquer consulta SQL para especificar vari√°veis de tupla para cada tabela na cl√°usula WHERE , n√£o importando se a mesma rela√ß√£o precisa ser referenciada mais de uma vez. De fato, essa pr√°tica √© recomendada, pois resulta em consultas mais f√°ceis de compreender. Por exemplo, poder√≠amos especificar a consulta C1 como em C1B :

C1B: SELECT F.Pnome  F.Unome  F.Endereco , ,

FROM

FUNCIONARIO F  DEPARTAMENTO D ,

WHERE

D.DNome ='Pesquisa' AND D.Dnumero = F.Dnr ;

## 4.3.3 Cl√°usula WHERE n√£o especificada e uso do asterisco

Vamos discutir aqui mais dois recursos da SQL. A falta de uma cl√°usula WHERE indica que n√£o h√° condi√ß√£o  sobre  a  sele√ß√£o  de  tuplas;  logo, todas  as tuplas da  rela√ß√£o especificada na cl√°usula FROM se qualificam  e  s√£o  selecionadas  para  o  resultado  da consulta. Se mais de uma rela√ß√£o for especificada na cl√°usula FROM e n√£o houver uma cl√°usula WHERE , ent√£o o PRODUTO CARTESIANO -todas as combina√ß√µes de tuplas poss√≠veis - dessas rela√ß√µes ser√° selecionado. Por exemplo, a Consulta 9 seleciona todos os Cpf s de FUNCIONARIO (Figura 4.3(e)) e a Consulta 10 seleciona todas as combina√ß√µes de um Cpf de FUNCIONARIO e um Dnome de DEPARTAMENTO , independentemente de o funcion√°rio trabalhar ou n√£o para o departamento (Figura 4.3(f)).

Consultas  9  e  10. Selecionar  todos  os Cpf s  de FUNCIONARIO  C9 ( ) e todas as combina√ß√µes de Cpf de FUNCIONARIO e Dnome de DEPARTAMENTO ( C10 ) no banco de dados.

C9:

SELECT

Cpf

FROM

FUNCIONARIO ;

C10: SELECT

Cpf  Dnome ,

FROM

FUNCIONARIO , DEPARTAMENTO ;



√â  extremamente  importante  especificar  cada condi√ß√£o de sele√ß√£o e jun√ß√£o na cl√°usula WHERE . Se alguma condi√ß√£o desse tipo for esquecida, o resultado poder√° ser rela√ß√µes  incorretas  e  muito  grandes. Observe que C10 √©  semelhante  a  uma  opera√ß√£o de PRODUTO CARTESIANO seguida por uma opera√ß√£o PROJECAO na √°lgebra relacional (ver Cap√≠tulo 6). Se especificarmos todos os atributos de FUNCIONARIO e DEPARTAMENTO em C10, obteremos o PRODUTO CARTESIANO real (exceto pela elimina√ß√£o de duplicatas, se houver).

Para recuperar todos os valores de atributo das tuplas selecionadas, n√£o precisamos listar os nomes de atributo explicitamente em SQL; basta especificar um asterisco ( * ),  que  significa todos os atributos .  Por  exemplo,  a  consulta C1C recupera  todos os  valores  de  atributo  de  qualquer FUNCIONARIO que trabalha no DEPARTAMENTO n√∫mero 5 (Figura 4.3(g)), a consulta C1D recupera todos os atributos de um FUNCIONARIO e  os  atributos  do DEPARTAMENTO em que ele ou ela trabalha para todo funcion√°rio no departamento 'Pesquisa', e C10A especifica o PRODUTO CARTESIANO das rela√ß√µes FUNCIONARIO e DEPARTAMENTO .

C1C:

SELECT *

FROM

FUNCIONARIO

WHERE Dnr =5;

C1D:

SELECT *

FROM

FUNCIONARIO  DEPARTAMENTO ,

WHERE

Dnome ='Pesquisa' AND Dnr = Dnumero ;

C10A:

SELECT *

FROM

FUNCIONARIO  DEPARTAMENTO , ;



## 4.3.4 abelas como conjuntos em SQL T

Conforme j√° dissemos, a SQL normalmente trata uma tabela n√£o como um conjunto, mas como um multiconjunto ; tuplas  duplicadas  podem  aparecer mais de uma vez em uma tabela, e no resultado de uma consulta. A SQL n√£o elimina automaticamente tuplas duplicadas nos resultados das consultas, pelos seguintes motivos:

- ¬Ñ A elimina√ß√£o de duplicatas √© uma opera√ß√£o dispendiosa.  Um  modo  de  implement√°-la  √© classificar as tuplas primeiro e depois eliminar as duplicatas.
- ¬Ñ O usu√°rio pode querer ver as tuplas duplicadas no resultado de uma consulta.
- ¬Ñ Quando  uma  fun√ß√£o  agregada  (ver  Se√ß√£o 5.1.7)  √©  aplicada  √†s  tuplas,  na  maioria  dos casos n√£o queremos eliminar duplicatas.

Uma tabela SQL com uma chave √© restrita a ser um conjunto, uma vez que o valor de chave precisa ser distinto em cada tupla. 10 Se quisermos eliminar tuplas duplicadas do resultado de uma consulta SQL, usamos a palavra-chave DISTINCT na cl√°usula SELECT , significando que apenas as tuplas distintas dever√£o permanecer no resultado. Em geral, uma consulta com SELECT DISTINCT elimina  duplicatas,  enquanto  uma  consulta com SELECT ALL n√£o elimina. A especifica√ß√£o de SELECT sem ALL ou DISTINCT - como em nossos exemplos  anteriores  -  √©  equivalente  a SELECT  ALL .  Por exemplo, a C11 recupera o sal√°rio de cada funcion√°rio; se v√°rios funcion√°rios tiverem o mesmo sal√°rio, esse valor de sal√°rio aparecer√° muitas vezes no resultado da consulta, como mostra a Figura 4.4(a). Se estivermos interessados  apenas  em  valores  de  sal√°rio  distintos, queremos que cada valor apare√ßa apenas uma vez, independentemente de quantos funcion√°rios ganham esse sal√°rio. Usando a palavra-chave DISTINCT , como em C11A , conseguimos isso, como mostra a Figura 4.4(b).

Consulta 11. Recuperar o sal√°rio de cada funcion√°rio ( C11 ) e todos os valores de sal√°rio distintos ( C11A ).

| C11:   | SELECT   | ALL Salario      |
|--------|----------|------------------|
|        | FROM     | FUNCIONARIO ;    |
| C11A:  | SELECT   | DISTINCT Salario |
|        | FROM     | FUNCIONARIO ;    |

|   Sal√°rio | Sal√°rio (b)   |
|-----------|---------------|
|        30 | 30.000        |
|        40 | 40.000        |
|        25 | 25.000        |
|        43 | 43.000        |
|        38 | 38.000        |
|        25 | 55.000        |
|        25 |               |
|        55 |               |

(a)

| (c)   | Pnome    | Unome   |
|-------|----------|---------|
| (d)   | Pnome    | Unome   |
|       | Fernando | Wong    |

## Figura 4.4

Resultados de consultas SQL adicionais, quando aplicadas ao estado de banco de dados EMPRESA, mostrados na Figura 3.6. (a) C11. (b) C11A. (c) C12. (d) C12A.

aplicamos a opera√ß√£o tenham os mesmos atributos e que os atributos apare√ßam na mesma ordem nas duas rela√ß√µes. O pr√≥ximo exemplo ilustra o uso de UNION .

Consulta 4. Fazer uma lista de todos os n√∫meros de projeto para aqueles que envolvam um funcion√°rio cujo √∫ltimo nome √© 'Silva', seja como um trabalhador ou como um gerente do departamento que controla o projeto.

C4A:

A SQL incorporou diretamente algumas das opera√ß√µes de conjunto da teoria de conjuntos da matem√°tica,  que tamb√©m fazem parte da √°lgebra relacional (ver Cap√≠tulo 6). Existem opera√ß√µes de uni√£o de conjunto (UNION ),  diferen√ßa de conjunto ( EXCEPT ), 11 e interse√ß√£o de conjunto ( INTERSECT ). As rela√ß√µes resultantes dessas opera√ß√µes de conjunto s√£o conjuntos de tuplas; ou seja, tuplas duplicadas s√£o eliminadas do resultado . Essas opera√ß√µes de conjunto se aplicam apenas a rela√ß√µes compat√≠veis com uni√£o ,  de  modo que precisamos garantir que as duas rela√ß√µes em que

(

SELECT

DISTINCT Projnumero

FROM

PROJETO, DEPARTAMENTO, FUNCIONARIO

WHERE

Dnum=Dnumero AND Cpf\_gerente=Cpf

AND Unome ='Silva' )

## UNION

(

SELECT

DISTINCT Projnumero

FROM

PROJETO, TRABALHA\_EM, FUNCIONARIO

WHERE

Projnumero=Pnr AND Fcpf=Cpf

AND Unome='Silva' );

A  primeira  consulta SELECT recupera  os  projetos que envolvem um 'Silva' como gerente do de-

10 Em geral, uma tabela SQL n√£o precisa ter uma chave, embora, na maioria dos casos, exista uma.

11 Em alguns sistemas, a palavra-chave MINUS √© usada para a opera√ß√£o de diferen√ßa de conjunto, em vez de EXCEPT.

Figura 4.5



Os resultados das opera√ß√µes de multiconjunto da SQL. (a) Duas tabelas, R(A) e S(A). (b) R(A) UNION ALL S(A). (c) R(A) EXCEPT ALL S(A). (d) R(A) INTERSECT ALL S(A).

partamento  que  controla  o  projeto,  e  a  segunda, recupera os projetos que envolvem um 'Silva' como um trabalhador no projeto. Observe que, se todos os  funcion√°rios  tiverem  o  √∫ltimo  nome  'Silva',  os nomes de projeto envolvendo qualquer um deles seriam recuperados. A aplica√ß√£o da opera√ß√£o UNION √†s duas consultas SELECT gera o resultado desejado.

A SQL tamb√©m possui opera√ß√µes multiconjuntos correspondentes, que s√£o acompanhadas da palavra-chave ALL ( UNION  ALL   EXCEPT  ALL   INTERSECT , , ALL ). Seus resultados s√£o multiconjuntos (duplicatas n√£o s√£o eliminadas). O comportamento dessas opera√ß√µes √© ilustrado pelos exemplos da Figura 4.5. Basicamente, cada tupla - seja ela uma duplicata ou n√£o - √© considerada uma tupla diferente ao aplicar essas opera√ß√µes.

## 4.3.5 Combina√ß√£o de padr√£o de subcadeias e operadores aritm√©ticos

Nesta  se√ß√£o,  discutimos  v√°rios  outros  recursos da SQL. O primeiro recurso permite condi√ß√µes de compara√ß√£o apenas sobre partes de uma cadeia de caracteres, usando o operador de compara√ß√£o LIKE . Isso pode ser usado para combina√ß√£o de padr√£o de cadeia.  Cadeias  parciais  s√£o  especificadas  usando dois caracteres reservados: % substitui um n√∫mero qualquer de zero ou mais caracteres, e o sublinhado (\_) substitui um √∫nico caractere. Por exemplo, considere a seguinte consulta.

Consulta  12. Recuperar  todos  os  funcion√°rios cujo endere√ßo esteja em S√£o Paulo, SP.

C12:

SELECT

Pnome, Unome

FROM

FUNCIONARIO

WHERE

Endereco

LIKE

'%SaoPaulo,SP%';

Para recuperar todos os funcion√°rios que nasceram durante a d√©cada de 1950, podemos usar a Consulta C12A . Aqui, '5' precisa ser o nono caractere da cadeia (de acordo com nosso formato para data), de modo que usamos o valor '\_ \_ \_ \_ \_ \_ \_ \_ 5 \_', com cada sublinhado servindo como um marcador de lugar para um caractere qualquer.

Consulta 12A. Encontrar todos os funcion√°rios que nasceram durante a d√©cada de 1950.



Se um sublinhado ou % for necess√°rio como um caractere literal na cadeia, este deve ser precedido por um caractere de escape , que √© especificado ap√≥s a cadeia usando a palavra-chave ESCAPE .  Por  exemplo, 'AB\_CD\%EF' ESCAPE '\' representa a cadeia literal 'AB\_CD%EF', pois \ √© especificado como o caractere de escape. Qualquer caractere n√£o usado na cadeia pode  ser  escolhido  como  caractere  de  escape.  Al√©m disso, precisamos de uma regra para especificar ap√≥strofos ou aspas simples (' ') se eles tiverem de ser inclu√≠dos em uma cadeia, pois s√£o usados para iniciar e terminar cadeias. Se um ap√≥strofo (') for necess√°rio, ele ser√° representado como dois ap√≥strofos consecutivos (''), de modo que n√£o ser√° interpretado como o t√©rmino da cadeia. Observe que a compara√ß√£o de subcadeia implica que os valores de atributo n√£o sejam valores  at√¥micos  (indivis√≠veis),  conforme  assumimos no modelo relacional formal (ver Se√ß√£o 3.1).

Outro recurso permite o uso de aritm√©tica nas consultas. Os operadores aritm√©ticos padr√£o para adi√ß√£o (+),  subtra√ß√£o (-), multiplica√ß√£o ( ) e divis√£o (/) po-* dem ser aplicados a valores  ou  atributos  num√©ricos com dom√≠nios num√©ricos. Por exemplo, suponha que queiramos ver o efeito de dar a todos os funcion√°rios que trabalham no projeto 'ProdutoX' um aumento de 10 por cento; podemos fazer a Consulta 13 para ver quais seriam seus novos sal√°rios. Este exemplo tamb√©m mostra como podemos renomear um atributo no resultado da consulta usando AS na cl√°usula SELECT .

Consulta 13. Mostrar os sal√°rios resultantes se cada funcion√°rio que trabalha no projeto 'ProdutoX' receber um aumento de 10 por cento.

C13:

SELECT

F.Pnome  F.Unome , , 1,1 * F .Salario AS Aumento\_salario

FROM

FUNCIONARIO AS F  TRABALHA\_EM ,

AS T  PROJETO , AS P

WHERE

F.Cpf = T.Fcpf AND T.Pnr = P.Projnumero

AND P .Projnome ='ProdutoX';

Para  os  tipos  de  dados  de  cadeia,  o  operador de concatena√ß√£o || pode ser usado em uma consulta para anexar dois valores de cadeia. Para tipos de dados data, hora, timestamp e intervalo, os operadores incluem  incremento  (+)  ou  decremento  (-)  de  uma data,  hora  ou  timestamp  por  um  intervalo.  Al√©m disso,  um  valor  de  intervalo  √©  o  resultado  da  diferen√ßa entre dois valores de data, hora ou timestamp. Outro operador de compara√ß√£o, que pode ser usado por conveni√™ncia, √© BETWEEN , que est√° ilustrado na Consulta 14.

Consulta 14. Recuperar todos os funcion√°rios no departamento 5 cujo sal√°rio esteja entre R$ 30.000 e R$ 40.000.

C14:

SELECT

*

FROM

FUNCIONARIO

WHERE

( Salario BETWEEN 30.000 AND 40.000) AND Dnr = 5;

A  condi√ß√£o  ( Salario BETWEEN 30.000 AND 40.000) em C14 √© equivalente √† condi√ß√£o (( Salario &gt;= 30.000) AND ( Salario &lt;= 40.000)).

## 4.3.6 Ordem dos resultados da consulta

A SQL permite que o usu√°rio ordene as tuplas no resultado de uma consulta pelos valores de um ou mais dos atributos que aparecem, usando a cl√°usula ORDER BY . Isso √© ilustrado pela Consulta 15.

Consulta  15. Recuperar  uma  lista  dos  funcion√°rios e dos projetos em que est√£o trabalhando, ordenada  por  departamento  e,  dentro  de  cada departamento,  ordenada  alfabeticamente  pelo sobrenome, depois pelo nome.

C15:

SELECT

D.Dnome  F.Unome  F.Pnome , , , P.Projnome

FROM

DEPARTAMENTO D  FUNCIONARIO , F  TRABALHA\_EM T PROJETO P , ,

WHERE

D.Dnumero = F.Dnr AND F.Cpf =

T.Fcpf AND T.Pnr = P .Projnumero

ORDER BY D.Dnome  F.Unome  F.Pnome , , ;

A ordem padr√£o est√° em ordem crescente de valores. Podemos especificar a palavra-chave DESC se quisermos ver o resultado em uma ordem decrescente de valores. A palavra-chave ASC pode ser usada para  especificar  a  ordem  crescente  explicitamente. Por exemplo, se quisermos a ordem alfab√©tica decrescente de Dnome e ordem crescente de Unome Pnome , , a cl√°usula ORDER BY da C15 pode ser escrita como

ORDER BY D.Dnome DESC , F .Unome ASC , F .Pnome ASC

## 4.3.7 Discuss√£o e resumo das consultas de recupera√ß√£o da SQL b√°sica

Uma simples consulta em  SQL  pode  consistir em  at√©  quatro  cl√°usulas,  mas  apenas  as  duas  primeiras SELECT e FROM - s√£o obrigat√≥rias. As cl√°usulas s√£o especificadas na seguinte ordem, com aquelas entre colchetes [ ... ] sendo opcionais:

SELECT

&lt;lista atributos&gt;

FROM

&lt;lista tabelas&gt;

[ WHERE

&lt;condi√ß√£o&gt; ]

[ ORDER BY

&lt;lista atributos&gt; ];

A  cl√°usula SELECT lista  os  atributos  a  serem recuperados, e a cl√°usula FROM especifica  todas as rela√ß√µes (tabelas) necess√°rias na consulta simples. A cl√°usula WHERE identifica as condi√ß√µes para selecionar as tuplas dessas rela√ß√µes, incluindo condi√ß√µes de jun√ß√£o, se necess√°rio. ORDER BY especifica uma ordem para exibir os resultados de uma consulta. Duas cl√°usulas adicionais, GROUP BY e HAVING , ser√£o descritas na Se√ß√£o 5.1.8.

No  Cap√≠tulo  5,  apresentaremos  recursos  mais complexos das consultas SQL. Estes incluem os seguintes: consultas aninhadas, que permitem que uma consulta seja inclu√≠da como parte de outra consulta; fun√ß√µes de agrega√ß√£o, que s√£o usadas para fornecer resumos da informa√ß√£o nas tabelas; duas cl√°usulas adicionais  ( GROUP BY e HAVING ),  que  podem  ser usadas  para  fornecer  mais  poder  para  as  fun√ß√µes agregadas; e v√°rios tipos de jun√ß√µes ( joins ) que podem combinar registros de v√°rias tabelas de diferentes maneiras.

## 4.4 nstru√ß√µes INSERT, DELETE e I UPDATE em SQL

Em SQL, tr√™s comandos podem ser usados para modificar  o  banco  de  dados: INSERT , DELETE e UPDATE . Discutiremos cada um deles.

## 4.4.1 O comando INSERT

Em  sua  forma  mais  simples, INSERT √©  usado para acrescentar uma √∫nica tupla a uma rela√ß√£o. Temos de especificar o nome da rela√ß√£o e uma lista de valores para a tupla. Os valores devem ser listados na mesma ordem em que os atributos correspondentes foram especificados no comando CREATE TABLE . Por exemplo, para acrescentar uma nova tupla √† rela√ß√£o FUNCIONARIO mostrada na Figura 3.5 e especificada no comando CREATE TABLE FUNCIONARIO ... da Figura 4.1, podemos usar U1 :

U1:

INSERT INTO

FUNCIONARIO

VALUES

( 'Ricardo', 'K', 'Marini', '65329865388', '30-12- 1962', 'Rua Itapira, 44, Santos, SP', 'M', 37.000, '65329865388', 4 );

Uma segunda forma da instru√ß√£o INSERT permite  que  o  usu√°rio  especifique  nomes  de  atributo expl√≠citos que correspondem aos valores fornecidos no comando INSERT . Isso √© √∫til se uma rela√ß√£o tiver muitos atributos, mas apenas alguns deles recebem valores em uma nova tupla. Por√©m, os valores precisam incluir todos os atributos com a especifica√ß√£o NOT NULL e nenhum valor padr√£o. Os atributos com NULL permitido ou com valores DEFAULT s√£o aqueles que podem ser omitidos .  Por  exemplo, para inserir uma tupla para um novo FUNCIONARIO do qual conhecemos apenas os atributos Pnome  Unome  Dnr , , e Cpf , podemos usar U1A :

U1A:

INSERT INTO

FUNCIONARIO  Pnome ( ,

Unome  Dnr  Cpf , , )

VALUES

('Ricardo', 'Marini', 4,

'65329865388');

Os atributos n√£o especificados em U1A s√£o definidos como seu valor DEFAULT ou NULL , e os valores s√£o listados na mesma ordem que os atributos s√£o listados  no  pr√≥prio  comando  INSERT .  Tamb√©m  √© poss√≠vel inserir em uma rela√ß√£o m√∫ltiplas tuplas separadas por v√≠rgulas em um √∫nico comando INSERT . Os valores de atributo que formam cada tupla ficam entre par√™nteses.

Um  SGBD  que  implementa  totalmente  a  SQL deve aceitar e impor todas as restri√ß√µes de integridade que podem ser especificadas na DDL. Por exemplo, se emitirmos o comando em U2 sobre o banco de dados mostrado na Figura 3.6, o SGBD deve rejeitar a opera√ß√£o, pois n√£o existe uma tupla DEPARTAMENTO no banco de dados com Dnumero = 2. De modo semelhante, U2A seria rejeitado porque nenhum valor de Cpf √© fornecido e essa √© a chave prim√°ria, que n√£o pode ser NULL .

U2:

INSERT INTO

FUNCIONARIO  Pnome ( ,

Unome  Cpf  Dnr , , )

VALUES

('Roberto', 'Gomes',

'98076054011', 2);

( U2 √© rejeitado se a verifica√ß√£o da integridade referencial for oferecida pelo SGBD.)

U2A: INSERT INTO

FUNCIONARIO  Pnome ( , Unome  Dnr , ) ('Roberto', 'Gomes', 5);

VALUES

( U2 √© rejeitado se a verifica√ß√£o de NOT NULL for oferecida pelo SGBD.)

Uma varia√ß√£o do comando INSERT inclui v√°rias tuplas em uma rela√ß√£o em conjunto com a cria√ß√£o da rela√ß√£o e sua carga com o resultado de uma consulta . Por exemplo, para criar uma tabela tempor√°ria que possui o sobrenome do funcion√°rio, o nome do projeto e as horas por semana para cada funcion√°rio que trabalha em um projeto, podemos escrever as instru√ß√µes em U3A e U3B :

U3A:

CREATE TABLE

TRABALHA\_EM\_INFO

( Func\_nome

VARCHAR (15),

Proj\_nome

VARCHAR (15),

Horas\_semanal

DECIMAL (3,1) );

U3B: INSERT INTO

TRABALHA\_EM\_INFO

( Func\_nome  Proj\_nome , , Horas\_por\_semana )

SELECT

F.Unome  P .Projnome , , T.Horas

FROM

PROJETO P  TRABALHA\_ , EM T  FUNCIONARIO F ,

WHERE

P.Projnumero = T.Pnr AND T.Fcpf = F.Cpf ;

Uma tabela TRABALHA\_EM\_INFO √©  criada  por U3A e  √©  carregada com a informa√ß√£o da jun√ß√£o recuperada do banco de dados pela consulta em U3B . Agora, podemos consultar TRABALHA\_EM\_INFO como far√≠amos com qualquer outra rela√ß√£o;  quando n√£o precisarmos mais dela, poderemos remov√™-la  usando  o  comando DROP TABLE (ver  Cap√≠tulo 5). Observe que a tabela TRABALHA\_EM\_INFO pode n√£o estar atualizada; ou seja, se atualizarmos qualquer uma das rela√ß√µes PROJETO TRABALHA\_EM , ou FUNCIONARIO depois  de  emitir U3B ,  a  informa√ß√£o em TRABALHA\_EM\_INFO pode  ficar  desatualizada . Temos de criar uma vis√£o, ou view (ver Cap√≠tulo 5), para manter essa tabela atualizada.

## 4.4.2 O comando DELETE

O comando DELETE remove tuplas de uma rela√ß√£o. Ele inclui uma cl√°usula WHERE , semelhante a que √© usada em uma consulta SQL, para selecionar as tuplas a serem exclu√≠das. As tuplas s√£o explicitamente exclu√≠das de apenas uma tabela por vez. No entanto, a exclus√£o pode se propagar para as tuplas

em outras  rela√ß√µes,  se a√ß√µes  de  disparo  referencial forem especificadas nas restri√ß√µes de integridade referencial  da  DDL  (ver  Se√ß√£o  4.2.2). 12 Dependendo do n√∫mero de tuplas selecionadas pela condi√ß√£o na cl√°usula WHERE , zero, uma ou v√°rias tuplas podem ser exclu√≠das por um √∫nico comando DELETE . Uma cl√°usula WHERE inexistente  especifica  que  todas  as tuplas na rela√ß√£o dever√£o ser exclu√≠das; por√©m, a tabela permanece no banco de dados como uma tabela vazia. Temos de usar o comando DROP TABLE para remover a defini√ß√£o da tabela (ver Cap√≠tulo 5). Os comandos DELETE em U4A a U4D ,  se  aplicados  de maneira independente ao banco de dados da Figura 3.6,  excluir√£o  zero,  uma,  quatro  e  todas  as  tuplas, respectivamente, da rela√ß√£o FUNCIONARIO :

U4A:

DELETE FROM

FUNCIONARIO

WHERE

Unome ='Braga';

U4B:

DELETE FROM

FUNCIONARIO

WHERE

Cpf ='12345678966';

U4C:

DELETE FROM

FUNCIONARIO

WHERE

Dnr =5;

U4D:

DELETE FROM

FUNCIONARIO ;

## 4.4.3 O comando UPDATE

O  comando UPDATE √©  usado  para  modificar valores de atributo de uma ou mais tuplas selecionadas. Assim como no comando DELETE , uma cl√°usula WHERE no  comando UPDATE seleciona  as  tuplas  a serem  modificadas  em  uma  √∫nica  rela√ß√£o.  No  entanto, a atualiza√ß√£o de uma chave prim√°ria pode ser propagada para os valores de chave estrangeira das tuplas em outras rela√ß√µes se tal a√ß√£o de disparo referencial for especificada nas restri√ß√µes de integridade referencial  da  DDL (ver Se√ß√£o 4.2.2). Uma cl√°usula SET adicional no comando UPDATE especifica os atributos a serem modificados e seus novos valores. Por exemplo, para alterar o local e n√∫mero de departamento que controla o n√∫mero de projeto 10 para 'Santo Andr√©' e 5, respectivamente, usamos U5 :



os funcion√°rios no departamento 'Pesquisa' um aumento de 10 por cento no sal√°rio, como mostra U6 . Nesta solicita√ß√£o, o valor de Salario modificado depende do valor de Salario em  cada  tupla,  de  modo que duas refer√™ncias ao atributo Salario s√£o necess√°rias. Na cl√°usula SET , a refer√™ncia ao atributo Salario √† direita refere-se ao antigo valor de Salario , antes da modifica√ß√£o ,  e  aquele  √†  esquerda refere-se ao novo valor de Salario , ap√≥s a modifica√ß√£o :

U6:

UPDATE

FUNCIONARIO

SET

Salario = Salario * 1,1

WHERE

Dnr = 5;

Tamb√©m √© poss√≠vel especificar NULL ou DEFAULT como o novo valor do atributo. Observe que cada comando UPDATE refere-se explicitamente a apenas uma √∫nica  rela√ß√£o.  Para  modificar  v√°rias  rela√ß√µes, precisamos emitir v√°rios comandos UPDATE .

## 4.5 Recursos adicionais da SQL

A SQL possui uma s√©rie de recursos adicionais que n√£o descrevemos neste cap√≠tulo, mas que discutiremos em outras partes do livro. S√£o eles:

- ¬Ñ No  Cap√≠tulo  5,  que  √©  uma  continua√ß√£o deste  cap√≠tulo,  apresentaremos  os  seguintes recursos da SQL: diversas t√©cnicas para especificar  consultas  de  recupera√ß√£o  complexas, incluindo consultas aninhadas, fun√ß√µes  de  agrega√ß√£o,  agrupamento,  tabelas com jun√ß√µes ( join ), jun√ß√µes externas ( outer joins ) e consultas recursivas; vis√µes ( views ), gatilhos  ( triggers )  e  asser√ß√µes  ( assertions ) da SQL; e comandos para modifica√ß√£o de esquema.
- ¬Ñ A  linguagem  SQL  possui  diversas  t√©cnicas para escrever programas em v√°rias linguagens de programa√ß√£o, que incluem instru√ß√µes SQL para  acessar  um  ou  mais  bancos  de  dados. Estas  incluem  SQL  embutida  (e  din√¢mica), SQL/CLI (Call Level Interface) e seu predecessor  ODBC (Open Data Base Connectivity) e SQL/PSM (Persistent Stored Modules). Discutiremos essas t√©cnicas no Cap√≠tulo 13. Tamb√©m discutiremos como acessar bancos de dados SQL por meio da linguagem de programa√ß√£o Java usando JDBC e SQLJ.

V√°rias  tuplas  podem  ser  modificadas  com  um √∫nico comando UPDATE . Um exemplo √© dar a todos

- ¬Ñ Cada SGBDR comercial ter√°, al√©m dos comandos  SQL,  um  conjunto  de  comandos para  especificar  par√¢metros  de  projeto  do

12 Outras a√ß√µes podem ser aplicadas automaticamente por meio de disparos (ver Se√ß√£o 26.1) e outros mecanismos.

banco  de  dados  f√≠sico,  estruturas  de  arquivo para rela√ß√µes e caminhos de acesso, como  √≠ndices.  Chamamos  esses  comandos de linguagem  de  defini√ß√£o  de  armazenamento  SDL ( )  no  Cap√≠tulo  2.  As  primeiras vers√µes  da  SQL  tinham  comandos  para criar √≠ndices , mas estes foram removidos da linguagem porque n√£o estavam no n√≠vel de esquema conceitual. Muitos sistemas ainda t√™m comandos CREATE INDEX .

- ¬Ñ A SQL possui comandos de controle de transa√ß√£o. Estes s√£o usados para especificar unidades de processamento de banco de dados para  fins  de  controle  de  concorr√™ncia  e  recupera√ß√£o. Discutiremos esses comandos no Cap√≠tulo 21, depois de discutirmos o conceito de transa√ß√µes com mais detalhes.
- ¬Ñ A  SQL  possui  constru√ß√µes  da  linguagem para especificar a concess√£o e revoga√ß√£o de privil√©gios aos  usu√°rios.  Os  privil√©gios  normalmente  correspondem  ao  direito  de  usar certos  comandos  SQL  para  acessar  determinadas  rela√ß√µes.  Cada  rela√ß√£o  recebe  um owner (propriet√°rio), e este ou o DBA pode conceder a usu√°rios selecionados o privil√©gio de usar uma instru√ß√£o SQL - como SELECT , INSERT , DELETE ou UPDATE - para acessar a rela√ß√£o. Al√©m disso, o DBA pode conceder os  privil√©gios  para  criar  esquemas,  tabelas ou views a certos usu√°rios. Esses comandos SQL - chamados de GRANT e REVOKE -ser√£o discutidos no Cap√≠tulo 24, onde falaremos sobre seguran√ßa e autoriza√ß√£o no banco de dados.
- ¬Ñ A  SQL  possui  constru√ß√µes  de  linguagem para a cria√ß√£o de triggers. Estas geralmente s√£o  conhecidas  como t√©cnicas  de banco de dados ativo , pois especificam a√ß√µes que s√£o disparadas  automaticamente  por  eventos, como atua  liza√ß√µes no banco de dados. Discutiremos esses recursos na Se√ß√£o 26.1, na qual abordaremos os conceitos de banco de dados ativo.
- la√ß√µes aninhadas ), especificar tipos de dados abstratos  (chamados UDT s  ou  tipos  definidos  pelo  usu√°rio)  para  atributos  e  tabelas, criar identificadores  de  objeto para  referenciar tuplas e especificar opera√ß√µes sobre tipos ser√£o discutidas no Cap√≠tulo 11.
- ¬Ñ SQL  e  bancos  de  dados  relacionais  podem interagir com novas tecnologias, como XML (ver Cap√≠tulo 12) e OLAP (Cap√≠tulo 29).

## Resumo

Neste cap√≠tulo, apresentamos a linguagem de banco de dados SQL. Essa linguagem e suas varia√ß√µes t√™m sido implementadas como interfaces para muitos SGBDs relacionais comerciais, incluindo Oracle e Rdb, da Oracle; 13 DB2, Informix Dynamic Server e SQL/DS, da IBM; SQL Server e Access, da Microsoft; e INGRES. Alguns sistemas de c√≥digo aberto tamb√©m fornecem SQL, como MySQL e PostgreSQL. A vers√£o original da SQL foi implementada no SGBD experimental chamado SYSTEM R,  que  foi  desenvolvido  na  IBM  Research.  A  SQL  foi projetada para ser uma linguagem abrangente, que inclui instru√ß√µes para defini√ß√£o de dados, consultas, atualiza√ß√µes, especifica√ß√£o de restri√ß√£o e defini√ß√£o de view. Discutimos os seguintes recursos da SQL neste cap√≠tulo: os comandos de defini√ß√£o de dados para criar tabelas, comandos para especifica√ß√£o de restri√ß√£o, consultas de recupera√ß√£o simples e comandos de atualiza√ß√£o de banco de dados. No pr√≥ximo cap√≠tulo, apresentaremos os seguintes  recursos  da  SQL:  consultas  de  recupera√ß√£o complexas; views; triggers e assertions; e comandos de modifica√ß√£o de esquema.

## Perguntas de revis√£o

- 4.1. Como as rela√ß√µes (tabelas) em SQL diferem das rela√ß√µes  definidas  formalmente  no  Cap√≠tulo  3? Discuta  as  outras  diferen√ßas  na  terminologia. Por  que  a  SQL  permite  tuplas  duplicadas  em uma tabela ou em um resultado de consulta?
- 4.2. Liste os tipos de dados que s√£o permitidos para atributos SQL.
- ¬Ñ A SQL incorporou muitos recursos dos modelos  orientados  a  objeto  para  ter  capacidades  mais  poderosas,  levando  a  sistemas relacionais avan√ßados, conhecidos como objeto-relacional . Capacidades  como  criar atributos  complexos (tamb√©m chamadas re-
- 4.3. Como a SQL permite a implementa√ß√£o das restri√ß√µes de integridade de entidade e de integridade referencial descritas no Cap√≠tulo 3? E as a√ß√µes de disparo referencial?
- 4.4. Descreva as quatro cl√°usulas na sintaxe de uma consulta  de  recupera√ß√£o  SQL  simples.  Mostre que tipo de constru√ß√µes pode ser especificado em cada uma das cl√°usulas. Quais s√£o obrigat√≥rias e quais s√£o opcionais?

13 O Rdb foi produzido originalmente pela Digital Equipment Corporation. Ele foi comprado da Digital pela Oracle em 1994, e est√° recebendo suporte e sendo melhorado.

## Exerc√≠cios

- 4.5. Considere o banco de dados mostrado na Figura 1.2, cujo esquema aparece na Figura 2.1. Quais s√£o  as  restri√ß√µes  de  integridade  referencial  que devem  ser  mantidas  no  esquema?  Escreva  instru√ß√µes DDL da SQL apropriadas para definir o banco de dados.
- 4.6. Repita o Exerc√≠cio 4.5, mas use o esquema de banco de dados COMPANHIA AEREA da Figura 3.8.
- 4.7. Considere  o  esquema  de  banco  de  dados  relacional BIBLIOTECA mostrado  na  Figura  4.6. Escolha  a  a√ß√£o  apropriada  (rejeitar,  propagar, SET NULL , SET DEFAULT ) para cada restri√ß√£o

## LIVRO



## Figura 4.6

Um esquema de banco de dados relacional para um banco de dados BIBLIOTECA.

- de integridade referencial, tanto para a exclus√£o de uma tupla referenciada quanto para a atualiza√ß√£o de um valor de atributo de chave prim√°ria em uma tupla referenciada. Justifique suas escolhas.
- 4.8. Escreva as instru√ß√µes DDL da SQL apropriadas para declarar o esquema de banco de dados relacional BIBLIOTECA da Figura 4.6. Especifique as chaves e a√ß√µes de disparo referencial.
- 4.9. Como as restri√ß√µes de chave e chave estrangeira  podem  ser  impostas  pelo  SGBD?  A  t√©cnica de imposi√ß√£o que voc√™ sugere √© dif√≠cil de implementar? As verifica√ß√µes de restri√ß√£o podem ser executadas de modo eficiente quando as atualiza√ß√µes s√£o aplicadas ao banco de dados?
- 4.10. Especifique as seguintes consultas em SQL sobre o  esquema  de  banco  de  dados  relacional EMPRESA mostrado  na  Figura  3.5.  Mostre  o  resultado de cada consulta se ela for aplicada ao banco de dados EMPRESA na Figura 3.6.
- a. Recupere os nomes de todos os funcion√°rios no departamento 5 que trabalham mais de 10 horas por semana no projeto ProdutoX.
- b. Liste os nomes de todos os funcion√°rios que possuem um dependente com o mesmo primeiro nome que seu pr√≥prio.
- c. Ache os nomes de todos os funcion√°rios que s√£o  supervisionados  diretamente  por  'Fernando Wong'.
- 4.11. Especifique  as  atualiza√ß√µes  do  Exerc√≠cio  3.11 usando comandos de atualiza√ß√£o da SQL.
- 4.12. Especifique as consultas a seguir em SQL no esquema de banco de dados da Figura 1.2.
- a. Recupere os nomes de todos os alunos s√™nior se formando em 'CC' (Ci√™ncia da computa√ß√£o).
- b. Recupere os nomes de todas as disciplinas lecionadas pelo Professor Kleber em 2007 e 2008.
- c. Para cada mat√©ria lecionada pelo Professor Kleber, recupere o n√∫mero da disciplina, semestre, ano e  n√∫mero de  alunos  que  realizaram  a  mat√©ria.
- d. Recupere o nome e o hist√≥rico de cada aluno s√™nior (Tipo\_aluno = 4) formando em CC. Um hist√≥rico inclui nome da disciplina, n√∫mero da disciplina, cr√©dito, semestre, ano e nota para cada disciplina conclu√≠da pelo aluno.
- 4.13. Escreva instru√ß√µes de atualiza√ß√£o SQL para realizar a√ß√µes sobre o esquema de banco de dados mostrado na Figura 1.2.
- a. Inserir um  novo aluno &lt;'Alves, 25, 1, 'MAT'&gt;, no banco de dados.
- b. Alterar a turma do aluno 'Silva' para 2.
- c. Inserir uma nova disciplina, &lt;'Engenharia do conhecimento', 'CC4390', 3, 'CC'&gt;.
- d. Excluir o registro para o aluno cujo nome √© 'Silva' e cujo n√∫mero de aluno √© 17.

- 4.14. Crie um esquema de banco de dados relacional para  uma  aplica√ß√£o  de  banco  de  dados  a  sua escolha.
- a. Declare  suas  rela√ß√µes,  usando  a  DDL  da SQL.
- b. Especifique  algumas  consultas  em  SQL  que sejam necess√°rias para sua aplica√ß√£o de banco de dados.
- c. Com base em seu uso esperado do banco de dados, escolha alguns atributos que dever√£o ter √≠ndices espec√≠ficos.
- d. Implemente seu banco de dados, se voc√™ tiver um SGBD que suporta SQL.
- 4.15. Considere que a restri√ß√£o CHESUPERFUNC da tabela FUNCIONARIO , conforme especificado na Figura 4.2, seja mudada para:

CONSTRAINT CHESUPERFUNC REFERENCES FUNCIONARIO Cpf ( )

ON  DELETE CASCADE ON

UPDATE CASCADE ,

FOREIGN KEY ( Cpf\_supervisor )

Responda √†s seguintes quest√µes:

- a. O que acontece quando o comando a seguir √© executado no estado de banco de dados mostrado na Figura 3.6?

DELETE FUNCIONARIO WHERE Unome = 'Brito'

- b. √â melhor usar CASCADE ou SET NULL no caso da restri√ß√£o ON DELETE de CHESUPERFUNC?

4.16. Escreva  instru√ß√µes  SQL  para  criar  uma  tabela FUNCIONARIO\_BACKUP para  fazer  o  backup da tabela FUNCIONARIO mostrada na Figura 3.6.

## Bibliografia selecionada

A linguagem SQL, originalmente chamada SEQUEL, foi baseada na linguagem SQUARE (Specifying Queries as Relational Expressions), descrita por Boyce et al. (1975). A sintaxe  da  SQUARE foi  modificada  para  a  SEQUEL (Chamberlin  e  Boyce,  1974)  e  depois  para  SEQUEL  2 (Chamberlin et al., 1976), na qual a SQL √© baseada. A implementa√ß√£o original da SEQUEL foi feita na IBM Research, em San Jose, Calif√≥rnia. Mostraremos outras refer√™ncias aos v√°rios aspectos da SQL ao final do Cap√≠tulo 5.



## Mais SQL: Consultas complexas, triggers, views e modifica√ß√£o de esquema

E ste cap√≠tulo descreve recursos mais avan√ßados da linguagem SQL padr√£o para bancos de dados relacionais. Come√ßamos na Se√ß√£o 5.1 apresentando recursos mais complexos das consultas de recupera√ß√£o SQL,  como  consultas  aninhadas,  tabelas  com  jun√ß√µes, jun√ß√µes externas, fun√ß√µes de agrega√ß√£o e agrupamento.  Na  Se√ß√£o  5.2,  descrevemos  o  comando CREATE ASSERTION , que permite a especifica√ß√£o de restri√ß√µes mais gerais sobre o banco de dados. Tamb√©m apresentamos o conceito de triggers (gatilhos) e o comando CREATE TRIGGER , que ser√° descrito com mais detalhes  na  Se√ß√£o  26.1,  quando  mostraremos os princ√≠pios dos bancos de dados ativos. Depois, na Se√ß√£o 5.3, descrevemos a facilidade da SQL para definir views (vis√µes) no banco de dados. As views tamb√©m s√£o chamadas de tabelas virtuais ou derivadas , pois apresentam ao usu√°rio o que parecem ser tabelas; por√©m, a informa√ß√£o nessas tabelas √© derivada de tabelas previamente definidas. A Se√ß√£o 5.4 apresenta o comando SQL ALTER TABLE , que √© usado para modificar as tabelas e restri√ß√µes do banco de dados. No final h√° um resumo do cap√≠tulo.

Este cap√≠tulo √© uma continua√ß√£o do Cap√≠tulo 4. O leitor poder√° pular partes deste cap√≠tulo se desejar uma introdu√ß√£o menos detalhada √† linguagem SQL.

## 5.1 Consultas de recupera√ß√£o SQL mais complexas

Na Se√ß√£o 4.3, descrevemos alguns tipos b√°sicos de consultas de recupera√ß√£o em SQL. Por causa da generalidade  e  do  poder  expressivo  da  linguagem, existem muitos outros recursos adicionais que permitem que os usu√°rios especifiquem recupera√ß√µes mais complexas do banco de dados. Discutiremos v√°rios desses recursos nesta se√ß√£o.

## 5.1.1 Compara√ß√µes envolvendo NULL e l√≥gica de tr√™s valores

A SQL tem diversas regras para lidar com valores NULL . Lembre-se, da Se√ß√£o 3.1.2, que NULL √© usado para representar um valor que est√° faltando, mas que em geral tem uma de tr√™s interpreta√ß√µes diferentes valor desconhecido (existe,  mas  n√£o  √©  conhecido), valor n√£o dispon√≠vel (existe, mas √© propositadamente retido)  ou  valor n√£o  aplic√°vel (o  atributo  √©  indefinido para essa tupla). Considere os seguintes exemplos para ilustrar cada um dos significados de NULL .

- 1. Valor desconhecido. A data de nascimento de uma pessoa n√£o √© conhecida, e por isso √© representada por NULL no banco de dados.
- 2. Valor indispon√≠vel ou retido. Uma pessoa tem um telefone residencial, mas n√£o deseja que ele seja listado, por isso ele √© retido e representado como NULL no banco de dados.
- 3. Atributo n√£o aplic√°vel. Um atributo Conjuge seria NULL para uma pessoa que n√£o fosse casada, pois ele n√£o se aplica a essa pessoa.

Normalmente, n√£o √© poss√≠vel determinar qual dos significados  √©  intencionado;  por  exemplo,  um NULL para  o  telefone  residencial  de  uma  pessoa  pode  ter qualquer um dos tr√™s significados. Logo, a SQL n√£o distingue entre os diferentes significados de NULL .

Em geral, cada valor NULL individual √© considerado diferente de qualquer outro valor NULL nos diversos registros do banco de dados. Quando um

NULL est√° envolvido em uma opera√ß√£o de compara√ß√£o, o resultado √© considerado UNKNOWN , ou desconhecido  (e  pode  ser TRUE ou FALSE ).  Assim,  a SQL usa uma l√≥gica de tr√™s valores com os valores TRUE FALSE , e UNKNOWN em vez da l√≥gica de dois valores (booleana) padr√£o, com os valores TRUE e FALSF .  Portanto, √© necess√°rio definir os resultados (ou valores verdadeiros) das express√µes l√≥gicas de tr√™s valores quando os conectivos l√≥gicos AND OR , e NOT forem usados. A Tabela 5.1 mostra os valores resultantes.

Nas Tabelas 5.1(a) e 5.1(b), as linhas e colunas representam  os  valores  dos  resultados  das  condi√ß√µes  de  compara√ß√£o,  que  normalmente  apareceriam  na  cl√°usula WHERE de  uma  consulta  SQL. Cada resultado de express√£o teria um valor TRUE , FALSE ou UNKNOWN . O resultado da combina√ß√£o de  dois  valores  usando  o  conectivo  l√≥gico AND √© mostrado pelas  entradas  na  Tabela  5.1(a).  A  Tabela 5.1(b) mostra o resultado do uso do conectivo l√≥gico OR . Por exemplo, o resultado de ( FALSE AND UNKNOWN ) √© FALSE , ao passo que o resultado de ( FALSE OR UNKNOWN ) √© UNKNOWN . A Tabela 5.1(c) mostra o resultado da opera√ß√£o l√≥gica NOT . Observe que, na l√≥gica booleana padr√£o, somente valores TRUE e FALSE s√£o  permitidos;  n√£o  existe um valor UNKNOWN .

Nas consultas sele√ß√£o-proje√ß√£o-jun√ß√£o, a regra geral √© que somente as combina√ß√µes de tuplas que avaliam a express√£o l√≥gica na cl√°usula WHERE da consulta como TRUE s√£o selecionadas. As combi-

Tabela 5.1 Conectivos l√≥gicos na l√≥gica de tr√™s valores.

| (a)   | AND     | TRUE    | FALSE   | UNKNOWN   |
|-------|---------|---------|---------|-----------|
|       | TRUE    | TRUE    | FALSE   | UNKNOWN   |
|       | FALSE   | FALSE   | FALSE   | FALSE     |
|       | UNKNOWN | UNKNOWN | FALSE   | UNKNOWN   |
| (b)   | OR      | TRUE    | FALSE   | UNKNOWN   |
|       | TRUE    | TRUE    | TRUE    | TRUE      |
|       | FALSE   | TRUE    | FALSE   | UNKNOWN   |
|       | UNKNOWN | TRUE    | UNKNOWN | UNKNOWN   |
| (c)   | NOT     |         |         |           |
|       | TRUE    | FALSE   |         |           |
|       | FALSE   | TRUE    |         |           |
|       | UNKNOWN | UNKNOWN |         |           |

na√ß√µes de tupla que s√£o avaliadas como FALSE ou UNKNOWN n√£o  s√£o  selecionadas.  Por√©m, existem exce√ß√µes a essa regra para certas opera√ß√µes, como jun√ß√µes externas ( outer joins ),  conforme veremos na Se√ß√£o 5.1.6.

A SQL permite consultas que verificam se o valor de um atributo √© NULL . Em vez de usar = ou &lt;&gt; para  comparar  o  valor  de  um  atributo  com NULL , a  SQL  usa  os  operadores  de  compara√ß√£o IS ou IS NOT . Isso porque ela considera cada valor NULL sendo distinto de cada outro valor NULL , de modo que a compara√ß√£o de igualdade n√£o √© apropriada. Acontece que, quando uma condi√ß√£o de jun√ß√£o √© especificada, as tuplas com valores NULL para os atributos de jun√ß√£o n√£o s√£o inclu√≠das no resultado (a menos que seja uma OUTER JOIN ; ver Se√ß√£o 5.1.6). A Consulta 18 ilustra isso.

Consulta 18. Recuperar os nomes de todos os funcion√°rios que n√£o possuem supervisores.

| C18:   | SELECT   | Pnome , Unome          |
|--------|----------|------------------------|
|        | FROM     | FUNCIONARIO            |
|        | WHERE    | Cpf_supervisor IS NULL |

## 5.1.2 Consultas aninhadas, tuplas e compara√ß√µes de conjunto/ multiconjunto

Algumas consultas precisam que os valores existentes  no  banco de dados sejam buscados e depois usados  em  uma  condi√ß√£o  de  compara√ß√£o.  Essas consultas  podem  ser  formuladas  convenientemente usando consultas aninhadas ,  que  s√£o  blocos  select-from-where  completos  dentro  da  cl√°usula WHERE de outra consulta. Essa outra consulta √© chamada de consulta externa .  A Consulta 4 √© formulada em C4 sem uma consulta aninhada, mas pode ser reformulada para usar consultas aninhadas, como mostramos em C4A . A C4A introduz o operador de compara√ß√£o IN ,  que compara um valor v com um conjunto (ou multiconjunto) de valores V e avalia como TRUE se v for um dos elementos em V .

A primeira consulta aninhada seleciona os n√∫meros dos projetos que possuem um funcion√°rio com sobrenome 'Silva' envolvido como gerente, enquanto a  segunda consulta aninhada seleciona os n√∫meros dos  projetos  que  possuem  um  funcion√°rio  com  o sobrenome 'Silva' envolvido como trabalhador. Na consulta externa, usamos o conectivo l√≥gico OR para recuperar uma tupla PROJETO se o valor de PROJNUMERO dessa  tupla  estiver  no  resultado  de  qualquer uma das consultas aninhadas.

## C4A: SELECTDISTINCT Projnumero

FROM WHERE

PROJETO

Projnumero IN

( SELECT

Projnumero

FROM

PROJETO ,

DEPARTAMENTO ,

FUNCIONARIO

WHERE

Dnum Dnumero = AND

Cpf\_gerente = Cpf

AND Unome ='Silva' )

OR Projnumero IN

( SELECT

Pnr

FROM

TRABALHA\_EM ,

FUNCIONARIO

WHERE

Fcpf = Cpf AND

Unome ='Silva' );

Se uma consulta aninhada retornar um √∫nico atributo e uma √∫nica tupla, o resultado da consulta ser√° um √∫nico valor (escalar). Nesses casos, √© permitido usar = em vez de IN para o operador de compara√ß√£o. Em geral, a consulta aninhada retornar√° uma tabela (rela√ß√£o), que √© um conjunto ou multiconjunto de tuplas.

A SQL permite o uso de tuplas de valores em compara√ß√µes, colocando-os entre par√™nteses. Para ilustrar isso, considere a seguinte consulta:

SELECT DISTINCT Fcpf

FROM

TRABALHA\_EM

WHERE

(

Pnr

,

Horas

)

IN

( SELECT Pnr  Horas ,

FROM

TRABALHA\_EM

WHERE Fcpf ='12345678966' );

Essa consulta selecionar√° os Fcpf s de todos os funcion√°rios que trabalham na mesma combina√ß√£o (projeto, horas) em algum projeto que o funcion√°rio 'Jo√£o Silva'  (cujo Cpf =  '12345678966')  trabalha.  Neste exemplo, o operador IN compara a subtupla de valores entre par√™nteses ( Pnr , Horas ) dentro de cada tupla em TRABALHA\_EM com o conjunto de tuplas com tipos compat√≠veis produzidas pela consulta aninhada.

Al√©m do operador IN , diversos outros operadores de compara√ß√£o podem ser usados para comparar um √∫nico valor v (em geral, um nome de atributo) com um conjunto ou multiconjunto v (tipicamente, uma consulta aninhada). O operador = ANY (ou = SOME ) retorna TRUE se o valor v for igual a algum valor no conjunto V e, portanto, √© equivalente a IN . As duas palavras-chave ANY e SOME possuem o mesmo efeito.  Outros  operadores  que  podem  ser  combinados com ANY (ou SOME )  incluem &gt;, &gt;=, &lt;, &lt;= e &lt;&gt;. A palavra-chave ALL tamb√©m pode ser combinada com cada um desses operadores. Por exemplo, a condi√ß√£o de compara√ß√£o ( v &gt; ALL V ) retorna TRUE se o valor v √©  maior do que todos os valores no conjunto (ou multiconjunto) V . Um exemplo √© a consulta a seguir, que retorna os nomes dos funcion√°rios cujo sal√°rio √© maior do que o sal√°rio de todos os funcion√°rios no departamento 5:

SELECT Unome  Pnome ,

FROM FUNCIONARIO

WHERE

Salario

&gt;

ALL

( SELECT

Salario

FROM

FUNCIONARIO

WHERE

Dnr =5 );

Observe que essa consulta tamb√©m pode ser especificada  usando a fun√ß√£o de agrega√ß√£o MAX (ver Se√ß√£o 5.1.7).

Em geral, podemos ter v√°rios n√≠veis de consultas aninhadas. Podemos mais uma vez lidar com a poss√≠vel ambiguidade entre nomes de atributo se existirem atributos com o mesmo nome - um em uma rela√ß√£o na cl√°usula FROM da consulta exterior e outro em uma rela√ß√£o na cl√°usula FROM da consulta aninhada . A regra √© que uma refer√™ncia a um atributo n√£o qualificado refere-se √† rela√ß√£o declarada na consulta aninhada mais  interna .  Por  exemplo,  nas  cl√°usulas SELECT e WHERE da primeira consulta aninhada de C4A , uma refer√™ncia a qualquer atributo n√£o qualificado da rela√ß√£o PROJETO refere-se √† rela√ß√£o PROJETO especificada na cl√°usula FROM da consulta aninhada. Para se referir a um atributo da rela√ß√£o PROJETO especificada na consulta externa, especificamos e nos referimos a um apelido (vari√°vel de tupla) para essa rela√ß√£o. Essas regras s√£o semelhantes √†s regras de escopo para vari√°veis de programa na maioria das linguagens de programa√ß√£o que permitem procedimentos e fun√ß√µes aninhadas. Para ilustrar a ambiguidade em potencial dos nomes de atributo nas consultas aninhadas, considere a Consulta 16.

Consulta  16. Recuperar  o  nome  de  cada  funcion√°rio que tem um dependente com o mesmo nome e com o mesmo sexo do funcion√°rio.

C16: SELECT F.Pnome  F.Unome ,

FROM

FUNCIONARIO AS F

WHERE F.Cpf IN

( SELECT D.Fcpf

FROM

DEPENDENTE

AS D

WHERE

F.Pnome =

D.Nome\_

dependente

AND

F.Sexo =

D.Sexo );

Na  consulta  aninhada  de C16 ,  temos  de  qualificar F.Sexo porque  se  refere  ao  atributo Sexo de FUNCIONARIO da consulta externa, e DEPENDENTE tamb√©m  tem  um  atributo  chamado Sexo .  Se  houvesse quaisquer refer√™ncias n√£o qualificadas a Sexo na consulta aninhada, elas se refeririam ao atributo Sexo de DEPENDENTF . No entanto, n√£o ter√≠amos de qualificar  os  atributos Pnome e Cpf de FUNCIONARIO se  eles  aparecessem na consulta aninhada, pois a rela√ß√£o DEPENDENTE n√£o tem atributos chamados Pnome e Cpf , de modo que n√£o existe ambiguidade.

√â aconselh√°vel criar vari√°veis de tupla ( apelidos ) para todas as tabelas referenciadas em uma consulta SQL , para evitar erros e ambiguidades em potencial, conforme ilustrado em C16 .

## 5.1.3 Consultas aninhadas correlacionadas

Sempre que uma condi√ß√£o na cl√°usula WHERE de uma consulta aninhada referencia algum atributo de uma rela√ß√£o declarada na consulta externa, as duas consultas s√£o consideradas correlacionadas . Podemos entender melhor uma consulta correlacionada ao considerar que a consulta aninhada √© avaliada uma vez para cada tupla (ou combina√ß√£o de tuplas) na consulta externa .  Por exemplo, podemos pensar em C16 da seguinte forma: para cada tupla FUNCIONARIO , avalie a consulta aninhada, que recupera os valores de Fcpf para todas as tuplas de DEPENDENTE com o mesmo sexo e nome da tupla em FUNCIONARIO ; se o valor de Cpf da tupla FUNCIONARIO estiver no resultado da consulta aninhada, ent√£o selecione essa tupla FUNCIONARIO .

Em geral, uma consulta escrita com blocos aninhados select-from-where e usando os operadores de compara√ß√£o = ou IN sempre pode ser expressa como uma  √∫nica  consulta  em  bloco.  Por  exemplo, C16 pode ser escrito como em C16A :

C16A:SELECT

F.Pnome  F.Unome ,

FROM

FUNCIONARIO AS F ,

DEPENDENTE AS D

WHERE

F.Cpf = D.Fcpf AND F.Sexo = D.Sexo

AND F .Pnome = D.Nome\_dependente ;

## 5.1.4 As fun√ß√µes EXISTS e UNIQUE em SQL

A fun√ß√£o EXISTS em SQL √© usada para verificar se o resultado de uma consulta aninhada correlacionada √© vazio (n√£o cont√©m tuplas) ou n√£o. O resultado de EXISTS √©  um  valor  booleano TRUE se  o  resultado da consulta aninhada tiver pelo menos uma tupla, ou FALSE , se o resultado da consulta aninhada n√£o tiver  tuplas.  Ilustramos  o  uso  de EXISTS -  e NOT EXISTS - com alguns exemplos. Primeiro, formulamos a Consulta 16 de uma forma alternativa, que usa EXISTS, como em C16B :

C16B: SELECT F.Pnome  F.Unome ,

FROM

FUNCIONARIO AS F

WHERE EXISTS

( SELECT *

FROM

DEPENDENTE

AS D

WHERE

F.Cpf = D.Fcpf

AND F.Sexo =

D.Sexo

AND F.Pnome =

D.Nome\_

dependente );

EXISTS e NOT EXISTS costumam ser usados em conjunto com uma consulta aninhada correlacionada. Em C16B , a consulta aninhada referencia os atributos Cpf , Pnome e Sexo da rela√ß√£o FUNCIONARIO da  consulta  externa.  Podemos  pensar  em C16B da seguinte forma: para cada tupla FUNCIONARIO , avalie a consulta aninhada, que recupera todas as tuplas DEPENDENTE com os mesmos Fcpf , Sexo e Nome\_de-pendente que a tupla FUNCIONARIO ; se houver pelo menos uma tupla EXISTS no  resultado  da  consulta aninhada,  ent√£o  selecionar  a  tupla FUNCIONARIO . Em  geral, EXISTS C ( )  retorna TRUE se  existe pelo menos uma tupla no resultado da consulta aninhada C , e retorna FALSE em caso contr√°rio. Por sua vez, NOT EXISTS C ( ) retorna TRUE se n√£o houver tuplas no resultado da consulta aninhada C , e retorna FALSE caso contr√°rio. Em seguida, ilustramos o uso de NOT EXISTS .

Consulta 6 . Recuperar os nomes de funcion√°rios que n√£o possuem dependentes.

C6: SELECT

Pnome  Unome ,

FROM FUNCIONARIO

WHERE NOT EXISTS (  SELECT *

FROM DEPENDENTE WHERE Cpf = Fcpf );

Em C6 , a consulta aninhada correlacionada recupera  todas  as  tuplas  de DEPENDENTE relacionadas a uma tupla FUNCIONARIO em particular. Se n√£o existir nenhuma , a tupla FUNCIONARIO √© selecionada, porque a condi√ß√£o da cl√°usula WHERE ser√° avaliada como TRUE nesse caso. Podemos explicar C6 da seguinte forma: para cada tupla FUNCIONARIO , a

consulta aninhada correlacionada seleciona todas as tuplas DEPENDENTE cujo valor de Fcpf combina com o Cpf de FUNCIONARIO ; se o resultado for vazio, nenhum dependente estar√° relacionado ao funcion√°rio, de modo que selecionamos essa tupla FUNCIONARIO e recuperamos seu Pnome e Unome .

Consulta 7 . Listar os nomes dos gerentes que possuem pelo menos um dependente.

C7: SELECT

Pnome  Unome

,

FROM

FUNCIONARIO

WHERE EXISTS ( SELECT

*

FROM

DEPENDENTE

WHERE

Cpf

=

Fcpf

)

AND

EXISTS ( SELECT

*

FROM

DEPARTAMENTO

WHERE

Cpf

=

Cpf\_gerente

);

Uma maneira de escrever essa consulta √© mostrada em C7 ,  onde  especificamos duas consultas aninhadas correlacionadas;  a  primeira  seleciona  todas  as  tuplas de DEPENDENTE relacionadas a um FUNCIONARIO , e a segunda seleciona todas as tuplas de DEPARTAMENTO gerenciadas pelo FUNCIONARIO . Se pelo menos uma da primeira e pelo menos uma da segunda existir, selecionamos a tupla FUNCIONARIO . Voc√™ consegue reescrever  essa  consulta  usando  apenas  uma  √∫nica  consulta aninhada ou nenhuma consulta aninhada?

A consulta C3, recuperar o nome de cada funcion√°rio que trabalha em todos os projetos controlados pelo departamento n√∫mero 5 , pode ser escrita usando EXISTS e NOT EXISTS nos sistemas SQL. Mostramos duas maneiras de especificar essa consulta C3 em SQL como C3A e C3B .  Este  √©  um  exemplo  de  certos  tipos de consultas que exigem quantifica√ß√£o universal , conforme discutiremos na Se√ß√£o 6.6.7. Um modo de escrever essa consulta √© usar a constru√ß√£o ( S2 EXCEPT S1 ), conforme explicaremos a seguir, e verificar se o resultado √© vazio. 1 Essa op√ß√£o aparece como C3A .

| C3A:   | SELECT FROM WHERE   | Pnome , Unome FUNCIONARIO NOT EXISTS ( (   |
|--------|---------------------|--------------------------------------------|
|        |                     | SELECT Projnumero                          |
|        |                     | FROM PROJETO                               |
|        |                     | WHERE Dnum =5)                             |
|        |                     | EXCEPT (                                   |
|        |                     | SELECT Pnr                                 |
|        |                     | FROM TRABALHA_EM                           |
|        |                     | WHERE Cpf = Fcpf                           |

projetos controlados pelo departamento 5, e a segunda subconsulta  (que  est√°  correlacionada)  seleciona  todos os projetos em que o funcion√°rio em particular trabalha. Se a diferen√ßa de conjunto do resultado da primeira subconsulta menos (SUBTRA√á√ÉO) ( EXCEPT ) o resultado da segunda subconsulta for vazio, isso significa que o funcion√°rio trabalha em todos os projetos e, portanto, √© selecionado.

A segunda op√ß√£o aparece como C3B .  Observe que  precisamos  de  aninhamento  de  dois  n√≠veis  em C3B e  que essa formula√ß√£o √© muito mais complexa do que C3A , que usa NOT EXISTS e EXCEPT .



| C3B:   | Unome , Pnome       | Unome , Pnome                   |
|--------|---------------------|---------------------------------|
|        | FUNCIONARIO         | FUNCIONARIO                     |
|        | NOT EXISTS          | NOT EXISTS                      |
|        | ( SELECT            | *                               |
|        | FROM                | TRABALHA_EM T1                  |
|        | WHERE               | ( T1.Pnr IN ( SELECT Projnumero |
|        |                     | FROM PROJETO                    |
|        |                     | WHERE Dnum =5 )                 |
|        | AND NOT EXISTS      | AND NOT EXISTS                  |
|        | ( SELECT *          | ( SELECT *                      |
|        | FROM TRABALHA_EM T2 | FROM TRABALHA_EM T2             |
|        | WHERE               | T2.Fcpf = Cpf                   |
|        | AND                 | T2.Pnr = B.Pnr )));             |

Em C3B , a consulta aninhada externa seleciona quaisquer tuplas de TRABALHA\_EM (T1)  cujo Pnr √© de  um  projeto  controlado  pelo  departamento  5, se n√£o houver uma tupla em TRABALHA\_EM (T2) com o mesmo Pnr e o mesmo Cpf daquele da tupla FUNCIONARIO em  considera√ß√£o na consulta externa. Se n√£o existir tal tupla, selecionamos a tupla FUNCIONARIO . A forma de C3B combina com a reformula√ß√£o da Consulta 3 a seguir: selecionar cada funcion√°rio de modo que n√£o exista um projeto controlado pelo departamento 5 em que o funcion√°rio n√£o trabalha. Isso corresponde ao modo como escreveremos essa consulta no c√°lculo relacional de tupla (ver Se√ß√£o 6.6.7).

Existe outra fun√ß√£o em SQL, UNIQUE C ( ), que retorna TRUE se n√£o houver tuplas duplicadas no resultado da consulta C ; caso contr√°rio, ela retorna FALSF . Isso pode ser usado para testar se o resultado de uma consulta aninhada √© um conjunto ou um multiconjunto.

## 5.1.5 Conjuntos expl√≠citos e renomea√ß√£o de atributos em SQL

Em C3A , a  primeira  subconsulta  (que  n√£o  est√° correlacionada  √†  consulta  externa)  seleciona  todos  os

Vimos v√°rias consultas com uma consulta aninhada na cl√°usula WHERF . Tamb√©m √© poss√≠vel usar um conjunto expl√≠cito de valores na cl√°usula WHERE , em vez de uma consulta aninhada. Esse conjunto √© delimitado por par√™nteses em SQL.

1 Lembre-se de que EXCEPT √© um operador de diferen√ßa de conjunto. A palavra-chave MINUS √†s vezes √© usada, por exemplo, no Oracle.

Consulta 17 . Recuperar os n√∫meros do CPF de todos os funcion√°rios que trabalham nos projetos de n√∫meros 1, 2 ou 3.

C17: SELECT FROM WHERE

DISTINCT Fcpf

TRABALHA\_EM

Pnr IN (1, 2, 3);

Em SQL, √© poss√≠vel renomear qualquer atributo que apare√ßa no resultado de uma consulta acrescentando o qualificador AS seguido pelo novo nome desejado. Logo, a constru√ß√£o AS pode ser usada para apelidar os nomes tanto do atributo quanto da rela√ß√£o, e ele pode ser usado nas cl√°usulas SELECT e FROM . Por exemplo, a C8A mostra como a consulta C8 da Se√ß√£o 4.3.2 pode ser ligeiramente alterada para recuperar o  √∫ltimo  nome  de  cada  funcion√°rio  e  seu  supervisor, enquanto renomeia os atributos resultantes como Nome\_funcionario e Nome\_supervisor . Os novos nomes aparecer√£o como cabe√ßalhos de coluna no resultado da consulta.

C8A: SELECT

F.Unome AS Nome\_funcionario ,

S.Unome AS Nome\_supervisor

FROM

FUNCIONARIO AS F ,

FUNCIONARIO AS S

WHERE

F.Cpf\_supervisor = S.Cpf ;

## 5.1.6 abelas de jun√ß√£o em SQL e jun√ß√µes T externas (outer joins)

O conceito de uma tabela de jun√ß√£o (ou rela√ß√£o de jun√ß√£o ) foi incorporado na SQL para permitir aos usu√°rios  especificar  uma  tabela  resultante  de  uma opera√ß√£o de jun√ß√£o na cl√°usula FROM de uma consulta. Essa constru√ß√£o pode ser mais f√°cil de compreender do que misturar todas as condi√ß√µes de sele√ß√£o e jun√ß√£o na cl√°usula WHERF .  Por  exemplo, considere a consulta C1 , que recupera o nome e o endere√ßo de todos os funcion√°rios que trabalham para o departamento 'Pesquisa'. Pode ser mais f√°cil especificar a jun√ß√£o  das  rela√ß√µes FUNCIONARIO e DEPARTAMENTO primeiro, e depois selecionar as tuplas e atributos desejados. Isso pode ser escrito em SQL como em C1A :

C1A: SELECT

Pnome  Unome  Endereco , ,

FROM

( FUNCIONARIO JOIN

DEPARTAMENTO

ON Dnr = Dnumero )

WHERE

Dnome ='Pesquisa';

A cl√°usula FROM em C1A cont√©m uma √∫nica tabela de jun√ß√£o . Os atributos dessa tabela s√£o todos os  atributos  da  primeira  tabela, FUNCIONARIO ,  se- guidos por todos os atributos da segunda tabela, DEPARTAMENTO . O conceito de uma tabela de jun√ß√£o tamb√©m permite que o usu√°rio especifique diferentes tipos de jun√ß√£o, como NATURAL JOIN ( jun√ß√£o natural) ,  e  v√°rios  tipos  de OUTER JOIN ( jun√ß√£o externa) . Em uma NATURAL JOIN sobre  duas  rea√ß√µes R e S , nenhuma condi√ß√£o de jun√ß√£o √© especificada; cria-se uma condi√ß√£o EQUIJOIN impl√≠cita para cada par de atributos  com  o  mesmo  nome de R e S .  Cada  par de atributos desse tipo √© inclu√≠do apenas uma vez na rela√ß√£o resultante (ver se√ß√µes 6.3.2 e 6.4.4 para mais detalhes sobre os v√°rios tipos de opera√ß√µes de jun√ß√£o na √°lgebra relacional).

Se os nomes dos atributos de jun√ß√£o n√£o forem os mesmos nas rela√ß√µes da base, √© poss√≠vel renomear os atributos de modo que eles combinem, e depois aplicar a NATURAL JOIN . Nesse caso, a constru√ß√£o AS pode ser usada para renomear uma rela√ß√£o e todos os seus atributos na cl√°usula FROM . Isso √© ilustrado em C1B , onde a rela√ß√£o DEPARTAMENTO √© renomeada como DEP e seus atributos s√£o renomeados como Dnome , Dnr (para combinar com o nome do atributo de jun√ß√£o desejado Dnr na tabela FUNCIONARIO ), Cpf\_gerente e Data\_incio\_gerente .  O  significado  da condi√ß√£o de jun√ß√£o para esse NATURAL JOIN √© FUNCIONARIO.Dnr = DEPT.Dnr , porque esse √© o √∫nico par de atributos com o mesmo nome ap√≥s a renomea√ß√£o:

C1B: SELECT

Pnome  Unome  Endereco , ,

FROM

( FUNCIONARIO NATURAL JOIN

(DEPARTAMENTO AS DEP

( Dnome Dnr Cpf\_gerente Data\_inicio\_gerente , , , )))

WHERE Dnome ='Pesquisa';

O tipo padr√£o de jun√ß√£o em uma tabela de jun√ß√£o √© chamado de inner join ,  onde uma tupla √© inclu√≠da no resultado somente se uma tupla combinar na outra rela√ß√£o. Por exemplo, na consulta C8A , somente os  funcion√°rios  que possuem um supervisor s√£o inclu√≠dos no resultado; uma tupla FUNCIONARIO cujo valor para Cpf\_supervisor √© NULL √© exclu√≠da. Se o usu√°rio exigir que todos os funcion√°rios sejam inclu√≠dos, uma OUTER JOIN precisa ser usada explicitamente (veja a defini√ß√£o de OUTER JOIN na  Se√ß√£o 6.4.4). Em SQL, isso √© tratado especificando explicitamente a palavra-chave OUTER JOIN em uma tabela de jun√ß√£o, conforme ilustrado em C8B :

C8B: SELECT

F.Unome AS Nome\_funcionario, S.Unome AS Nome\_supervisor FUNCIONARIO

FROM

( FUNCIONARIO AS F LEFT OUTER JOIN AS S ON F.Cpf\_supervisor = S.Cpf );

Existem  diversas  opera√ß√µes  de  jun√ß√£o  externa, que discutiremos com mais detalhes na Se√ß√£o 6.4.4. Em SQL, as op√ß√µes dispon√≠veis para especificar tabelas  de  jun√ß√£o  incluem INNER JOIN (apenas  pares  de tuplas que combinam com a condi√ß√£o de jun√ß√£o s√£o recuperadas, o mesmo que JOIN ), LEFT OUTER JOIN (toda  tupla  na  tabela  da  esquerda  precisa  aparecer no resultado; se ela n√£o tiver uma tupla combinando, ela √© preenchida com valores NULL para os atributos da tabela da direita), RIGHT OUTER JOIN (toda tupla na  tabela  da  direita  precisa  aparecer  no  resultado; se ela n√£o tiver uma tupla combinando, ela √© preenchida com valores NULL para os atributos da tabela da esquerda) e FULL OUTER JOIN .  Nas  tr√™s  √∫ltimas op√ß√µes a palavra-chave OUTER pode ser omitida. Se os atributos de jun√ß√£o tiverem o mesmo nome, tamb√©m √© poss√≠vel especificar a varia√ß√£o de jun√ß√£o natural das jun√ß√µes externas usando a palavra-chave NATURAL antes da opera√ß√£o (por exemplo, NATURAL LEFT OUTER JOIN ). A palavra-chave CROSS JOIN √© usada para especificar a opera√ß√£o PRODUTO CARTESIANO (ver Se√ß√£o 6.2.2), embora isso s√≥ deva ser feito com o m√°ximo de cuidado, pois gera todas as combina√ß√µes de tuplas poss√≠veis.

Tamb√©m  √©  poss√≠vel aninhar especifica√ß√µes  de jun√ß√£o;  ou  seja,  uma  das  tabelas  em  uma  jun√ß√£o pode ela mesma ser uma tabela de jun√ß√£o. Isso permite a especifica√ß√£o da jun√ß√£o de tr√™s ou mais tabelas como uma √∫nica tabela de jun√ß√£o, o que √© chamado de jun√ß√£o m√∫ltipla . Por exemplo, a C2A √© um modo diferente de especificar a consulta C2 , da Se√ß√£o 4.3.1, usando o conceito de uma tabela de jun√ß√£o:

C2A: SELECT

Projnumero  Dnum  Unome , , ,

Endereco  Datanasc ,

FROM

(( PROJETO JOIN DEPARTAMENTO

ON Dnum Dnumero = ) JOIN

FUNCIONARIO ON

Cpf\_gerente = Cpf )

WHERE

Projlocal ='Mau√°';

a condi√ß√£o de jun√ß√£o. Por exemplo, essa sintaxe est√° dispon√≠vel no Oracle. Para especificar a jun√ß√£o externa esquerda na C8B usando essa sintaxe, poder√≠amos escrever a consulta C8C , da seguinte forma:

C8C: SELECT

F.Unome  S.Unome ,

FROM

FUNCIONARIO F ,

FUNCIONARIO S

WHERE

F.Cpf\_supervisor + = S.Cpf ;

## 5.1.7 Fun√ß√µes de agrega√ß√£o em SQL

Na Se√ß√£o 6.4.2,  apresentaremos  o  conceito  de uma fun√ß√£o de agrega√ß√£o como uma opera√ß√£o da √°lgebra relacional. As fun√ß√µes de agrega√ß√£o s√£o usadas para resumir informa√ß√µes de v√°rias tuplas em uma s√≠ntese de tupla √∫nica. O agrupamento √© usado para criar subgrupos de tuplas antes do resumo. O agrupamento e a agrega√ß√£o s√£o exigidos em muitas aplica√ß√µes de banco de dados, e apresentaremos seu uso na SQL por meio de exemplos. Existem diversas fun√ß√µes de agrega√ß√£o embutidas: COUNT SUM MAX MIN , , , e

AVG . 2 A fun√ß√£o COUNT retorna o n√∫mero de tuplas ou valores, conforme especificado em uma consulta. As fun√ß√µes SUM MAX MIN , , e AVG podem ser aplicadas a um conjunto ou multiconjunto de valores num√©ricos e retornam, respectivamente, a soma, o valor m√°ximo, o valor m√≠nimo e a m√©dia desses valores. Essas fun√ß√µes podem ser usadas na cl√°usula SELECT ou  em  uma  cl√°usula HAVING (que  apresentaremos mais adiante). As fun√ß√µes MAX e MIN tamb√©m podem ser usadas com atributos que possuem dom√≠nios n√£o num√©ricos, se os valores do dom√≠nio tiverem uma ordena√ß√£o total entre si.  Vamos ilustrar o uso dessas 3 fun√ß√µes com algumas consultas.

Consulta 19 . Achar a soma dos sal√°rios de todos os funcion√°rios, o sal√°rio m√°ximo, o sal√°rio m√≠nimo e a m√©dia dos sal√°rios.

C19: SELECT SUM (Salario), MAX (Salario),

MIN (Salario), AVG (Salario)

FROM

FUNCIONARIO;

Nem todas as implementa√ß√µes de SQL empregaram a nova sintaxe das tabelas de jun√ß√£o. Em alguns sistemas, uma sintaxe diferente foi usada para especificar jun√ß√µes externas usando os operadores de compara√ß√£o +=, =+ e +=+ para a jun√ß√£o externa esquerda, direta e completa, respectivamente, ao especificar

Se quisermos obter os valores das fun√ß√µes para os funcion√°rios de um departamento espec√≠fico - digamos, o departamento 'Pesquisa' -, podemos escrever a Consulta 20, na qual as tuplas FUNCIONARIO s√£o restringidas pela cl√°usula WHERE aos funcion√°rios que trabalham para o departamento 'Pesquisa'.

2 Fun√ß√µes de agrega√ß√£o adicionais para c√°lculo estat√≠stico mais avan√ßado foram acrescentadas na SQL-99.

3 Ordena√ß√£o total significa que, para dois valores quaisquer no dom√≠nio, pode ser determinado que um aparece antes do outro na ordem definida; por exemplo, os dom√≠nios DATE, TIME e TIMESTAMP possuem ordena√ß√µes totais em seus valores, assim como as cadeias alfab√©ticas.

Consulta 20 . Achar a soma dos sal√°rios de todos os funcion√°rios do departamento 'Pesquisa', bem como o sal√°rio m√°ximo, o sal√°rio m√≠nimo e a m√©dia dos sal√°rios nesse departamento.

C20: SELECT

SUM

( Salario ), MAX ( Salario ),

MIN ( Salario ), AVG (Salario )

FROM

( FUNCIONARIO JOIN

DEPARTAMENTO ON Dnr = Dnumero )

WHERE

Dnome ='Pesquisa';

Consultas 21 e 22 . Recuperar o n√∫mero total de funcion√°rios na empresa ( C21 ) e o n√∫mero de funcion√°rios no departamento 'Pesquisa' ( C22 ).

C21: SELECT

COUNT ( * )

FROM

FUNCIONARIO ;

C22: SELECT

COUNT ( * )

FROM

FUNCIONARIO  DEPARTAMENTO ,

WHERE

Dnr = Dnumero

AND Dnome ='Pesquisa';

Aqui, o asterisco ( ) refere-se √†s * linhas (tuplas), de modo que COUNT * ( ) retorna o n√∫mero de linhas no resultado da consulta. Tamb√©m podemos usar a fun√ß√£o COUNT para contar os valores em uma coluna, em vez de tuplas, como no exemplo a seguir.

Consulta 23 . Contar o n√∫mero de valores de sal√°rio distintos no banco de dados.

## C23: SELECT COUNT DISTINCT ( Salario ) FROM FUNCIONARIO ;

Se escrevermos COUNT(SALARIO) em vez de COUNT (DISTINCT SALARIO) na C23 , ent√£o os valores duplicados n√£o ser√£o eliminados. Por√©m, quaisquer tuplas com NULL para SALARIO n√£o  ser√£o  contadas.  Em geral, valores NULL s√£o descartados quando as fun√ß√µes de agrega√ß√£o s√£o aplicadas a determinada coluna (atributo).

Os  exemplos  anteriores  resumem uma  rela√ß√£o inteira ( C19 , C21 , C23 ) ou um subconjunto selecionado de tuplas ( C20 C22 , ), e, portanto, todos produzem tuplas ou valores isolados. Eles ilustram como as fun√ß√µes s√£o aplicadas para recuperar um valor de resumo ou uma tupla de resumo do banco de dados. Essas  fun√ß√µes  tamb√©m  podem  ser  usadas  nas  condi√ß√µes  de  sele√ß√£o  envolvendo  consultas  aninhadas. Podemos especificar uma consulta aninhada correlacionada com uma fun√ß√£o de agrega√ß√£o, e depois usar a consulta aninhada na cl√°usula WHERE de uma con- sulta externa. Por exemplo, para recuperar os nomes de todos os funcion√°rios que t√™m dois ou mais dependentes (Consulta 5), podemos escrever o seguinte:

C5: SELECT

Unome  Pnome , FUNCIONARIO

FROM

WHERE

( SELECT COUNT ( * )

FROM DEPENDENTE WHERE Cpf = Fcpf

) &gt;= 2;

A consulta aninhada correlacionada conta o n√∫mero de dependentes que cada funcion√°rio tem; se for maior ou igual a dois, a tupla do funcion√°rio √© selecionada.

## 5.1.8 Agrupamento: as cl√°usulas GROUP BY e HAVING

Em muitos casos, queremos aplicar as fun√ß√µes de agrega√ß√£o a subgrupos de tuplas em uma rela√ß√£o , na qual os subgrupos s√£o baseados em alguns valores de atributo. Por exemplo, podemos querer achar o sal√°rio m√©dio dos funcion√°rios em cada departamento ou o n√∫mero de funcion√°rios que trabalham em cada projeto . Nesses casos, precisamos particionar a rela√ß√£o em subconjuntos de tuplas (ou grupos ) n√£o  sobrepostos.  Cada  grupo  (parti√ß√£o)  consistir√° nas tuplas que possuem o mesmo valor de algum(ns) atributo(s), chamado(s) atributo(s) de agrupamento . Podemos, ent√£o, aplicar a fun√ß√£o a cada grupo desse  tipo  independentemente, para produzir informa√ß√µes de resumo sobre cada grupo. A SQL tem uma cl√°usula GROUP BY para essa finalidade. A cl√°usula GROUP BY especifica os atributos de agrupamento, que tamb√©m devem aparecer na cl√°usula SELECT , de modo que o valor resultante  da  aplica√ß√£o  de  cada fun√ß√£o de agrega√ß√£o a um grupo de tuplas apare√ßa junto com o valor do(s) atributo(s) de agrupamento.

Consulta 24 . Para cada departamento, recuperar o n√∫mero do departamento, o n√∫mero de funcion√°rios no departamento e seu sal√°rio m√©dio.

C24: SELECT FROM GROUP BY

Dnr , COUNT * ( ), AVG ( Salario

)

FUNCIONARIO Dnr ;

Na C24 ,  as  tuplas FUNCIONARIO s√£o  divididas em grupos - cada grupo tendo o mesmo valor para o atributo de agrupamento Dnr . Logo, cada grupo cont√©m os funcion√°rios que trabalham no mesmo departamento. As fun√ß√µes COUNT e AVG s√£o  aplicadas  a cada grupo de tuplas. Observe que a cl√°usula SELECT inclui apenas o atributo de agrupamento e as fun√ß√µes de agrega√ß√£o a serem aplicadas a cada grupo de tuplas. A Figura 5.1(a) ilustra como o agrupamento funciona na C24 ; ela tamb√©m mostra o resultado da C24 .



| (a)      | Pnome   | Minicial Unome   |         Cpf | . . .   |    | Salario Cpf_supervisor   |   Dnr | Dnr              |                  | Count (*)        | Avg (Salario)    |
|----------|---------|------------------|-------------|---------|----|--------------------------|-------|------------------|------------------|------------------|------------------|
| Jo√£o     | B       | Silva            | 12345678966 |         | 30 | 33344555587              |     5 |                  | 5                | 4                | 33.250           |
| Fernando | T       | Wong             | 33344555587 |         | 40 | 88866555576              |     5 | 4                |                  | 3                | 31.000           |
| Ronaldo  | K       | Lima             | 66688444476 |         | 38 | 33344555587              |     5 | 1                |                  | 1                | 55.000           |
| Joice    | A       | Leite            | 45345345376 | . . .   | 25 | 33344555587              |     5 | Resultado de C24 | Resultado de C24 | Resultado de C24 | Resultado de C24 |
| Alice    | J       | Zelaya           | 99988777767 |         | 25 | 98765432168              |     4 |                  |                  |                  |                  |
| Jennifer | S       | Souza            | 98765432168 |         | 43 | 88866555576              |     4 |                  |                  |                  |                  |
| Andr√©    | V       | Pereira          | 98798798733 |         | 25 | 98765432168              |     4 |                  |                  |                  |                  |
| Jorge    | E       | Brito            | 88866555576 |         | 55 | NULL                     |     1 |                  |                  |                  |                  |

Agrupamento de tuplas FUNCIONARIO pelo valor de Dnr

(b)

| Projnome         |   Projnumero | . . .   |        Fcpf |   Pnr | Horas   |
|------------------|--------------|---------|-------------|-------|---------|
| ProdutoX         |            1 |         | 12345678966 |     1 | 32,5    |
| ProdutoX         |            1 |         | 45345345376 |     1 | 20,0    |
| ProdutoY         |            2 |         | 12345678966 |     2 | 7,5     |
| ProdutoY         |            2 |         | 45345345376 |     2 | 20,0    |
| ProdutoY         |            2 |         | 33344555587 |     2 | 10,0    |
| ProdutoZ         |            3 |         | 66688444476 |     3 | 40,0    |
| ProdutoZ         |            3 |         | 33344555587 |     3 | 10,0    |
| Informatiza√ß√£o   |           10 | . . .   | 33344555587 |    10 | 10,0    |
| Informatiza√ß√£o   |           10 |         | 99988777767 |    10 | 10,0    |
| Informatiza√ß√£o   |           10 |         | 98798798733 |    10 | 35,0    |
| Reorganiza√ß√£o    |           20 |         | 33344555587 |    20 | 10,0    |
| Reorganiza√ß√£o    |           20 |         | 98765432168 |    20 | 15,0    |
| Reorganiza√ß√£o    |           20 |         | 88866555576 |    20 | NULL    |
| Novos Benef√≠cios |           30 |         | 98798798733 |    30 | 5,0     |
| Novos Benef√≠cios |           30 |         | 98765432168 |    30 | 20,0    |
| Novos Benef√≠cios |           30 |         | 99988777767 |    30 | 30,0    |

Estes grupos n√£o s√£o selecionados pela condi√ß√£o de HAVING de C26.

Ap√≥s aplicar a cl√°usula WHERE, mas antes de aplicar HAVING

| Projnome         |   Projnumero | . . .   |        Fcpf |   Pnr | Horas   | Projnome                     | Count (*)                    |
|------------------|--------------|---------|-------------|-------|---------|------------------------------|------------------------------|
| ProdutoY         |            2 |         | 12345678966 |     2 | 7,5     | ProdutoY                     | 3                            |
| ProdutoY         |            2 |         | 45345345376 |     2 | 20,0    | Informatiza√ß√£o               | 3                            |
| ProdutoY         |            2 |         | 33344555587 |     2 | 10,0    | Reorganiza√ß√£o                | 3                            |
| Informatiza√ß√£o   |           10 |         | 33344555587 |    10 | 10,0    | Novos Benef√≠cios             | 3                            |
| Informatiza√ß√£o   |           10 | . . .   | 99988777767 |    10 | 10,0    | Resultado de C26 (Projnumero | Resultado de C26 (Projnumero |
| Informatiza√ß√£o   |           10 |         | 98798798733 |    10 | 35,0    | n√£o mostrado)                | n√£o mostrado)                |
| Reorganiza√ß√£o    |           20 |         | 33344555587 |    20 | 10,0    |                              |                              |
| Reorganiza√ß√£o    |           20 |         | 98765432168 |    20 | 15,0    |                              |                              |
| Reorganiza√ß√£o    |           20 |         | 88866555576 |    20 | NULL    |                              |                              |
| Novos Benef√≠cios |           30 |         | 98798798733 |    30 | 5,0     |                              |                              |
| Novos Benef√≠cios |           30 |         | 98765432168 |    30 | 20,0    |                              |                              |
| Novos Benef√≠cios |           30 |         | 99988777767 |    30 | 30,0    |                              |                              |

Ap√≥s aplicar a condi√ß√£o da cl√°usula HAVING

## Figura 5.1

Resultados de GROUP BY e HAVING. (a) C24. (b) C26.

Se  houver NULL s  no  atributo  de  agrupamento, ent√£o um grupo separado √© criado para todas as tuplas com um valor NULL no atributo de agrupamento .  Por  exemplo,  se  a  tabela FUNCIONARIO tivesse algumas tuplas com NULL para o atributo de agrupamento Dnr , haveria um grupo separado para essas tuplas no resultado da C24 .

Consulta 25. Para cada projeto, recuperar o n√∫mero do projeto, o nome do projeto e o n√∫mero de funcion√°rios que trabalham nesse projeto.

C25: SELECT Projnumero  Projnome , , COUNT ( ) * FROM PROJETO  TRABALHA\_EM , WHERE Projnumero = Pnr

GROUP BY Projnumero  Projnome , ;

A C25 mostra como podemos usar uma condi√ß√£o de jun√ß√£o em conjunto com GROUP BY .  Neste caso, o agrupamento e as fun√ß√µes s√£o aplicados ap√≥s a jun√ß√£o das duas rela√ß√µes. √Äs vezes, queremos recuperar os valores dessas fun√ß√µes somente para grupos que satisfazem certas condi√ß√µes . Por exemplo, suponha que queremos modificar a Consulta 25 de modo que apenas projetos com mais de dois funcion√°rios apare√ßam no resultado. A SQL oferece uma cl√°usula HAVING ,  que pode aparecer em conjunto com uma cl√°usula GROUP BY , para essa finalidade. A cl√°usula HAVING oferece uma condi√ß√£o sobre a informa√ß√£o de resumo referente ao grupo de tuplas associado a cada valor dos atributos de agrupamento. Somente os grupos que satisfazem a condi√ß√£o s√£o recuperados no resultado da consulta. Isso √© ilustrado pela Consulta 26.

Consulta 26. Para cada projeto em que mais de dois funcion√°rios trabalham , recupere o n√∫mero e o nome do projeto e o n√∫mero de funcion√°rios que trabalham no projeto.

C26: SELECT

Projnumero  Projnome , , COUNT * ( )

FROM

PROJETO  TRABALHA\_EM ,

WHERE

Projnumero = Pnr

GROUP BY

Projnumero  Projnome ,

HAVING

COUNT ( * ) &gt; 2 ;

Observe que, embora as condi√ß√µes de sele√ß√£o na cl√°usula WHERE limitem as tuplas √†s  quais  as  fun√ß√µes s√£o aplicadas, a cl√°usula HAVING serve para escolher grupos inteiros . A Figura 5.1(b) ilustra o uso de HAVING e apresenta o resultado da C26 .

Consulta 27 . Para cada projeto, recupere o n√∫mero e o nome do projeto e o n√∫mero de funcion√°rios do departamento 5 que trabalham no projeto.

C27: SELECT

Projnumero  Projnome , , COUNT ( * )

FROM

PROJETO  TRABALHA\_EM , , FUNCIONARIO

WHERE

Projnumero = Pnr

AND

Cpf = Fcpf AND Dnr = 5

GROUP BY Projnumero  Projnome , ;

Aqui, restringimos as tuplas na rela√ß√£o (e, portanto, as tuplas em cada grupo) √†quelas que satisfazem a condi√ß√£o especificada na cl√°usula WHERE - a saber, que eles trabalham no departamento n√∫mero 5. Observe que precisamos ter um cuidado extra quando duas condi√ß√µes diferentes se aplicam (uma para a fun√ß√£o de agrega√ß√£o na cl√°usula SELECT e outra para a fun√ß√£o na cl√°usula HAVING ).  Por  exemplo,  suponha que queremos contar o n√∫mero total de funcion√°rios cujos sal√°rios s√£o superiores a R$ 40.000 em cada departamento, mas somente para os departamentos em que h√° mais de cinco funcion√°rios trabalhando. Aqui, a condi√ß√£o ( SALARIO &gt; 40.000) se aplica apenas √† fun√ß√£o COUNT na cl√°usula SELECT . Suponha que escrevamos a seguinte consulta incorreta :

SELECT

Dnome , COUNT ( * )

FROM

DEPARTAMENTO  FUNCIONARIO ,

WHERE

Dnumero Dnr = AND Salario &gt; 40.000

GROUP BY

Dnome

HAVING

COUNT ( * ) &gt; 5 ;

Ela est√° incorreta porque selecionar√° somente departamentos que tenham mais de cinco funcion√°rios que ganham cada um mais de R$ 40.000 . A regra √© que a cl√°usula WHERE √©  executada primeiro, para selecionar as tuplas individuais ou tuplas de jun√ß√£o; a cl√°usula HAVING √©  aplicada depois, para selecionar grupos individuais de tuplas. Logo, as tuplas j√° est√£o restritas a funcion√°rios que ganham mais de R$ 40.000 antes que a cl√°usula HAVING seja aplicada. Um modo de escrever essa consulta corretamente √© usar uma consulta aninhada, como mostra a Consulta 28.

Consulta  28 . Para  cada  departamento  que  tem mais de cinco funcion√°rios, recuperar o n√∫mero do departamento e o n√∫mero de seus funcion√°rios que est√£o ganhando mais de R$ 40.000.

C28: SELECT Dnumero , COUNT ( * )

FROM DEPARTAMENTO  FUNCIONARIO ,

WHERE Dnumero Dnr = AND Salario &gt; 40.000 AND

( SELECT Dnr IN

FROM FUNCIONARIO

GROUP BY Dnr

HAVING  COUNT ( * ) &gt; 5)

## 5.1.9 Discuss√£o e resumo das consultas em SQL

Uma  consulta  de  recupera√ß√£o  em  SQL  pode consistir em at√© seis cl√°usulas, mas somente as duas primeiras  SELECT e FROM -  s√£o  obrigat√≥rias. A consulta pode se espalhar por v√°rias linhas, e termina com um sinal de ponto e v√≠rgula. Os termos da consulta s√£o separados por espa√ßos, e par√™nteses podem ser usados para agrupar partes relevantes de uma consulta na forma padr√£o. As cl√°usulas s√£o especificadas na seguinte ordem, sendo que os colchetes [ ... ] s√£o opcionais:

SELECT &lt;lista atributo e fun√ß√£o&gt;

FROM

&lt;lista tabela&gt;

[ WHERE

&lt;condi√ß√£o&gt; ]

[ GROUP BY &lt;atributo(s) de agrupamento&gt; ]

[

HAVING

&lt;condi√ß√£o de grupo&gt; ]

[ ORDER BY &lt;lista atributos&gt; ] ;

A cl√°usula SELECT lista os atributos ou fun√ß√µes a serem recuperadas. A cl√°usula FROM especifica todas as rela√ß√µes (tabelas) necess√°rias na consulta, incluindo as rela√ß√µes, mas n√£o aquelas nas consultas aninhadas. A cl√°usula WHERE especifica as condi√ß√µes para selecionar as tuplas dessas rela√ß√µes, incluindo as condi√ß√µes de jun√ß√£o, se necess√°rio. A GROUP BY especifica atributos de agrupamento, enquanto a HAVING especifica uma condi√ß√£o sobre os grupos selecionados, em vez das tuplas individuais. As fun√ß√µes de agrega√ß√£o embutidas COUNT  SUM  MIN  MAX , , , e AVG s√£o  usadas  em  conjunto  com  o  agrupamento, mas tamb√©m podem ser aplicadas a todas as tuplas selecionadas  em  uma  consulta  sem  uma  cl√°usula GROUP BY .  Por fim, ORDER BY especifica uma ordem para exibir o resultado de uma consulta.

de cada uma das rela√ß√µes especificadas na cl√°usula FROM -, avaliar a cl√°usula WHERE ; se ela for avaliada  como TRUE ,  colocar  os  valores  dos  atributos especificados na cl√°usula SELECT dessa combina√ß√£o de tuplas no resultado da consulta. √â √≥bvio que esse n√£o √© um modo eficiente de implementar a consulta em um sistema real, e cada SGBD possui rotinas especiais de otimiza√ß√£o de consulta para decidir sobre um plano de execu√ß√£o que seja eficiente para ser executado. Discutiremos sobre o processamento e a otimiza√ß√£o da consulta no Cap√≠tulo 19.

Em geral, existem v√°rias maneiras de especificar  a  mesma  consulta  em  SQL.  Essa  flexibilidade na  especifica√ß√£o  de  consultas  possui  vantagens  e desvantagens. A principal vantagem √© que os usu√°rios podem escolher a t√©cnica com a qual est√£o mais acostumados ao especificar uma consulta. Por exemplo, muitas consultas podem ser especificadas com condi√ß√µes de jun√ß√£o na cl√°usula WHERE , ou usando rela√ß√µes  de  jun√ß√£o  na  cl√°usula FROM ,  ou  com  alguma forma de consultas aninhadas e o operador de compara√ß√£o IN .  Alguns usu√°rios podem se sentir  mais  confiantes  usando  uma  t√©cnica,  enquanto outros podem estar mais acostumados √† outra. Do ponto de vista do programador e do sistema com rela√ß√£o √† otimiza√ß√£o da consulta, √© prefer√≠vel escrever uma consulta com o m√≠nimo de aninhamento e de ordena√ß√£o poss√≠vel.

Para  formular  consultas  de  maneira  correta,  √© √∫til considerar as etapas que definem o significado ou a sem√¢ntica de cada consulta. Uma consulta √© avaliada conceitualmente 4 aplicando primeiro a cl√°usula FROM (para  identificar  todas  as  tabelas  envolvidas na consulta ou materializar quaisquer tabelas de jun√ß√£o),  seguida  pela  cl√°usula WHERE para  selecionar e juntar tuplas, e depois por GROUP BY e HAVING . Conceitualmente, ORDER BY √© aplicado no final para classificar o resultado da consulta. Se nenhuma das tr√™s √∫ltimas cl√°usulas ( GROUP BY HAVING , e ORDER BY ) for especificada, podemos pensar conceitualmente em uma consulta como sendo executada da seguinte  forma:  para cada combina√ß√£o de tuplas -  uma

A desvantagem de ter v√°rias maneiras de especificar a mesma consulta √© que isso pode confundir o  usu√°rio,  que  pode  n√£o  saber  qual  t√©cnica  usar para especificar tipos particulares de consultas. Outro problema √© que pode ser mais eficiente executar uma consulta especificada de uma maneira do que a mesma consulta especificada de uma maneira alternativa. O ideal √© que isso n√£o aconte√ßa: o SGBD deve processar a mesma consulta da mesma maneira,  independentemente de como ela √© especificada. Mas isso √© muito dif√≠cil na pr√°tica, pois cada SGBD possui diferentes m√©todos para processar consultas espec√≠ficas  de  diversas  maneiras.  Assim,  um  fardo adicional sobre o usu√°rio √© determinar qual das especifica√ß√µes alternativas √© a mais eficiente de se executar. O ideal √© que o usu√°rio se preocupe apenas em  especificar  a  consulta  corretamente,  enquanto o SGBD determinaria como executar a consulta de forma eficiente. Na pr√°tica, contudo, ajuda se o usu√°rio souber quais tipos de constru√ß√µes em uma consulta  s√£o  mais  dispendiosas para processar do que outras (ver Cap√≠tulo 20).

4 A ordem real da avalia√ß√£o de consulta depende da implementa√ß√£o; esse √© apenas um modo de visualizar conceitualmente uma consulta a fim de formul√°-la de maneira correta.

## 5.2 Especificando restri√ß√µes como asser√ß√µes e a√ß√µes como triggers

Nesta se√ß√£o, apresentamos dois recursos adicionais da SQL: o comando CREATE ASSERTION e o comando CREATE TRIGGER . A Se√ß√£o 5.2.1 discute o CREATE ASSERTION , que pode ser usado para especificar tipos adicionais de restri√ß√µes que est√£o fora do escopo das restri√ß√µes embutidas do modelo relacional (chaves  prim√°ria  e  √∫nica,  integridade  de  entidade  e  integridade  referencial),  que  apresentamos na Se√ß√£o 3.2. Essas restri√ß√µes embutidas podem ser especificadas dentro do comando CREATE TABLE da SQL (ver se√ß√µes 4.1 e 4.2).

Depois, na Se√ß√£o 5.2.2, apresentamos CREATE TRIGGER , que pode ser usado para especificar a√ß√µes autom√°ticas que o sistema de banco de dados realizar√° quando certos eventos e condi√ß√µes ocorrerem. Esse  tipo  de  funcionalidade  costuma  ser  conhecido como bancos de dados ativos .  S√≥  apresentamos  os fundamentos  b√°sicos  dos triggers neste  cap√≠tulo,  e uma discuss√£o mais completa sobre os bancos de dados ativos pode ser encontrada na Se√ß√£o 26.1.

## 5.2.1 Especificando restri√ß√µes gerais como asser√ß√µes em SQL

Em SQL, os usu√°rios podem especificar restri√ß√µes gerais - aquelas que n√£o se encaixam em nenhuma das categorias descritas nas se√ß√µes 4.1 e 4.2 - por meio de asser√ß√µes  declarativas ,  usando  o  comando CREATE ASSERTION da DDL. Cada asser√ß√£o recebe um nome de restri√ß√£o e √© especificada por uma condi√ß√£o semelhante √† cl√°usula WHERE de uma consulta SQL. Por exemplo, para especificar a restri√ß√£o de que o sal√°rio de um funcion√°rio n√£o pode ser maior que o sal√°rio do gerente do departamento para o qual o funcion√°rio trabalha em SQL, podemos escrever a seguinte asser√ß√£o:

CREATE ASSERTION RESTRICAO\_SALARIAL CHECK   NOT EXISTS ( ( SELECT * FROM FUNCIONARIO F , FUNC  IONARIO G , DEPARTAMENTO D WHERE F.Salario&gt;G.Salario AND F.Dnr = D.Dnumero

AND D. Cpf\_gerente = G.Cpf ) );

O nome de restri√ß√£o RESTRICAO\_SALARIAL √© seguido pela palavra-chave CHECK , que √© seguida por uma condi√ß√£o entre par√™nteses que precisa ser verdadeira em cada estado do banco de dados para que a asser√ß√£o seja satisfeita. O nome da restri√ß√£o pode ser usado mais tarde para se referir √† restri√ß√£o ou para modific√°-la ou exclu√≠-la. O SGBD √© respons√°vel por garantir que a condi√ß√£o n√£o seja violada. Qualquer condi√ß√£o  de  cl√°usula WHERE pode  ser  usada,  mas muitas restri√ß√µes podem ser especificadas usando o estilo EXISTS e NOT EXISTS das condi√ß√µes em SQL. Sempre que alguma tupla no banco de dados fizer que  a  condi√ß√£o  de  um  comando ASSERTION seja avaliada como FALSE ,  a  restri√ß√£o  √© violada .  A  restri√ß√£o √© satisfeita por um estado do banco de dados se nenhuma combina√ß√£o de tuplas nesse  estado  do banco de dados violar a restri√ß√£o.

A t√©cnica de uso comum para escrever essas asser√ß√µes √© especificar uma consulta que seleciona quaisquer tuplas que violam a condi√ß√£o desejada . Ao incluir essa consulta em uma cl√°usula NOT EXISTS , a asser√ß√£o especificar√° que o resultado dessa consulta precisa ser vazio para que a condi√ß√£o seja sempre TRUF . Assim, uma asser√ß√£o √© violada se o resultado da consulta n√£o for vazio. No exemplo anterior, a consulta seleciona todos os funcion√°rios cujos sal√°rios s√£o maiores que o sal√°rio do gerente de seu departamento. Se o resultado da consulta n√£o for vazio, a asser√ß√£o √© violada.

Observe que a cl√°usula CHECK e  a  condi√ß√£o  de restri√ß√£o  tamb√©m  podem  ser  utilizadas  para  especificar  restri√ß√µes  sobre  atributos  e  dom√≠nios individuais (ver Se√ß√£o 4.2.1) e sobre tuplas individuais (ver Se√ß√£o 4.2.4).   A principal diferen√ßa entre CREATE ASSERTION e as restri√ß√µes de dom√≠nio e de tupla individuais √© que as cl√°usulas CHECK sobre atributos, dom√≠nios e tuplas individuais s√£o verificadas na SQL somente quando as tuplas s√£o inseridas ou atualizadas . Logo, a verifica√ß√£o de restri√ß√£o pode ser implementada de maneira mais eficiente pelo SGBD nesses casos. O projetista do esquema deve usar CHECK sobre atributos, dom√≠nios e tuplas apenas quando estiver certo de que a restri√ß√£o s√≥ pode ser violada pela inser√ß√£o ou atualiza√ß√£o de tuplas . Al√©m disso, o projetista do esquema deve usar CREATE ASSERTION somente em casos em que n√£o √© poss√≠vel usar CHECK sobre atributos, dom√≠nios ou tuplas, de modo que verifica√ß√µes simples s√£o implementadas de modo mais eficiente pelo SGBD.

## 5.2.2 Introdu√ß√£o √†s triggers em SQL

Outro comando importante em SQL √© o CREATE TRIGGER . Em muitos casos, √© conveniente especificar um tipo de a√ß√£o a ser tomada quando certos eventos ocorrem  e  quando  certas  condi√ß√µes  s√£o  satisfeitas. Por exemplo, pode ser √∫til especificar uma condi√ß√£o que, se violada, faz que algum usu√°rio seja informado dela. Um gerente pode querer ser informado se as despesas de viagem de um funcion√°rio excederem certo limite, recebendo uma mensagem sempre que isso acontecer. A a√ß√£o que o SGBD deve tomar nesse caso √© enviar uma mensagem apropriada a esse usu√°rio.  A  condi√ß√£o,  portanto,  √©  usada  para monitorar

o banco de dados. Outras a√ß√µes podem ser especificadas,  como  executar  um  procedimento  armazenado ( stored procedure )  espec√≠fico  ou disparar outras atua  liza√ß√µes. A instru√ß√£o CREATE TRIGGER √© utilizada para implementar essas a√ß√µes em SQL. Discutiremos sobre triggers (gatilhos) com detalhes na Se√ß√£o 26.1, quando descreveremos os bancos de dados ativos . Aqui, vamos apenas dar um exemplo simples de como os triggers podem ser usadas.

Suponha que queiramos verificar se o sal√°rio de um funcion√°rio √© maior que o sal√°rio de seu supervisor direto no banco de dados EMPRESA (ver figuras 3.5  e  3.6).  V√°rios  eventos  podem  disparar  essa  regra: inserir um novo registro de funcion√°rio, alterar o sal√°rio de um funcion√°rio ou alterar o supervisor de um funcion√°rio. Suponha que a a√ß√£o a ser tomada seria chamar o procedimento armazenado, 5  que notificar√° o supervisor. O trigger poderia ent√£o ser escrita como em R5 , a seguir. Aqui, estamos usando a sintaxe do sistema de banco de dados Oracle.

R5:  CREATE TRIGGER VIOLACAO\_SALARIAL BEFORE INSERT OR UPDATE OF SALARIO ,

CPF\_SUPERVISOR ON FUNCIONARIO

FOR EACH ROW

WHEN (

NEW .SALARIO &gt; ( SELECT SALARIO FROM FUNCIONARIO WHERE CPF = NEW .CPF\_SUPERVISOR ) ) INFORMAR\_SUPERVISOR

( NEW .Cpf\_supervisor ,

NEW .Cpf );

- O  trigger  recebe  o  nome VIOLACAO\_SALARIAL , que pode ser usada para remover ou desativar o trigger mais tarde. Um trigger t√≠pico tem tr√™s componentes:
- 1. O(s) evento(s): estes em geral s√£o opera√ß√µes de atualiza√ß√£o no banco de dados, aplicadas explicitamente a ele. Neste exemplo, os eventos s√£o: inserir um novo registro de funcion√°rio, alterar o sal√°rio de um funcion√°rio ou alterar o supervisor de um funcion√°rio. A pessoa que escreve  o  trigger  precisa  garantir  que  todos os  eventos  poss√≠veis  sejam  considerados.  Em alguns  casos,  pode  ser  preciso  escrever  mais de um trigger para cobrir todos os casos poss√≠veis. Esses eventos s√£o especificados ap√≥s a palavra-chave BEFORE em nosso exemplo, o que significa que o trigger deve ser executada antes  que  a  opera√ß√£o  de  disparo  seja  execu-
- tada. Uma alternativa √© usar a palavra-chave AFTER ,  que especifica que o trigger deve ser executada  ap√≥s  a  opera√ß√£o  especificada  no evento ser conclu√≠da.
- 2. A condi√ß√£o que determina se a a√ß√£o da regra deve ser executada: depois que o evento de disparo tiver ocorrido, uma condi√ß√£o opcional pode ser avaliada. Se nenhuma condi√ß√£o for especificada, a a√ß√£o ser√° executada uma vez  que  o  evento  ocorra.  Se  uma  condi√ß√£o for  especificada,  ela  primeiro  √©  avaliada  e, somente se  for  avaliada  como verdadeira ,  a a√ß√£o da regra ser√° executada. A condi√ß√£o √© especificada na cl√°usula WHEN do trigger.
- 3. A a√ß√£o a ser tomada: a a√ß√£o normalmente √© uma  sequ√™ncia  de  instru√ß√µes  em  SQL,  mas tamb√©m poderia ser uma transa√ß√£o de banco de dados ou um programa externo que ser√° executado automaticamente. Neste exemplo, a a√ß√£o √© executar o procedimento armazenado INFORMAR\_SUPERVISOR .

Os triggers  podem  ser  usados  em  v√°rias  aplica√ß√µes, como na manuten√ß√£o da coer√™ncia do banco  de  dados,  no  monitoramento  de  atualiza√ß√µes do banco de dados e na atualiza√ß√£o de dados derivados automaticamente. Uma discuss√£o mais completa pode ser vista na Se√ß√£o 26.1.

## 5.3 Vis√µes (views) - Tabelas virtuais em SQL

Nesta  se√ß√£o,  apresentamos  o  conceito  de  uma view  (vis√£o)  em  SQL.  Mostraremos  como  as  views s√£o especificadas, depois discutiremos o problema de atualiz√°-las e como elas podem ser implementadas pelo SGBD.

## 5.3.1 Conceito de uma view em SQL

Uma view em terminologia SQL √© uma √∫nica tabela que √© derivada de outras tabelas. 6 Essas outras tabelas podem ser tabelas da base ou views previamente definidas.  Uma  view  n√£o  necessariamente  existe  em forma f√≠sica; ela √© considerada uma tabela virtual , ao contr√°rio das tabelas da base , cujas tuplas sempre est√£o armazenadas fisicamente no banco de dados. Isso limita as poss√≠veis opera√ß√µes de atualiza√ß√£o que podem ser aplicadas √†s views, mas n√£o oferece quaisquer limita√ß√µes sobre a consulta de uma view.

5 Supondo que um procedimento externo tenha sido declarado. Discutiremos os procedimentos armazenados no Cap√≠tulo 13.

6 Conforme usado em SQL, o termo view √© mais limitado do que o termo view do usu√°rio discutido nos cap√≠tulos 1 e 2, pois esta √∫ltima possivelmente incluiria muitas rela√ß√µes.

Pensamos em uma view como um modo de especificar uma tabela que precisamos referenciar com frequ√™ncia, embora ela possa n√£o existir fisicamente. Por exemplo, em rela√ß√£o ao banco de dados EMPRESA da Figura 3.5, podemos emitir frequentemente consultas que recuperam o nome do funcion√°rio e os nomes dos projetos em que o funcion√°rio trabalha. Em vez de ter que especificar a jun√ß√£o das tr√™s tabelas FUNCIONARIO , TRABALHA\_EM e PROJETO toda vez que emitirmos essa consulta, podemos definir uma view que √© especificada como o resultado dessas jun√ß√µes. Depois, podemos emitir consultas sobre a view, que s√£o especificadas como leituras de uma √∫nica tabela, em vez de leituras envolvendo duas jun√ß√µes sobre tr√™s tabelas. Chamamos as tabelas FUNCIONARIO TRABALHA\_EM , e PROJETO de tabelas de defini√ß√£o da view.

## 5.3.2 Especifica√ß√£o das views em SQL

Em SQL, o comando para especificar uma view √© CREATE VIEW .  A view recebe um nome de tabela (virtual),  ou  nome de view, uma lista de nomes de atributo e uma consulta para especificar o conte√∫do da view. Se nenhum dos atributos da view resultar da aplica√ß√£o de fun√ß√µes ou opera√ß√µes aritm√©ticas, n√£o temos de especificar novos nomes de atributo para a view, pois eles seriam iguais aos nomes dos atributos das tabelas de defini√ß√£o no caso default. As views em V1 e V2 criam  tabelas  virtuais,  cujos  esquemas  s√£o ilustrados na Figura 5.2, quando aplicadas ao esquema de banco de dados da Figura 3.5.

## V1: CREATE VIEW

TRABALHA\_EM1

AS SELECT

Pnome  Unome  Projnome , , , Horas

FROM

FUNCIONARIO  PROJETO , , TRABALHA\_EM

WHERE

Cpf = Fcpf AND Pnr = Projnumero ;

V2: CREATE VIEW

DEP\_INFO Dep\_nome  Qtd\_ ( , func  Total\_sal , )

AS SELECT

Dnome , COUNT ( * ), SUM ( Salario )

FROM

DEPARTAMENTO  FUNCIONARIO ,

WHERE

Dnumero = Dnr

GROUP BY Dnome ;

Em V1 ,  n√£o especificamos quaisquer novos nomes de atributo para a view TRABALHA\_EM1 (embora  pud√©ssemos  t√™-lo  feito);  nesse  caso, TRABA-LHA\_EM1 herda os  nomes  dos  atributos  de  view das tabelas de defini√ß√£o FUNCIONARIO , PROJETO e TRABALHA\_EM .  A  view V2 especifica  explicitamen-

TRABALHA\_EM1



Figura 5.2

Duas views especificadas sobre o esquema de banco de dados da Figura 3.5.

te novos nomes de atributo para a view DEP\_INFO , usando uma correspond√™ncia um para um entre os atributos  especificados  na  cl√°usula CREATE VIEW e aqueles especificados na cl√°usula SELECT da consulta que define a view.

Agora,  podemos  especificar  consultas  SQL  em uma view - ou tabela virtual - da mesma forma como fazemos consultas envolvendo tabelas da base. Por exemplo, para recuperar o primeiro e o √∫ltimo nome  de  todos  os  funcion√°rios  que  trabalham  no projeto 'ProdutoX', podemos utilizar a view TRABA-LHA\_EM1 e especificar a consulta como na CV1 :

CV1: SELECT

Pnome  Unome , TRABALHA\_EM1

FROM

WHERE

Projnome ='ProdutoX';

A  mesma  consulta  exigiria  a  especifica√ß√£o  de duas jun√ß√µes se fosse realizada sobre as rela√ß√µes da base  diretamente;  uma  das  principais  vantagens  de uma view √© simplificar a especifica√ß√£o de certas consultas. As views tamb√©m s√£o usadas como um mecanismo de seguran√ßa e autoriza√ß√£o (ver Cap√≠tulo 24).

Sup√µe-se que uma view esteja sempre atualizada ; se modificarmos as tuplas nas tabelas da base sobre as  quais  a  view  √©  definida,  esta  precisa  refletir  automaticamente essas mudan√ßas. Logo, a view n√£o √© realizada ou materializada no momento de sua defini√ß√£o , mas quando especificamos uma consulta na view. √â responsabilidade do SGBD, e n√£o do usu√°rio, cuidar para que a view mantenha-se atualizada. Discutiremos v√°rias maneiras como o SGBD pode manter uma view atualizada na pr√≥xima subse√ß√£o.

Se  n√£o  precisarmos  mais  de  uma  view,  podemos usar o comando DROP VIEW para  descart√°-la. Por exemplo, para descartarmos a view V1 , podemos usar o comando SQL em V1A :

V1A: DROP VIEW TRABALHA\_EM1 ;

## 5.3.3 mplementa√ß√£o e atualiza√ß√£o de I view e views em linha

O problema de implementar uma view de forma eficiente para consulta √© muito complexo. Duas

t√©cnicas principais foram sugeridas. Uma estrat√©gia, chamada modifica√ß√£o de consulta , envolve modificar ou transformar a consulta da view (submetida pelo usu√°rio) em uma consulta nas tabelas da base. Por exemplo, a consulta CV1 seria automaticamente modificada para a seguinte consulta pelo SGBD:

SELECT Pnome, Unome FROM WHERE Cpf = Fcpf AND Pnr = Projnumero AND Projnome ='ProdutoX';

FUNCIONARIO  PROJETO  TRABALHA\_EM , ,

A desvantagem dessa t√©cnica √© que ela √© ineficaz  para  views  definidas  por  consultas  complexas, que s√£o demoradas de se executar, especialmente se v√°rias delas tiverem de ser aplicadas √† mesma view em um curto per√≠odo. A segunda estrat√©gia, chamada materializa√ß√£o de view , envolve criar fisicamente uma tabela de view tempor√°ria quando a view for consultada pela primeira vez e manter essa tabela na suposi√ß√£o de que outras consultas a view acontecer√£o em seguida. Nesse caso, uma estrat√©gia eficiente para atualizar automaticamente a tabela da view quando as tabelas de base forem atualizadas dever√° ser desenvolvida para que a view esteja sempre atualizada.  As  t√©cnicas  que  usam  o  conceito  de atualiza√ß√£o incremental t√™m sido desenvolvidas para essa finalidade, nas quais o SGBD pode determinar quais novas tuplas devem ser inseridas, exclu√≠das ou modificadas em uma tabela de view materializada quando uma atualiza√ß√£o de banco de dados √© aplicada a uma das tabelas da base definidas .  A  view  geralmente  √© mantida como uma tabela materializada (armazenada fisicamente), desde que esteja sendo consultada. Se a view n√£o for consultada por certo per√≠odo, o sistema pode ent√£o remover automaticamente a tabela f√≠sica e recalcul√°-la do zero quando consultas futuras referenciarem a view.

A atualiza√ß√£o das views √© complicada e pode ser amb√≠gua. Em geral, uma atualiza√ß√£o em uma view definida sobre uma √∫nica tabela sem quaisquer fun√ß√µes de agrega√ß√£o pode ser mapeada para uma atualiza√ß√£o sobre a tabela da base sob certas condi√ß√µes. Para uma view  que  envolve  jun√ß√µes  ( joins ),  uma  opera√ß√£o  de atualiza√ß√£o pode ser mapeada para opera√ß√µes de atualiza√ß√£o sobre as rela√ß√µes da base de m√∫ltiplas maneiras . Logo, com frequ√™ncia n√£o √© poss√≠vel que o SGBD determine qual das atualiza√ß√µes √© intencionada. Para ilustrar os problemas em potencial com a atualiza√ß√£o de uma view definida sobre m√∫ltiplas tabelas, considere a view TRABALHA\_EM1 e suponha que emitamos o comando para atualizar o atributo PROJNOME de 'Jo√£o Silva' de 'ProdutoX' para 'ProdutoY'. Essa atualiza√ß√£o de view aparece em UV1 :

UV1: UPDATE

TRABALHA\_EM1

SET

Projnome = 'ProdutoY'

WHERE

Unome ='Silva' AND Pnome

='Jo√£o'

AND Projnome ='ProdutoX';

Essa consulta pode ser mapeada para v√°rias atualiza√ß√µes sobre as rela√ß√µes da base para gerar o efeito de atualiza√ß√£o desejado sobre a view. Al√©m disso, algumas das atualiza√ß√µes criar√£o efeitos colaterais adicionais, que afetam o resultado de outras consultas. Por exemplo, aqui est√£o duas atualiza√ß√µes poss√≠veis, (a) e (b), sobre as rela√ß√µes da base correspondentes √† opera√ß√£o de atualiza√ß√£o de view em UV1 :

## (a): UPDATE TRABALHA\_EM

| SET        | Pnr =   | ( SELECT FROM   | Projnumero PROJETO Projnome = 'ProdutoY' )   |
|------------|---------|-----------------|----------------------------------------------|
|            |         | WHERE           |                                              |
| WHERE      | Fcpf IN | ( SELECT        | Cpf                                          |
|            |         | FROM            | FUNCIONARIO                                  |
|            |         | WHERE           | Unome ='Silva' AND                           |
|            |         |                 | Pnome ='Jo√£o'                                |
|            | AND     |                 |                                              |
|            | Pnr =   | ( SELECT        | Projnumero                                   |
|            |         | FROM            | PROJETO                                      |
|            |         | WHERE           | Projnome = 'ProdutoX' );                     |
| (b):UPDATE | PROJETO | SET             | Projnome = 'ProdutoY'                        |

WHERE Projnome = 'ProdutoX';

A atualiza√ß√£o (a) relaciona 'Jo√£o Silva' √† tupla 'ProdutoY' de PROJETO em vez da tupla 'ProdutoX' de PROJETO e  √©  a  atualiza√ß√£o  provavelmente mais desejada. Por√©m, (b) tamb√©m daria o efeito de atualiza√ß√£o desejado sobre a view, mas realiza isso alterando o nome da tupla 'ProdutoX' na rela√ß√£o PROJETO para 'ProdutoY'. √â muito pouco prov√°vel que o usu√°rio que especificou a atualiza√ß√£o de view UV1 queira que ela seja interpretada como em (b), pois isso tamb√©m tem o efeito colateral de alterar todas as tuplas de view com Projnome = 'ProdutoX'.

Algumas atualiza√ß√µes de view podem n√£o fazer muito  sentido;  por  exemplo,  modificar  o  atributo Total\_sal da view DEP\_INFO n√£o faz sentido porque Total\_sal √© definido como sendo a soma dos sal√°rios de funcion√°rio individuais. Esta solicita√ß√£o aparece como em UV2 :

UV2:    UPDATE DEP\_INFO

SET Total\_sal = 100.000

WHERE

Dnome= 'Pesquisa';

Um grande n√∫mero de atualiza√ß√µes sobre as rela√ß√µes da base pode satisfazer essa atualiza√ß√£o de view.

Em  geral,  uma  atualiza√ß√£o  de  view  √©  vi√°vel quando somente uma atualiza√ß√£o poss√≠vel sobre as rela√ß√µes da base pode realizar seu efeito desejado sobre a view. Sempre que uma atualiza√ß√£o sobre a view pode ser mapeada para mais de uma atualiza√ß√£o sobre as rela√ß√µes da base, precisamos ter um certo procedimento para escolher uma das atualiza√ß√µes poss√≠veis  como  a  mais  prov√°vel.  Alguns  pesquisadores desenvolveram m√©todos para escolher a atualiza√ß√£o mais prov√°vel, enquanto outros preferem deixar que o usu√°rio escolha o mapeamento de atualiza√ß√£o desejado durante a defini√ß√£o da view.

Resumindo, podemos fazer as seguintes  observa√ß√µes:

- ¬Ñ Uma view com uma √∫nica tabela de defini√ß√£o √© atualiz√°vel se seus atributos tiverem a chave prim√°ria da rela√ß√£o da base, bem como todos os atributos com a restri√ß√£o NOT NULL que n√£o tem valor default especificado.
- ¬Ñ As  views  definidas  sobre  m√∫ltiplas  tabelas usando jun√ß√µes  geralmente  n√£o  s√£o  atualiz√°veis.
- ¬Ñ As views definidas usando fun√ß√µes de agrupamento e agrega√ß√£o n√£o s√£o atualiz√°veis.

Em SQL, a cl√°usula WITH CHECK OPTION precisa ser acrescentada ao final da defini√ß√£o de view se uma view tiver  de  ser  atualizada .  Isso  permite  que o sistema verifique a possibilidade de atualiza√ß√£o da view e planeje uma estrat√©gia de execu√ß√£o para ela.

Tamb√©m √© poss√≠vel definir uma tabela de view na cl√°usula FROM de uma consulta em SQL. Isso √© conhecido como uma view em linha .  Nesse caso, a view √© definida na pr√≥pria consulta.

## 5.4 nstru√ß√µes de altera√ß√£o de I esquema em SQL

Nesta  se√ß√£o,  oferecemos  uma  vis√£o  geral  dos comandos de evolu√ß√£o  de  esquema dispon√≠veis  em SQL, que podem ser usados para alterar um esquema, acrescentando ou removendo tabelas, atributos, restri√ß√µes e outros elementos dele. Isso pode ser feito enquanto o banco de dados est√° operando e n√£o exige recompila√ß√£o do esquema. Certas verifica√ß√µes precisam ser feitas pelo SGBD para garantir que as mudan√ßas n√£o afetar√£o o restante do banco de dados, tornando-o inconsistente.

## 5.4.1 O comando DROP

O comando DROP pode ser usado para remover elementos nomeados do esquema, como tabelas, dom√≠nios ou restri√ß√µes. Tamb√©m √© poss√≠vel remover um esquema. Por exemplo, se todo um esquema n√£o for mais necess√°rio, o comando DROP SCHEMA pode ser utilizado.  Existem  duas  op√ß√µes  de comportamento de drop : CASCADE e RESTRICT . Por exemplo, para remover o esquema de banco de dados EMPRESA e todas as suas tabelas, dom√≠nios e outros elementos, a op√ß√£o CASCADE √© usada da seguinte forma:

## DROP SCHEMA EMPRESA CASCADE ;

Se a op√ß√£o RESTRICT for escolhida no lugar da CASCADE , o esquema √© removido somente se ele n√£o tiver  elementos ;  caso  contr√°rio,  o  comando DROP n√£o ser√° executado. Para usar a op√ß√£o RESTRICT , o usu√°rio deve primeiro remover individualmente cada elemento no esquema, depois remover o pr√≥prio esquema.

Se uma rela√ß√£o da base dentro de um esquema n√£o for mais necess√°ria, a rela√ß√£o e sua defini√ß√£o podem ser exclu√≠das usando o comando DROP TABLF . Por exemplo, se n√£o quisermos mais manter os dependentes dos funcion√°rios no banco de dados EMPRESA da Figura 4.1, podemos descartar a rela√ß√£o DEPENDENTE emitindo o seguinte comando:

## DROP TABLE DEPENDENTE CASCADE ;

Se  a  op√ß√£o RESTRICT for  escolhida  em  vez  da CASCADE , uma tabela √© removida somente se ela n√£o for  referenciada em quaisquer restri√ß√µes  (por  exemplo, por defini√ß√µes de chave estrangeira em outra rela√ß√£o) ou views (ver Se√ß√£o 5.3), ou por quaisquer outros elementos. Com a op√ß√£o CASCADE , todas essas restri√ß√µes, views e outros elementos que referenciam a tabela sendo removida tamb√©m s√£o exclu√≠dos automaticamente do esquema, junto com a pr√≥pria tabela.

Observe que o comando DROP TABLE n√£o apenas  exclui  todos  os  registros  na  tabela  se  tiver  sucesso, mas tamb√©m remove a defini√ß√£o de tabela do cat√°logo. Se for desejado excluir apenas os registros, mas deixar a defini√ß√£o de tabela para uso futuro, ent√£o  o  comando DELETE (ver  Se√ß√£o  4.4.2)  deve  ser usado no lugar de DROP TABLF .

- O comando DROP tamb√©m pode ser empregado para descartar outros tipos de elementos de esquema nomeados, como restri√ß√µes ou dom√≠nios.

## 5.4.2 O comando ALTER

A defini√ß√£o de uma tabela da base ou de outros elementos de esquema nomeados pode ser alterada usando o comando ALTER .  Para as tabelas

da base, as poss√≠veis a√ß√µes de altera√ß√£o de tabela incluem acrescentar ou remover uma coluna (atributo), alterar uma defini√ß√£o de coluna e acrescentar ou remover restri√ß√µes de tabela. Por exemplo, para incluir um atributo que mant√©m as tarefas dos funcion√°rios na rela√ß√£o da base FUNCIONARIO do esquema EMPRESA (ver Figura 4.1), podemos usar o comando

## ALTER TABLE EMPRESA.FUNCIONARIO ADD COLUMN Tarefa VARCHAR 12 ( );

Ainda  podemos  inserir  um  valor  para  o  novo atributo Tarefa para  cada  tupla  individual  de FUNCIONARIO . Isso  pode  ser  feito  especificando  uma cl√°usula default ou usando o comando UPDATE individualmente sobre cada tupla (ver Se√ß√£o 4.4.3). Se nenhuma  cl√°usula  default  for  especificada,  o  novo atributo receber√° o valor NULL em  todas  as  tuplas da rela√ß√£o imediatamente ap√≥s o comando ser executado; logo, a restri√ß√£o NOT NULL n√£o √© permitida nesse caso.

Para  remover  uma  coluna,  temos  de  escolher CASCADE ou RESTRICT para  o  comportamento de remo√ß√£o. Se CASCADE for escolhido, todas as restri√ß√µes e views que referenciam a coluna s√£o removidas automaticamente do esquema, junto com a coluna. Se RESTRICT for escolhido, o comando s√≥ tem sucesso se nenhuma view ou restri√ß√£o (o outro elemento do esquema) referenciar a coluna. Por exemplo, o comando a seguir remove o atributo Endereco da tabela FUNCIONARIO :

## ALTER TABLE EMPRESA.FUNCIONARIO DROP COLUMN Endereco CASCADE ;

Tamb√©m √© poss√≠vel alterar uma defini√ß√£o de coluna  removendo  uma  cl√°usula  default  existente  ou definindo uma nova cl√°usula default. Os exemplos a seguir ilustram essa cl√°usula:

ALTER TABLE EMPRESA.DEPARTAMENTO ALTER COLUMN Cpf\_gerente DROP DEFAULT ;

ALTER TABLE EMPRESA.DEPARTAMENTO ALTER COLUMN Cpf\_gerente SET DEFAULT '33344555587';

Tamb√©m √© poss√≠vel alterar as restri√ß√µes especificadas sobre uma tabela ao acrescentar ou remover uma restri√ß√£o nomeada. Para ser removida, uma restri√ß√£o precisa ter recebido um nome quando foi especificada.  Por  exemplo,  para  descartar  a  restri√ß√£o chamada CHESUPERFUNC da Figura 4.2 da rela√ß√£o FUNCIONARIO , escrevemos:

## ALTER TABLE EMPRESA.FUNCIONARIO DROP  CONSTRAINT CHESUPERFUNC CASCADE ;

Quando isso √© feito, podemos redefinir uma restri√ß√£o substitu√≠da acrescentando uma nova restri√ß√£o √†  rela√ß√£o,  se  necess√°rio.  Isso  √©  especificado  usando a palavra-chave ADD na instru√ß√£o ALTER TABLE seguida pela nova restri√ß√£o, que pode ser nomeada ou n√£o, e pode ser de qualquer um dos tipos de restri√ß√£o de tabela discutidos.

As  subse√ß√µes  anteriores  deram  uma  vis√£o  geral dos comandos de evolu√ß√£o de esquema da SQL. Tamb√©m √© poss√≠vel criar tabelas e views em um esquema de banco de dados usando os comandos apropriados. Existem muitos outros detalhes e op√ß√µes; o leitor  interessado  dever√°  consultar  os  documentos sobre SQL listados na 'Bibliografia selecionada', ao final deste cap√≠tulo.

## Resumo

Neste  cap√≠tulo,  apresentamos  recursos  adicionais da linguagem de banco de dados em SQL. Come√ßamos na Se√ß√£o 5.1 apresentando recursos mais complexos das consultas  de  atualiza√ß√£o  de  SQL,  incluindo  consultas aninhadas, tabelas de jun√ß√£o, jun√ß√µes externas, fun√ß√µes agregadas e agrupamento. Na Se√ß√£o 5.2, descrevemos o comando CREATE ASSERTION ,  que  permite  a  especifica√ß√£o  de  restri√ß√µes  mais  gerais  sobre  o  banco  de  dados, e apresentamos o conceito de triggers e o comando CREATE TRIGGER . Depois, na Se√ß√£o 5.3, descrevemos a facilidade da SQL para definir views no banco de dados. As views tamb√©m s√£o chamadas de tabelas virtuais ou derivadas , pois apresentam ao usu√°rio o que parecem ser tabelas;  no  entanto,  as  informa√ß√µes  nessas  tabelas  s√£o derivadas  de  outras  definidas  anteriormente.  A  Se√ß√£o 5.4 introduziu o comando ALTER TABLE da SQL, que √© usado para modificar as tabelas e restri√ß√µes do banco de dados.

A Tabela 5.2 resume a sintaxe (ou estrutura) de diversos comandos SQL. Esse resumo n√£o √© abrangente, nem descreve cada constru√ß√£o SQL poss√≠vel; em vez disso,  ele  serve  como  uma  refer√™ncia  r√°pida  para  os principais  tipos  de  constru√ß√µes  dispon√≠veis  em  SQL. Usamos a nota√ß√£o BNF, onde os s√≠mbolos n√£o terminais aparecem entre sinais de &lt;...&gt;, as partes opcionais aparecem entre colchetes [...], as repeti√ß√µes aparecem entre chaves {...} e as alternativas aparecem entre par√™nteses (... | ... | ...). 7

7 A sintaxe completa da SQL √© descrita em muitos documentos volumosos, com centenas de p√°ginas.

Tabela 5.2

Resumo da sintaxe da SQL.

CREATE TABLE &lt;nome tabela&gt;   (&lt;nome coluna&gt; &lt;tipo coluna&gt; [ &lt;restri√ß√£o atributo&gt; ]

{ , &lt;nome coluna&gt; &lt;tipo coluna&gt; [ &lt;restri√ß√£o atributo&gt; ] }

[ &lt;restri√ß√£o tabela&gt; { , &lt;restri√ß√£o tabela&gt; } ] )

DROP TABLE &lt;nome tabela&gt;

ALTER TABLE &lt;nome tabela&gt; ADD &lt;nome coluna&gt; &lt;tipo coluna&gt;

SELECT [ DISTINCT ] &lt;lista atributos&gt;

FROM ( &lt;nome tabela&gt; { &lt;apelido&gt; } | &lt;tabela de jun√ß√£o&gt; ) { , ( &lt;nome tabela&gt; { &lt;apelido&gt; } | &lt;tabela de jun√ß√£o&gt; ) }

[ WHERE &lt;condi√ß√£o&gt; ]

[ GROUP BY &lt;atributos agrupamento&gt; [ HAVING &lt;condi√ß√£o sele√ß√£o grupo&gt; ] ]

[ ORDER BY &lt;nome coluna&gt; [ &lt;ordem&gt; ] { , &lt;nome coluna&gt; [ &lt;ordem&gt; ] } ]

&lt;lista atributos&gt; ::= ( * | (   &lt;nome coluna&gt; | &lt;fun√ß√£o&gt; ( ( [ DISTINCT ] &lt;nome coluna&gt; | * ) ) ) { , ( &lt;nome coluna&gt; | &lt;fun√ß√£o&gt; ( ( [ DISTINCT] &lt;nome coluna&gt; | * ) ) } ) )

&lt;atributos agrupamento&gt; ::= &lt;nome coluna&gt; { , &lt;nome coluna&gt; }

&lt;ordem&gt; ::= ( ASC | DESC )

INSERT INTO &lt;nome tabela&gt; [ ( &lt;nome coluna&gt; { , &lt;nome coluna&gt; } ) ]

( VALUES ( &lt;valor constante&gt; , { &lt;valor constante&gt; } ) { , ( &lt;valor constante&gt; { , &lt;valor constante&gt; } ) }

| &lt;instru√ß√£o sele√ß√£o&gt; )

DELETE FROM &lt;nome tabela&gt;

[ WHERE &lt;condi√ß√£o sele√ß√£o&gt; ]

UPDATE &lt;nome tabela&gt;

SET &lt;nome coluna&gt; = &lt; express√£o valor&gt; { , &lt;nome coluna&gt; = &lt;express√£o valor&gt; }

[ WHERE &lt;condi√ß√£o sele√ß√£o&gt; ]

CREATE [ UNIQUE] INDEX &lt;nome √≠ndice&gt;

ON &lt;nome tabela&gt; ( &lt;nome coluna&gt; [ &lt;ordem&gt; ] { , &lt;nome coluna&gt; [ &lt;ordem&gt; ] } )

[ CLUSTER ]

DROP INDEX &lt;nome √≠ndice&gt;

CREATE VIEW &lt;nome view&gt; [ ( &lt;nome coluna&gt; { , &lt;nome coluna&gt; } ) ]

AS &lt;instru√ß√£o sele√ß√£o&gt;

DROP VIEW &lt;nome view&gt;

NOTA: Os comandos para criar e excluir √≠ndices n√£o fazem parte do padr√£o SQL.

## Perguntas de revis√£o

- 5.1. Descreva  as  seis  cl√°usulas  na  sintaxe  de  uma consulta de recupera√ß√£o SQL. Mostre que tipos de constru√ß√µes podem ser especificados em cada uma das seis cl√°usulas. Quais das seis cl√°usulas s√£o obrigat√≥rias e quais s√£o opcionais?
- 5.2. Descreva conceitualmente como uma consulta de recupera√ß√£o SQL ser√° executada, especificando a ordem conceitual de execu√ß√£o de cada uma das seis cl√°usulas.
- 5.3. Discuta como os NULL s s√£o tratados nos operadores de compara√ß√£o em SQL. Como os NULL s s√£o tratados quando fun√ß√µes de agrega√ß√£o s√£o aplicadas  em  uma  consulta  SQL?  Como  os NULL s s√£o tratados quando existem nos atributos de agrupamento?
- 5.4. Discuta  como  cada  uma  das  seguintes  constru√ß√µes √© usada em SQL e quais s√£o as diversas op√ß√µes para  cada  constru√ß√£o.  Especifique  a  utilidade de cada constru√ß√£o.

- a. Consultas aninhadas.
- b. Tabelas de jun√ß√£o e jun√ß√µes externas.
- c. Fun√ß√µes de agrega√ß√£o e agrupamento.
- d. Triggers.
- e. Asser√ß√µes e como elas diferem dos triggers.
- f. Views e suas formas de atualiza√ß√£o.
- g. Comandos de altera√ß√£o de esquema.

## Exerc√≠cios

- 5.5. Especifique as seguintes consultas no banco de dados da Figura 3.5 em SQL. Mostre os resultados da consulta se cada uma for aplicada ao banco de dados da Figura 3.6.
- a. Para cada departamento cujo sal√°rio m√©dio do funcion√°rio seja maior do que R$30.000,00, recupere o nome do departamento e o n√∫mero de funcion√°rios que trabalham nele.
- b. Suponha que queiramos o n√∫mero de funcion√°rios do sexo masculino em cada departamento que ganhe mais de R$30.000,00, em vez de todos os funcion√°rios (como no Exerc√≠cio 5.5a). Podemos especificar essa consulta em SQL? Por qu√™?
- 5.6. Especifique as seguintes consultas em SQL sobre o esquema de banco de dados da Figura 1.2.
- a. Recupere os nomes e departamentos de todos os alunos com notas A (alunos que t√™m uma nota A em todos as disciplinas).
- b. Recupere os nomes e departamentos de todos os alunos que n√£o t√™m uma nota A em qualquer uma das disciplinas.
- 5.7. Em SQL, especifique as seguintes consultas sobre o banco de dados da Figura 3.5 usando o conceito de consultas aninhadas e conceitos descritos neste cap√≠tulo.
- a. Recupere os nomes de todos os funcion√°rios que trabalham no departamento que tem o funcion√°rio com o maior sal√°rio entre todos os funcion√°rios.
- b. Recupere os nomes de todos os funcion√°rios cujo  supervisor  do  supervisor  tenha  como Cpf o n√∫mero '88866555576'.
- c. Recupere os nomes dos funcion√°rios que ganham pelo menos R$10.000,00 a mais que o funcion√°rio que recebe menos na empresa.
- 5.8. Especifique as seguintes views em SQL no esquema de banco de dados EMPRESA mostrado na Figura 3.5.
- a. Uma view que tem o nome do departamento, nome do gerente e sal√°rio do gerente para todo departamento.
- b. Uma view que tenha o nome do funcion√°rio, nome do supervisor e sal√°rio de cada funcion√°rio que trabalha no departamento 'Pesquisa'.
- c. Uma  view  que  tenha  o  nome  do  projeto, nome do departamento que o controla, n√∫mero de funcion√°rios e total de horas trabalhadas por semana em cada projeto.
- d. Uma view que tenha o nome do projeto, nome do departamento que o controla, n√∫mero de funcion√°rios e total de horas trabalhadas por semana  no  projeto  para  cada  projeto com mais de um funcion√°rio trabalhando nele .
- 5.9. Considere  a  seguinte  view, RESUMO\_DEPAR-TAMENTO , definida  sobre  o  banco  de  dados EMPRESA da Figura 3.6:

CREATE VIEW

RESUMO\_DEPARTAMENTO  D ( , C  Total\_sal  Media\_sal , , )

AS SELECT

Dnr , COUNT ( * ), SUM ( Salario ), AVG ( Salario )

FROM

FUNCIONARIO

GROUP BY

Dnr;

Indique quais das seguintes consultas e atualiza√ß√µes seriam permitidas sobre a view. Se uma consulta ou atualiza√ß√£o for permitida, mostre como ficaria a consulta ou atualiza√ß√£o correspondente nas rela√ß√µes da base e seu resultado quando aplicado ao banco de dados da Figura 3.6.

- a. SELECT

*

FROM

RESUMO\_DEPARTAMENTO;

- b. SELECT

D  C ,

FROM

RESUMO\_DEPARTAMENTO

WHERE

TOTAL\_SAL &gt; 100.000;

- c. SELECT

D  MEDIA\_SAL ,

FROM

RESUMO\_DEPARTAMENTO

WHERE

C &gt; ( SELECT C FROM RESUMO\_DEPARTAMENTO WHERE D=4);

- d. UPDATE

RESUMO\_DEPARTAMENTO

SET

D=3

WHERE

D=4;

- e. DELETE

FROM RESUMO\_ DEPARTAMENTO

WHERE

C &gt; 4;

## Bibliografia selecionada

Reisner (1977) descreve uma avalia√ß√£o dos fatores humanos da SEQUEL, precursora da SQL, em que descobriu que os usu√°rios possuem alguma dificuldade de

para especificar corretamente as condi√ß√µes de jun√ß√£o e agrupamento. Date (1984) cont√©m uma cr√≠tica da linguagem SQL que indica seus portos fortes e fracos. Date e Darwen (1993) descrevem a SQL2. ANSI (1986) esbo√ßa o padr√£o SQL original. Diversos manuais de fabricante  descrevem  as  caracter√≠sticas  da  SQL  implementadas em DB2, SQL/DS, Oracle, INGRES, Informix e outros produtos de SGBD comerciais. Melton e Simon (1993) oferecem  um  tratamento  abrangente  do  padr√£o  ANSI 1992, chamado SQL2. Horowitz (1992) discute alguns dos  problemas  relacionados  √†  integridade  referencial  e propaga√ß√£o das atualiza√ß√µes em SQL2.

A quest√£o de atualiza√ß√µes de view √© abordada por Dayal  e  Bernstein  (1978),  Keller  (1982)  e  Langerak (1990), entre outros. A implementa√ß√£o de view √© discutida em Blakeley et al. (1989). Negri et al. (1991) descrevem a sem√¢ntica formal das consultas SQL.

Existem muitos livros que descrevem v√°rios aspectos da SQL. Por exemplo, duas refer√™ncias que descrevem a SQL-99 s√£o Melton e Simon (2002) e Melton (2003). Outros padr√µes SQL - SQL 2006 e SQL 2008 - s√£o descritos em diversos relat√≥rios t√©cnicos; mas n√£o existem refer√™ncias padr√£o.



## √Ålgebra e c√°lculo relacional

N este cap√≠tulo, discutimos as duas linguagens formais para o modelo relacional: a √°lgebra relacional e o c√°lculo relacional. Ao contr√°rio, os cap√≠tulos 4 e 5 descreveram a linguagem pr√°tica para o modelo relacional, a saber, o padr√£o SQL. Historicamente, a √°lgebra  e  o  c√°lculo  relacional  foram  desenvolvidos antes da linguagem SQL. De fato, de algumas maneiras, a SQL √© baseada nos conceitos tanto da √°lgebra quanto do c√°lculo, conforme veremos. Como a maioria dos SGBDs relacionais utiliza a SQL como linguagem, n√≥s a apresentamos primeiro.

para a implementa√ß√£o e otimiza√ß√£o de consultas nos m√≥dulos de otimiza√ß√£o e processamento de consulta, que s√£o partes integrais dos sistemas de gerenciamento de banco de dados relacional (SGBDRs), conforme discutiremos no Cap√≠tulo 19. Terceiro, alguns de seus conceitos s√£o incorporados na linguagem de consulta padr√£o SQL para SGBDRs.

Lembre-se, do Cap√≠tulo 2, de que um modelo de dados precisa incluir um conjunto de opera√ß√µes para manipular o banco de dados, al√©m dos conceitos do modelo de dados para definir a estrutura e as restri√ß√µes do banco de dados. Apresentamos as estruturas e as restri√ß√µes do modelo relacional formal no Cap√≠tulo 3. O conjunto b√°sico de opera√ß√µes para o modelo  relacional  √©  a √°lgebra relacional .  Essas  opera√ß√µes permitem que um usu√°rio especifique as solicita√ß√µes de recupera√ß√£o b√°sicas como express√µes da √°lgebra relacional . O resultado de uma recupera√ß√£o √© uma nova rela√ß√£o, que pode ter sido formada de uma ou mais rela√ß√µes. As opera√ß√µes da √°lgebra, assim, produzem novas rela√ß√µes, que podem ser manipuladas ainda mais usando opera√ß√µes da mesma √°lgebra. Uma sequ√™ncia de opera√ß√µes da √°lgebra relacional forma uma express√£o da √°lgebra relacional , cujo resultado tamb√©m ser√° uma rela√ß√£o que representa o resultado de uma consulta de banco de dados (ou consulta de recupera√ß√£o).

A √°lgebra relacional √© muito importante por diversos motivos. Primeiro, ela oferece um alicerce formal para as opera√ß√µes do modelo relacional. Segundo, e talvez mais importante, ela √© usada como base

Embora a maioria dos SGBDRs comerciais em uso hoje n√£o ofere√ßa interfaces de usu√°rio para consultas da √°lgebra relacional, as opera√ß√µes e fun√ß√µes essenciais nos m√≥dulos internos da maioria dos sistemas relacionais s√£o baseadas nas opera√ß√µes da √°lgebra  relacional.  Definiremos  essas  opera√ß√µes  com detalhes nas se√ß√µes 6.1 a 6.4 deste cap√≠tulo.

Embora  a  √°lgebra defina um  conjunto  de opera√ß√µes para o modelo relacional, o c√°lculo  relacional oferece uma  linguagem declarativa de n√≠vel  mais  alto  para  especificar  consultas  relacionais.  Uma  express√£o  do  c√°lculo  relacional  gera uma nova  rela√ß√£o.  Em  uma  express√£o  do  c√°lculo relacional, n√£o  existe  ordem  de  opera√ß√µes para especificar  como  recuperar  o  resultado  da  consulta  -  somente  qual  informa√ß√£o  o  resultado  deve conter.  Esse  √©  o  principal  fator  de  distin√ß√£o  entre a  √°lgebra  relacional  e  o  c√°lculo  relacional.  O  c√°lculo relacional √© importante porque tem uma firme base na l√≥gica matem√°tica e porque a linguagem de consulta  padr√£o  (SQL)  para  SGBDRs  tem  alguns de seus alicerces em uma varia√ß√£o do c√°lculo relacional conhecida como c√°lculo relacional de tupla. 1

A √°lgebra relacional normalmente √© considerada uma parte integral do modelo de dados relacional. Suas opera√ß√µes podem ser divididas em dois grupos. Um grupo inclui conjunto de opera√ß√µes da teoria de

conjunto  da  matem√°tica;  estas  s√£o  aplic√°veis  porque cada rela√ß√£o √© definida como um conjunto de tuplas no modelo relacional formal (ver Se√ß√£o 3.1). As  opera√ß√µes  de  conjunto  incluem UNI√ÉO , INTERSEC√á√ÉO , DIFEREN√áA DE CONJUNTO e PRODUTO CARTESIANO (tamb√©m conhecida como PRODUTO CRUZADO ).  O  outro  grupo  consiste  em  opera√ß√µes desenvolvidas especificamente para bancos de dados relacionais - entre elas est√£o SELE√á√ÉO PROJE√á√ÉO , e JUN√á√ÉO , entre outras. Primeiro, vamos descrever as opera√ß√µes SELE√á√ÉO e PROJE√á√ÉO na Se√ß√£o 6.1, pois elas s√£o opera√ß√µes un√°rias que ocorrem sobre rela√ß√µes  isoladas.  Depois,  discutimos  as  opera√ß√µes de conjunto na Se√ß√£o 6.2. Na Se√ß√£o 6.3, discutimos JUN√á√ÉO e outras opera√ß√µes bin√°rias complexas, que operam sobre duas tabelas combinando tuplas relacionadas (registros) baseadas em condi√ß√µes de jun√ß√£o .  O banco de dados relacional EMPRESA, mostrado na Figura 3.6, √© usado para nossos exemplos.

Algumas solicita√ß√µes de banco de dados comuns n√£o podem ser realizadas com as opera√ß√µes originais da √°lgebra relacional, de modo que opera√ß√µes adicionais  foram  criadas  para  express√°-las.  Estas incluem fun√ß√µes de agrega√ß√£o ,  que  s√£o  opera√ß√µes que podem resumir dados das tabelas, bem como tipos  adicionais  de  opera√ß√µes JUN√á√ÉO e UNI√ÉO , conhecidas  como JUN√á√ÉO EXTERNA e UNI√ÉO EXTERNA .  Essas opera√ß√µes, que foram acrescentadas √† √°lgebra relacional devido a sua import√¢ncia para muitas aplica√ß√µes de banco de dados, s√£o descritas na Se√ß√£o 6.4. Oferecemos exemplos da especifica√ß√£o de consultas que usam opera√ß√µes relacionais na Se√ß√£o 6.5. Algumas dessas mesmas consultas foram utilizadas nos cap√≠tulos 4 e 5. Ao usar os mesmos n√∫meros de consulta neste cap√≠tulo, o leitor poder√° comparar como as mesmas consultas s√£o escritas nas diversas linguagens de consulta.

vis√£o geral da linguagem Query-By-Example (QBE), que √© uma linguagem relacional gr√°fica de uso facilitado, basea  da no c√°lculo relacional de dom√≠nio. No final do cap√≠tulo h√° um resumo.

Para o leitor interessado em uma introdu√ß√£o menos detalhada √†s linguagens relacionais formais, as se√ß√µes 6.4, 6.6 e 6.7 podem ser puladas.

## 6.1 Opera√ß√µes relacionais un√°rias: SELE√á√ÉO e PROJE√á√ÉO

## 6.1.1 A opera√ß√£o SELE√á√ÉO

A opera√ß√£o SELE√á√ÉO √© usada para escolher um subconjunto das tuplas de uma rela√ß√£o que satisfa√ßa uma condi√ß√£o de sele√ß√£o . 3 Pode-se considerar que a opera√ß√£o SELE√á√ÉO seja um filtro que mant√©m apenas as tuplas que satisfazem uma condi√ß√£o qualificadora. Como alternativa, podemos considerar que essa opera√ß√£o restringe as tuplas em uma rela√ß√£o para apenas aquelas que satisfazem a condi√ß√£o. A opera√ß√£o SELE√á√ÉO tamb√©m pode ser visualizada  como  uma parti√ß√£o horizontal da rela√ß√£o em dois conjuntos de tuplas - aquelas que satisfazem a condi√ß√£o e s√£o selecionadas, e aquelas que n√£o satisfazem a condi√ß√£o e s√£o descartadas. Por exemplo, para selecionar a tupla FUNCIONARIO cujo departamento √© 4, ou aquelas cujo sal√°rio √© maior do que R$ 30.000,00, podemos especificar  individualmente  cada  uma  dessas  duas condi√ß√µes com uma opera√ß√£o SELE√á√ÉO da seguinte maneira:

<!-- formula-not-decoded -->

Em geral, a opera√ß√£o SELE√á√ÉO √© indicada por

Nas se√ß√µes 6.6 e 6.7, descrevemos a outra linguagem formal principal para bancos de dados relacionais, o c√°lculo relacional . Existem duas varia√ß√µes do c√°lculo relacional. O c√°lculo relacional de tupla √© descrito na Se√ß√£o 6.6, e o c√°lculo relacional de dom√≠nio √© descrito na Se√ß√£o 6.7. Algumas das constru√ß√µes SQL discutidas nos cap√≠tulos 4 e 5 s√£o baseadas no c√°lculo relacional de tupla. O c√°lculo relacional √© uma linguagem formal, fundamentada no ramo da l√≥gica  matem√°tica  chamado  de  c√°lculo  de  predicado. 2 No c√°lculo relacional de tupla, vari√°veis estendem-se por tuplas , enquanto no c√°lculo relacional de dom√≠nio, vari√°veis estendem-se por dom√≠nios (valores)  de  atributos.  No  Ap√™ndice C, oferecemos uma

<!-- formula-not-decoded -->

onde  o  s√≠mbolo ùõî (sigma)  √©  usado  para  indicar  o operador SELE√á√ÉO e  a  condi√ß√£o  de  sele√ß√£o  √©  uma express√£o booleana (condi√ß√£o) especificada nos atributos da rela√ß√£o R . Observe que R costuma ser uma express√£o da √°lgebra relacional cujo resultado √© uma rela√ß√£o - a mais simples express√£o desse tipo √© apenas o nome de uma rela√ß√£o de banco de dados. A rela√ß√£o resultante da opera√ß√£o SELE√á√ÉO tem os mesmos atributos de R .

A  express√£o  booleana  especificada  em  &lt;condi√ß√£o sele√ß√£o&gt; √© composta de uma s√©rie de cl√°usulas da forma

2 Neste cap√≠tulo, nenhuma familiaridade com o c√°lculo de predicado de primeira ordem - que lida com vari√°veis e valores quantificados - √© assumida.

3 A opera√ß√£o SELE√á√ÉO √© diferente da cl√°usula SELECT da SQL. A opera√ß√£o SELE√á√ÉO escolhe tuplas de uma tabela, e √†s vezes √© chamada de opera√ß√£o RESTRINGIR ou FILTRAR.

&lt;nome atributo&gt; &lt;op compara√ß√£o&gt; &lt;valor constante&gt;

ou

&lt;nome atributo&gt; &lt;op compara√ß√£o&gt; &lt;nome atributo&gt;

onde &lt;nome atributo&gt; √© o nome de um atributo de R , &lt;op compara√ß√£o&gt; em geral √© um dos operadores { = , &lt; ‚â§ &gt; ‚â• ‚â† , , , , } e &lt;valor constante&gt; √© um valor constante  do  dom√≠nio  do  atributo.  As  cl√°usulas  podem ser  conectadas  pelos  operadores  booleanos  padr√£o and , or e not para formar uma condi√ß√£o de sele√ß√£o geral.  Por  exemplo,  para  selecionar  as  tuplas  para todos os funcion√°rios que ou trabalham no departamento 4 e ganham mais de R$ 25.000,00 por ano, ou trabalham no departamento 5 e ganham mais de R$ 30.000,00, podemos especificar a seguinte opera√ß√£o SELE√á√ÉO :

<!-- formula-not-decoded -->

O resultado √© mostrado na Figura 6.1(a).

Observe que todos os operadores de compara√ß√£o no conjunto { = &lt; ‚â§ &gt; ‚â• ‚â† , , , , , } podem ser aplicados aos atributos cujos dom√≠nios s√£o valores ordenados , como dom√≠nios num√©ricos ou de data. Os dom√≠nios de cadeias de caracteres tamb√©m s√£o considerados ordenados com base na ordem alfab√©tica dos caracteres. Se o dom√≠nio de um atributo for um conjunto de valores desordenados , ent√£o somente os operadores de compara√ß√£o no conjunto {=, ‚â† } podem ser usados. Um exemplo de dom√≠nio desordenado √© o dom√≠nio Cor = { 'vermelho', 'azul', 'verde', 'branco', 'amarelo', ...},  onde  nenhuma ordem √© especificada entre  as  diversas  cores.  Alguns  dom√≠nios  permitem tipos adicionais de operadores de compara√ß√£o; por exemplo, um dom√≠nio de cadeias de caracteres pode permitir o operador de compara√ß√£o SUBSTRING\_OF .

Em geral, o resultado de uma opera√ß√£o SELE√á√ÉO pode ser determinado da seguinte forma. A &lt;condi√ß√£o sele√ß√£o&gt; √© aplicada independentemente para cada tupla individual t em R . Isso √© feito substituindo cada ocorr√™ncia de um atributo A i na condi√ß√£o de sele√ß√£o por seu valor na tupla  [ t A i ]. Se a condi√ß√£o for avaliada como TRUE , ent√£o a tupla   √© t selecionada . Todas as tuplas selecionadas aparecem no resultado da opera√ß√£o SELE√á√ÉO .  As  condi√ß√µes  booleanas AND , OR e NOT t√™m sua interpreta√ß√£o normal, da seguinte forma:

- ¬Ñ (cond1 AND cond2)  √© TRUE se (cond1) e  (cond2)  forem TRUE ; caso  contr√°rio,  √© FALSE .
- ¬Ñ (cond1 OR cond2)  √© TRUE se  (cond1)  ou (cond2) ou ambas forem TRUE ; caso contr√°rio, √© FALSE .
- ¬Ñ ( NOT cond)  √© TRUE se  cond  √© FALSE ;  caso contr√°rio, √© FALSE .

O operador SELE√á√ÉO √© un√°rio ;  ou  seja,  ele  √© aplicado a uma √∫nica rela√ß√£o. Al√©m do mais, a opera√ß√£o de sele√ß√£o √© aplicada a cada tupla individualmente ; logo, as condi√ß√µes de sele√ß√£o n√£o podem envolver mais de uma tupla. O grau da rela√ß√£o resultante de uma opera√ß√£o SELE√á√ÉO - seu n√∫mero de atributos - √© o mesmo que o grau de R . O n√∫mero de tuplas na rela√ß√£o resultante √© sempre menor ou igual ao n√∫mero de tuplas em R . Ou seja, | ùõî c ( R )| ‚â§ | R | para qualquer condi√ß√£o C . A fra√ß√£o de tuplas selecionada por uma condi√ß√£o de sele√ß√£o √© conhecida como seletividade da condi√ß√£o.

Observe que a opera√ß√£o SELECT √© comutativa ; ou seja,

<!-- formula-not-decoded -->

Portanto, uma sequ√™ncia de SELE√á√ÉO pode ser aplicada em qualquer ordem. Al√©m disso, sempre podemos combinar uma cascata (ou sequ√™ncia ) de opera√ß√µes SELE√á√ÉO a  uma  √∫nica  opera√ß√£o SELE√á√ÉO , com uma condi√ß√£o conjuntiva ( AND ); ou seja,

<!-- formula-not-decoded -->

Em SQL, a condi√ß√£o SELE√á√ÉO normalmente √© especificada  na  cl√°usula WHERE de  uma  consulta. Por exemplo, a opera√ß√£o a seguir:

<!-- formula-not-decoded -->

corresponderia √† seguinte consulta SQL:

SELECT

ÔÇ´

FROM

FUNCIONARIO

WHERE

Dnr=4 AND Salario &gt; 25.000;

## 6.1.2 A opera√ß√£o PROJE√á√ÉO

Se pensarmos em uma rela√ß√£o como uma tabela, a opera√ß√£o SELE√á√ÉO escolhe algumas das linhas da tabela enquanto descarta outras linhas. A opera√ß√£o PROJE√á√ÉO ,  por  sua  vez,  seleciona  certas colunas da  tabela  e  descarta  as  outras.  Se  estivermos  interessados apenas em certos atributos de uma rela√ß√£o, usamos a opera√ß√£o PROJE√á√ÉO para projetar a rela√ß√£o apenas por esses atributos. Portanto, o resultado da opera√ß√£o PROJE√á√ÉO pode ser visualizado como uma parti√ß√£o vertical da rela√ß√£o em duas rela√ß√µes: uma tem as colunas (atributos) necess√°rias e cont√©m o resultado da opera√ß√£o, e a outra cont√©m as colunas

descartadas. Por exemplo, para listar √∫ltimo nome e primeiro nome e sal√°rio de cada funcion√°rio, podemos usar a opera√ß√£o PROJE√á√ÉO da seguinte forma:

<!-- formula-not-decoded -->

A  rela√ß√£o  resultante  aparece  na  Figura  6.1(b). A forma geral da opera√ß√£o PROJE√á√ÉO √©

<!-- formula-not-decoded -->

onde ùõë (pi) √© o s√≠mbolo usado para representar a opera√ß√£o PROJE√á√ÉO , e &lt;lista atributos&gt; √© a sublista desejada de atributos da rela√ß√£o R . Mais uma vez, observe que R , em geral, √© uma express√£o da √°lgebra relacional cujo resultado √© uma rela√ß√£o, que no caso mais simples √© apenas o nome de uma rela√ß√£o do banco de dados. O resultado da opera√ß√£o PROJE√á√ÉO tem  apenas  os atributos especificados em &lt;lista atributos&gt; na mesma ordem em que eles aparecem na lista . Logo, seu grau √© igual ao n√∫mero de atributos em &lt;lista atributos&gt;.

Se a lista de atributos inclui apenas atributos n√£o chave de R , tuplas duplicadas provavelmente ocorrer√£o. A opera√ß√£o PROJE√á√ÉO remove quaisquer tuplas duplicadas , de modo que o resultado dessa opera√ß√£o

√© um conjunto de tuplas distintas, e, portanto, uma rela√ß√£o v√°lida. Isso √© conhecido como elimina√ß√£o de duplicatas . Por exemplo, considere a seguinte opera√ß√£o PROJE√á√ÉO :

<!-- formula-not-decoded -->

O resultado  √©  mostrado  na  Figura  6.1(c).  Observe que a tupla &lt;'F', 25.000&gt; s√≥ aparece uma vez na Figura 6.1(c), embora essa combina√ß√£o de valores apare√ßa duas vezes na rela√ß√£o FUNCIONARIO . A elimina√ß√£o de duplicatas envolve a classifica√ß√£o ou alguma outra t√©cnica para detectar duplicatas e, portanto,  aumenta  o  processamento.  Se  as  duplicatas n√£o fossem eliminadas, o resultado seria um multiconjunto ou bag de tuplas, em vez de um conjunto. Isso n√£o era permitido no modelo relacional formal, mas pode ocorrer na SQL (ver Se√ß√£o 4.3).

O n√∫mero de tuplas em uma rela√ß√£o resultante de uma opera√ß√£o PROJE√á√ÉO √© sempre menor ou igual ao n√∫mero de tuplas em R . Se a lista de proje√ß√£o √© uma superchave de R - ou seja, inclui alguma chave de R -, a rela√ß√£o resultante tem o mesmo n√∫mero de tuplas que R . Al√©m do mais,

## (a)

| Pnome    | Minicial   | Unome   |         Cpf | Datanasc   | Endereco                                | Sexo   |   Salario |   Cpf_supervisor |   Dnr |
|----------|------------|---------|-------------|------------|-----------------------------------------|--------|-----------|------------------|-------|
| Fernando | T          | Wong    | 33344555587 | 08-12-1955 | Rua da Lapa, 34, S√£o Paulo, SP          | M      |        40 |      88866555576 |     5 |
| Jennifer | S          | Souza   | 98765432168 | 20-06-1941 | Av. Arthur de Lima, 54, Santo Andr√©, SP | F      |        43 |      88866555576 |     4 |
| Ronaldo  | K          | Lima    | 66688444476 | 15-09-1962 | Rua Rebou√ßas, 65, Piracicaba, SP        | M      |        38 |      33344555587 |     5 |

## (b)

## (c)

| Unome   | Pnome    |   Salario |
|---------|----------|-----------|
| Silva   | Jo√£o     |        30 |
| Wong    | Fernando |        40 |
| Zelaya  | Alice    |        25 |
| Souza   | Jennifer |        43 |
| Lima    | Ronaldo  |        38 |
| Leite   | Joice    |        25 |
| Pereira | Andr√©    |        25 |
| Brito   | Jorge    |        55 |

| Sexo   |   Salario |
|--------|-----------|
| M      |        30 |
| M      |        40 |
| F      |        25 |
| F      |        43 |
| M      |        38 |
| M      |        25 |
| M      |        55 |

## Figura 6.1

Resultados das opera√ß√µes SELE√á√ÉO e PROJE√á√ÉO. (a) ùõî (Dnr=4 AND Salario&gt;25.000) OR (Dnr=5 AND Salario&gt;30.000) (FUNCIONARIO). (b) ùõë Unome, Pnome, Salario (FUNCIONARIO). (c) ùõë Sexo, Salario (FUNCIONARIO).

<!-- formula-not-decoded -->

desde que a &lt;lista2&gt; contenha os atributos em &lt;lista1&gt;; caso contr√°rio, o lado esquerdo √© uma express√£o incorreta. Tamb√©m vale a pena notar que a comutatividade n√£o √© mantida em PROJE√á√ÉO .

Em SQL, a lista  de  atributos  de PROJE√á√ÉO √© especificada na cl√°usula SELE√á√ÉO de uma consulta. Por exemplo, a opera√ß√£o a seguir:

<!-- formula-not-decoded -->

corresponderia √† seguinte consulta SQL:

<!-- formula-not-decoded -->

Observe  que,  se  removermos  a  palavra-chave DISTINCT dessa  consulta  SQL,  ent√£o  as  duplicatas n√£o ser√£o eliminadas. Essa op√ß√£o n√£o est√° dispon√≠vel na √°lgebra relacional formal.

## 6.1.3 Sequ√™ncias de opera√ß√µes e a opera√ß√£o RENOMEAR

As rela√ß√µes mostradas na Figura 6.1, que representam resultados de opera√ß√£o, n√£o possuem nome. Em geral,  para  a  maioria  das  consultas,  precisamos  aplicar  v√°rias  opera√ß√µes  da  √°lgebra  relacional  uma  ap√≥s a  outra.  Ou  podemos  escrev√™-las  como  uma  √∫nica express√£o  da  √°lgebra  relacional aninhando  as  opera√ß√µes, ou aplicar uma opera√ß√£o de cada vez e criar rela√ß√µes de resultado intermedi√°rio. No √∫ltimo caso, temos de dar nomes √†s rela√ß√µes que mant√™m os resultados intermedi√°rios. Por exemplo, para recuperar o  primeiro  nome,  sobrenome e sal√°rio de todos os funcion√°rios que trabalham no departamento n√∫mero 5, devemos aplicar uma opera√ß√£o SELE√á√ÉO e uma PROJE√á√ÉO . Podemos escrever uma √∫nica express√£o da √°lgebra relacional, tamb√©m conhecida como uma express√£o em linha , da seguinte forma:

<!-- formula-not-decoded -->

A Figura 6.2(a) mostra o resultado dessa express√£o da √°lgebra relacional em linha. Como alternativa, podemos explicitamente mostrar a sequ√™ncia de opera√ß√µes, dando um nome a cada rela√ß√£o intermedi√°ria, da seguinte forma:

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

√Äs  vezes, √© mais  simples desmembrar  uma sequ√™n  cia complexa de opera√ß√µes especificando rela√ß√µes de resultado intermedi√°rio do que escrever uma √∫nica express√£o da √°lgebra relacional. Tamb√©m podemos usar essa t√©cnica para renomear os atributos nas rela√ß√µes intermedi√°rias e de resultado. Isso pode ser √∫til em conex√£o com opera√ß√µes mais complexas, como UNI√ÉO e JUN√á√ÉO , conforme veremos. Para renomear os atributos em uma rela√ß√£o, simplesmente listamos os novos nomes de atributo entre par√™nteses, como no exemplo a seguir:

<!-- formula-not-decoded -->

Essas  duas  opera√ß√µes  s√£o  ilustradas  na  Figura 6.2(b).

Se nenhuma renomea√ß√£o for aplicada, os nomes dos atributos na rela√ß√£o resultante de uma opera√ß√£o SELE√á√ÉO ser√£o  iguais  aos  da  rela√ß√£o  original  e  na mesma ordem. Para uma opera√ß√£o PROJE√á√ÉO sem renomea√ß√£o, a rela√ß√£o resultante tem os mesmos nomes de atributo daqueles na lista de proje√ß√£o e na mesma ordem em que eles aparecem na lista.

Tamb√©m podemos definir uma opera√ß√£o RENOMEAR formal - que pode renomear o nome da rela√ß√£o ou os nomes de atributo, ou ambos - como um operador un√°rio. A opera√ß√£o RENOMEAR geral, quando aplicada √† rela√ß√£o R de  grau n ,  √©  indicada por qualquer uma das tr√™s formas a seguir:

<!-- formula-not-decoded -->

onde o s√≠mbolo œÅ (rho) √© usado para indicar o operador RENOMEAR , S √© o nome da nova rela√ß√£o, e B 1 , B 2 , ..., B n s√£o os novos nomes de atributo. A primeira express√£o renomeia tanto a rela√ß√£o quanto seus atributos, a segunda renomeia apenas a rela√ß√£o, e a terceira renomeia apenas os atributos. Se os atributos de R s√£o ( A 1 , A 2 , ..., A n ) nessa ordem, ent√£o cada A i √© renomeado como B i .

Em SQL, uma √∫nica consulta costuma representar  uma express√£o complexa da √°lgebra relacional. A renomea√ß√£o em SQL √© obtida por apelidos usando AS , como no exemplo a seguir:

SELECT

.Pnome F AS

Primeiro\_nome, F.Unome

AS Ultimo\_nome, F.Salario AS Salario

FROM

FUNCIONARIO AS F

WHERE

F.Dnr=5,

## (a)

| Pnome    | Unome   |   Salario |
|----------|---------|-----------|
| Jo√£o     | Silva   |        30 |
| Fernando | Wong    |        40 |
| Ronaldo  | Lima    |        38 |
| Joice    | Leite   |        25 |

## (b)

## TEMP

| Pnome    | Minicial   | Unome   |         Cpf | Datanasc   | Endereco                           | Sexo   |   Salario |   Cpf_supervisor |   Dnr |
|----------|------------|---------|-------------|------------|------------------------------------|--------|-----------|------------------|-------|
| Jo√£o     | B          | Silva   | 12345678966 | 09-01-1965 | Rua das Flores, 751, S√£o Paulo, SP | M      |        30 |      33344555587 |     5 |
| Fernando | T          | Wong    | 33344555587 | 08-12-1955 | Rua da Lapa, 34, S√£o Paulo, SP     | M      |        40 |      88866555576 |     5 |
| Ronaldo  | K          | Lima    | 66688444476 | 15-09-1962 | Rua Rebou√ßas, 65, Piracicaba, SP   | M      |        38 |      33344555587 |     5 |
| Joice    | A          | Leite   | 45345345376 | 31-07-1972 | Av. Lucas Obes, 74, S√£o Paulo, SP  | F      |        25 |      33344555587 |     5 |

## R

| Primeiro_nome   | Ultimo_nome   |   Salario |
|-----------------|---------------|-----------|
| Jo√£o            | Silva         |        30 |
| Fernando        | Wong          |        40 |
| Ronaldo         | Lima          |        38 |
| Joice           | Leite         |        25 |

## Figura 6.2

Resultados de uma sequ√™ncia de opera√ß√µes. (a) œÄ Pnome, Unome, Salario ( ùõî Dnr=5 (FUNCIONARIO)). (b) Usando rela√ß√µes intermedi√°rias e renomeando atributos.

## 6.2 Opera√ß√µes de √°lgebra relacional com base na teoria dos conjuntos

FUNCS\_DEP5 ‚Üê ùõî Dnr=5 (FUNCIONARIO) RESULTADO1 ‚Üê ùõë Cpf (FUNCS\_DEP5) RESULTADO2(Cpf) ‚Üê ùõë Cpf\_supervisor (FUNCS\_DEP5) RESULTADO ‚Üê RESULTADO1 ‚à™ RESULTADO2

## 6.2.1 As opera√ß√µes UNI√ÉO, INTERSEC√á√ÉO e SUBTRA√á√ÉO

O pr√≥ximo grupo de opera√ß√µes da √°lgebra relacional s√£o as opera√ß√µes matem√°ticas padr√£o sobre conjuntos. Por exemplo, para recuperar os n√∫meros de Cadastro de Pessoa F√≠sica de todos os funcion√°rios que ou trabalham no departamento 5 ou supervisionam diretamente um funcion√°rio que trabalha no departamento 5, podemos usar a opera√ß√£o UNI√ÉO da seguinte forma: 4

A rela√ß√£o RESULTADO1 tem o Cpf de  todos os funcion√°rios  que  trabalham  no  departamento  5, enquanto RESULTADO2 tem o Cpf de todos os funcion√°rios que supervisionam diretamente um funcion√°rio que trabalha no departamento 5. A opera√ß√£o UNION produz as tuplas que est√£o ou no RESULTADO1 ou no RESULTADO2 ou em ambos (ver Figura 6.3), enquanto elimina quaisquer duplicatas. Assim, o valor de Cpf '33344555587' aparece apenas uma vez no resultado.

4 Como uma √∫nica express√£o da √°lgebra relacional, isso se torna Resultado ‚ÜêœÄ Cpf ( ùõî Dnr=5 (FUNCIONARIO)) ‚à™ œÄ Cpf\_supervisor ( ùõî Dnr=5 (FUNCIONARIO)).

## RESULTADO1 RESULTADO2 RESULTADO

| Cpf         | Cpf         |         Cpf |
|-------------|-------------|-------------|
| 12345678966 | 33344555587 | 12345678966 |
| 33344555587 | 88866555576 | 33344555587 |
| 66688444476 |             | 66688444476 |
| 45345345376 |             | 45345345376 |
|             |             | 88866555576 |

Figura 6.3

Resultado da opera√ß√£o UNI√ÉO

RESULTADO ‚Üê RESULTADO1 ‚à™ RESULTADO2.

V√°rias opera√ß√µes de teoria de conjunto s√£o usadas para mesclar os elementos de dois conjuntos de diversas maneiras, incluindo UNI√ÉO INTERSEC√á√ÉO , e DIFEREN√áA  DE  CONJUNTO (tamb√©m  chamada SUBTRA√á√ÉO ou EXCETO ). Estas s√£o opera√ß√µes bin√°rias ; ou seja, cada uma √© aplicada a dois conjuntos (de tuplas). Quando essas opera√ß√µes s√£o adaptadas aos bancos de dados relacionais, as duas rela√ß√µes sobre as quais qualquer uma dessas tr√™s opera√ß√µes s√£o aplicadas precisam ter o mesmo tipo de tuplas ; essa condi√ß√£o √© chamada de compatibilidade de uni√£o ou compatibilidade de tipo . Duas rela√ß√µes R A ( 1 , A 2 , ..., A n ) e S B ( 1 , B 2 , ..., B n ) s√£o consideradas compat√≠veis na uni√£o (ou compat√≠veis no tipo ) se tiverem o mesmo grau n e  se  dom( A i ) = dom( B i )  para  1 ‚â§ i ‚â§ n .  Isso significa que as duas rela√ß√µes t√™m o mesmo n√∫mero de atributos e cada par correspondente de atributos tem o mesmo dom√≠nio.

Podemos definir as tr√™s opera√ß√µes UNI√ÉO INTER-, SEC√á√ÉO e SUBTRA√á√ÉO sobre duas rela√ß√µes compat√≠veis na uni√£o, R e S , como se segue :

- ¬Ñ UNI√ÉO : O resultado dessa opera√ß√£o, indicada por R ‚à™ S , √© uma rela√ß√£o que inclui todas as tuplas que est√£o em R ou em S ou tanto em R quanto em S . As tuplas duplicadas s√£o eliminadas.
- ¬Ñ INTERSEC√á√ÉO : O resultado dessa opera√ß√£o, indicada por R ‚à© S , √© uma rela√ß√£o que inclui todas as tuplas que est√£o tanto em R quanto em  . S
- ¬Ñ DIFEREN√áA  DE  CONJUNTO (ou SUBTRA√á√ÉO ): O resultado dessa opera√ß√£o, indicada por R -S , √© uma rela√ß√£o que inclui todas as tuplas que est√£o em R , mas n√£o em S .

Adotaremos  a  conven√ß√£o  de  que  a  rela√ß√£o resultante  tem  os  mesmos  nomes  de  atributo  da primeira rela√ß√£o R .  Sempre  √©  poss√≠vel  renomear os  atributos  no  resultado  usando  o  operador  de renomea√ß√£o.

A Figura 6.4 ilustra as tr√™s opera√ß√µes. As rela√ß√µes ALUNO e PROFESSOR na Figura 6.4(a) s√£o compat√≠veis na uni√£o e suas tuplas representam os nomes dos alunos e dos professores, respectivamente. O resultado da opera√ß√£o UNI√ÉO na Figura 6.4(b) mostra os nomes de todos os alunos e professores. Observe que tuplas duplicadas aparecem apenas uma vez no resultado.  O  resultado  da  opera√ß√£o INTERSEC√á√ÉO (Figura  6.4(c))  inclui  apenas  aqueles  que  s√£o  tanto alunos quanto professores.

Observe  que  tanto UNI√ÉO quanto INTERSEC√á√ÉO s√£o opera√ß√µes comutativas ; ou seja,

<!-- formula-not-decoded -->

Tanto UNI√ÉO quanto INTERSEC√á√ÉO podem ser tratadas como opera√ß√µes n -√°rias,  aplic√°veis a qualquer quantidade de rela√ß√µes, pois ambas tamb√©m s√£o opera√ß√µes associativas ; ou seja,

<!-- formula-not-decoded -->

A opera√ß√£o SUBTRA√á√ÉO n√£o √© comutativa ; ou seja, em geral,

<!-- formula-not-decoded -->

A Figura 6.4(d) mostra os nomes dos alunos que n√£o s√£o professores, e a Figura 6.4(e) mostra os nomes dos professores que n√£o s√£o alunos.

Observe  que INTERSEC√á√ÉO pode  ser  expressa em termos de uni√£o e diferen√ßa de conjunto, da seguinte forma:

<!-- formula-not-decoded -->

Em SQL, existem tr√™s opera√ß√µes UNION , INTERSECT e EXCEPT - que  correspondem  √†s  opera√ß√µes  de  conjunto  uni√£o,  intersec√ß√£o  e  subtra√ß√£o. Al√©m  disso,  existem  opera√ß√µes  de  multiconjunto ( UNION ALL INTERSECT ALL , e EXCEPT ALL ) que n√£o eliminam duplicatas (ver Se√ß√£o 4.3.4).

## 6.2.2 A opera√ß√£o PRODUTO CARTESIANO ou PRODUTO CRUZADO

Em seguida, discutimos a opera√ß√£o PRODUTO CARTESIANO -  tamb√©m  conhecida  como PRODUTO CRUZADO ou JUN√á√ÉO CRUZADA -, que √© indicada por √ó. Esta tamb√©m √© uma opera√ß√£o de conjunto bin√°ria, mas as rela√ß√µes sobre as quais ela √© aplicada n√£o precisam ser compat√≠veis na uni√£o. Em sua forma bin√°ria, esta opera√ß√£o de conjunto produz um novo elemento combinando cada membro (tupla) de uma rela√ß√£o (conjunto) com cada membro (tupla)  da  outra  rela√ß√£o  (conjunto).  Em  geral,

## (a) ALUNO

| Pn      | Un        |
|---------|-----------|
| Susana  | Yao       |
| Ronaldo | Lima      |
| Jos√©    | Gon√ßalves |
| Barbara | Pires     |
| Ana     | Tavares   |
| Jonas   | Wang      |
| Ernesto | Gilberto  |

## PROFESSOR

Figura 6.4 As opera√ß√µes de conjunto UNI√ÉO, INTERSEC√á√ÉO e SUBTRA√á√ÉO. (a) Duas rela√ß√µes compat√≠veis na uni√£o. (b) ALUNO

| Pnome     | Unome   |
|-----------|---------|
| Jo√£o      | Silva   |
| Ricardo   | Braga   |
| Susana    | Yao     |
| Francisco | Leme    |
| Ronaldo   | Lima    |

| (b)       | Pn    | Un        |
|-----------|-------|-----------|
| Susana    | Yao   |           |
| Ronaldo   | Lima  |           |
| Jos√©      |       | Gol√ßalves |
| Barbara   |       | Pires     |
| Ana       |       | Tavares   |
| Jonas     |       | Wang      |
| Ernesto   |       | Gilberto  |
| Jo√£o      |       | Silva     |
| Ricardo   | Braga |           |
| Francisco | Leme  |           |

| (c)     | Pn Un   |
|---------|---------|
| Susana  | Yao     |
| Ronaldo | Lima    |

| Pn (d)   | Un        |
|----------|-----------|
| Jos√©     | Gon√ßalves |
| Barbara  | Pires     |
| Ana      | Tavares   |
| Jonas    | Wang      |
| Ernesto  | Gilberto  |

| Pnome (e)   | Unome   |
|-------------|---------|
| Jo√£o        | Silva   |
| Ricardo     | Braga   |
| Francisco   | Leme    |

‚à™ PROFESSOR. (c) ALUNO ‚à© PROFESSOR. (d) ALUNO -PROFESSOR. (e) PROFESSOR -ALUNO.

o resultado de R A ( 1 , A 2 ,  ..., A n )  √ó S B ( 1 , B 2 ,  ..., B m ) √© uma rela√ß√£o Q com grau n + m atributos Q A ( 1 , A 2 ,  ..., A n , B 1 , B 2 ,  ..., B m ),  nessa  ordem.  A  rela√ß√£o resultante Q tem uma tupla para cada combina√ß√£o de tuplas - uma de R e uma de S . Logo, se R tem n R tuplas (indicado como | R | = n R ), e S tem n S tuplas, ent√£o R √ó S ter√° n R ÔÇ´ n S tuplas.

A  opera√ß√£o n -√°ria PRODUTO  CARTESIANO √© uma extens√£o desse conceito, que produz novas tuplas ao concatenar todas as combina√ß√µes de tuplas poss√≠veis de n rela√ß√µes b√°sicas.

Com frequ√™ncia, a opera√ß√£o PRODUTO CARTESIANO aplicada isoladamente n√£o tem significado. Ela √© mais √∫til quando seguida por uma sele√ß√£o que combina valores de atributos vindos das rela√ß√µes componentes.  Por  exemplo,  suponha  que  queiramos  recuperar uma lista dos nomes dos dependentes de cada funcion√°ria. Podemos fazer isso da seguinte forma:



As rela√ß√µes resultantes dessa sequ√™ncia de opera√ß√µes aparecem na Figura 6.5. A rela√ß√£o FUNC\_DE-PENDENTES √© o resultado da aplica√ß√£o da opera√ß√£o PRODUTO CARTESIANO a FUNCNOMES da  Figura 6.5 com DEPENDENTE da Figura 3.6. Em FUNC\_DE-PENDENTES ,  cada  tupla  de FUNCNOMES √©  combinada  com  cada  tupla  de DEPENDENTE ,  dando  um resultado  que  n√£o  √©  muito  significativo  (cada  dependente √© combinado com cada funcion√°ria). Queremos combinar uma tupla de funcion√°ria somente com seus dependentes em particular - a saber, as tuplas de DEPENDENTE cujo valor de Fcpf combina com o valor de Cpf da  tupla FUNCIONARIO .  A  rela√ß√£o DEPENDENTES\_PARTIC realiza isso. A rela√ß√£o FUNC\_DEPENDENTES √©  um  bom  exemplo  do  caso em que a √°lgebra relacional pode ser corretamente aplicada para gerar resultados que n√£o fazem sentido algum. √â responsabilidade do usu√°rio garantir que aplicar√° apenas opera√ß√µes significativas √†s rela√ß√µes.

O PRODUTO  CARTESIANO cria  tuplas  com  os atributos combinados de duas rela√ß√µes. Podemos selecionar ( SELE√á√ÉO ) tuplas relacionadas somente das duas rela√ß√µes especificando uma condi√ß√£o de sele√ß√£o apropriada ap√≥s o produto Cartesiano, como fizemos no exemplo anterior. Como essa sequ√™ncia de PRODUTO CARTESIANO seguida por SELE√á√ÉO √©  muito  uti-

## FUNC\_MULHERES

| Pnome    | Minicial   | Unome   |         Cpf | Datanasc   | Endereco                                | Sexo   |   Salario |   Cpf_supervisor |   Dnr |
|----------|------------|---------|-------------|------------|-----------------------------------------|--------|-----------|------------------|-------|
| Alice    | J          | Zelaya  | 99988777767 | 19-01-1968 | Rua Souza Lima, 35, Curitiba, PR        | F      |        25 |      98765432168 |     4 |
| Jennifer | S          | Souza   | 98765432168 | 20-06-1941 | Av. Arthur de Lima, 54, Santo Andr√©, SP | F      |        43 |      88866555576 |     4 |
| Joice    | A          | Leite   | 45345345376 | 31-07-1972 | Av. Lucas Obes, 74, S√£o Paulo, SP       | F      |        25 |      33344555587 |     5 |

## FUNCNOMES

| Pnome    | Unome   |         Cpf |
|----------|---------|-------------|
| Alice    | Zelaya  | 99988777767 |
| Jennifer | Souza   | 98765432168 |
| Joice    | Leite   | 45345345376 |

## FUNC\_DEPENDENTES

| Pnome    | Unome   |         Cpf |        Fcpf | Nome_dependente   | Sexo   | Datanasc   | . . .   |
|----------|---------|-------------|-------------|-------------------|--------|------------|---------|
| Alice    | Zelaya  | 99988777767 | 33344555587 | Alicia            | F      | 05-04-1986 | . . .   |
| Alice    | Zelaya  | 99988777767 | 33344555587 | Tiago             | M      | 25-10-1983 | . . .   |
| Alice    | Zelaya  | 99988777767 | 33344555587 | Janaina           | F      | 03-05-1958 | . . .   |
| Alice    | Zelaya  | 99988777767 | 98765432168 | Antonio           | M      | 28-02-1942 | . . .   |
| Alice    | Zelaya  | 99988777767 | 12345678966 | Michael           | M      | 04-01-1988 | . . .   |
| Alice    | Zelaya  | 99988777767 | 12345678966 | Alicia            | F      | 30-12-1988 | . . .   |
| Alice    | Zelaya  | 99988777767 | 12345678966 | Elizabeth         | F      | 05-05-1967 | . . .   |
| Jennifer | Souza   | 98765432168 | 33344555587 | Alicia            | F      | 05-04-1986 | . . .   |
| Jennifer | Souza   | 98765432168 | 33344555587 | Tiago             | M      | 25-10-1983 | . . .   |
| Jennifer | Souza   | 98765432168 | 33344555587 | Janaina           | F      | 03-05-1958 | . . .   |
| Jennifer | Souza   | 98765432168 | 98765432168 | Antonio           | M      | 28-02-1942 | . . .   |
| Jennifer | Souza   | 98765432168 | 12345678966 | Michael           | M      | 04-01-1988 | . . .   |
| Jennifer | Souza   | 98765432168 | 12345678966 | Alicia            | F      | 30-12-1988 | . . .   |
| Jennifer | Souza   | 98765432168 | 12345678966 | Elizabeth         | F      | 05-05-1967 | . . .   |
| Joice    | Leite   | 45345345376 | 33344555587 | Alicia            | F      | 05-04-1986 | . . .   |
| Joice    | Leite   | 45345345376 | 33344555587 | Tiago             | M      | 25-10-1983 | . . .   |
| Joice    | Leite   | 45345345376 | 33344555587 | Janaina           | F      | 03-05-1958 | . . .   |
| Joice    | Leite   | 45345345376 | 98765432168 | Antonio           | M      | 28-02-1942 | . . .   |
| Joice    | Leite   | 45345345376 | 12345678966 | Michael           | M      | 04-01-1988 | . . .   |
| Joice    | Leite   | 45345345376 | 12345678966 | Alicia            | F      | 30-12-1988 | . . .   |
| Joice    | Leite   | 45345345376 | 12345678966 | Elizabeth         | F      | 05-05-1967 | . . .   |

## DEPENDENTES\_RESULT

| Pnome    | Unome   |         Cpf |        Fcpf | Nome_dependente   | Sexo   | Datanasc   | . . .   |
|----------|---------|-------------|-------------|-------------------|--------|------------|---------|
| Jennifer | Souza   | 98765432168 | 98765432168 | Antonio           | M      | 28-02-1942 | . . .   |

## RESULTADO

| Pnome    | Unome   | Nome_dependente   |
|----------|---------|-------------------|
| Jennifer | Souza   | Antonio           |

## Figura 6.5

A opera√ß√£o Produto Cartesiano (Produto Cruzado).

lizada para combinar tuplas relacionadas de duas rela√ß√µes, uma opera√ß√£o especial, chamada JUN√á√ÉO , foi criada para especificar essa sequ√™ncia como uma √∫nica opera√ß√£o. Discutimos a opera√ß√£o JUN√á√ÉO em seguida.

Em  SQL,  o PRODUTO  CARTESIANO pode  ser realizado usando a op√ß√£o CROSS JOIN nas  tabelas juntadas (ver Se√ß√£o 5.1.6). Como alternativa, se houver  duas  tabelas  na  cl√°usula WHERE e  n√£o  houver condi√ß√£o de jun√ß√£o correspondente na consulta, o resultado tamb√©m ser√° o PRODUTO CARTESIANO das duas tabelas (ver C10 , na Se√ß√£o 4.3.3).

## 6.3 Opera√ß√µes relacionais bin√°rias: JUN√á√ÉO e DIVIS√ÉO

## 6.3.1 A opera√ß√£o JUN√á√ÉO

A opera√ß√£o JUN√á√ÉO , indicada por /triangleleft /triangleright , √© usada para  combinar tuplas  relacionadas de  duas  rela√ß√µes em uma √∫nica tupla 'maior'. Essa opera√ß√£o √© muito importante para qualquer banco de dados relacional com mais de uma rela√ß√£o √∫nica, porque nos permite  processar  relacionamentos  entre  as  rela√ß√µes.  Para ilustrar JUN√á√ÉO ,  suponha  que  queiramos  recuperar o nome do gerente de cada departamento. Para obter esse nome, precisamos combinar cada tupla de departamento com a tupla de funcion√°rio cujo valor de Cpf (Cadastro de Pessoa F√≠sica) combina com o valor de Cpf\_gerente na tupla de departamento. Fazemos isso usando a opera√ß√£o JUN√á√ÉO e depois projetando o resultado nos atributos necess√°rios, da seguinte forma:

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

A primeira opera√ß√£o √© ilustrada na Figura 6.6. Observe que o Cpf\_gerente √©  uma  chave  estrangeira da rela√ß√£o DEPARTAMENTO que referencia Cpf , a chave prim√°ria da rela√ß√£o FUNCIONARIO . Essa restri√ß√£o de integridade referencial desempenha um papel importante para que haja tuplas combinando na rela√ß√£o referenciada FUNCIONARIO.

A opera√ß√£o JUN√á√ÉO pode ser especificada como uma  opera√ß√£o PRODUTO  CARTESIANO seguida  por uma opera√ß√£o SELE√á√ÉO .  Por√©m, a JUN√á√ÉO √©  muito  importante porque √© usada muito frequentemente quando se especifica consultas de banco de dados. Considere o exemplo anterior, ilustrando PRODUTO CARTESIANO , que incluiu a seguinte sequ√™ncia de opera√ß√µes:

```
FUNC_DEPENDENTES ‚Üê FUNCNOMES √ó DEPENDENTE DEPENDENTES_PARTIC ‚Üê ùõî Cpf=Fcpf (FUNC_ DEPENDENTES)
```

Essas duas opera√ß√µes podem ser substitu√≠das por uma √∫nica opera√ß√£o JUN√á√ÉO da seguinte forma:

<!-- formula-not-decoded -->

A forma geral de uma opera√ß√£o JUN√á√ÉO sobre duas rela√ß√µes 5 R A ( 1 , A 2 , ..., A n ) e S B ( 1 , B 2 , ..., B m ) √©

<!-- formula-not-decoded -->

O resultado da JUN√á√ÉO √© uma rela√ß√£o Q com n + m atributos Q A ( 1 , A 2 , ..., A n , B 1 , B 2 , ... , B m ) nessa ordem, Q tem uma tupla para cada combina√ß√£o de tuplas - uma de R e uma de S -sempre que a combina√ß√£o satisfaz a condi√ß√£o de jun√ß√£o . Essa √© a principal diferen√ßa entre PRODUTO CARTESIANO e JUN√á√ÉO . Em JUN√á√ÉO , apenas combina√ß√µes de tuplas que satisfa√ßam a condi√ß√£o de jun√ß√£o aparecem no resultado, enquanto no PRODUTO CARTESIANO todas as combina√ß√µes de tuplas s√£o inclu√≠das no resultado. A condi√ß√£o de jun√ß√£o √© especificada sobre atributos das duas rela√ß√µes R e S e √© avaliada para cada  combina√ß√£o  de  tuplas.  Cada  combina√ß√£o  de tupla para a qual a condi√ß√£o de jun√ß√£o √© avaliada como TRUE √© inclu√≠da na rela√ß√£o resultante Q como uma √∫nica tupla combinada .

Uma condi√ß√£o de jun√ß√£o geral tem a forma

<!-- formula-not-decoded -->

## DEP\_GER

| Dnome         |   Dnumero |   Cpf_gerente | . . .   | Pnome    | Minicial   | Unome   |         Cpf | . . .   |
|---------------|-----------|---------------|---------|----------|------------|---------|-------------|---------|
| Pesquisa      |         5 |   33344555587 | . . .   | Fernando | T          | Wong    | 33344555587 | . . .   |
| Administra√ß√£o |         4 |   98765432168 | . . .   | Jennifer | S          | Souza   | 98765432168 | . . .   |
| Matriz        |         1 |   88866555576 | . . .   | Jorge    | E          | Brito   | 88866555576 | . . .   |

Figura 6.6

Resultado da opera√ß√£o JUN√á√ÉO em DEP\_GER ‚Üê DEPARTAMENTO /triangleleft /triangleright Cpf\_gerente=Cpf FUNCIONARIO.

5 Novamente, observe que R e S podem ser quaisquer rela√ß√µes que resultam de express√µes da √°lgebra relacional gerais.

onde cada &lt;condi√ß√£o&gt; tem a forma A i ùõâ B t , A i √© um atributo de R B j , √©  um atributo de S , A i e B j t√™m o mesmo dom√≠nio, e ùõâ (teta) √© um dos operadores de compara√ß√£o { =, &lt;, ‚â§, &gt;, ‚â•, ‚â† }. Uma opera√ß√£o JUN√á√ÉO com essa condi√ß√£o de jun√ß√£o geral √© chamada de JUN√á√ÉO THETA .  As  tuplas  cujos  atributos  de jun√ß√£o s√£o NULL ou dos quais a condi√ß√£o de jun√ß√£o √© FALSE n√£o aparecem no resultado. Nesse sentido, a  opera√ß√£o JUN√á√ÉO n√£o necessariamente  preserva toda a informa√ß√£o das rela√ß√µes participantes, pois as tuplas  que  n√£o  s√£o  combinadas  com  as  correspondentes na outra rela√ß√£o n√£o aparecem no resultado.

## 6.3.2 Varia√ß√µes de JUN√á√ÉO: EQUIJUN√á√ÉO e JUN√á√ÉO NATURAL

O uso mais comum de JUN√á√ÉO envolve condi√ß√µes de jun√ß√£o apenas em compara√ß√µes de igualdade. Esse tipo de JUN√á√ÉO ,  em que o √∫nico operador de compara√ß√£o usado √© = , √© chamado de EQUIJUN√á√ÉO . Os  dois  exemplos  anteriores  foram EQUIJUN√á√ÉO . Observe que, no resultado de um EQUIJUN√á√ÉO , sempre temos um ou mais pares de atributos que possuem valores id√™nticos em cada tupla. Por exemplo, na Figura 6.6, os valores dos atributos Cpf\_gerente e Cpf s√£o id√™nticos em cada tupla de DEP\_GER (o resultado de EQUIJUN√á√ÉO ), porque a condi√ß√£o de jun√ß√£o de igualdade especificada sobre esses dois atributos requer que os valores sejam id√™nticos em cada tupla no resultado. Como um de cada par de atributos com valores id√™nticos √© desnecess√°rio, uma nova opera√ß√£o, chamada JUN√á√ÉO NATURAL - indicada por ÔÇ´ - foi criada para eliminar o segundo atributo (desnecess√°rio) na condi√ß√£o  de EQUIJUN√á√ÉO . 6 A  defini√ß√£o  padr√£o  de JUN√á√ÉO NATURAL requer  que  os  dois  atributos  de jun√ß√£o (ou cada par de atributos de jun√ß√£o) tenham o mesmo nome nas duas rela√ß√µes. Se isso n√£o acontecer, uma opera√ß√£o de renomea√ß√£o √© aplicada primeiro.

Suponha  que  queiramos  combinar  cada  tupla PROJETO com a tupla DEPARTAMENTO que controla o  projeto.  No  exemplo  a  seguir,  primeiro  renomeamos o atributo Dnumero de DEPARTAMENTO para Dnum - de modo que ele tenha o mesmo nome do atributo Dnum em PROJETO - e depois aplicamos a JUN√á√ÉO NATURAL :

<!-- formula-not-decoded -->

A mesma consulta pode ser feita em duas etapas criando  uma  tabela  intermedi√°ria DEP da  seguinte forma:

```
DEP ‚Üê ùõí (Dnome, Dnum, Cpf_gerente, Data_inicio_gerente) (DEPARTAMENTO) PROJETO_DEP ‚Üê PROJETO   DEP ÔÇ´
```

O atributo Dnum √© chamado de atributo de jun√ß√£o para a opera√ß√£o JUN√á√ÉO NATURAL , pois √© o √∫nico atributo com o mesmo nome nas duas rela√ß√µes. A rela√ß√£o resultante √© ilustrada na Figura 6.7(a). Na rela√ß√£o PROJETO\_DEP , cada tupla combina uma tupla PROJETO com a tupla DEPARTAMENTO para o departamento que controla o projeto, mas somente um valor de atributo de jun√ß√£o √© mantido.

Se os atributos sobre os quais a jun√ß√£o natural √© especificada j√° tiverem os mesmos nomes nas duas rela√ß√µes , a renomea√ß√£o n√£o √© necess√°ria. Por exemplo,  para  aplicar  uma  jun√ß√£o  natural  aos  atributos Dnumero de DEPARTAMENTO   LOCALIZACAO\_DEP e , basta escrever

<!-- formula-not-decoded -->

A rela√ß√£o resultante est√° na Figura 6.7(b), que combina cada departamento com sua localiza√ß√£o e tem uma tupla para cada local. Em geral, a condi√ß√£o de jun√ß√£o para JUN√á√ÉO NATURAL √© constru√≠da igualando cada par de atributos de jun√ß√£o que tem o mesmo nome nas duas rela√ß√µes e combinando essas condi√ß√µes com AND . Pode haver uma lista de atributos de jun√ß√£o de cada rela√ß√£o, e cada par correspondente deve ter o mesmo nome.

Uma defini√ß√£o  mais  geral,  por√©m  n√£o  padr√£o, para JUN√á√ÉO NATURAL √©

<!-- formula-not-decoded -->

Nesse caso, &lt;lista1&gt; especifica uma lista de i atributos de R , e &lt;lista2&gt; especifica uma lista de   atribui tos de S . As listas s√£o usadas para formar condi√ß√µes de compara√ß√£o de igualdade entre pares de atributos correspondentes,  e  as  condi√ß√µes  passam  ent√£o  por um AND . Somente a lista correspondente aos atributos da primeira rela√ß√£o R - &lt;lista1&gt; - √© mantida no resultado Q .

Observe que, se nenhuma combina√ß√£o de tuplas satisfizer  a  condi√ß√£o  de  jun√ß√£o,  o  resultado  de  uma JUN√á√ÉO √© uma rela√ß√£o vazia com zero tuplas. Em geral, se R tiver n R tuplas e S tiver n S tuplas, o resultado de uma opera√ß√£o JUN√á√ÉO R /triangleleft /triangleright &lt;condi√ß√£o jun√ß√£o&gt; S ter√° entre zero e n R ÔÇ´ n S tuplas. O tamanho esperado do resultado da jun√ß√£o dividido pelo tamanho m√°ximo n R ÔÇ´ n S leva  a  uma  raz√£o  chamada seletividade  de  jun√ß√£o , que √© uma propriedade de cada condi√ß√£o de jun√ß√£o.

Observe  que  { Aluno, Disciplina } √©  uma  chave candidata  para  essa  rela√ß√£o  e  que  as  depend√™ncias mostradas seguem o padr√£o da Figura 15.13(b), com Aluno como A , Disciplina como B e Professor como C . Logo, essa rela√ß√£o est√° na 3FN, mas n√£o na FNBC. A decomposi√ß√£o desse esquema de rela√ß√£o em dois esquemas n√£o √© direta, pois ele pode ser decomposto em um dos tr√™s pares poss√≠veis a seguir:

- 1. { Aluno , Professor } e { Aluno , Disciplina }.
- 2. { Disciplina , Professor } e { Disciplina , Aluno }.
- 3. { Professor , Disciplina } e { Professor , Aluno }.

Todas as tr√™s decomposi√ß√µes perdem a depend√™ncia funcional DF1. A decomposi√ß√£o desej√°vel dessas que s√£o mostradas √© a 3 porque isso n√£o gerar√° tuplas falsas ap√≥s uma jun√ß√£o.

Um teste para determinar se uma decomposi√ß√£o √© n√£o aditiva (ou sem perdas) ser√° discutido na Se√ß√£o 16.2.4, sob a Propriedade NJB. Em geral, uma rela√ß√£o n√£o na FNBC deve ser decomposta de modo a atender a esta propriedade.

Garantimos que atendemos a essa propriedade, pois a decomposi√ß√£o n√£o aditiva √© essencial durante a normaliza√ß√£o. Possivelmente, podemos ter de abrir m√£o da preserva√ß√£o de todas as depend√™ncias funcionais nas rela√ß√µes decompostas, como acontece neste exemplo. O algoritmo 16.5 faz isso e poderia ser usado para dar a decomposi√ß√£o 3 para ENSINA , que produz duas rela√ß√µes em FNBC como:

(Professor, Disciplina) e (Professor, Aluno)

Observe que, se designarmos ( Aluno, Professor ) como chave prim√°ria da rela√ß√£o ENSINA , a DF Professor ‚Üí Disciplina causa  uma  depend√™ncia  parcial (n√£o  totalmente  funcional)  de Disciplina sobre  uma parte dessa chave. Essa DF pode ser removida como uma  parte  da  segunda  normaliza√ß√£o,  produzindo exatamente  as  mesmas  duas  rela√ß√µes  no  resultado. Esse √© um exemplo de caso em que podemos atingir o mesmo projeto FNBC definitivo por meio de caminhos de normaliza√ß√£o alternativos.

## 15.6 Depend√™ncia multivalorada e quarta forma normal

At√© aqui, discutimos o conceito de depend√™ncia funcional, que de longe √© o tipo mais importante de depend√™ncia na teoria de projeto de banco de dados relacional,  e  formas  normais  baseadas  nas  depend√™ncias  funcionais.  Entretanto,  em  muitos  casos,  as rela√ß√µes possuem restri√ß√µes que n√£o podem ser especificadas como depend√™ncias funcionais. Nesta se√ß√£o, discutimos o conceito de depend√™ncia multivalorada ( MVD  -  Multivalued  Dependency )  e  definimos  a quarta forma normal , que se baseia nessa depend√™ncia. Uma discuss√£o mais formal das MVDs e suas propriedades ficar√° para o Cap√≠tulo 16. As depend√™ncias multivaloradas s√£o uma consequ√™ncia da primeira forma normal (1FN) (ver Se√ß√£o 15.3.4), que desaprova um atributo em uma tupla para ter um conjunto de valores , e o processo correspondente de convers√£o de uma rela√ß√£o n√£o normalizada para 1FN. Se tivermos dois ou mais atributos independentes multivalorados no mesmo esquema de rela√ß√£o, obtemos o problema de ter que repetir cada valor de um dos atributos com cada valor do outro atributo, a fim de manter o estado da rela√ß√£o coerente e as independ√™ncias entre os atributos, envolvidos. Essa restri√ß√£o √© especificada por uma depend√™ncia multivalorada.

Por exemplo, considere a rela√ß√£o FUNC mostrada na Figura 15.15(a). Uma tupla nessa rela√ß√£o FUNC representa o fato de que um funcion√°rio cujo nome √© Fnome trabalha no projeto cujo nome √© Projnome e tem um dependente cujo nome √© Nome\_dependente. Um funcion√°rio pode atuar em v√°rios projetos e ter v√°rios dependentes, e seus projetos e dependentes s√£o independentes um do outro. 13  Para manter o estado da rela√ß√£o coerente, e para evitar quaisquer relacionamentos falsos entre os dois atributos independentes, devemos ter uma tupla separada para representar cada combina√ß√£o de um dependente e de um projeto de um funcion√°rio. Essa restri√ß√£o √© especificada como uma depend√™ncia multivalorada na rela√ß√£o FUNC , que definimos nesta se√ß√£o. Informalmente, sempre que dois relacionamentos  1:N independentes A:B e A:C s√£o misturados na mesma rela√ß√£o, R A B C ( , , ), uma MVD pode surgir. 14

## 15.6.1 Defini√ß√£o formal de depend√™ncia multivalorada

Defini√ß√£o . Uma depend√™ncia multivalorada X ‚Üí ‚Üí Y especificada sobre o esquema de rela√ß√£o R , onde X e Y s√£o  subconjuntos de R ,  determina  a  seguinte  restri√ß√£o  sobre  qualquer  estado  de  rela√ß√£o   de r R : Se duas tuplas t 1 e t 2 existirem em r tais que t 1 [X] = t 2 [X], ent√£o duas tuplas t 3 e t 4 tamb√©m dever√£o existir em r com  as  seguintes propriedades, 15  nas quais usamos Z para indicar ( R -( X ‚à™ Y)): 16

13 Em um diagrama ER, cada um seria representado como um atributo multivalorado ou como um tipo de entidade fraca (ver Cap√≠tulo 7).

14 Essa MVD √© indicada como A ‚Üí ‚Üí B|C.

15 As tuplas t 1 , t 2 , t 3 e t 4 n√£o s√£o necessariamente distintas.

16 Z √© uma forma abreviada para os atributos em R ap√≥s os atributos em ( X ‚à™ Y ) serem removidos de R.

(a)

## FUNC

| Fnome   | Projnome   | Dnome   |
|---------|------------|---------|
| Silva   | X          | Jo√£o    |
| Silva   | Y          | Ana     |
| Silva   | X          | Ana     |
| Silva   | Y          | Jo√£o    |

## (b)

## FUNC\_PROJETOS

## FUNC\_DEPENDETES

| Fnome   | Projnome   |
|---------|------------|
| Silva   | X          |
| Silva   | Y          |

| Fnome   | Nome_dependente   |
|---------|-------------------|
| Silva   | Jo√£o              |
| Silva   | Ana               |

## (d)

## R1

## R2

## FORNECE

| Nome_fornece   | Nome_peca   | Nome_proj   |
|----------------|-------------|-------------|
| Silva          | Peneira     | ProjX       |
| Silva          | Porca       | ProjY       |
| Adam           | Peneira     | ProjY       |
| Walter         | Porca       | ProjZ       |
| Adam           | Prego       | ProjX       |
| Adam           | Peneira     | ProjX       |
| Silva          | Peneira     | ProjY       |

## R3

| Nome_fornece   | Nome_peca   |
|----------------|-------------|
| Silva          | Peneira     |
| Silva          | Porca       |
| Adam           | Peneira     |
| Walter         | Porca       |
| Adam           | Prego       |

| Nome_fornece   | OR_proj   |
|----------------|-----------|
| Silva          | ProjX     |
| Silva          | ProjY     |
| Adam           | ProjY     |
| Walter         | ProjZ     |
| Adam           | ProjX     |

| Nome_peca   | OR_proj   |
|-------------|-----------|
| Peneira     | ProjX     |
| Porca       | ProjY     |
| Peneira     | ProjY     |
| Porca       | ProjZ     |
| Prego       | ProjX     |

## Figura 15.15

Quarta e quinta formas normais. (a) A rela√ß√£o FUNC com duas MVDs: Fnome ‚Üí ‚Üí Projnome e Fnome ‚Üí ‚Üí Dnome. (b) Decompondo a rela√ß√£o FUNC em duas rela√ß√µes 4FN FUNC\_PROJETOS e FUNC\_DEPENDENTES. (c) A rela√ß√£o FORNECE sem MVDs est√° na 4FN, mas n√£o na 5FN se tiver a DJ( R 1 , R 2 , R 3 ). (d) Decompondo a rela√ß√£o FORNECE nas rela√ß√µes 5FN R 1 , R 2 , R 3 .

- ¬Ñ t 3 [ X ] = t 4 [ X ] = t 1 [ X ] = t 2 [ X ].
- ¬Ñ t 3 [ Y ] = t 1 [ Y ] e t 4 [ Y ] = t 2 [ Y ].
- ¬Ñ t 3 [ Z ] = t 2 [ Z ] e t 4 [ Z ] = t 1 [ Z ].

Sempre que X ‚Üí ‚Üí Y se mantiver, diremos que X multidetermina Y .  Devido  √†  simetria  na  defini√ß√£o, toda vez que X ‚Üí ‚Üí Y for  mantido  em R ,  o  mesmo acontecer√° com X ‚Üí ‚Üí Z . Logo, X ‚Üí ‚Üí Y implica X ‚Üí ‚Üí Z , e, portanto, √†s vezes √© escrito como X ‚Üí ‚Üí YZ | .

Uma MVD X ‚Üí ‚Üí Y em R √© chamada de MVD trivial se (a) Y for um subconjunto de X , ou (b) X ‚à™ Y = R . Por exemplo, a rela√ß√£o FUNC\_PROJETOS da Figura 15.15(b) tem a MVD trivial Fnome ‚Üí ‚Üí Projnome. Uma MVD que n√£o satisfaz nem (a) nem (b) √© chamada de MVD n√£o trivial . Uma MVD trivial ser√° mantida em qualquer estado de rela√ß√£o r de R . Ela √© chamada dessa maneira porque n√£o especifica qualquer restri√ß√£o significativa sobre R .

os valores 'X' e 'Y' de Projnome s√£o repetidos com cada  valor  de Dnome (ou,  por  simetria,  os  valores 'Jo√£o'  e  'Ana'  de Nome\_dependente s√£o  repetidos com cada valor de Projnome) . Essa redund√¢ncia √© claramente indesej√°vel. Contudo, o esquema FUNC est√° na FNBC porque nenhuma depend√™ncia funcional se mant√©m em FUNC. Portanto, precisamos definir uma quarta forma normal que √© mais forte que a FNBC e desaprova esquemas de rela√ß√£o como FUNC. Observe que as rela√ß√µes com MVDs n√£o triviais tendem a ser rela√ß√µes de todas as chaves - ou seja, sua chave s√£o todos os seus atributos juntos. Al√©m do mais, √© raro que essas rela√ß√µes de todas as chaves com uma ocorr√™ncia combinat√≥ria de valores repetidos sejam projetadas na pr√°tica. Por√©m, o reconhecimento das MVDs como uma depend√™ncia problem√°tica em potencial √© essencial no projeto relacional.

Se tivermos uma MVD n√£o trivial em uma rela√ß√£o, talvez precisemos repetir valores redundantemente  nas  tuplas.  Na rela√ß√£o FUNC da Figura 15.15(a),

Agora, apresentamos a defini√ß√£o da quarta forma normal  4FN ( ),  que √© violada quando uma rela√ß√£o tem depend√™ncias multivaloradas indesej√°veis e, portanto, pode ser usada para identificar e decompor essas rela√ß√µes.

(c)

Defini√ß√£o. Um esquema  de  rela√ß√£o R est√°  na 4FN com rela√ß√£o a um conjunto de depend√™ncias F (que inclui depend√™ncias funcionais e depend√™ncias  multivaloradas)  se,  para  cada  depend√™ncia multivalorada n√£o trivial X ‚Üí ‚Üí Y em F + , 17 X √© uma superchave para R .

Podemos declarar os seguintes pontos:

- ¬Ñ Uma rela√ß√£o de todas as chaves est√° sempre na FNBC, pois n√£o tem DFs.
- ¬Ñ Uma rela√ß√£o de todas as chaves, como a rela√ß√£o FUNC da Figura 15.15(a), que n√£o tem DFs mas tem a MVD Fnome ‚Üí ‚Üí Projnome | Dnome, n√£o est√° na 4FN.
- ¬Ñ Uma rela√ß√£o que n√£o est√° na 4FN devido a uma MVD n√£o trivial precisa ser decomposta para convert√™-la em um conjunto de rela√ß√µes na 4FN.
- ¬Ñ A decomposi√ß√£o remove a redund√¢ncia causada pela MVD.

O processo de normaliza√ß√£o de uma rela√ß√£o envolvendo MVDs n√£o triviais, que n√£o est√° na 4FN, consiste em decomp√¥-la de modo que cada MVD seja representada por uma rela√ß√£o separada, onde se torna uma MVD trivial. Considere a rela√ß√£o FUNC da Figura 15.15(a). FUNC n√£o est√° na 4FN porque, nas MVDs n√£o triviais, Fnome ‚Üí ‚Üí Projnome e Fnome ‚Üí ‚Üí Nome\_ dependente , e Fnome n√£o √© uma superchave de FUNC . Decompomos FUNC em FUNC\_PROJETOS e FUNC\_ DEPENDENTES , mostrados na Figura 15.15(b). Tanto FUNC\_PROJETOS quanto FUNC\_DEPENDENTES est√£o na 4FN, porque as MVDs Fnome ‚Üí ‚Üí Projnome em FUNC\_PROJETOS e Fnome ‚Üí ‚Üí Nome\_dependentes em FUNC\_DEPENDENTES s√£o MVDs triviais. Nenhuma outra MVD n√£o trivial √© mantida em FUNC\_PRO-JETOS ou FUNC\_DEPENDENTES . Tamb√©m, nenhuma DF √© mantida nesses esquemas de rela√ß√£o.

## 15.7 Depend√™ncias de jun√ß√£o e quinta forma normal

Em nossa discuss√£o at√© aqui, indicamos as depend√™ncias  funcionais  problem√°ticas  e  mostramos como elas foram eliminadas por um processo de decomposi√ß√£o bin√°ria repetido para remov√™-las durante o processo de normaliza√ß√£o, para obter 1FN, 2FN, 3FN e FNBC. Essas decomposi√ß√µes  bin√°rias  precisam obedecer √† propriedade NJB da Se√ß√£o 16.2.4, que referenciamos ao discutir a decomposi√ß√£o para alcan√ßar a FNBC. Obter a 4FN normalmente tam- b√©m envolve eliminar as MVDs por decomposi√ß√µes bin√°rias repetidas. Entretanto, em alguns casos, pode n√£o haver decomposi√ß√£o de jun√ß√£o n√£o aditiva de R em dois esquemas de rela√ß√£o, mas pode haver uma decomposi√ß√£o de jun√ß√£o n√£o aditiva em mais de dois esquemas  de  rela√ß√£o.  Al√©m  disso,  pode  n√£o  haver depend√™ncia funcional em R que viole qualquer forma normal at√© a FNBC, e tamb√©m pode n√£o haver MVD n√£o trivial presente em R que viole a 4FN. Ent√£o, lan√ßamos m√£o de outra depend√™ncia, chamada depend√™ncia de jun√ß√£o e, se estiver presente, executamos  uma decomposi√ß√£o  multivias para  a  quinta forma normal (5FN). √â importante observar que tal depend√™ncia √© uma restri√ß√£o sem√¢ntica bastante peculiar, que √© muito dif√≠cil de detectar na pr√°tica. Portanto, a normaliza√ß√£o para a 5FN raramente √© feita nestes termos.

Defini√ß√£o. Uma depend√™ncia  de  jun√ß√£o ( DJ ), indicada por DJ( R 1 , R 2 , ..., R n ), especificada no esquema de rela√ß√£o R , determina uma restri√ß√£o sobre os estados r de R .  A restri√ß√£o indica que cada estado v√°lido r de R deve ter uma decomposi√ß√£o de jun√ß√£o n√£o aditiva para R 1 , R 2 , ..., R n . Logo, para cada   desse tipo, temos r

<!-- formula-not-decoded -->

Observe que uma MVD √© um caso especial de DJ em que n = 2. Ou seja, uma DJ indicada como DJ( R 1 , R 2 )  implica  uma MVD ( R 1 ‚à© R 2 ) ‚Üí ‚Üí ( R 1 -R 2 ) (ou, por simetria, ( R 1 ‚à© R 2 ) ‚Üí ‚Üí ( R 2 -R 1 )). Uma depend√™ncia de jun√ß√£o DJ( R 1 , R 2 ,  ..., R n ),  especificada sobre o esquema de rela√ß√£o R , √© uma DJ trivial se um dos esquemas de rela√ß√£o R i em DJ( R 1 , R 2 , ..., R n ) √©  igual  a R .  Tal  depend√™ncia  √©  chamada  de  trivial porque tem a propriedade de jun√ß√£o n√£o aditiva para qualquer estado de rela√ß√£o r de R e,  portanto, n√£o especifica qualquer restri√ß√£o sobre R .  Agora, podemos definir a quinta forma normal, que tamb√©m √© chamada forma normal proje√ß√£o-jun√ß√£o .

Defini√ß√£o. Um  esquema  de  rela√ß√£o R est√°  na quinta forma normal  5FN ( ) (ou forma normal proje√ß√£o-jun√ß√£o -FNPJ ) com rela√ß√£o a um conjunto F de depend√™ncias funcionais, multivaloradas e de jun√ß√£o se, para cada depend√™ncia de jun√ß√£o n√£o trivial DJ( R 1 , R 2 , ..., R n ) em F + (ou seja, implicada por F ), 18 cada R i √© uma superchave de R .

Para ver um exemplo de DJ, considere mais uma vez a rela√ß√£o de todas as chaves FORNECE da Figura 15.15(c). Suponha que a seguinte restri√ß√£o adicional sempre seja mantida: toda vez que um fornecedor f

17 F + refere-se √† cobertura das depend√™ncias funcionais F , ou todas as depend√™ncias que s√£o implicadas por F . Isso ser√° definido na Se√ß√£o 16.1.

18 Novamente, F + refere-se √† cobertura de depend√™ncias funcionais F , ou todas as depend√™ncias que s√£o implicadas por F . Isso ser√° definido na Se√ß√£o 16.1.

fornece a pe√ßa p e , um projeto   usa a pe√ßa j p e , o fornecedor   fornece f pelo menos uma pe√ßa para o projeto  , j ent√£o o fornecedor f tamb√©m estar√° fornecendo a pe√ßa p ao projeto  . Essa restri√ß√£o pode ser declaj rada de outras maneiras e especifica uma depend√™ncia de jun√ß√£o DJ( R 1 , R  R 2 , 3 ) entre as tr√™s proje√ß√µes R 1 ( Nome\_fornece , Nome\_peca ), R 2 ( Nome\_fornece , Nome\_proj ) e R 3 ( Nome\_peca , Nome\_proj ) de FORNECE .  Se  essa  restri√ß√£o  for  mantida,  as  tuplas  abaixo da linha tracejada na Figura 15.15(c) devem existir em algum estado v√°lido da rela√ß√£o FORNECE, que tamb√©m cont√©m as tuplas acima da linha tracejada. A Figura 15.15(d) mostra como a rela√ß√£o FORNECE com a depend√™ncia de jun√ß√£o √© decomposta em tr√™s rela√ß√µes R 1 , R 2 e R 3 que est√£o, cada uma, na 5FN. Observe  que  a  aplica√ß√£o  de  uma  jun√ß√£o  natural  a duas quaisquer dessas rela√ß√µes produz tuplas falsas , mas a aplica√ß√£o de uma jun√ß√£o natural a todas as tr√™s  juntas n√£o as produz. O leitor dever√° verificar isso no exemplo de rela√ß√£o da Figura 15.15(c) e suas proje√ß√µes na Figura 15.15(d). Isso porque somente a DJ existe, mas nenhuma MVD √© especificada. Observe, tamb√©m, que a DJ( R 1 , R 2 , R 3 ) √© especificada em todos os estados de rela√ß√£o v√°lidos, n√£o apenas sobre aquele mostrado na Figura 15.15(c).

A descoberta de DJs em bancos de dados pr√°ticos com centenas de atributos √© quase imposs√≠vel. Isso s√≥ pode ser feito com um grande grau de intui√ß√£o sobre os dados da parte do projetista. Portanto, a pr√°tica atual do projeto de banco de dados n√£o presta muita aten√ß√£o a elas.

## Resumo

Neste  cap√≠tulo,  discutimos  v√°rias  armadilhas  no projeto de banco de dados relacional usando argumentos intuitivos. Identificamos informalmente algumas das medidas para indicar se um esquema de rela√ß√£o √© bom ou ruim , e fornecemos diretrizes informais para um bom projeto. Essas diretrizes s√£o baseadas na realiza√ß√£o de um projeto conceitual cuidadoso no modelo ER e EER, seguindo o procedimento de mapeamento do Cap√≠tulo 9 corretamente, para mapear entidades e relacionamentos em rela√ß√µes. A imposi√ß√£o apropriada dessas diretrizes e a falta de redund√¢ncia evitar√£o as anomalias de inser√ß√£o/ exclus√£o/atualiza√ß√£o, e a gera√ß√£o de dados falsos. Recomendamos limitar os valores NULL , que causam problemas durante opera√ß√µes SELE√á√ÉO, JUN√á√ÉO e de agrega√ß√£o. Depois, apresentamos alguns conceitos formais que nos permitem realizar o projeto relacional de uma maneira de cima para baixo ao analisar as rela√ß√µes individualmente. Definimos esse processo de projeto pela an√°lise e decomposi√ß√£o, introduzindo o processo de normaliza√ß√£o.

Definimos o conceito de depend√™ncia funcional, que √© a ferramenta b√°sica para analisar esquemas relacionais, e  discutimos  algumas  de  suas  propriedades.  As  depend√™ncias  funcionais  especificam  as  restri√ß√µes  sem√¢nticas entre os atributos de um esquema de rela√ß√£o. Em seguida, descrevemos o processo de normaliza√ß√£o para obter bons projetos ao testar rela√ß√µes para tipos indesej√°veis de  depend√™ncias funcionais problem√°ticas .  Oferecemos um tratamento da normaliza√ß√£o sucessiva com base em uma chave prim√°ria predefinida em cada rela√ß√£o, e depois  relaxamos  esse  requisito  e  fornecemos  defini√ß√µes mais gerais da segunda forma normal (2FN) e terceira forma normal (3FN), que levam em conta todas as chaves candidatas de uma rela√ß√£o. Apresentamos exemplos para ilustrar como, usando a defini√ß√£o geral da 3FN, determinada rela√ß√£o pode ser analisada e decomposta para eventualmente gerar um conjunto de rela√ß√µes na 3FN.

Apresentamos a Forma Normal Boyce-Codd (FNBC) e discutimos como ela √© uma forma mais forte da 3FN. Tamb√©m ilustramos como a decomposi√ß√£o de uma rela√ß√£o n√£o FNBC deve ser feita considerando o requisito de decomposi√ß√£o n√£o aditiva. Ent√£o, introduzimos a quarta forma normal com base em depend√™ncias multivaloradas, que normalmente surgem devido √† mistura de atributos multivalorados independentes em uma √∫nica rela√ß√£o. Por fim, apresentamos a quinta forma normal, que √© baseada na depend√™ncia de jun√ß√£o, e que identifica uma restri√ß√£o peculiar que faz que uma rela√ß√£o seja decomposta em v√°rios componentes, de modo que eles sempre produzam a rela√ß√£o original de volta, ap√≥s uma jun√ß√£o. Na pr√°tica, a maioria dos projetos comerciais seguiu as formas normais at√© a FNBC. A necessidade de decomposi√ß√£o para a 5FN raramente surge na pr√°tica, e as depend√™ncias de jun√ß√£o s√£o dif√≠ceis de detectar para a maioria das situa√ß√µes pr√°ticas, tornando a 5FN de valor mais te√≥rico.

O Cap√≠tulo 16 apresentar√° a s√≠ntese e tamb√©m a decomposi√ß√£o de algoritmos para o projeto de banco de dados  relacional  baseado  em  depend√™ncias  funcionais. Em  rela√ß√£o  √†  decomposi√ß√£o,  discutimos  os  conceitos de jun√ß√£o n√£o aditiva (ou sem perdas ) e preserva√ß√£o de depend√™ncia ,  que s√£o impostos por alguns desses algoritmos. Outros t√≥picos no Cap√≠tulo 16 incluem um tratamento mais detalhado das depend√™ncias funcionais e multivaloradas, al√©m de outros tipos de depend√™ncias.

## Perguntas de revis√£o

- 15.1. Discuta a sem√¢ntica de atributo como uma medida informal de boas pr√°ticas para um esquema de rela√ß√£o.
- 15.2. Discuta as anomalias de inser√ß√£o, exclus√£o e modifica√ß√£o. Por que elas s√£o consideradas ruins? Ilustre com exemplos.
- 15.3. Por que os NULL s em uma rela√ß√£o devem ser evitados ao m√°ximo poss√≠vel? Discuta o problema das tuplas falsas e como podemos impedi-lo.
- 15.4. Indique as diretrizes informais para o projeto de esquema de rela√ß√£o que discutimos. Ilustre como a viola√ß√£o dessas diretrizes pode ser prejudicial.
- 15.5. O que √© uma depend√™ncia funcional? Quais s√£o as poss√≠veis fontes da informa√ß√£o que definem as depend√™ncias funcionais que se mant√™m entre os atributos de um esquema de rela√ß√£o?

- 15.6. Por que n√£o podemos deduzir uma depend√™ncia funcional automaticamente com base em um estado de rela√ß√£o em particular?
- 15.7. A que se refere o termo rela√ß√£o n√£o normalizada ? Como as formas normais se desenvolveram historicamente  desde  a  primeira  forma  normal at√© a forma normal de Boyce-Codd?
- 15.8. Defina  a  primeira,  segunda  e  terceira  formas normais quando somente chaves prim√°rias s√£o consideradas. Como as defini√ß√µes gerais da 2FN e 3FN, que consideram todas as chaves de uma rela√ß√£o, diferem daquelas que consideram apenas chaves prim√°rias?
- 15.9. Que depend√™ncias indesej√°veis s√£o evitadas quando uma rela√ß√£o est√° na 2FN?
- 15.10. Que depend√™ncias indesej√°veis s√£o evitadas quando uma rela√ß√£o est√° na 3FN?
- 15.11. De que maneira as defini√ß√µes  generalizadas  da 2FN e 3FN estendem as defini√ß√µes al√©m das chaves prim√°rias?
- 15.12. Defina  a  forma  normal  de  Boyce-Codd.  Como ela  difere  da  3FN?  Por  que  ela  √©  considerada uma forma mais forte de 3FN?
- 15.13. O que √© depend√™ncia multivalorada? Quando ela surge?
- 15.14. Uma rela√ß√£o com duas ou mais colunas sempre tem uma MVD? Mostre com um exemplo.
- 15.15. Defina  a  quarta  forma  normal.  Quando  ela  √© violada? Quando ela costuma ser aplicada?
- 15.16. Defina a depend√™ncia de jun√ß√£o e a quinta forma normal.
- 15.17. Por que a 5FN tamb√©m √© chamada de forma normal proje√ß√£o-jun√ß√£o (FNPJ)?
- 15.18. Por que os projetos de banco de dados pr√°ticos normalmente visam a FNBC, e n√£o visam √†s formas normais mais altas?

## Exerc√≠cios

- 15.19. Suponha  que  tenhamos  os  seguintes  requisitos para um banco de dados de universidade, que √© usado para registrar os hist√≥ricos dos alunos:
- a. A universidade registra o nome de cada aluno ( Anome ),  o  n√∫mero do aluno ( Anum ),  o n√∫mero do Cadastro de Pessoa F√≠sica ( Cpf ), o  endere√ßo  moradia  ( Aendereco\_mora )  e  o n√∫mero  do  telefone  ( Atelefone\_mora ), endere√ßo  permanente  ( Aendereco\_fixo ) e  telefone  ( Atelefone\_fixo ),  data  de  nascimento ( Datanasc ), sexo ( Sexo ), tipo\_aluno ('calouro', 'veterano', ... , 'graduado'), departamento  principal  ( Dep\_princ ),  departamento  secund√°rio ( Dep\_sec ) (se houver) e programa de  t√≠tulo  ( Titulacao )  ('bacharel',  'mestrado', ...  ,  'doutorado').  Tanto Cpf quanto  o  n√∫mero do aluno possuem valores √∫nicos para cada um.
- b. Cada departamento √© descrito por um nome ( Dnome ),  c√≥digo  de  departamento  ( Dcodigo ),  n√∫mero  de  escrit√≥rio  ( Descritorio ),  telefone  de  escrit√≥rio  ( Dtelefone )  e  faculdade ( Dfaculdade ). Tanto o nome quanto o c√≥digo possuem  valores  √∫nicos  para  cada  departamento.
- c. Cada disciplina tem um nome ( Dnome ), descri√ß√£o ( Ddesc ), n√∫mero ( Dnum ), n√∫mero de horas semestrais ( Credito ), n√≠vel ( Nivel ) e departamento de oferta ( Num\_dep ). O n√∫mero da disciplina √© √∫nico para cada curso.
- d. Cada  turma  tem  um  professor  ( Unome ), semestre  ( Semestre ),  ano  ( Ano ),  disciplina ( Disciplina\_turma ) e n√∫mero de turma ( Num\_ turma ).  O  n√∫mero  de  turma  distingue  diferentes  turmas  da  mesma  disciplina  que  s√£o lecionadas  durante  o  mesmo  semestre/ano; seus valores s√£o 1, 2, 3, ..., at√© o n√∫mero total de turmas lecionadas durante cada semestre.
- e. Um  registro  de  nota  refere-se  a  um  aluno ( Cpf ), uma turma em particular e uma nota ( Nota ).

Crie um esquema de banco de dados relacional para essa aplica√ß√£o de banco de dados. Primeiro, mostre todas as depend√™ncias funcionais que devem ser mantidas entre os atributos. Depois, projete  esquemas  de  rela√ß√£o  para  o  banco  de dados  que  estejam,  cada  uma,  na  3FN  ou  na FNBC.  Especifique  os  principais  atributos  de cada rela√ß√£o. Observe quaisquer requisitos n√£o especificados e fa√ßa suposi√ß√µes apropriadas para tornar a especifica√ß√£o completa.

- 15.20. Que anomalias de atualiza√ß√£o ocorrem nas rela√ß√µes FUNC\_PROJ e FUNC\_DEP das figuras 15.3 e 15.4?
- 15.21. Em que forma normal est√° o esquema de rela√ß√£o LOTES da Figura 15.12(a) com rela√ß√£o √†s interpreta√ß√µes restritivas da forma normal que levam em conta apenas a chave prim√°ria ? Ela estaria na mesma forma normal se as defini√ß√µes gerais da forma normal fossem usadas?
- 15.22. Prove  que  qualquer  esquema  de  rela√ß√£o  com dois atributos est√° na FNBC.
- 15.23. Por que ocorrem tuplas falsas no resultado da jun√ß√£o  das  rela√ß√µes FUNC\_PROJ1 e FUNC\_ LOCAL da Figura 15.5 (resultado mostrado na Figura 15.6)?
- 15.24. Considere a rela√ß√£o universal R = { A B C D E , , , , , F , G H I J , , , } e o conjunto de depend√™ncias funcionais F = { { A B , } ‚Üí { C }, { A } ‚Üí { D E , }, { B } ‚Üí { F }, { F } ‚Üí { G H , },  { D } ‚Üí { I  J , } }. Qual √© a chave para R ? Decomponha R em rela√ß√µes na 2FN e depois na 3FN.
- 15.25. Repita o Exerc√≠cio 15.24 para o seguinte conjunto de depend√™ncias funcionais G = {{ A B , } ‚Üí { C }, { B , D } ‚Üí { E F , }, { A D , } ‚Üí { G H , }, { A } ‚Üí { I }, { H } ‚Üí {  } }. J

## 15.26. Considere a seguinte rela√ß√£o:

|   A | B   | C   |   NUM_TUPLA |
|-----|-----|-----|-------------|
|  10 | b1  | c1  |           1 |
|  10 | b2  | c2  |           2 |
|  11 | b4  | c1  |           3 |
|  12 | b3  | c4  |           4 |
|  13 | b1  | c1  |           5 |
|  14 | b3  | c4  |           6 |

- a. Dada a extens√£o (estado) anterior, qual das seguintes depend√™ncias pode ser mantida na rela√ß√£o acima? Se a depend√™ncia n√£o puder ser mantida, explique por que, especificando as tuplas que causam a viola√ß√£o.

i. A ‚Üí B , ii. B ‚Üí C , iii. C ‚Üí B , iv. B ‚Üí A , v. C ‚Üí A

- b. A rela√ß√£o acima tem uma chave candidata em potencial? Se tiver, qual √©? Se n√£o, por qu√™?

Considere uma rela√ß√£o R A B C D E ( , , , , ) com as seguintes depend√™ncias:

AB ‚Üí C, CD ‚Üí E, DE ‚Üí B

AB √© uma chave candidata dessa rela√ß√£o? Se n√£o for, ABD √©? Explique sua resposta.

15.28. Considere  a  rela√ß√£o R ,  que  tem  atributos  que mant√©m  hor√°rios  de  disciplinas  e  turmas  em uma universidade; R = { Nr\_disciplina, Nr\_turma, Dep\_oferece, Horas\_credits, Nivel\_disciplina, Cpf\_professor, Semestre, Ano, Horas\_dias, Nr\_ sala, Nr\_de\_alunos }.  Suponha  que  as  seguintes depend√™ncias funcionais sejam mantidas em R :

{Nr\_disciplina} ‚Üí {Dep\_oferece, Horas\_ credits, Nivel\_disciplina}

{Nr\_disciplina, Nr\_turma, Semestre, Ano} ‚Üí {Horas\_dias, Nr\_sala, Nr\_de\_alunos, Cpf\_ professor}

{Nr\_sala, Horas\_dias, Semestre, Ano} ‚Üí {Cpf\_professor, Nr\_disciplina, Nr\_turma}

Tente  determinar  quais  conjuntos  de  atributos formam chaves de R .  Como voc√™ normalizaria essa rela√ß√£o?

Considere as seguintes rela√ß√µes para um banco de dados de aplica√ß√£o de processamento de pedido na ABC, Inc.

PEDIDO (Pnum, Pdata, Custo, Quantia\_total) ITEM\_PEDIDO (Pnum, Inum, Qtd\_pedida,

Preco\_total, Desconto\_porc)

Suponha que cada item tenha um desconto diferente. O Preco\_total refere-se a um item, Pdata √© a data em que o pedido foi feito e Quantia\_total √© o valor do pedido. Se aplicarmos uma jun√ß√£o natural  nas  rela√ß√µes ITEM\_PEDIDO e PEDIDO nesse banco de dados, como ser√° o esquema de rela√ß√£o resultante? Qual ser√° sua chave? Mostre as DFs nessa rela√ß√£o resultante. Ela est√° na 2FN?

15.27.

15.29.

15.30.

15.32.

Est√° na 3FN? Por qu√™? (Indique as suposi√ß√µes, se voc√™ fizer alguma.)

Considere a seguinte rela√ß√£o:

VENDA\_CARRO (Num\_carro , Data\_venda , Num\_vendedor , Comissao\_porc , Desconto\_ tempo )

Suponha que um carro possa ser vendido por v√°rios vendedores e, portanto, { Num\_carro , Num\_ vendedor } √© a chave prim√°ria. Depend√™ncias adicionais s√£o

Data\_venda ‚Üí Desconto\_tempo e

Num\_vendedor ‚Üí Comissao\_porc

Com base na chave prim√°ria dada, essa rela√ß√£o est√° na 1FN, 2FN ou 3FN? Por qu√™? Como voc√™ a normalizaria completamente com sucesso?

15.31. Considere a seguinte rela√ß√£o para livros publicados:

LIVRO (Titulo\_livro, Nome\_autor, Tipo\_livro, Lista\_preco, Afiliacao\_autor, Editora)

Afiliacao\_autor refere-se √† afilia√ß√£o do autor. Suponha que existam as seguintes depend√™ncias:

Titulo\_livro ‚Üí Editora, Tipo\_livro

Tipo\_livro ‚Üí Lista\_preco

Nome\_autor ‚Üí Afiliacao\_autor

- a. Em que forma normal essa rela√ß√£o est√°? Explique sua resposta.
- b. Aplique  a  normaliza√ß√£o  at√©  n√£o  poder  decompor mais a rela√ß√£o. Indique os motivos por tr√°s de cada decomposi√ß√£o.

Este  exerc√≠cio  lhe  pede  para  converter  declara√ß√µes  de  neg√≥cios  em  depend√™ncias.  Considere a  rela√ß√£o DISCO\_RIGIDO ( Numero\_de\_serie, Fabricante, Modelo, Lote, Capacidade, Revendedor ).  Cada  tupla  na  rela√ß√£o DISCO\_RIGIDO cont√©m informa√ß√µes sobre uma unidade de disco com um Numero\_de\_serie exclusivo, criado por um fabricante, com um n√∫mero de modelo em  particular,  lan√ßado  em  certo  lote,  que  tem determinada capacidade de armazenamento e √© vendido  por  certo  revendedor.  Por  exemplo,  a tupla Disco\_rigido ('1978619', 'WesternDigital', 'A2235X', '765234', 500, 'CompUSA') especifica que a WesternDigital fabricou uma unidade de disco com n√∫mero de s√©rie 1978619 e n√∫mero de modelo A2235X, lan√ßado no lote 765234; ele tem 500 GB e √© vendido pela CompUSA.

Escreva  cada  uma  das  seguintes  depend√™ncias como uma DF:

- a. O fabricante e n√∫mero de s√©rie identificam a unidade com exclusividade.
- b. Um n√∫mero de modelo √© registrado por um fabricante  e,  portanto,  n√£o  pode  ser  usado por outro fabricante.

- c. Todas as unidades de disco em determinado lote s√£o do mesmo modelo.
- d. Todas as unidades de disco de certo modelo de um fabricante em particular possuem exatamente a mesma capacidade.

15.33. Considere a seguinte rela√ß√£o:

R (Num\_medico, Num\_paciente, Data, Diagnostico, Codigo\_tratamento, Gasto)

Na rela√ß√£o acima, uma tupla descreve uma visita de um paciente a um m√©dico junto com o c√≥digo  de  tratamento  e  gasto  di√°rio.  Suponha  que o diagn√≥stico seja determinado (exclusivamente) para cada paciente por um m√©dico. Suponha que cada c√≥digo de tratamento tenha um custo fixo (independente do paciente). Essa rela√ß√£o est√° na 2FN? Justifique sua resposta e decomponha, se necess√°rio.  Depois,  argumente  se  √©  necess√°ria uma maior normaliza√ß√£o para 3FN e, se preciso, realize-a.

15.34. Considere a seguinte rela√ß√£o:

VENDA\_CARRO (Id\_carro, Tipo\_opcao, Opcao\_listapreco, Data\_venda, Opcao\_ descontopreco)

Essa rela√ß√£o se refere  √†s  op√ß√µes  instaladas  nos carros (por exemplo, controle de navega√ß√£o) que foram vendidas em um revendedor, e a lista de pre√ßos e descontos das op√ß√µes.

Se IDcarro ‚Üí Data\_venda e Tipo\_opcao ‚Üí Op-cao\_listapreco e IDcarro , Tipo\_opcao ‚Üí Op-cao\_descontopreco ,  argumente  usando  a  defini√ß√£o generalizada da 3FN de que essa rela√ß√£o n√£o est√° na 3FN. Depois, argumente com base em seu conhecimento da 2FN, por que ela sequer est√° na 2FN.

15.35. Considere a rela√ß√£o:

LIVRO (Nome\_livro, Autor, Edicao, Ano) com os dados:

| Nome_livro   | Autor   |   Edicao |   Ano_copyright |
|--------------|---------|----------|-----------------|
| Sistemas BD  | Navathe |        4 |            2004 |
| Sistemas BD  | Elmasri |        4 |            2004 |
| Sistemas BD  | Elmasri |        5 |            2007 |
| Sistemas BD  | Navathe |        5 |            2007 |

- a. Com base em um conhecimento de senso comum dos dados acima, quais s√£o as chaves candidatas poss√≠veis dessa rela√ß√£o?
- b. Justifique que essa rela√ß√£o tem a MVD { Livro } ‚Üí ‚Üí { Autor } | { Edicao , Ano }.
- c. Qual seria a decomposi√ß√£o dessa rela√ß√£o com base na MVD acima? Avalie cada rela√ß√£o resultante para a forma normal mais alta que ela possui.

15.36. Considere a seguinte rela√ß√£o:

VIAGEM (Id\_viagem, Data\_inicio, Cidades\_ visitadas, Cartoes\_usados)

Essa rela√ß√£o refere-se a viagens de neg√≥cios feitas  por  vendedores  da  empresa.  Suponha  que VIAGEM tenha uma √∫nica Data\_inicio, mas envolva muitas Cidades, e  os  vendedores  podem usar m√∫ltiplos cart√µes de cr√©dito na viagem. Crie uma popula√ß√£o fict√≠cia da tabela.

- a. Discuta quais DFs e/ou MVDs existem na rela√ß√£o.
- b. Mostre como voc√™ tratar√° de sua normaliza√ß√£o.

## Exerc√≠cio de laborat√≥rio

Nota: o  exerc√≠cio  a  seguir  usa  o  sistema  DBD ( Data Base Designer ) que √© descrito no manual do laborat√≥rio. O esquema relacional R e  conjunto de depend√™ncias funcionais F precisam ser codificados como listas. Como exemplo, R e F para este problema s√£o codificados como:

R = [ a , b c , , d e , , f , g , h i ,  ,  ] j F = [[[ a , b ],[ c ]], [[ a ],[ d , e ]], [[ b ],[ f ]], [[ ],[ f g , h ]], [[ d ],[ ,  ]]] i j

Como o DBD √© implementado em Prolog, o uso de termos em mai√∫sculas √© reservado para vari√°veis na linguagem e, portanto, constantes em min√∫sculas s√£o usadas para codificar os atributos. Para obter mais detalhes sobre o sistema DBD, por favor, consulte o manual do laborat√≥rio.

15.37. Usando o sistema DBD, verifique suas respostas para os seguintes exerc√≠cios:

a. 15.24 (3FN apenas)

b. 15.25

c. 15.27

d. 15.28

## Bibliografia selecionada

As depend√™ncias funcionais foram introduzidas originalmente por Codd (1970). As defini√ß√µes originais da primeira, segunda e terceira formas normais tamb√©m foram definidas em Codd (1972a), onde pode ser encontrada uma discuss√£o sobre anomalias de atualiza√ß√£o. A Forma Normal de Boyce-Codd foi definida em Codd (1974). A defini√ß√£o alternativa da terceira forma normal √© dada em Ullman (1988), assim como a defini√ß√£o da FNBC que mostramos aqui. Ullman (1988), Maier (1983) e Atzeni e  De  Antonellis  (1993)  cont√™m  muitos  dos  teoremas  e provas referentes a depend√™ncias funcionais.

Outras refer√™ncias √† teoria do projeto relacional ser√£o dadas no Cap√≠tulo 16.



## Algoritmos de projeto de banco de dados relacional e demais depend√™ncias

O Cap√≠tulo 15 apresentou uma t√©cnica de projeto relacional de cima para baixo (top-down) e conceitos relacionados  usados  extensivamente  nos  projetos  de bancos de dados comerciais atuais. O procedimento envolve projetar um esquema conceitual ER ou EER, depois mape√°-lo para o modelo relacional por um procedimento como aquele descrito no Cap√≠tulo 9. As chaves prim√°rias s√£o atribu√≠das a cada rela√ß√£o com base nas depend√™ncias funcionais conhecidas. No processo subsequente, que pode ser chamado de projeto relacional por an√°lise , rela√ß√µes projetadas inicialmente pelo procedimento citado - ou aquelas herdadas de arquivos anteriores, formul√°rios e outras fontes - s√£o analisadas para detectar depend√™ncias funcionais indesej√°veis. Essas depend√™ncias s√£o removidas por sucessivos procedimentos de normaliza√ß√£o que descrevemos na Se√ß√£o 15.3, junto com as defini√ß√µes das formas normais relacionadas, as quais s√£o estados de projeto sucessivamente  melhores  das  rela√ß√µes  individuais.  Na  Se√ß√£o  15.3, consideramos que as chaves prim√°rias eram atribu√≠das a rela√ß√µes individuais; na Se√ß√£o 15.4, foi apresentado um tratamento mais gen√©rico da normaliza√ß√£o, no qual todas as chaves candidatas s√£o consideradas para cada rela√ß√£o, e a Se√ß√£o 15.5 discutiu outra forma normal, chamada FNBC. Depois, nas se√ß√µes 15.6 e 15.7, discutimos mais dois tipos de depend√™ncias - depend√™ncias multivaloradas e depend√™ncias de jun√ß√£o -, que tamb√©m podem causar redund√¢ncias, e mostramos como elas podem ser eliminadas com mais normaliza√ß√£o.

Neste cap√≠tulo, usamos a teoria das formas normais e depend√™ncias funcionais, multivaloradas e de jun√ß√£o desenvolvidas no cap√≠tulo anterior e nos baseamos nela enquanto mantemos tr√™s investidas diferentes. Primeiro, discutimos o conceito de deduzir novas depend√™ncias funcionais com base em um conjunto dado e discutimos no√ß√µes que incluem cobertura, cobertura m√≠nima e equival√™ncia. Conceitualmente, precisamos capturar a sem√¢ntica dos atributos em uma rela√ß√£o de maneira completa e sucinta, e a cobertura m√≠nima nos permite fazer isso. Segundo, discutimos as propriedades desej√°veis das jun√ß√µes n√£o aditivas (sem perdas) e a preserva√ß√£o de depend√™ncias funcionais. Um algoritmo geral para testar a n√£o aditividade das jun√ß√µes entre um conjunto de rela√ß√µes √© apresentado. Terceiro, apresentamos uma t√©cnica para o projeto relacional por s√≠ntese das depend√™ncias funcionais. Essa √©  uma abordagem de baixo para cima (bottom-up) para  o  projeto ,  que  pressup√µe  que  as  depend√™ncias funcionais conhecidas entre os conjuntos de atributos no Universo de Discurso (UoD) foram dadas como entrada. Apresentamos algoritmos para obter as formas normais desej√°veis, a saber, 3FN e FNBC, e alcan√ßamos uma ou ambas as propriedades desej√°veis da n√£o aditividade de jun√ß√µes e preserva√ß√£o da depend√™ncia funcional. Embora a t√©cnica de s√≠ntese seja teoricamente atraente como uma t√©cnica formal, ela n√£o tem sido usada na pr√°tica para grandes projetos de banco de dados, devido √† dificuldade de oferecer todas as depend√™ncias funcionais poss√≠veis antes que o projeto possa ser experimentado. Como alternativa,  com  a  t√©cnica  apresentada  no  Cap√≠tulo  15,  decomposi√ß√µes sucessivas e refinamentos cont√≠nuos ao projeto tornam-se mais trat√°veis e podem evoluir com o tempo. O objetivo final deste cap√≠tulo √© discutir melhor o conceito de depend√™ncia multivalorada ( MVD - Multivalued  Dependency )  que  apresentamos  no Cap√≠tulo 15 e indicar rapidamente outros tipos de depend√™ncias que foram identificadas.

Na Se√ß√£o 16.1,  vamos  discutir  as  regras  de  infer√™ncia para depend√™ncias funcionais e us√°-las para definir os conceitos de uma cobertura, equival√™ncia e cobertura m√≠nima entre depend√™ncias funcionais. Na Se√ß√£o 16.2, primeiro vamos descrever as duas propriedades das decomposi√ß√µes ,  a  saber, a propriedade de preserva√ß√£o de depend√™ncia e a propriedade de jun√ß√£o n√£o aditiva (ou sem perda), que s√£o utilizadas pelos algoritmos  de  projeto  para  alcan√ßar  decomposi√ß√µes desej√°veis. √â importante observar que n√£o √© suficiente testar os esquemas de rela√ß√£o independentemente um do outro para compatibilidade com formas normais mais altas, como 2FN, 3FN e FNBC. As rela√ß√µes resultantes precisam satisfazer coletivamente essas duas propriedades adicionais para que se qualifiquem como um bom projeto. A Se√ß√£o 16.3 √© dedicada ao desenvolvimento  de  algoritmos  de  projeto  relacional  que come√ßam com um esquema de rela√ß√£o gigante, chamada rela√ß√£o universal , a qual √© hipot√©tica e cont√©m todos os atributos. Essa rela√ß√£o √© decomposta (ou, em outras palavras, as depend√™ncias funcionais dadas s√£o sintetizadas) em rela√ß√µes que satisfazem certa forma normal, como 3FN ou FNBC, e tamb√©m atendem a uma ou ambas as propriedades desej√°veis.

Na Se√ß√£o 16.5, discutimos o conceito de depend√™ncia multivalorada (MVD) ainda mais, aplicando as no√ß√µes de infer√™ncia e equival√™ncia √†s MVDs. Por fim, na Se√ß√£o 16.6, completamos a discuss√£o sobre depend√™ncias entre dados ao introduzir depend√™ncias de inclus√£o e depend√™ncias de modelo. As depend√™ncias de inclus√£o podem representar restri√ß√µes de integridade referencial e restri√ß√µes de classe/subclasse entre as rela√ß√µes. As depend√™ncias de modelo s√£o uma forma de representar qualquer restri√ß√£o generalizada sobre atributos. Tamb√©m descrevemos algumas situa√ß√µes onde um procedimento ou fun√ß√£o √© necess√°rio para declarar e verificar uma depend√™ncia funcional entre  atributos.  Depois,  vamos  discutir  rapidamente a forma normal de dom√≠nio-chave (FNDC), que √© considerada a forma normal mais gen√©rica. No final do cap√≠tulo h√° um resumo.

√â  poss√≠vel  pular  algumas  ou  todas  as  se√ß√µes 16.3, 16.4 e 16.5 em um curso introdut√≥rio de banco de dados.

## 16.1 Outros t√≥picos em depend√™ncias funcionais: regras de infer√™ncia, equival√™ncia e cobertura m√≠nima

Apresentamos  o  conceito  de  depend√™ncias  funcionais (DFs) na Se√ß√£o 15.2, ilustramos com alguns exemplos  e  desenvolvemos  uma  nota√ß√£o  para  indicar  m√∫ltiplas  DFs  em  uma  √∫nica  rela√ß√£o.  Identificamos e discutimos depend√™ncias problem√°ticas  funcionais  nas  se√ß√µes  15.3  e  15.4,  e  mostramos como  elimin√°-las  com  uma  decomposi√ß√£o  de  uma rela√ß√£o apropriada. Esse processo foi descrito como normaliza√ß√£o e  mostramos  como  conseguir  da  primeira at√© a terceira formas normais (1FN at√© 3FN), dadas as chaves prim√°rias na Se√ß√£o 15.3. Nas se√ß√µes  15.4  e  15.5,  oferecemos  testes  generalizados para 2FN, 3FN e FNBC, dado qualquer n√∫mero de chaves candidatas em uma rela√ß√£o, e mostramos como alcan√ß√°-las. Agora, retornamos ao estudo das depend√™ncias funcionais, mostramos como novas depend√™ncias podem ser deduzidas de determinado conjunto e discutimos os conceitos de fechamento, equival√™ncia e cobertura m√≠nima, de que precisaremos mais tarde ao considerar uma t√©cnica de s√≠ntese para o projeto de rela√ß√µes dado um conjunto de DFs.

## 16.1.1 Regras de infer√™ncias para depend√™ncias funcionais

Indicamos  com F o  conjunto  de  depend√™ncias funcionais que s√£o especificadas no esquema de rela√ß√£o R . Em geral, o projetista do esquema especifica as depend√™ncias funcionais que s√£o semanticamente √≥bvias . Por√©m, diversas outras depend√™ncias funcionais s√£o mantidas em todas as inst√¢ncias de rela√ß√£o v√°lidas  entre  os  conjuntos  de  atributos  que  podem ser derivados de e satisfazem as depend√™ncias em F . Essas outras depend√™ncias podem ser deduzidas das DFs em F .

Na vida real, √© imposs√≠vel especificar todas as depend√™ncias funcionais poss√≠veis para determinada situa√ß√£o.  Por  exemplo,  se  cada  departamento  tem um gerente, de modo que Dep\_nr determina unicamente Cpf\_gerente ( Dep\_nr ‚Üí Cpf\_gerente ),  e  um gerente tem um n√∫mero de telefone √∫nico, chamado Telefone\_ger  Cpf\_gerente ( ‚Üí Telefone\_ger ), ent√£o essas duas depend√™ncias juntas implicam que Dep\_ nr ‚Üí Telefone\_ger. Essa  √©  uma  DF  deduzida e n√£o precisa ser explicitamente declarada al√©m das duas DFs dadas. Portanto, √© √∫til definir formalmente um conceito chamado fechamento ,  que inclui todas as eventuais depend√™ncias que podem ser deduzidas do conjunto F indicado.

Defini√ß√£o. Formalmente, o conjunto de todas as depend√™ncias que incluem F ,  bem como todas as depend√™ncias que podem ser deduzidas de F , √© chamado de fechamento de F , sendo indicado por F + .

Por exemplo, suponha que especifiquemos o seguinte conjunto F de depend√™ncias funcionais sobre o esquema de rela√ß√£o na Figura 15.3(a):

F = { Cpf ‚Üí { Fnome Datanasc , , Endereco , Dnumero }, Dnumero ‚Üí { Dnome Cpf\_gerente , } }

Algumas das depend√™ncias funcionais adicionais que podemos deduzir de F s√£o as seguintes:

Cpf ‚Üí { Dnome  Cpf\_gerente , }

Cpf ‚Üí Cpf

Dnumero ‚Üí Dnome

Uma DF X ‚Üí Y √© deduzida de um conjunto de depend√™ncias F especificado em R se X ‚Üí Y se mantiver em cada estado de rela√ß√£o v√°lido   de r R ; ou seja, sempre que   satisfizer todas as depend√™ncias em r F , X ‚Üí Y tamb√©m se mant√©m em  . O fechamento r F + de F √© o conjunto de todas as depend√™ncias funcionais que podem ser deduzidas de F . Para determinar um modo sistem√°tico de deduzir depend√™ncias, temos de descobrir  um  conjunto  de regras  de  infer√™ncia que podem ser usadas para deduzir novas depend√™ncias de determinado conjunto de depend√™ncias. Consideramos algumas dessas regras de infer√™ncia em seguida. Usamos a nota√ß√£o F |= X ‚Üí Y para indicar que a depend√™ncia funcional X ‚Üí Y √© deduzida do conjunto de depend√™ncias funcionais F .

Na discuss√£o a seguir, usamos uma nota√ß√£o abreviada  ao  discutirmos  as  depend√™ncias  funcionais. Concatenamos as vari√°veis de atributo e removemos as v√≠rgulas por conveni√™ncia. Logo, a DF { X Y , } ‚Üí Z √© abreviada para XY ‚Üí Z , e a DF { X Y Z , , } ‚Üí { U  V , } √© abreviada para XYZ ‚Üí UV . As seis regras a seguir, de RI1 a RI6 , s√£o regras de infer√™ncia bem conhecidas para as depend√™ncias funcionais:

RI1 (regra reflexiva):  se 1 X ‚äá Y , ent√£o X ‚Üí Y .

RI2 (regra do aumento): 2  { X ‚Üí Y } |= XZ ‚Üí YZ .

RI3 (regra transitiva): { X ‚Üí Y Y , ‚Üí Z } |= X ‚Üí Z .

RI4 (regra da decomposi√ß√£o, ou projetiva): { X ‚Üí YZ } |= X ‚Üí Y . RI5 (regra da uni√£o, ou aditiva): { X ‚Üí Y X , ‚Üí Z } |= X ‚Üí YZ . RI6 (regra pseudotransitiva): { X ‚Üí Y , W Y ‚Üí Z } |=W X ‚Üí Z .

A regra reflexiva ( RI1 ) declara que um conjunto de atributos sempre determina a si mesmo ou a qualquer um de seus subconjuntos, o que √© √≥bvio. Como RI1 gera depend√™ncias que s√£o sempre verdadeiras, elas s√£o chamadas de triviais . Formalmente, uma depend√™ncia funcional X ‚Üí Y √© trivial se X ‚äá Y ; caso contr√°rio, ela √© n√£o trivial . A regra do aumento ( RI2 ) diz que a inclus√£o do mesmo conjunto de atributos aos lados esquerdo e direito de uma depend√™ncia resulta em outra depend√™ncia v√°lida. De acordo com a RI3 , as depend√™ncias funcionais s√£o transitivas. A

regra da decomposi√ß√£o ( RI4 ) diz que podemos remover atributos do lado direito de uma depend√™ncia. A aplica√ß√£o dessa regra de maneira repetida pode decompor a DF X ‚Üí { A 1 , A 2 ,  ..., A n }  no conjunto de depend√™ncias { X ‚Üí A 1 , X ‚Üí A 2 , ..., X ‚Üí A n }. A regra da uni√£o ( RI5 ) nos permite fazer o contr√°rio. Podemos combinar um conjunto de depend√™ncias { X ‚Üí A 1 , X ‚Üí A 2 , ..., X ‚Üí A n } em uma √∫nica DF X ‚Üí { A 1 , A 2 ,  ..., A n }.  A  regra  pseudotransitiva  ( RI6 )  nos  permite substituir um conjunto de atributos Y no lado esquerdo de uma depend√™ncia por outro conjunto X que determina Y funcionalmente, e pode ser derivado de RI2 e RI3 se aumentarmos a primeira depend√™ncia funcional X ‚Üí Y com W (a regra do aumento) e depois aplicarmos a regra transitiva.

Uma nota de cuidado com rela√ß√£o ao uso dessas regras.  Embora X ‚Üí A e X ‚Üí B impliquem X ‚Üí AB pela regra da uni√£o dada, X ‚Üí A e Y ‚Üí B n√£o implicam que XY ‚Üí AB. Al√©m disso , XY ‚Üí A n√£o necessariamente implica X ‚Üí A ou Y ‚Üí A .

Cada uma das regras de infer√™ncia anteriores pode ser provada pela defini√ß√£o da depend√™ncia funcional, seja pela prova direta ou por contradi√ß√£o . Uma prova por contradi√ß√£o considera que a regra n√£o se mant√©m e mostra que isso n√£o √© poss√≠vel. Agora, vamos provar que as tr√™s primeiras regras, de RI1 at√© RI3 , s√£o v√°lidas. A segunda prova √© por contradi√ß√£o.

Prova de RI1. Suponha que X ‚äá Y e que duas tuplas t 1 e t 2 existam em alguma inst√¢ncia de rela√ß√£o r de R, tal que t 1 [ X ] = t 2 [ X ]. Ent√£o, t 1 [ Y ] = t 2 [ Y ] porque X ‚äá Y ; logo, X ‚Üí Y dever√° se manter em  . r

Prova de RI2 (por contradi√ß√£o). Suponha que X ‚Üí Y se mantenha em uma inst√¢ncia de rela√ß√£o r de R ,  mas  que XZ ‚Üí YZ n√£o  se  mantenha. Ent√£o, devem existir duas tuplas t 1 e t 2 em r, tais que (1) t 1 [ X ] = t 2 [ X ], (2) t 1 [ Y ] = t 2 [ Y ], (3) t 1 [ XZ ] = t 2 [ XZ ] e (4) t 1 [ YZ ] ‚â† t 2 [ YZ ]. Isso n√£o √© poss√≠vel porque, com base em (1) e (3), deduzimos (5) t 1 [ Z ] = t 2 [ Z ], e de (2) e (5) deduzimos (6) t 1 [ YZ ] = t 2 [ YZ ], contradizendo (4).

Prova de RI3. Suponha que (1) X ‚Üí Y e (2) Y ‚Üí Z se mantenham em uma rela√ß√£o  . Ent√£o, para r quaisquer duas tuplas t 1 e t 2 em   tal que r t 1 [ X ] = t 2 [ X ], devemos ter (3) t 1 [ Y ] = t 2 [ Y ], pela suposi√ß√£o (1). Da√≠, tamb√©m devemos ter (4) t 1 [ Z ] = t 2 [ Z ] baseado em (3) e na suposi√ß√£o (2); assim, X ‚Üí Z deve se manter em  . r

Usando argumentos de prova semelhantes, podemos demonstrar as regras de infer√™ncia RI4 , RI6 e

1 A regra reflexiva tamb√©m pode ser declarada como X ‚Üí X ; ou seja, qualquer conjunto de atributos determina funcionalmente a si mesmo.

2 A regra do aumento tamb√©m pode ser declarada como X ‚Üí Y |= XZ ‚Üí Y ; ou seja, aumentar os atributos do lado esquerdo de uma DF produz outra DF v√°lida.

quaisquer outras regras de infer√™ncia v√°lidas. Por√©m, um modo mais simples de provar a validade de uma regra  de  infer√™ncia  para  depend√™ncias  funcionais  √© prov√°-la usando regras de infer√™ncia que j√° se mostraram v√°lidas. Por exemplo, podemos provar de RI4 a RI6 usando de RI1 at√© RI3 da seguinte forma.

## Prova de RI4 (usando de RI1 a RI3).

- 1. X ‚Üí YZ (dado).
- 2. YZ ‚Üí Y (usando RI1 e sabendo que YZ ‚äá Y ).
- 3. X ‚Üí Y (usando RI3 em 1 e 2).

## Prova de RI5 (usando de RI1 a RI3).

- 1. X ‚Üí Y (dado).
- 2. X ‚Üí Z (dado).
- 3. X ‚Üí XY (usando RI2 em 1 ao aumentar com X ; observe que XX = X ).
- 4. XY ‚Üí YZ (usando RI2 em  2  ao  aumentar com Y ).
- 5. X ‚Üí YZ (usando RI3 em 3 e 4).

## Prova de RI6 (usando de RI1 a RI3).

- 1. X ‚Üí Y (dado).
- 2. WY ‚Üí Z (dado).
- 3. WX ‚Üí WY (usando RI2 em 1 ao aumentar com W ).
- 4. WX ‚Üí Z (usando RI3 em 3 e 2).

Foi mostrado por Armstrong (1974) que as regras de infer√™ncia de RI1 a RI3 s√£o leg√≠timas e completas. Por leg√≠timas queremos dizer que, dado um conjunto de depend√™ncias funcionais F especificadas em um esquema de rela√ß√£o R , qualquer depend√™ncia que possamos deduzir de F usando de RI1 a RI3 se mant√©m em cada estado de rela√ß√£o r de R que satisfaz as depend√™ncias em F . Por completas queremos dizer que usar RI1 a RI3 repetidamente para deduzir depend√™ncias  at√©  que  nenhuma  outra  depend√™ncia  possa ser deduzida resulta no conjunto completo de todas as depend√™ncias poss√≠veis que podem ser deduzidas de F . Em outras palavras, o conjunto de depend√™ncias F + , que chamamos de fechamento de F , pode ser determinado de F ao usar apenas regras de infer√™ncia de RI1 a RI3. As regras de infer√™ncia de RI1 a RI3 s√£o conhecidas como regras de infer√™ncia de Armstrong . 3

fa√ßa

<!-- formula-not-decoded -->

at√© ( X + = old X +

O  Algoritmo  16.1  come√ßa  definindo X + para todos  os  atributos  em X .  Com RI1, sabemos  que todos  esses  atributos  s√£o  funcionalmente  dependentes de X .  Usando as regras de infer√™ncia RI3 e RI4, acrescentamos atributos a X + ,  utilizando cada depend√™ncia funcional em F . Continuamos por todas  as  depend√™ncias  em F (o  loop repita )  at√©  que nenhum outro atributo seja acrescentado a X du-+ rante um ciclo completo (do loop para cada ) pelas depend√™ncias em F . Por exemplo, considere o esquema de rela√ß√£o FUNC\_PROJ da Figura 15.3(b). Pela sem√¢ntica  dos  atributos,  especificamos  o  seguinte conjunto F de  depend√™ncias funcionais que devem ser mantidas em FUNC\_PROJ:

},

Normalmente, os projetistas de banco de dados primeiro  especificam  o  conjunto  de  depend√™ncias funcionais F que podem ser facilmente determinadas

F = { Cpf ‚Üí Fnome , Projnumero ‚Üí { Projnome  Projlocal , { Cpf , Projnumero } ‚Üí Horas }

Com o Algoritmo 16.1, calculamos os seguintes conjuntos de fechamento com rela√ß√£o a F :

3 Na realidade, elas s√£o conhecidas como axiomas de Armstrong . No sentido matem√°tico estrito, os axiomas (fatos dados) s√£o as depend√™ncias funcionais em F , pois consideramos que eles est√£o corretos, enquanto R1 a R3 s√£o as regras de infer√™ncia para deduzir novas depend√™ncias funcionais (novos fatos).

pela sem√¢ntica dos atributos de R .  Ent√£o, RI1, RI2 e RI3 s√£o usados para deduzir depend√™ncias funcionais adicionais que tamb√©m se manter√£o em R . Um modo sistem√°tico de determinar essas depend√™ncias funcionais  adicionais  consiste  inicialmente  em  determinar cada conjunto de atributos X que aparece como um lado esquerdo de alguma depend√™ncia funcional em F e, depois, determinar o conjunto de todos os atributos que s√£o dependentes de X .

Defini√ß√£o. Para  cada  conjunto  de  atributos X , especificamos o conjunto X + de atributos que s√£o funcionalmente determinados por X com base em F ; X + √©  chamado de fechamento de X sob F .  O Algoritmo 16.1 pode ser usado para calcular X + .

Algoritmo 16.1. Determinando X + , o fechamento de X sob F

Entrada: um conjunto F de DFs em um esquema de rela√ß√£o R, e um conjunto de atributos X , que √© um subconjunto de R.

X + := X ;

repita old X + := X + ;

para cada depend√™ncia funcional Y ‚Üí Z em F

```
{ Cpf } + = { Cpf , Fnome } { Projnumero }   = { + Projnumero , Projnome , Projlocal } { Cpf , Projnumero } + =  { Cpf , Projnumero , Fnome , Projnome , Projlocal , Horas }
```

Intuitivamente, o conjunto de atributos no lado direito em cada linha acima representa todos os atributos que s√£o funcionalmente dependentes do conjunto  de  atributos  no  lado  esquerdo,  com  base  no conjunto F indicado.

## 16.1.2 Equival√™ncia de conjuntos de depend√™ncias funcionais

Nesta se√ß√£o, discutimos a equival√™ncia de dois conjuntos de depend√™ncias funcionais. Primeiro, damos algumas defini√ß√µes preliminares.

Defini√ß√£o. Diz-se  que  um  conjunto  de  depend√™ncias funcionais F cobre outro conjunto de depend√™ncias funcionais E se cada DF em E tamb√©m estiver em F + ; ou seja, se cada depend√™ncia em E puder ser deduzida de F . Como alternativa, podemos dizer que E √© coberto por F .

Defini√ß√£o. Dois conjuntos de depend√™ncias funcionais E e F s√£o equivalentes se E + = F + .  Portanto, a equival√™ncia significa que cada DF em E pode ser deduzida de F , e cada DF em F pode ser deduzida de E ; ou seja, E √© equivalente a F se as duas condi√ß√µes E cobre F e F cobre E - se mantiverem.

Podemos determinar se F cobre E calculando X + com rela√ß√£o a F para cada DF X ‚Üí Y em E , e depois verificando  se  esse X + inclui  os  atributos  em Y .  Se isso acontecer para cada DF em E , ent√£o F cobre E . Determinamos se E e F s√£o equivalentes verificando se E cobre F e se F cobre E . Fica como um exerc√≠cio para o leitor mostrar que os dois conjuntos de DFs a seguir s√£o equivalentes:

<!-- formula-not-decoded -->

## 16.1.3 Conjuntos m√≠nimos de depend√™ncias funcionais

perde se qualquer depend√™ncia do conjunto F for removida; F n√£o deve ter redund√¢ncias e as depend√™ncias em F est√£o em um formato-padr√£o. Para satisfazer essas propriedades, podemos definir formalmente um conjunto de depend√™ncias funcionais F como sendo m√≠nimas se ele satisfizer as seguintes condi√ß√µes:

- 1. Cada depend√™ncia em F tem um √∫nico atributo para seu lado direito.
- 2. N√£o podemos substituir qualquer depend√™ncia X ‚Üí A em F por uma depend√™ncia Y ‚Üí A , em que Y √© um subconjunto apropriado de X , e ainda ter um conjunto de depend√™ncias que seja equivalente a F .
- 3. N√£o podemos remover qualquer depend√™ncia de F e ainda ter um conjunto de depend√™ncias que seja equivalente a F .

Podemos pensar em um conjunto m√≠nimo de depend√™ncias como sendo um conjunto de depend√™ncias em uma forma-padr√£o ou can√¥nica e sem redund√¢ncias . A condi√ß√£o 1 apenas representa cada depend√™ncia em uma forma can√¥nica com um √∫nico atributo no lado direito. 4 As condi√ß√µes 2 e 3 garantem que n√£o haja  redund√¢ncias  nas  depend√™ncias,  com  atributos redundantes  no  lado  esquerdo  de  uma  depend√™ncia (Condi√ß√£o 2) ou com uma depend√™ncia que pode ser deduzida pelas DFs restantes em F (Condi√ß√£o 3).

Defini√ß√£o. Uma cobertura m√≠nima de um conjunto de depend√™ncias funcionais E √© um conjunto m√≠nimo de depend√™ncias (na forma can√¥nica padr√£o e sem redund√¢ncia) equivalente a E . Sempre podemos encontrar pelo menos uma cobertura m√≠nima F para qualquer conjunto de depend√™ncias E usando o Algoritmo 16.2.

Se  v√°rios  conjuntos  de  DFs  se  qualificam  como coberturas m√≠nimas de E pela  defini√ß√£o  dada,  √©  comum usar crit√©rios adicionais  de minimalidade .  Por exemplo, podemos escolher o conjunto m√≠nimo com o menor n√∫mero de depend√™ncias ou  com  o  menor tamanho total (o tamanho total de um conjunto de depend√™ncias √© calculado ao concatenar as depend√™ncias e tratando-as como uma string de caracteres longa).

Informalmente,  uma cobertura  m√≠nima de  um conjunto  de  depend√™ncias  funcionais E √©  um  conjunto  de  depend√™ncias  funcionais F que  satisfaz  a propriedade de que cada depend√™ncia em E est√° no fechamento F + de F . Al√©m disso, essa propriedade se

Algoritmo  16.2. Encontrando  uma  cobertura m√≠nima F para  um  conjunto  de  depend√™ncias funcionais E

Entrada: um conjunto de depend√™ncias funcionais E.

4 Esse √© a formato-padr√£o para simplificar as condi√ß√µes e algoritmos que garantem que n√£o haja redund√¢ncia em F . Ao usar a regra de infer√™ncia RI4, podemos converter uma √∫nica depend√™ncia com v√°rios atributos no lado direito para um conjunto de depend√™ncias com atributos isolados nesse mesmo lado.

- 1. Defina F := E .
- 2. Substitua  cada  depend√™ncia  funcional X ‚Üí { A 1 , A 2 ,  ..., A n }  em F pelas n depend√™ncias funcionais X ‚Üí A 1 , X ‚Üí A 2 , ..., X ‚Üí A n .
- 3. Para cada depend√™ncia funcional X ‚Üí A em F para cada atributo B que √© um elemento de X e { { s F - { X ‚Üí A } } ‚à™ { ( X - { B } ) ‚Üí A} } for equivalente a F nt√£o substitua e X ‚Üí A por ( X -  { B }  ) ‚Üí A em F .
- 4. Para cada depend√™ncia funcional restante X
- ‚Üí A em F se { F - { X ‚Üí A } } for equivalente a F , ent√£o remova X ‚Üí A de F .

Ilustramos o algoritmo acima com o seguinte: Seja o conjunto dado de DFs E : { B ‚Üí A D , ‚Üí A , AB ‚Üí D }. Temos de encontrar a cobertura m√≠nima de E .

- ¬Ñ Todas as depend√™ncias citadas est√£o na forma can√¥nica (ou seja, elas t√™m apenas um atributo no lado direito), de modo que completamos a etapa 1 do Algoritmo 16.2 e podemos prosseguir para a etapa 2. Na etapa 2, precisamos determinar se AB ‚Üí D tem algum atributo redundante no lado esquerdo; ou seja, ele pode ser substitu√≠do por B ‚Üí D ou A ‚Üí D ?
- ¬Ñ Como B ‚Üí A, ao aumentar com B nos dois lados ( RI2 ), temos BB ‚Üí AB , ou B ‚Üí AB (i). Contudo, AB ‚Üí D conforme indicado (ii).
- ¬Ñ Logo, pela regra transitiva ( RI3 ), obtemos de (i)  e  (ii), B ‚Üí D .  Assim, AB ‚Üí D pode ser substitu√≠do por B ‚Üí D .
- ¬Ñ Agora, temos um conjunto equivalente ao E original, digamos E ': { B ‚Üí A D , ‚Üí A B , ‚Üí D }.  Nenhuma  outra  redu√ß√£o  √©  poss√≠vel  na etapa 2, pois todas as DFs t√™m um √∫nico atributo no lado esquerdo.
- ¬Ñ Na etapa 3, procuramos uma DF redundante em E '. Ao usar a regra transitiva em B ‚Üí D e D ‚Üí A , derivamos B ‚Üí A . Logo, B ‚Üí A √© redundante em E ' e pode ser eliminada.
- ¬Ñ Portanto, a cobertura m√≠nima de E √© { B ‚Üí D , D ‚Üí A }.

Na Se√ß√£o 16.3, veremos como as rela√ß√µes podem ser sintetizadas com base em determinado conjunto de depend√™ncias E primeiro achando a cobertura m√≠nima F para E .

Em seguida, apresentamos um algoritmo simples para determinar a chave de uma rela√ß√£o.

Algoritmo 16.2(a). Encontrando uma chave Ch para R dado um conjunto F de depend√™ncias funcionais

Entrada: uma rela√ß√£o R e um conjunto de depend√™ncias funcionais F nos atributos de R .

- 1. Defina Ch := R .
- 2. Para cada atributo A em Ch {calcule ( Ch - A) + em rela√ß√£o a F ; s +
- e (Ch - A)  contiver todos os atributos em R, ent√£o defina Ch := Ch - {A} };

No Algoritmo 16.2(a), come√ßamos pela defini√ß√£o de Ch para todos os atributos de R ; depois, removemos um atributo de cada vez e verificamos se os atributos  restantes  ainda  formam  uma  superchave. Observe, tamb√©m, que o Algoritmo 16.2(a) determina apenas uma chave das poss√≠veis chaves candidatas para R . A chave retornada depende da ordem em que os atributos s√£o removidos de R na etapa 2.

## 16.2 Propriedades de decomposi√ß√µes relacionais

Agora, voltamos nossa aten√ß√£o para o processo de decomposi√ß√£o que usamos ao longo do Cap√≠tulo 15 para decompor rela√ß√µes a fim de nos livrarmos de  depend√™ncias  indesejadas  e  alcan√ßarmos  formas normais maiores. Na Se√ß√£o 16.2.1, damos exemplos para mostrar que examinar uma rela√ß√£o individual para testar  se  ela  est√°  em  uma  forma  normal  mais  alta, por si s√≥, n√£o garante um bom projeto. Em vez disso,  um conjunto de rela√ß√µes, que  juntas  formam  o esquema de banco de dados relacional, deve possuir certas propriedades adicionais para garantir um bom projeto. Nas se√ß√µes 16.2.2 e 16.2.3, discutimos duas dessas  propriedades:  a  propriedade  de  preserva√ß√£o de depend√™ncia e a propriedade de jun√ß√£o n√£o aditiva (ou sem perdas). A Se√ß√£o 16.2.4 discute as decomposi√ß√µes bin√°rias e a Se√ß√£o 16.2.5 discute as decomposi√ß√µes sucessivas de jun√ß√£o n√£o aditiva.

## 16.2.1 Decomposi√ß√£o da rela√ß√£o e insufici√™ncia de formas normais

Os algoritmos do projeto de banco de dados relacional que apresentamos na Se√ß√£o 16.3 come√ßam de um √∫nico esquema de rela√ß√£o universal R = { A 1 , A 2 , ..., A n }, √† qual inclui todos os atributos do banco de dados. Implicitamente, tornamos a suposi√ß√£o de rela√ß√£o universal , que declara que cada nome de atributo √© exclusivo. O conjunto F de depend√™ncias funcionais que devem ser mantidas nos atributos de R √© especificado pelos projetistas de banco de dados

e se torna dispon√≠vel aos algoritmos de projeto. Ao utilizar as depend√™ncias funcionais, os algoritmos decomp√µem o esquema de rela√ß√£o universal R em um conjunto de esquemas de rela√ß√£o D = { R 1 , R 2 , ..., R m }, que se tornar√° o esquema do banco de dados relacional; D √© chamado de decomposi√ß√£o de R .

Temos de garantir que cada atributo em R aparecer√° em pelo menos um esquema de rela√ß√£o R i na decomposi√ß√£o,  de  modo  que  nenhum  atributo  seja perdido . Formalmente, temos

<!-- formula-not-decoded -->

Esta √© chamada de condi√ß√£o de preserva√ß√£o de atributo de uma decomposi√ß√£o.

Outro objetivo √© fazer que cada rela√ß√£o individual R i na  decomposi√ß√£o D esteja na FNBC ou na 3FN. Contudo, essa condi√ß√£o n√£o √© suficiente para garantir um bom projeto de banco de dados por si s√≥. Temos de considerar a decomposi√ß√£o da rela√ß√£o universal como um todo, al√©m de examinar as rela√ß√µes individuais. Para ilustrar esse ponto, considere a  rela√ß√£o FUNC\_LOCAL (Fnome, Projlocal )  da  Figura  15.5,  que  est√°  na  3FN  e  tamb√©m  na  FNBC. De fato, qualquer esquema de rela√ß√£o com apenas dois atributos est√° automaticamente na FNBC. 5  Embora a FUNC\_LOCAL esteja na FNBC, ela ainda faz surgir tuplas falsas quando juntada com a FUNC\_PROJ ( Cpf, Projnumero, Horas, Projnome, Projlocal ), que n√£o est√° na FNBC (ver o resultado da jun√ß√£o natural na Figura 15.6). Logo, FUNC\_LOCAL representa um esquema de rela√ß√£o particularmente ruim por causa de sua  sem√¢ntica  complicada,  pela  qual Projloca d√°  o local de um dos projetos em que um funcion√°rio trabalha. Juntar FUNC\_LOCAL com PROJETO (Projnome, Projnumero, Projlocal, Dnum )  na  Figura  15.2  - que est√° na FNBC -, usando Projlocal como um atributo de jun√ß√£o, tamb√©m faz surgir tuplas falsas. Isso enfatiza a necessidade de outros crit√©rios que, junto com as condi√ß√µes da 3FN ou FNBC, impedem tais projetos  ruins.  Nas  pr√≥ximas  tr√™s  subse√ß√µes,  discutimos essas  condi√ß√µes  adicionais  que  devem  ser  mantidas em uma decomposi√ß√£o D como um todo.

## 16.2.2 Propriedade de preserva√ß√£o de depend√™ncia de uma decomposi√ß√£o

Seria  √∫til  se  cada  depend√™ncia  funcional X ‚Üí Y especificada em F aparecesse diretamente em um dos esquemas de rela√ß√£o R i na decomposi√ß√£o D ou pu-

5 Como exerc√≠cio, o leitor dever√° provar que essa afirma√ß√£o √© verdadeira.

desse  ser  deduzida  das  depend√™ncias  que  aparecem em alguma R i . Informalmente, essa √© a condi√ß√£o de preserva√ß√£o de depend√™ncia . Queremos preservar as depend√™ncias porque cada uma delas em F representa uma restri√ß√£o  no  banco  de  dados.  Se  uma  das  depend√™ncias n√£o for representada em alguma rela√ß√£o individual R i da decomposi√ß√£o, n√£o podemos impor essa restri√ß√£o ao lidar com uma rela√ß√£o individual. Podemos ter de juntar v√°rias rela√ß√µes a fim de incluir todos os atributos envolvidos nessa depend√™ncia.

N√£o √© necess√°rio que as depend√™ncias exatas especificadas em F apare√ßam elas mesmas nas rela√ß√µes individuais  da  decomposi√ß√£o D .  √â  suficiente  que  a uni√£o das depend√™ncias que se mant√™m nas rela√ß√µes individuais em D seja equivalente a F . Agora, vamos definir esses conceitos de maneira mais formal.

Defini√ß√£o. Dado um conjunto de depend√™ncias F em R ,  a proje√ß√£o de F em R i ,  indicada  por œÄ Ri ( F ), onde R i √© um subconjunto de R , √© o conjunto das depend√™ncias X ‚Üí Y em F + tal que os atributos em X ‚à™ Y estejam todos contidos em R i . Logo, a proje√ß√£o de F sobre cada esquema de rela√ß√£o R i na  decomposi√ß√£o D √©  o  conjunto de depend√™ncias funcionais em F + , o fechamento de F , tal que todos os atributos do lado esquerdo e direito estejam em R i . Dizemos que uma decomposi√ß√£o D = { R 1 , R 2 , ..., R m } de R est√° preservando a depend√™ncia em rela√ß√£o a F se a uni√£o das proje√ß√µes de F em cada R i em D for equivalente a F ; ou seja, (( œÄ R 1 ( F )) ‚à™ ... ‚à™ œÄ ( Rm ( F )))  = + F + .

Se  uma  decomposi√ß√£o  n√£o  for  do  tipo  preserva a depend√™ncia, alguma depend√™ncia √© perdida na decomposi√ß√£o.  Para  verificar  se  uma  depend√™ncia perdida se mant√©m, temos de obter a JUN√á√ÉO de duas ou mais rela√ß√µes na decomposi√ß√£o para obter uma rela√ß√£o que inclua todos os atributos do lado esquerdo e direito da depend√™ncia perdida, e depois verificar se a depend√™ncia se mant√©m no resultado da JUN√á√ÉO - uma op√ß√£o que n√£o √© pr√°tica.

Um exemplo de decomposi√ß√£o que n√£o preserva depend√™ncias aparece na Figura 15.13(a), em que a depend√™ncia funcional DF2 √© perdida quando LOTES1A √© decomposto em { LOTES1AX, LOTES1AY }. As decomposi√ß√µes da Figura 15.12, no entanto, est√£o preservando a depend√™ncia. De modo semelhante, para o exemplo da Figura 15.14, n√£o importa que decomposi√ß√£o seja escolhida para a rela√ß√£o ENSINA  Aluno, ( Disciplina, Professor ) das tr√™s fornecidas no texto, uma ou ambas as depend√™ncias  originalmente  presentes  na  certa  ser√£o perdidas. Fazemos uma afirma√ß√£o a seguir relacionada a essa propriedade sem fornecer qualquer prova.

Afirma√ß√£o 1. Sempre √© poss√≠vel encontrar uma decomposi√ß√£o de preserva√ß√£o de depend√™ncia D em rela√ß√£o a F , de modo que cada rela√ß√£o R i em D esteja na 3FN.

Na Se√ß√£o 16.3.1, descrevemos o Algoritmo 16.4, que  cria  uma  decomposi√ß√£o  de  preserva√ß√£o  de  depend√™ncia D = { R 1 , R 2 , ..., R m } de uma rela√ß√£o universal R com base em um conjunto de depend√™ncias funcionais F , tal que cada R i em D esteja na 3FN.

## 16.2.3 Propriedade de jun√ß√£o n√£o aditiva (sem perda) de uma decomposi√ß√£o

Outra  propriedade  que  uma  decomposi√ß√£o D deve possuir √© a de jun√ß√£o n√£o aditiva, que garante  que  nenhuma  tupla  falsa  √©  gerada  quando  uma opera√ß√£o JUN√á√ÉO NATURAL √©  aplicada  √†s  rela√ß√µes resultantes da decomposi√ß√£o. J√° ilustramos esse problema na Se√ß√£o 15.1.4 com o exemplo das figuras 15.5 e 15.6. Como essa √© uma propriedade de uma decomposi√ß√£o  de esquemas de  rela√ß√£o,  a  condi√ß√£o de  nenhuma tupla  falsa  deve  ser  mantida  em cada estado de rela√ß√£o v√°lido - ou seja, cada estado de rela√ß√£o que satisfa√ßa as depend√™ncias funcionais em F . Logo, a propriedade de jun√ß√£o sem perda √© sempre definida  em  rela√ß√£o  a  um  conjunto  espec√≠fico F de depend√™ncias.

Defini√ß√£o. Formalmente, uma decomposi√ß√£o D = { R 1 , R 2 , ..., R m } de R tem a propriedade de jun√ß√£o  sem  perda  (n√£o  aditiva) em  rela√ß√£o  ao conjunto de depend√™ncias F em R se, para cada estado de rela√ß√£o   de r R que satisfa√ßa F , o seguinte for mantido, onde √© √© a JUN√á√ÉO NATURAL de todas as rela√ß√µes em D : √© ( œÄ R 1 ( r ), ..., œÄ R m ( r )) = r.

A  palavra  perda  em sem  perda refere-se  √† perda de informa√ß√£o ,  e  n√£o  √†  perda  de  tuplas.  Se  uma decomposi√ß√£o n√£o tem a propriedade de jun√ß√£o sem perda,  podemos  obter  tuplas  falsas  adicionais  ap√≥s as  opera√ß√µes PROJETO ( œÄ )  e JUN√á√ÉO NATURAL ( √© ) serem aplicadas. Essas tuplas adicionais representam informa√ß√µes err√¥neas ou inv√°lidas. Preferimos o termo jun√ß√£o n√£o aditiva porque ele descreve a situa√ß√£o com mais precis√£o. Embora o termo jun√ß√£o sem perda seja popular na literatura, daqui por diante usaremos o termo jun√ß√£o n√£o aditiva ,  que √© autoexplicativo e n√£o √© amb√≠guo. A propriedade de jun√ß√£o n√£o aditiva garante que n√£o haver√° tuplas falsas ap√≥s a aplica√ß√£o das opera√ß√µes PROJETO e JUN√á√ÉO . Por√©m, podemos √†s vezes usar o termo projeto sem perda para nos referirmos a um projeto que representa uma perda de informa√ß√£o (ver o exemplo ao final do Algoritmo 16.4).

A  decomposi√ß√£o  de FUNC\_PROJ  (Cpf, Projnumero, Horas, Fnome, Projnome, Projlocal) na  Figura 15.3 para FUNC\_LOCAL (Fnome, Projlocal) e FUNC\_

PROJ1(Cpf, Projnumero, Horas, Projnome, Projlocal) na Figura  15.5  obviamente  n√£o  tem  a  propriedade  de jun√ß√£o n√£o aditiva, conforme ilustrada pela Figura 15.6. Usaremos um procedimento geral para testar se  qualquer decomposi√ß√£o D de  uma rela√ß√£o em n rela√ß√µes √© n√£o aditiva com rela√ß√£o a um conjunto de depend√™ncias  funcionais  dadas F na  rela√ß√£o.  Ele  √© apresentado como o Algoritmo 16.3 a seguir. √â poss√≠vel aplicar um teste mais simples para verificar se a  decomposi√ß√£o  √©  n√£o  aditiva  para  decomposi√ß√µes bin√°rias, o qual √© descrito na Se√ß√£o 16.2.4.

Algoritmo 16.3. Testando a propriedade de jun√ß√£o n√£o aditiva

Entrada: uma rela√ß√£o universal R , uma decomposi√ß√£o D = { R 1 , R 2 , ..., R m } de R e um conjunto F de depend√™ncias funcionais.

Nota : coment√°rios explicativos s√£o dados ao final de algumas das etapas. Eles seguem o formato: ( √© coment√°rio √© ).

- 1. Crie uma matriz inicial   com uma linha   para S i cada rela√ß√£o R i em D , e uma coluna   para cada j atributo A j em R .
- 2. Defina S i ( , j ):= b ij para todas as entradas de matriz. ( √© cada b ij √© um s√≠mbolo distinto associado aos √≠ndices ( ,  ) i j √© ).
- 3. Para cada linha   representando o esquema de i rela√ß√£o R i
- {para cada coluna   representando o atributo j A j se (rela√ß√£o { R i inclui atributo A j ) ent√£o defina S i ( , j ):= a j ;};}; ( √© cada a j √© um s√≠mbolo distinto associado ao √≠ndice (  ) j √© ).
- 4. Repita o loop a seguir at√© que uma execu√ß√£o de  loop  completa resulte  em  nenhuma  mudan√ßa para S
- {para cada depend√™ncia funcional X ‚Üí Y em F para todas as linhas em { S que t√™m os mesmos s√≠mbolos nas colunas correspondentes aos atributos em X

fa√ßa  que  os  s√≠mbolos  em  cada  coluna { que  corresponde  a  um  atributo  em Y sejam  iguais  em  todas  essas  linhas  da seguinte forma: se qualquer uma das linhas tiver um s√≠mbolo a para a coluna, defina as outras linhas com esse mesmo s√≠mbolo a na coluna. Se nenhum s√≠mbolo a existir para o atributo em qualquer uma das linhas, escolha um dos s√≠mbolos b que aparecem em uma das linhas para o atributo e defina as outras linhas com o mesmo s√≠mbolo b na coluna ;} ; } ;};

- 5. Se  uma  linha  for  composta  inteiramente  de s√≠mbolos a , ent√£o a decomposi√ß√£o tem a propriedade de jun√ß√£o n√£o aditiva; caso contr√°rio, ela n√£o tem.

Dada uma rela√ß√£o R que √© decomposta em uma s√©rie de rela√ß√µes R 1 , R 2 , ..., R m , o Algoritmo 16.3 inicia a matriz S que consideramos ser algum estado de rela√ß√£o r de R . A linha   em i S representa uma tupla t i (correspondente √† rela√ß√£o R i ) que tem s√≠mbolos a nas colunas que correspondem aos atributos de R i e s√≠mbolos b nas colunas restantes. O algoritmo ent√£o transforma as linhas dessa matriz (durante o loop na etapa  4),  de  modo  que  representem  tuplas  que  satisfazem todas as depend√™ncias funcionais em F . Ao final  da  etapa  4,  duas  linhas  quaisquer  em S - as quais representam duas tuplas em r - que combinam em seus valores para os atributos do lado esquerdo de X de uma depend√™ncia funcional X ‚Üí Y em F tamb√©m combinar√£o em seus valores para os atributos do lado direito Y . Pode-se demonstrar que, depois de aplicar o loop da etapa 4, se qualquer linha em S acabar com todos os s√≠mbolos a ,  ent√£o a decomposi√ß√£o D tem  a  propriedade  de  jun√ß√£o  n√£o aditiva em rela√ß√£o a F .

Se, ao contr√°rio, nenhuma linha acabar com todos os s√≠mbolos a , D n√£o satisfaz a propriedade de jun√ß√£o sem perda. Nesse caso, o estado de rela√ß√£o r representado por S ao final do algoritmo ser√° um exemplo de um estado de rela√ß√£o   de r R que satisfaz as depend√™ncias em F , mas n√£o satisfaz a condi√ß√£o de jun√ß√£o n√£o aditiva. Portanto, essa rela√ß√£o serve como um contraexemplo que prova que D n√£o tem a propriedade de jun√ß√£o n√£o aditiva em rela√ß√£o a F . Observe que os s√≠mbolos a e b n√£o possuem significado especial ao final do algoritmo.

A Figura 16.1(a) mostra como aplicamos o Algoritmo 16.3 √† decomposi√ß√£o do esquema da rela√ß√£o FUNC\_PROJ da  Figura  15.3(b)  para  os  dois  esquemas de rela√ß√£o FUNC\_PROJ1 e FUNC\_LOCAL da Figura 15.5(a). O loop na etapa 4 do algoritmo n√£o pode mudar quaisquer s√≠mbolos b para s√≠mbolos a . Logo, a matriz resultante S n√£o tem uma linha com todos os s√≠mbolos a e, portanto, a decomposi√ß√£o n√£o tem a propriedade de jun√ß√£o n√£o aditiva.

A Figura 16.1(b) mostra outra decomposi√ß√£o de FUNC\_PROJ (para FUNC, PROJETO e TRABALHA\_ EM ) que tem a propriedade de jun√ß√£o n√£o aditiva, e a Figura 16.1(c) mostra como aplicamos o algoritmo a essa decomposi√ß√£o. Quando uma linha consiste apenas em s√≠mbolos a , conclu√≠mos que a decomposi√ß√£o tem a propriedade de jun√ß√£o n√£o aditiva, e podemos parar de aplicar as depend√™ncias funcionais (etapa 4 no algoritmo) √† matriz S .

## 16.2.4 estando decomposi√ß√µes bin√°rias T para a propriedade de jun√ß√£o n√£o aditiva

O algoritmo 16.3 nos permite testar se determinada decomposi√ß√£o D em n rela√ß√µes obedece √† propriedade de jun√ß√£o n√£o aditiva em rela√ß√£o a um conjunto de depend√™ncias funcionais F . Existe um caso especial  de  decomposi√ß√£o  chamado decomposi√ß√£o bin√°ria - decomposi√ß√£o de uma rela√ß√£o R em duas rela√ß√µes. Oferecemos um teste mais f√°cil de aplicar do que o Algoritmo 16.3, mas, embora ele seja muito pr√°tico de usar, √© limitado apenas a decomposi√ß√µes bin√°rias.

Propriedade NJB (jun√ß√£o n√£o aditiva para decomposi√ß√µes bin√°rias) . Uma decomposi√ß√£o D = { R 1 , R 2 } de R tem  a  propriedade de jun√ß√£o sem perda (n√£o aditiva) em rela√ß√£o a um conjunto de depend√™ncias funcionais F sobre R se, e somente se,

- ¬Ñ A DF (( R 1 ‚à© R 2 ) ‚Üí ( R 1 -R 2 )) estiver em F + , ou
- ¬Ñ A DF (( R 1 ‚à© R 2 ) ‚Üí ( R 2 -R 1 )) estiver em F +

Voc√™  dever√°  verificar  se  essa  propriedade  se mant√©m em rela√ß√£o a nossos exemplos informais de normaliza√ß√£o sucessiva nas se√ß√µes 15.3 e 15.4. Na Se√ß√£o  15.5,  decompomos LOTES1A em  duas  rela√ß√µes FNBC LOTES1AX e LOTES1AY, e  decompomos a rela√ß√£o ENSINA da Figura 15.14 nas duas rela√ß√µes { Professor, Disciplina} e  { Professor, Aluno }.  Estas  s√£o decomposi√ß√µes v√°lidas, pois s√£o n√£o aditivas para o teste citado.

## 16.2.5 Decomposi√ß√µes sucessivas de jun√ß√£o n√£o aditiva

Vimos  a  decomposi√ß√£o  sucessiva  de  rela√ß√µes durante o processo de segunda e terceira normaliza√ß√£o nas se√ß√µes 15.3 e 15.4. Para verificar se essas decomposi√ß√µes s√£o n√£o aditivas, precisamos garantir outra  propriedade,  conforme  estabelecida  na Afirma√ß√£o 2.

Afirma√ß√£o  2  (preserva√ß√£o  da  n√£o  aditivida -de  nas  decomposi√ß√µes  sucessivas). Se  uma decomposi√ß√£o D =  { R 1 , R 2 ,  ..., R m }  de R tem a propriedade de jun√ß√£o n√£o aditiva (sem perda) em rela√ß√£o a um conjunto de depend√™ncias funcionais F em R , e se uma decomposi√ß√£o Di = { Q 1 , Q 2 ,  ..., Qk }  de R i tem a propriedade de jun√ß√£o n√£o aditiva em rela√ß√£o √† proje√ß√£o de F em R i , ent√£o a decomposi√ß√£o D 2 = { R 1 , R 2 , ..., R i -1 , Q 1 , Q 2 , ..., Qk , R i +1 , ..., R m } de R tem a propriedade de jun√ß√£o n√£o aditiva em rela√ß√£o a F .

- (a) R = {Cpf, Fnome, Projnumero, Projnome, Projlocal, Horas}

R 1 = FUNC\_LOCAL = {Fnome, Projlocal}

R 2 = FUNC\_PROJ1 {Cpf, Projnumero, Horas, Projnome, Projlocal}

F = {Cpf ‚Üí Fnome; Projnumero ‚Üí {Projnome, Projlocal}; {Cpf, Projnumero} ‚Üí Horas}

|     | Cpf   | Fnome   | Projnumero   | Projnome   | Projlocal   | Horas   |
|-----|-------|---------|--------------|------------|-------------|---------|
| R 1 | b 11  | a 2     | b 13         | b 14       | a 5         | b 16    |
| R 2 | a 1   | b 22    | a 3          | a 4        | a 5         | a 6     |

(Nenhuma mudan√ßa na matriz ap√≥s aplicar as depend√™ncias funcionais)

| (b)   | FUNC   | FUNC   | PROJETO    | PROJETO   | PROJETO   | TRABALHA_EM   | TRABALHA_EM   | TRABALHA_EM   |
|-------|--------|--------|------------|-----------|-----------|---------------|---------------|---------------|
|       | Cpf    | Fnome  | Projnumero | Projnome  | Projlocal | Cpf           | Projnumero    | Horas         |

- (c) R

= {Cpf, Fnome, Projnumero, Projnome, Projlocal, Horas} D = { R 1 , R 2 , R 3 }

R 1 = FUNC = {Cpf, Fnome}

R 2 = PROJ = {Projnumero, Projnome, Projlocal}

R 3 = TRABALHA\_EM = {Cpf, Projnumero, Horas}

F = {Cpf ‚Üí Fnome; Projnumero ‚Üí {Projnome, Projlocal}; {Cpf, Projnumero} ‚Üí Horas}

|     | Cpf   | Fnome   | Projnumero   | Projnome   | Projlocal   | Horas   |
|-----|-------|---------|--------------|------------|-------------|---------|
| R 1 | a 1   | a 2     | b 13         | b 14       | b 15        | b 16    |
| R 2 | b 21  | b 22    | a 3          | a 4        | a 5         | b 26    |
| R 3 | a 1   | b 32    | a 3          | b 34       | b 35        | a 6     |

(Matriz original S no in√≠cio do algoritmo)

|     | Cpf   | Fnome    | Projnumero   | Projnome   | Projlocal   | Horas   |
|-----|-------|----------|--------------|------------|-------------|---------|
| R 1 | a 1   | a 2      | b 13         | b 14       | b 15        | b 16    |
| R 2 | b 21  | b 22     | a 3          | a 4        | a 5         | b 26    |
| R 3 | a 1   | b 32 a 2 | a 3          | b 34 a 4   | b 35 a 5    | a 6     |

(Matriz original S depois de aplicar as duas primeiras depend√™ncias funcionais; a √∫ltima linha tem apenas s√≠mbolos 'a' e, por isso, paramos)

## Figura 16.1

Teste de jun√ß√£o n√£o aditivo para decomposi√ß√µes n -√°rias. (a) Caso 1: decomposi√ß√£o de FUNC\_PROJ em FUNC\_PROJ1 e FUNC\_LOCAL falha no teste. (b) Uma decomposi√ß√£o de FUNC\_PROJ que tem a propriedade de jun√ß√£o sem perda. (c) Caso 2: decomposi√ß√£o de FUNC\_PROJ em FUNC, PROJETO e TRABALHA\_EM satisfaz o teste.

D = { R 1 , R 2 }

## 16.3 Algoritmos para projeto de esquema de banco de dados relacional

Agora, apresentamos tr√™s algoritmos para criar uma decomposi√ß√£o relacional com base em uma rela√ß√£o  universal.  Cada  algoritmo  tem  propriedades espec√≠ficas, conforme discutiremos a seguir.

## 16.3.1 Decomposi√ß√£o de preserva√ß√£o de depend√™ncia em esquemas 3FN

O  Algoritmo  16.4  cria  uma  decomposi√ß√£o  de preserva√ß√£o de depend√™ncia D = { R 1 , R 2 , ..., R m } de uma rela√ß√£o  universal R com  base  em  um  conjunto  de depend√™ncias  funcionais F ,  tal  que  cada R i em D est√° na 3FN. Isso garante apenas a propriedade de preserva√ß√£o de depend√™ncia; mas n√£o garante a propriedade de jun√ß√£o n√£o aditiva. A primeira etapa do Algoritmo 16.4 √© encontrar uma cobertura m√≠nima G para F ;  o  Algoritmo  16.2  pode  ser  usado  para essa etapa. Observe que v√°rias coberturas m√≠nimas podem existir para determinado conjunto F (conforme ilustramos mais adiante no exemplo ap√≥s o Algoritmo 16.4). Nesses casos, os algoritmos podem potencialmente gerar v√°rios projetos alternativos.

Algoritmo 16.4. S√≠ntese  relacional  para  a  3FN com preserva√ß√£o de depend√™ncia

Entrada: uma rela√ß√£o universal R e  um  conjunto de depend√™ncias funcionais F nos atributos de R .

- 1. Ache uma cobertura m√≠nima G para F (use o Algoritmo 16.2);
- 2. Para cada X do lado esquerdo de uma depend√™ncia funcional que aparece em G, crie um esquema de rela√ß√£o em D com atributos { X ‚à™ { A 1 } ‚à™ { A 2 } ... ‚à™ { A k } }, em que X ‚Üí A 1 , X ‚Üí A 2 , ..., X ‚Üí A k s√£o as √∫nicas depend√™ncias em G com X como lado esquerdo ( X √©  a chave dessa rela√ß√£o);
- 3. Coloque  quaisquer  atributos  restantes  (que n√£o foram inseridos em qualquer rela√ß√£o) em um √∫nico esquema de rela√ß√£o para garantir a propriedade de preserva√ß√£o de atributo.

Exemplo do Algoritmo  16.4. Considere  a  seguinte rela√ß√£o universal:

U ( Func\_cpf , Pnr , Fsal , Ftelefone , Dnr , Projnome , Projlocal )

6 Veja uma prova em Maier (1983) ou Ullman (1982).

Func\_cpf, Fsal, Ftelefone referem-se  ao  n√∫mero do Cadastro de Pessoa F√≠sica, sal√°rio e n√∫mero de telefone do funcion√°rio. Pnr, Projnome e Projlocal referem-se ao n√∫mero, nome e local do projeto. Dnr √© o n√∫mero do departamento.

As seguintes depend√™ncias est√£o presentes:

DF1: Func\_cpf ‚Üí { Fsal , Ftelefone , Dnr

} }

DF2: Pnr ‚Üí { Projnome , Projlocal

DF3: Func\_cpf , Pnr ‚Üí { Fsal , Ftelefone , Dnr , Proj- nome Projlocal , }

Em  virtude  de  DF3,  o  conjunto  de  atributos { Func\_cpf, Pnr } representa  uma  chave  da  rela√ß√£o universal. Logo, F , o conjunto de DFs dadas, inclui { Func\_cpf ‚Üí Fsal, Ftelefone, Dnr; Pnr ‚Üí Projnome, Projlocal; Func\_cpf, Pnr ‚Üí Fsal, Ftelefone, Dnr, Projnome, Projlocal }.

Ao aplicar o Algoritmo 16.2 de cobertura m√≠nima, na etapa 3 vemos que Pnr √© um atributo redundante em Func\_cpf, Pnr ‚Üí Fsal, Ftelefone, Dnr. Al√©m do mais, Func\_cpf √© redundante em Func\_cpf, Pnr ‚Üí Projnome, Projlocal. Logo,  a  cobertura  m√≠nima  consiste  em  DF1  e  DF2  apenas  (DF3  sendo completamente redundante) da seguinte forma (se agruparmos atributos com o mesmo lado direito em uma DF):

Cobertura m√≠nima G : { Func\_cpf ‚Üí Fsal , Ftelefone , Dnr ; Pnr ‚Üí Projnome , Projlocal }

Ao aplicar o Algoritmo 16.4 √† cobertura m√≠nima G , obtemos um projeto na 3FN consistindo em duas rela√ß√µes com chaves Func\_cpf e Pnr , da seguinte forma:

R 1 ( Func\_cpf , Fsal , Ftelefone , Dnr ) )

- R 2 ( Pnr , Projnome , Projlocal

Um  leitor  atento  notaria  facilmente  que  essas duas rela√ß√µes perderam a informa√ß√£o original contida  na  chave  da  rela√ß√£o  universal U (a  saber,  que existem certos funcion√°rios trabalhando em determinados projetos em um relacionamento muitos-para-muitos). Assim, embora o algoritmo preserve as depend√™ncias originais, ele n√£o garante a preserva√ß√£o de toda a informa√ß√£o. Logo, o projeto resultante √© um projeto com perda .

Afirma√ß√£o 3. Todo esquema de rela√ß√£o criado pelo Algoritmo 16.4 est√° na 3FN. (N√£o daremos uma prova formal aqui; 6  ela depende de G ser um conjunto m√≠nimo de depend√™ncias.)

√â √≥bvio que todas as depend√™ncias em G s√£o preservadas pelo algoritmo, pois cada depend√™ncia

aparece em uma das rela√ß√µes R i na  decomposi√ß√£o D .  Como G √©  equivalente a F ,  todas as depend√™ncias  em F ou  s√£o  preservadas  diretamente  na  decomposi√ß√£o ou s√£o deriv√°veis usando as regras de infer√™ncia da Se√ß√£o 16.1.1 com base naquelas das rela√ß√µes  resultantes,  garantindo  assim  a  propriedade de preserva√ß√£o de depend√™ncia. O Algoritmo 16.4 √© chamado de algoritmo de s√≠ntese relacional porque cada esquema de rela√ß√£o R i na decomposi√ß√£o √© sintetizado (constru√≠do) com base no conjunto de depend√™ncias funcionais em G com o mesmo X do lado esquerdo.

## 16.3.2 Decomposi√ß√£o de jun√ß√£o n√£o aditiva para esquemas FNBC

O pr√≥ximo algoritmo decomp√µe um esquema de rela√ß√£o  universal R =  { A 1 , A 2 ,  ..., A n }  em  uma  decomposi√ß√£o D = { R 1 , R 2 , ..., R m }, tal que cada R i est√° na FNBC e a decomposi√ß√£o D tem a propriedade de jun√ß√£o sem perda em rela√ß√£o a F . O Algoritmo 16.5 utiliza a Propriedade NJB e a Afirma√ß√£o 2 (preserva√ß√£o de n√£o aditividade em decomposi√ß√µes sucessivas) para criar uma decomposi√ß√£o de jun√ß√£o n√£o aditiva D = { R 1 , R 2 , ..., R m } de uma rela√ß√£o universal R baseada em um conjunto de depend√™ncias funcionais F , tal que cada R i em D esteja na FNBC.

Algoritmo 16.5. Decomposi√ß√£o relacional para FNBC com propriedade de jun√ß√£o n√£o aditiva

Entrada: uma rela√ß√£o universal R e um conjunto de depend√™ncias funcionais F nos atributos de R .

- 1. Defina D := { R } ;
- 2. Enquanto existe  um  esquema  de  rela√ß√£o Q em D que n√£o esteja na FNBC, fa√ßa
- { scolha um esquema de rela√ß√£o e Q em D que n√£o esteja na FNBC; etermine uma depend√™ncia funcional d X ‚Üí Y em Q que viole a FNBC; pelos dois esquemas de
- ubstitua s Q em D rela√ß√£o ( Q -Y ) e ( X ‚à™ Y );

} ;

A cada passagem pelo loop no Algoritmo 16.5, decompomos um esquema de rela√ß√£o Q que n√£o est√° na FNBC em dois esquemas de rela√ß√£o. De acordo com a Propriedade NJB para decomposi√ß√µes bin√°rias e a Afirma√ß√£o 2, a decomposi√ß√£o D tem a propriedade de jun√ß√£o n√£o aditiva. Ao final do algoritmo, todos os esquemas de rela√ß√£o em D estar√£o na FNBC. O leitor poder√° verificar que o exemplo de normaliza√ß√£o das figuras 15.12 e 15.13 basicamente segue esse algoritmo. As depend√™ncias funcionais DF3, DF4 e, mais tarde, DF5 violam a FNBC, de modo que a rela√ß√£o LOTES √© decomposta corretamente em rela√ß√µes FNBC, e a decomposi√ß√£o ent√£o satisfaz a propriedade de jun√ß√£o n√£o aditiva. De modo semelhante, se aplicarmos o algoritmo ao esquema de rela√ß√£o ENSINA da Figura 15.14, ele √© decomposto em ENSINA1 (Professor, Aluno) e ENSINA2 ( Professor , Disciplina ), pois a depend√™ncia DF2 Professor ‚Üí Disciplina viola a FNBC.

Na etapa 2 do Algoritmo 16.5, √© necess√°rio determinar se um esquema de rela√ß√£o Q est√° na FNBC ou n√£o. Um m√©todo para fazer isso √© testar, para cada depend√™ncia funcional X ‚Üí Y em Q , se X + deixa de incluir todos os atributos em Q , determinando assim se X √© ou n√£o uma (super)chave em Q . Outra t√©cnica est√° baseada em uma observa√ß√£o de que, sempre que um esquema de rela√ß√£o Q tem uma viola√ß√£o da FNBC, existe um par de atributos A e B em Q ,  tal que { Q -  { A B , }  } ‚Üí A .  Ao  calcular  o  fechamento { Q - { A B , } } + para cada par de atributos { A B , } de Q , e verificar se o fechamento inclui A (ou B ), podemos determinar se Q est√° na FNBC.

## 16.3.3 Decomposi√ß√£o de jun√ß√£o preservando a depend√™ncia e n√£o aditiva (sem perda) para esquemas 3FN

At√© aqui, no Algoritmo 16.4, mostramos como obter um projeto 3FN com o potencial para perda de informa√ß√£o e, no Algoritmo 16.5, mostramos como obter um projeto FNBC com a perda em potencial de certas depend√™ncias funcionais. No momento, sabemos que n√£o √© poss√≠vel ter todos os tr√™s a seguir: (1) projeto sem perdas garantido, (2) preserva√ß√£o de depend√™ncia garantida e (3) todas as rela√ß√µes na FNBC. Como j√° dissemos, a primeira condi√ß√£o √© essencial e n√£o pode ser comprometida. A segunda condi√ß√£o √© desej√°vel, mas n√£o essencial, e pode ter de ser relaxada se insistirmos em obter a FNBC. Agora, damos um algoritmo alternativo onde alcan√ßamos as condi√ß√µes 1 e 2 e s√≥ garantimos a 3FN. Uma modifica√ß√£o simples no Algoritmo 16.4, mostrada como Algoritmo 16.6, gera uma decomposi√ß√£o D de R que faz o seguinte:

- ¬Ñ Preserva depend√™ncias.
- ¬Ñ Tem a propriedade de jun√ß√£o n√£o aditiva.
- ¬Ñ √â tal que cada esquema de rela√ß√£o resultante na decomposi√ß√£o est√° na 3FN.

Como o Algoritmo 16.6 alcan√ßa as duas propriedades desej√°veis, em vez de apenas a preserva√ß√£o da depend√™ncia funcional, conforme garantida pelo Algoritmo 16.4, ela √© preferida em rela√ß√£o ao Algoritmo 16.4.

Algoritmo 16.6. S√≠ntese  relacional  para  a  3FN com preserva√ß√£o de depend√™ncia e propriedade de jun√ß√£o n√£o aditiva

Entrada: uma rela√ß√£o universal R e um conjunto de depend√™ncias funcionais F nos atributos de R .

- 1. Determine uma cobertura m√≠nima G para F (use o Algoritmo 16.2).
- 2. Para cada X do lado esquerdo de uma depend√™ncia funcional que aparece em G , crie um esquema de rela√ß√£o em D com atributos { X ‚à™ { A 1 } ‚à™ { A 2 } ... ‚à™ { A k } }, onde X ‚Üí A 1 , X ‚Üí A 2 , ..., X ‚Üí A k s√£o as √∫nicas depend√™ncias em G com X como lado esquerdo ( X √©  a chave dessa rela√ß√£o).
- 3. Se  nenhum  dos  esquemas  de  rela√ß√£o  em D tiver uma chave de R , ent√£o crie mais um esquema de rela√ß√£o em D que contenha atributos que formam uma chave de R . 7 (O Algoritmo 16.2(a) pode ser usado para determinar uma chave.)
- 4. Elimine rela√ß√µes redundantes do conjunto resultante de rela√ß√µes no esquema de banco de dados relacional. Uma rela√ß√£o R √© considerada redundante se R for uma proje√ß√£o de outra rela√ß√£o S no esquema; como alternativa, R √© submetido por S . 8

A etapa 3 do Algoritmo 16.6 envolve identificar uma chave K de R .  O  Algoritmo  16.2(a)  pode  ser usado para identificar uma chave K de R com base no conjunto de depend√™ncias funcionais F dadas. Observe que o conjunto de depend√™ncias funcionais usadas para determinar uma chave no Algoritmo 16.2(a) poderia ser F ou G , pois eles s√£o equivalentes.

Exemplo 1 do Algoritmo 16.6. Vamos retornar ao exemplo dado anteriormente no final do Algoritmo 16.4. A cobertura m√≠nima G se mant√©m como antes. A segunda etapa produz rela√ß√µes R 1 e R 2 como antes. Contudo, agora na etapa 3, geraremos uma rela√ß√£o correspondente √† chave { Func\_cpf , Pnr }. Logo, o projeto resultante cont√©m:

- R 1 ( Func\_cpf , Fsal , Ftelefone , Dnr )
- R 2 ( Pnr , Projnome , Projlocal )
- R 3 ( Func\_cpf , Pnr )

Esse projeto alcan√ßa as propriedades desej√°veis de preserva√ß√£o de depend√™ncia e jun√ß√£o n√£o aditiva.

Exemplo 2 do Algoritmo 16.6 (Caso X). Considere o esquema de rela√ß√£o LOTES1A mostrado na  Figura  15.13(a).  Suponha  que  essa  rela√ß√£o seja  dada  como  uma  rela√ß√£o  universal  com  as seguintes depend√™ncias funcionais:

DF1: Propriedade\_num ‚Üí Num\_lote , Cidade , Area DF2: Num\_lote , Cidade ‚Üí Area , Propriedade\_num DF3: Area ‚Üí Cidade

Estas foram chamadas DF1, DF2 e DF5 na Figura 15.13(a). Os significados dos atributos e a implica√ß√£o das depend√™ncias funcionais acima foram explicados na Se√ß√£o 15.4. Por facilidade de refer√™ncia, vamos abreviar os atributos acima com a primeira letra de cada um e representar as depend√™ncias funcionais como o conjunto

F : { P ‚Üí LCA LC , ‚Üí AP A , ‚Üí C . }

Se  aplicarmos  o  Algoritmo  16.2  de  cobertura m√≠nima a F (na etapa 2), primeiro representamos o conjunto F como

F : { P ‚Üí L P , ‚Üí C P , ‚Üí A LC , ‚Üí A LC , ‚Üí P A , ‚Üí C . }

No conjunto F , P ‚Üí A pode ser deduzido de P ‚Üí LC e LC ‚Üí A; logo, P ‚Üí A por transitividade e √©, portanto, redundante. Assim, uma cobertura m√≠nima poss√≠vel √©

Cobertura m√≠nima GX : { P ‚Üí LC LC , ‚Üí AP A , ‚Üí C . }

Na etapa  2  do  Algoritmo  16.6,  produzimos  o projeto X (antes de removermos rela√ß√µes redundantes) usando a cobertura m√≠nima acima como

Projeto X R : 1 ( P L C , , ), R 2 ( L , C A P , , ) e R 3 ( A C . , )

Na etapa 4 do algoritmo, descobrimos que R 3 √© subordinado a R 2 (ou seja, R 3 sempre √© uma proje√ß√£o de R 2 e R 1 √© uma proje√ß√£o de R 2 tamb√©m). Logo, essas duas rela√ß√µes s√£o redundantes. Assim, o esquema 3FN que alcan√ßa as duas propriedades desej√°veis √© (depois de remover rela√ß√µes redundantes)

Projeto X R : 2 ( L , C A P . , , )

ou, em outras palavras, √© id√™ntico √† rela√ß√£o LOTES1A ( Num\_lote, Cidade, Area, Propriedade\_num) que determinamos como estando na 3FN na Se√ß√£o 15.4.2.

Exemplo 2 do Algoritmo 16.6 (Caso Y). Come√ßando com LOTES1A como a rela√ß√£o universal e com o mesmo conjunto dado de depend√™ncias funcionais, a segunda etapa do Algoritmo 16.2 de cobertura m√≠nima produz, como antes

7 A Etapa 3 do Algoritmo 16.4 n√£o √© necess√°ria no Algoritmo 16.6 para preservar atributos, pois a chave incluir√° quaisquer atributos n√£o colocados; esses s√£o os atributos que n√£o participam de qualquer depend√™ncia funcional.

8 Observe que existe um tipo adicional de depend√™ncia: R √© uma proje√ß√£o da jun√ß√£o de duas ou mais rela√ß√µes no esquema. Esse tipo de redund√¢ncia √© considerado depend√™ncia de jun√ß√£o , conforme discutimos na Se√ß√£o 15.7. Logo, tecnicamente, ele pode continuar a existir sem atrapalhar o status 3FN para o esquema.

<!-- formula-not-decoded -->

A DF LC ‚Üí A pode ser considerada redundante porque LC ‚Üí P e P ‚Üí A implica LC ‚Üí A por transitividade. Al√©m disso, P ‚Üí C pode ser considerado redundante porque P ‚Üí A e A ‚Üí C implica P ‚Üí C por transitividade. Isso d√° uma cobertura m√≠nima diferente como

Cobertura m√≠nima GY : { P ‚Üí LA LC , ‚Üí P A , ‚Üí C . }

O projeto alternativo Y produzido pelo algoritmo agora √©

<!-- formula-not-decoded -->

Observe que esse projeto tem tr√™s rela√ß√µes 3FN, nenhuma delas podendo ser considerada redundante pela condi√ß√£o na etapa 4. Todas as DFs no conjunto original F s√£o preservadas. O leitor notar√° que, das tr√™s rela√ß√µes acima, as rela√ß√µes S 1 e S  foram produ3 zidas como o projeto FNBC pelo procedimento dado na Se√ß√£o 15.5 (implicando que S 2 √©  redundante  na presen√ßa de S 1 e S 3 ).  No entanto, n√£o podemos eliminar a rela√ß√£o S  do conjunto de tr√™s rela√ß√µes 3FN 2 acima, visto que ela n√£o √© uma proje√ß√£o de S 1 ou S 3 . O projeto Y , portanto, permanece como um resultado final poss√≠vel da aplica√ß√£o do Algoritmo 16.6 √† rela√ß√£o universal dada, que oferece rela√ß√µes na 3FN.

√â importante observar que a teoria de decomposi√ß√µes de jun√ß√£o n√£o aditiva est√° baseada na suposi√ß√£o de que nenhum valor NULL √© permitido para os atributos de jun√ß√£o . A pr√≥xima se√ß√£o discute alguns dos problemas que os NULL s podem causar nas decomposi√ß√µes  relacionais  e  oferece  uma  discuss√£o  geral dos  algoritmos  para  projeto  relacional  por  s√≠ntese, apresentados nesta se√ß√£o.

## 16.4 Sobre nulos, tuplas suspensas e projetos relacionais alternativos

Nesta se√ß√£o, discutiremos algumas quest√µes gerais relacionadas aos problemas que surgem quando o projeto relacional n√£o √© abordado corretamente.

## 16.4.1 Problemas com valores NULL e tuplas suspensas

Temos de considerar com cuidado os problemas associados a NULL s  ao projetar um esquema de banco de dados relacional. Ainda n√£o existe uma teoria de projeto relacional totalmente satisfat√≥ria e que inclua valores NULL .  Um  problema ocorre quando algumas tuplas t√™m valores NULL para atributos que ser√£o usados para juntar rela√ß√µes individuais na decomposi√ß√£o.

Para ilustrar isso, considere o banco de dados mostrado na Figura 16.2(a), no qual mostramos duas rela√ß√µes, FUNCIONARIO e DEPARTAMENTO . As  duas  √∫ltimas tuplas de funcion√°rios - 'Borges' e 'Benitez' - representam funcion√°rios rec√©m-contratados, que ainda n√£o foram atribu√≠dos a um departamento (suponha que isso n√£o viole quaisquer restri√ß√µes de integridade). Agora, suponha que queiramos recuperar uma lista de valores ( Fnome, Dnome ) para todos os funcion√°rios. Se aplicarmos a opera√ß√£o JUN√á√ÉO NATURAL sobre FUNCIONARIO e DEPARTAMENTO (Figura 16.2(b)), as duas tuplas mencionadas n√£o aparecer√£o no resultado. A opera√ß√£o JUN√á√ÉO EXTERNA , discutida no Cap√≠tulo 6, pode lidar com esse problema. Lembre-se de que, se apanharmos a JUN√á√ÉO EXTERNA √Ä ESQUERDA de FUNCIONARIO com DEPARTAMENTO, as tuplas em FUNCIONARIO que possuem NULL para  o  atributo  de  jun√ß√£o  aparecer√£o no resultado, junto com uma tupla imagin√°ria em DEPARTAMENTO , que tem NULL s para todos os valores de atributo. A Figura 16.2(c) mostra o resultado.

Em geral, sempre que um esquema de banco de dados relacional √© projetado, em que duas ou mais rela√ß√µes s√£o inter-relacionadas por chaves estrangeiras,  deve-se  dedicar um cuidado em particular para  observar  os  valores NULL em  potencial  nas chaves estrangeiras. Isso pode causar perda de informa√ß√£o inesperada nas consultas que envolvem jun√ß√µes nessa chave estrangeira. Al√©m do mais, se houver NULL s  em  outros  atributos,  como Salario, seu efeito sobre fun√ß√µes embutidas como SOMA e M√âDIA deve ser cuidadosamente avaliado.

Um problema relacionado √© o das tuplas suspensas , que pode ocorrer se executarmos uma decomposi√ß√£o em demasia. Suponha que decomponhamos a rela√ß√£o FUNCIONARIO da Figura 16.2(a) ainda mais para FUN-CIONARIO\_1 e FUNCIONARIO\_2 , como mostra a Figura 16.3(a) e 16.3(b). 9 Se aplicarmos a opera√ß√£o JUN√á√ÉO NATURAL a FUNCIONARIO\_1 e FUNCIONARIO\_2, obtemos a rela√ß√£o FUNCIONARIO original. Por√©m, podemos usar  a  representa√ß√£o  alternativa,  mostrada  na  Figura 16.3(c), na qual n√£o inclu√≠mos uma tupla em FUNCIO-NARIO\_3 se o funcion√°rio n√£o tiver sido atribu√≠do a um departamento (em vez de incluir uma tupla com NULL para Dnum ,  como  em FUNCIONARIO\_2) .  Se  usarmos FUNCIONARIO\_3 no lugar de FUNCIONARIO\_2 e aplicarmos uma JUN√á√ÉO NATURAL em FUNCIONARIO\_1 e FUNCIONARIO\_3 , as tuplas para Borges e Benitez n√£o aparecer√£o  no  resultado.  Estas  s√£o  chamadas tuplas suspensas em FUNCIONARIO\_1 porque  s√£o  representadas  em  apenas  uma  das  rela√ß√µes  que  representam funcion√°rios, e por isso se perdem se aplicarmos uma opera√ß√£o (INTERNA) JUN√á√ÉO .

(a)

## FUNCIONARIO

| Fnome               |         Cpf | Datanasc   | Endereco                                | Dnum   |
|---------------------|-------------|------------|-----------------------------------------|--------|
| Silva, Jo√£o B.      | 12345678966 | 09-01-1965 | Rua das Flores, 751, S√£o Paulo, SP      | 5      |
| Wong, Fernando T.   | 33344555587 | 08-12-1955 | Rua da Lapa, 34, S√£o Paulo, SP          | 5      |
| Zelaya, Alice J.    | 99988777767 | 19-01-1968 | Rua Souza Lima, 35, Curitiba, PR        | 4      |
| Souza, Jennifer S.  | 98765432168 | 20-06-1941 | Av. Arthur de Lima, 54, Santo Andr√©, SP | 4      |
| Lima, Ronaldo K.    | 66688444476 | 15-09-1962 | Rua Rebou√ßas, 65, Piracicaba, SP        | 5      |
| Leite, Joice A.     | 45345345376 | 31-07-1972 | Av. Lucas Obes, 74, S√£o Paulo, SP       | 5      |
| Pereira, Andr√© V.   | 98798798733 | 29-03-1969 | Rua Timbira, 35, S√£o Paulo, SP          | 4      |
| Brito, Jorge E.     | 88866555576 | 10-11-1937 | Rua do Horto, 35, S√£o Paulo, SP         | 1      |
| Borges, Anderson C. | 99977555511 | 26-04-1965 | Rua Br√°s Leme, 6530, Santo Andr√©, SP    | NULL   |
| Benitez, Carlos M.  | 88866444433 | 09-01-1963 | Av. Paes de Barros, 7654, S√£o Paulo, SP | NULL   |

## DEPARTAMENTO

| Dnome         |   Dnum |    Dcpf_ger |
|---------------|--------|-------------|
| Pesquisa      |      5 | 33344555587 |
| Administra√ß√£o |      4 | 98765432168 |
| Matriz        |      1 | 88866555576 |

## (b)

| Fnome              |         Cpf | Datanasc   | Endereco                                |   Dnum | Dnome         |    Dcpf_ger |
|--------------------|-------------|------------|-----------------------------------------|--------|---------------|-------------|
| Silva, Jo√£o B.     | 12345678966 | 09-01-1965 | Rua das Flores, 751, S√£o Paulo, SP      |      5 | Pesquisa      | 33344555587 |
| Wong, Fernando T.  | 33344555587 | 08-12-1955 | Rua da Lapa, 34, S√£ Paulo, SP           |      5 | Pesquisa      | 33344555587 |
| Zelaya, Alice J.   | 99988777767 | 19-01-1968 | Rua Souza Lima, 35, Curitiba, PR        |      4 | Administra√ß√£o | 98765432168 |
| Souza, Jennifer S. | 98765432168 | 20-06-1941 | Av. Arthur de Lima, 54, Santo Andr√©, SP |      4 | Administra√ß√£o | 98765432168 |
| Lima, Ronaldo K.   | 66688444476 | 15-09-1962 | Rua Rebou√ßas, 65, Piracicaba, SP        |      5 | Pesquisa      | 33344555587 |
| Leite, Joice A.    | 45345345376 | 31-07-1972 | Av. Lucas Obes, 74, S√£o Paulo, SP       |      5 | Pesquisa      | 33344555587 |
| Pereira, Andr√© V.  | 98798798733 | 29-03-1969 | Rua Timbira, 35, S√£o Paulo, SP          |      4 | Administra√ß√£o | 98765432168 |
| Brito, Jorge E.    | 88866555576 | 10-11-1937 | Rua do Horto, 35, S√£o Paulo, SP         |      1 | Matriz        | 88866555576 |

## (c)

| Fnome               |         Cpf | Datanasc   | Endereco                                | Dnum   | Dnome         | Dcpf_ger    |
|---------------------|-------------|------------|-----------------------------------------|--------|---------------|-------------|
| Silva, Jo√£o B.      | 12345678966 | 09-01-1965 | Rua das Flores, 751, S√£o Paulo, SP      | 5      | Pesquisa      | 33344555587 |
| Wong, Fernando T.   | 33344555587 | 08-12-1955 | Rua da Lapa, 34, S√£o Paulo, SP          | 5      | Pesquisa      | 33344555587 |
| Zelaya, Alice J.    | 99988777767 | 19-01-1968 | Rua Souza Lima, 35, Curitiba, PR        | 4      | Administra√ß√£o | 98765432168 |
| Souza, Jennifer S.  | 98765432168 | 20-06-1941 | Av. Arthur de Lima, 54, Santo Andr√©, SP | 4      | Administra√ß√£o | 98765432168 |
| Lima, Ronaldo K.    | 66688444476 | 15-09-1962 | Rua Rebou√ßas, 65, Piracicaba, SP        | 5      | Pesquisa      | 33344555587 |
| Leite, Joice A.     | 45345345376 | 31-07-1972 | Av. Lucas Obes, 74, S√£o Paulo. SP       | 5      | Pesquisa      | 33344555587 |
| Pereira, Andr√© V.   | 98798798733 | 29-03-1969 | Rua Timbira, 35, S√£o Paulo, SP          | 4      | Administra√ß√£o | 98765432168 |
| Brito, Jorge E.     | 88866555576 | 10-11-1937 | Rua do Horto, 35, S√£o Paulo, SP         | 1      | Matriz        | 88866555576 |
| Borges, Anderson C. | 99977555511 | 26-04-1965 | Rua Br√°s Leme, 6530, Santo Andr√©, SP    | NULL   | NULL          | NULL        |
| Benitez, Carlos M.  | 88866444433 | 09-01-1963 | Av. Paes de Barros, 7654, S√£o Paulo, SP | NULL   | NULL          | NULL        |

## Figura 16.2

Problemas com jun√ß√µes de valor NULL. (a) Algumas tuplas de FUNCIONARIO t√™m NULL para o atributo de jun√ß√£o Dnum. (b) Resultado da aplica√ß√£o de JUN√á√ÉO NATURAL √†s rela√ß√µes FUNCIONARIO e DEPARTAMENTO. (c) Resultado da aplica√ß√£o de JUN√á√ÉO EXTERNA √Ä ESQUERDA a FUNCIONARIO e DEPARTAMENTO.

## (a) FUNCIONARIO\_1

| Fnome               |         Cpf | Datanasc   | Endereco                                |
|---------------------|-------------|------------|-----------------------------------------|
| Silva, Jo√£o B.      | 12345678966 | 09-01-1965 | Rua das Flores, 751, S√£o Paulo, SP      |
| Wong, Fernando T.   | 33344555587 | 08-12-1955 | Rua da Lapa, 34, S√£o Paulo, SP          |
| Zelaya, Alice J.    | 99988777767 | 19-01-1968 | Rua Souza Lima, 35, Curitiba, PR        |
| Souza, Jennifer S.  | 98765432168 | 20-06-1941 | Av. Arthur de Lima, 54, Santo Andr√©, SP |
| Lima, Ronaldo K.    | 66688444476 | 15-09-1962 | Rua Rebou√ßas, 65, Piracicaba, SP        |
| Leite, Joice A.     | 45345345376 | 31-07-1972 | Av. Lucas Obes, 74, S√£o Paulo, PR       |
| Pereira, Andr√© V.   | 98798798733 | 29-03-1969 | Rua Timbira, 35, S√£o Paulo, SP          |
| Brito, Jorge E.     | 88866555576 | 10-11-1937 | Rua do Horto, 35, S√£o Paulo, SP         |
| Borges, Anderson C. | 99977555511 | 26-04-1965 | Rua Br√°s Leme, 6530, Santo Andr√©, SP    |
| Benitez, Carlos M.  | 88866444433 | 09-01-1963 | Av. Paes de Barros, 7654, S√£o Paulo, SP |

## (b) FUNCIONARIO\_2

## (c) FUNCIONARIO\_3

|         Cpf | Dnum   |
|-------------|--------|
| 12345678966 | 5      |
| 33344555587 | 5      |
| 99988777767 | 4      |
| 98765432168 | 4      |
| 66688444476 | 5      |
| 45345345376 | 5      |
| 98798798733 | 4      |
| 88866555576 | 1      |
| 99977555511 | NULL   |
| 88866444433 | NULL   |

|         Cpf |   Dnum |
|-------------|--------|
| 12345678966 |      5 |
| 33344555587 |      5 |
| 99988777767 |      4 |
| 98765432168 |      4 |
| 66688444476 |      5 |
| 45345345376 |      5 |
| 98798798733 |      4 |
| 88866555576 |      1 |

## Figura 16.3

O problema de tupla pendente. (a) A rela√ß√£o FUNCIONARIO\_1 inclui todos os atributos de FUNCIONARIO da Figura 16.2(a) exceto Dnum. (b) A rela√ß√£o FUNCIONARIO\_2 inclui o atributo Dnum com valores NULL. (c) A rela√ß√£o FUNCIONARIO\_3 inclui o atributo Dnum, mas n√£o as tuplas para as quais Dnum tem valores NULL.

## 16.4.2 Discuss√£o sobre algoritmos de normaliza√ß√£o e projetos relacionais alternativos

Um dos problemas com os algoritmos de normaliza√ß√£o que descrevemos √© que o projetista de banco de dados precisa primeiro especificar todas as depend√™ncias  funcionais  relevantes  entre  os  atributos  do banco de dados. Essa n√£o √© uma tarefa simples para um banco de dados grande, com centenas de atributos. Deixar de especificar uma ou duas depend√™ncias importantes pode resultar em um projeto indesej√°vel. Outro problema √© que esses algoritmos n√£o s√£o determin√≠sticos em  geral.  Por  exemplo,  os algoritmos de  s√≠ntese (algoritmos  16.4  e  16.6)  exigem  a  espe- cifica√ß√£o  de  uma  cobertura  m√≠nima G para  o  conjunto de depend√™ncias funcionais F . Como costuma haver  muitas  coberturas  m√≠nimas  correspondentes a F , conforme ilustramos no Exemplo 2 do Algoritmo 16.6, o algoritmo pode dar origem a diferentes projetos, dependendo da cobertura m√≠nima em particular utilizada. Alguns desses projetos podem n√£o ser desej√°veis. O algoritmo de decomposi√ß√£o para alcan√ßar a FNBC (Algoritmo 16.5) depende da ordem em que as depend√™ncias funcionais s√£o fornecidas ao algoritmo para verificar a viola√ß√£o da FNBC. Novamente, √© poss√≠vel que muitos projetos diferentes possam surgir correspondentes ao mesmo conjunto de depend√™ncias funcionais, dependendo da ordem em que tais depend√™ncias s√£o consideradas para viola√ß√£o

da FNBC. Alguns dos projetos podem ser preferidos, enquanto outros podem ser indesej√°veis.

Nem sempre √© poss√≠vel encontrar uma decomposi√ß√£o para esquemas de rela√ß√£o que preserve depend√™ncias e permita que cada esquema de rela√ß√£o na decomposi√ß√£o esteja na FNBC (em vez da 3FN, como no Algoritmo 16.6). Podemos verificar os esquemas de rela√ß√£o 3FN na decomposi√ß√£o individualmente para ver se cada um satisfaz a FNBC. Se algum esquema de rela√ß√£o R i n√£o estiver na FNBC, podemos decidir decomp√¥-la ainda mais e deix√°-la como se encontra na 3FN (com algumas poss√≠veis anomalias de atualiza√ß√£o).

Para ilustrar esses pontos, vamos retornar √† rela√ß√£o LOTES1A da Figura 15.13(a). Trata-se de uma rela√ß√£o na 3FN, que n√£o est√° na FNBC, como mostramos na Se√ß√£o 15.5. Tamb√©m mostramos que, ao come√ßar com as depend√™ncias funcionais (DF1, DF2 e DF5 na Figura 15.13(a)), usando a t√©cnica de baixo para cima para projetar e aplicar o Algoritmo 16.6, √© poss√≠vel aparecer com a rela√ß√£o LOTES1A como o projeto  3FN  (que  foi  chamado  de  projeto X anteriormente), ou um projeto alternativo Y que consiste  em tr√™s rela√ß√µes S 1 , S 2 , S 3 (projeto Y ),  cada  uma

Tabela 16.1

Resumo dos algoritmos discutidos neste cap√≠tulo.

| Algoritmo   | Entrada                                                                 | Sa√≠da                                                                   | Propriedades/Finalidade                                                               | Coment√°rios                                                                                      |
|-------------|-------------------------------------------------------------------------|-------------------------------------------------------------------------|---------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------|
| 16.1        | Um atributo ou um conjunto de atributos X, e um conjunto de DFs F       | Um conjunto de atributos no fechamento de X com rela√ß√£o a F             | Determinar todos os atributos que podem ser funcionalmente determinados com base em X | O fechamento de uma chave √© a rela√ß√£o inteira                                                    |
| 16.2        | Um conjunto de depend√™ncias funcionais F                                | A cobertura m√≠nima de depend√™ncias funcionais                           | Determinar a cobertura m√≠nima de um conjunto de depend√™ncias F                        | Pode haver m√∫ltiplas coberturas m√≠nimas -depende da ordem de sele√ß√£o das depend√™ncias funcionais |
| 16.2a       | Esquema de rela√ß√£o R com um conjunto de depend√™ncias funcionais F       | Chave Ch de R                                                           | Encontrar uma chave Ch (que seja um subconjunto de R)                                 | A rela√ß√£o R inteira √© sempre uma superchave padr√£o                                               |
| 16.3        | Uma decomposi√ß√£o D de R e um conjunto F de depend√™ncias funcionais      | Resultado booleano: sim ou n√£o para a propriedade de jun√ß√£o n√£o aditiva | Testar para decomposi√ß√£o da jun√ß√£o n√£o aditiva                                        | Veja uma NJB de teste simples na Se√ß√£o 16.2.4 para decomposi√ß√µes bin√°rias                        |
| 16.4        | Uma rela√ß√£o R e um conjunto de depend√™ncias funcionais F                | Um conjunto de rela√ß√µes na 3FN                                          | Preserva√ß√£o de depend√™ncia                                                            | N√£o h√° garantia de satisfazer a propriedade de jun√ß√£o sem perda                                  |
| 16.5        | Uma rela√ß√£o R e um conjunto de depend√™ncias funcionais F                | Um conjunto de rela√ß√µes na FNBC                                         | Decomposi√ß√£o de jun√ß√£o n√£o aditiva                                                    | N√£o h√° garantia de preserva√ß√£o de depend√™ncia                                                    |
| 16.6        | Uma rela√ß√£o R e um conjunto de depend√™ncias funcionais F                | Um conjunto de rela√ß√µes na 3FN                                          | Jun√ß√£o n√£o aditiva e decomposi√ß√£o por preserva√ß√£o da depend√™ncia                      | Pode n√£o alcan√ßar a FNBC, mas alcan√ßa todas as propriedades desej√°veis e a 3FN                   |
| 16.7        | Uma rela√ß√£o R e um conjunto de depend√™ncias funcionais e multivaloradas | Um conjunto de rela√ß√µes na 4FN                                          | Decomposi√ß√£o por jun√ß√£o n√£o aditiva                                                   | Sem garantia de preserva√ß√£o de depend√™ncia                                                       |

sendo uma rela√ß√£o 3FN. Observe que, se testarmos mais  o  projeto Y para  a  FNBC,  cada  uma  das  rela√ß√µes S 1 , S 2 e S 3 estar√°  individualmente  na  FNBC. O projeto X , por√©m, quando testado para a FNBC, falha no teste. Ele gera as duas rela√ß√µes S 1 e S 3 ao aplicar  o  Algoritmo  16.5  (por  causa  da  depend√™ncia  funcional  que  viola A ‚Üí C ).  Assim,  o  procedimento de projeto de baixo para cima de aplica√ß√£o do  Algoritmo  16.6  para  projetar  rela√ß√µes  3FN  a fim  de  obter  as  duas  propriedades  e  depois  aplicar o  Algoritmo  16.5  para  conseguir  a  FNBC  com  a propriedade de jun√ß√£o n√£o aditiva (e sacrificando a preserva√ß√£o  da  depend√™ncia  funcional)  produz S 1 , S 2 , S 3 como projeto FNBC final por uma rota (rota do projeto Y )  e S 1 , S 3 pela  outra rota (rota do projeto X ). Isso acontece devido √†s m√∫ltiplas coberturas m√≠nimas para o conjunto original de depend√™ncias funcionais. Observe que S 2 √© uma rela√ß√£o redundante no projeto Y ; por√©m, ela n√£o viola a restri√ß√£o de jun√ß√£o n√£o aditiva. √â f√°cil ver que S 2 √© uma rela√ß√£o v√°lida e significativa que tem as duas chaves candidatas ( L, C ) e P colocadas lado a lado.

A Tabela 16.1 resume as propriedades dos algoritmos discutidos at√© aqui neste cap√≠tulo.

## 16.5 Discuss√£o adicional sobre depend√™ncias multivaloradas e 4FN

Apresentamos e definimos o conceito de depend√™ncias  multivaloradas  e  o  usamos  para  definir  a quarta  forma  normal  na  Se√ß√£o  15.6.  Agora,  retornamos √†s MVDs para completar nosso tratamento, indicando as regras de infer√™ncia sobre elas.

## 16.5.1 Regras de infer√™ncia para depend√™ncias funcionais e multivaloradas

Assim como as depend√™ncias funcionais (DFs), as regras de infer√™ncia para depend√™ncias multivaloradas (MVDs) tamb√©m foram desenvolvidas. Por√©m, √© melhor desenvolver uma estrutura unificada que inclua tanto DFs quanto MVDs, de modo que os dois tipos  de  restri√ß√µes  possam  ser  considerados  juntos. As regras de infer√™ncia RI1 a RI8 a seguir formam um conjunto confi√°vel e completo para deduzir depend√™ncias funcionais e multivaloradas de determinado conjunto  de  depend√™ncias.  Suponha  que  todos  os atributos estejam inclu√≠dos em um esquema de rela√ß√£o universal R = { A 1 , A 2 , ..., A n } e que X Y Z , , e W sejam subconjuntos de R .

RI1 (regra reflexiva para DFs): se X ‚äá Y ,  ent√£o X ‚Üí Y .

RI2 (regra de aumento para DFs): { X ‚Üí Y } |= XZ ‚Üí YZ .

- RI3 (regra transitiva para DFs): { X ‚Üí Y Y , ‚Üí Z } |= X ‚Üí Z .

R4 (regra de complementa√ß√£o para MVDs): { X ‚Üí ‚Üí Y } |= { X ‚Üí ‚Üí ( R - ( X ‚à™ Y ))}.

RI5 (regra de aumento para MVDs): Se X ‚Üí ‚Üí Y e W ‚äá Z , ent√£o WX ‚Üí ‚Üí YZ.

RI6 (regra  transitiva  para  MVDs):  { X ‚Üí ‚Üí Y , Y ‚Üí ‚Üí Z } |= X ‚Üí ‚Üí ( Z -Y ) .

RI7 (regra de replica√ß√£o para DF para MVD): { X ‚Üí Y } |= X ‚Üí ‚Üí Y.

RI8 (regra de coalesc√™ncia para DFs e MVDs): se X ‚Üí ‚Üí Y e houver W com as propriedades de que (a) W ‚à© Y √© vazio, (b) W ‚Üí Z , e (c) Y ‚äá Z , ent√£o X ‚Üí Z.

De RI1 at√© RI3 s√£o as regras de infer√™ncia de Armstrong para DFs apenas. De RI4 at√© RI6 s√£o as regras de infer√™ncia pertencentes √†s MVDs somente. As RI7 e RI8 relacionam DFs e MVDs. Em particular, a RI7 diz que uma depend√™ncia funcional √© um caso especial de uma depend√™ncia multivalorada; ou seja, cada DF tamb√©m √© uma MVD, pois satisfaz a defini√ß√£o formal de uma MVD. No entanto, essa equival√™ncia tem um problema: uma DF X ‚Üí Y √© uma MVD X ‚Üí ‚Üí Y com a restri√ß√£o adicional impl√≠cita de que no m√°ximo um valor de Y √© associado a cada valor de X . 10 Dado um conjunto F de depend√™ncias funcionais e multivaloradas, especificadas em R = { A 1 , A 2 , ..., A n }, podemos usar de RI1 a RI8 para deduzir o conjunto (completo) de todas as depend√™ncias (funcionais e multivaloradas) F + que ser√£o mantidas em cada estado de rela√ß√£o   de r R que satisfa√ßa F . Novamente chamamos de F + o fechamento de F .

## 16.5.2 Revis√£o da quarta forma normal

Reproduzimos a defini√ß√£o da quarta forma normal  4FN ( ) da Se√ß√£o 15.6:

Defini√ß√£o. Um esquema de rela√ß√£o R est√° na 4FN com rela√ß√£o a um conjunto de depend√™ncias F (que inclui depend√™ncias funcionais e depend√™ncias multivaloradas) se, para cada depend√™ncia multivalorada n√£o trivial X ‚Üí ‚Üí Y em F + , X for uma superchave para R .

Para  ilustrar  a  import√¢ncia  da  4FN,  a  Figura 16.4(a) mostra a rela√ß√£o FUNC da Figura 15.15 com um funcion√°rio adicional, 'Braga', que tem tr√™s dependentes ('Jim', 'Joana' e 'Roberto') e trabalha em quatro projetos diferentes ('W', 'X', 'Y' e 'Z'). Existem 16 tuplas em FUNC na Figura 16.4(a). Se decompusermos FUNC em FUNC\_PROJETOS e FUNC\_DEPENDENTES, como mostra a Figura 16.4(b), precisamos armazenar um total de apenas 11 tuplas nas duas rela√ß√µes. N√£o apenas a decomposi√ß√£o economizaria armazenamento, mas as anomalias de atualiza√ß√£o associadas a depend√™ncias  multivaloradas  tamb√©m  seriam  evitadas. Por exemplo, se 'Braga' come√ßar a trabalhar em um novo projeto adicional 'P', temos de inserir tr√™s tuplas em FUNC - uma para cada dependente. Se nos esquecermos de inserir qualquer um deles, a rela√ß√£o viola a MVD e torna-se incoerente porque implica incorretamente um relacionamento entre projeto e dependente.

Se a rela√ß√£o tiver MVDs n√£o triviais, ent√£o as opera√ß√µes de inser√ß√£o, exclus√£o e atualiza√ß√£o em tuplas  isoladas  podem  fazer  que  as  tuplas  adicionais sejam  modificadas  al√©m  daquela  em  quest√£o.  Se  a atualiza√ß√£o for tratada incorretamente, o significado da rela√ß√£o pode mudar. No entanto, ap√≥s a normaliza√ß√£o para a 4FN, essas anomalias de atualiza√ß√£o desaparecem. Por exemplo, para acrescentar a informa√ß√£o de que 'Braga' ser√° atribu√≠do ao projeto 'P', somente uma √∫nica tupla precisa ser inserida na rela√ß√£o 4FN FUNC\_PROJETOS .

## (a) FUNC

| Fnome   | Projnome   | Nome_dependente   |
|---------|------------|-------------------|
| Silva   | X          | Jo√£o              |
| Silva   | Y          | Ana               |
| Silva   | X          | Ana               |
| Silva   | Y          | Jo√£o              |
| Braga   | W          | Jim               |
| Braga   | X          | Jim               |
| Braga   | Y          | Jim               |
| Braga   | Z          | Jim               |
| Braga   | W          | Joana             |
| Braga   | X          | Joana             |
| Braga   | Y          | Joana             |
| Braga   | Z          | Joana             |
| Braga   | W          | Roberto           |
| Braga   | X          | Roberto           |
| Braga   | Y          | Roberto           |
| Braga   | Z          | Roberto           |

## (b) FUNC\_PROJETOS

| Fnome   | Projnome   |
|---------|------------|
| Silva   | X          |
| Silva   | Y          |
| Braga   | W          |
| Braga   | X          |
| Braga   | Y          |
| Braga   | Z          |

## (c) FUNC\_DEPENDENTES

Figura 16.4

| Fnome   | Nome_ dependente   |
|---------|--------------------|
| Silva   | Ana                |
| Silva   | Jo√£o               |
| Braga   | Jim                |
| Braga   | Joana              |
| Braga   | Roberto            |

Decompondo um estado de rela√ß√£o de FUNC que n√£o est√° na 4FN. (a) Rela√ß√£o FUNC com tuplas adicionais. (b) Duas rela√ß√µes 4FN correspondentes FUNC\_PROJETOS e FUNC\_DEPENDENTES.

A rela√ß√£o FUNC da Figura 15.15(a) n√£o est√° na 4FN  porque  representa  dois  relacionamentos  1:N independentes - um entre funcion√°rios e os projetos em que trabalham e um entre funcion√°rios e seus dependentes.  √Äs  vezes,  temos  um  relacionamento entre tr√™s entidades, o qual depende de todas as tr√™s entidades participantes, como a rela√ß√£o FORNECE mostrada na Figura 15.15(c). (Considere apenas as tuplas  na  Figura  15.5(c) acima da  linha  tracejada por  enquanto.)  Nesse  caso,  uma  tupla  representa um fornecedor  que  entrega  uma  pe√ßa  espec√≠fica a um projeto em particular ,  de  modo  que n√£o existem MVDs n√£o triviais.  Logo,  a  rela√ß√£o  de  todas as chaves FORNECE j√° est√° na 4FN e n√£o deve ser decomposta.

## 16.5.3 Decomposi√ß√£o de jun√ß√£o n√£o aditiva para rela√ß√µes 4FN

Sempre que decompomos um esquema de rela√ß√£o R em R 1 = ( X ‚à™ Y ) e R 2 = ( R -Y ) com base em uma MVD X ‚Üí ‚Üí Y que se mant√©m em R , a decomposi√ß√£o tem a propriedade de jun√ß√£o n√£o aditiva. Pode-se mostrar que essa √© uma condi√ß√£o necess√°ria e sufi- ciente para decompor um esquema em dois esquemas que t√™m a propriedade de jun√ß√£o n√£o aditiva, conforme dado pela Propriedade NJB', que √© mais uma generaliza√ß√£o da Propriedade NJB dada anteriormente. A propriedade NJB tratava apenas de DFs, enquanto a NJB' trata de DFs e MVDs (lembre-se de que uma DF tamb√©m √© uma MVD).

Propriedade NJB'. Os esquemas de rela√ß√£o R 1 e R 2 formam uma decomposi√ß√£o de jun√ß√£o n√£o aditiva de R em rela√ß√£o a um conjunto F de depend√™ncias funcionais e multivaloradas se, e somente se,

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

Podemos usar uma pequena modifica√ß√£o do Algoritmo 16.5 para desenvolver o Algoritmo 16.7, que cria uma decomposi√ß√£o de jun√ß√£o n√£o aditiva para esquemas de rela√ß√£o que est√£o na 4FN (em vez da FNBC). Assim como no Algoritmo 16.5, o Algoritmo 16.7 n√£o necessariamente produz uma decomposi√ß√£o que preserva DFs.

Algoritmo  16.7. Decomposi√ß√£o  relacional  em rela√ß√µes  4FN  com  propriedade  de  jun√ß√£o  n√£o aditiva

Entrada: uma rela√ß√£o universal R e um conjunto de depend√™ncias funcionais e multivaloradas F.

- 1. Defina D := { R };
- 2. Enquanto houver um esquema de rela√ß√£o Q em D que n√£o esteja na 4FN, {   escolha um esquema de rela√ß√£o Q em D que n√£o est√° na 4FN; che  uma a MVD n√£o  trivial X ‚Üí ‚Üí Y em Q que viola a 4FN; ubstitua s Q em D por dois esquemas de rela√ß√£o ( Q -Y ) e ( X ‚à™ Y ); };

## 16.6 Outras depend√™ncias e formas normais

J√° apresentamos outro tipo de depend√™ncia, chamada depend√™ncia de jun√ß√£o (DJ) na Se√ß√£o 15.7. Ela surge quando uma rela√ß√£o pode ser decomposta em um conjunto de rela√ß√µes projetadas, que podem ser reunidas de volta para gerar a rela√ß√£o original. Depois de estabelecer a DJ, definimos a quinta forma normal com base nela, na Se√ß√£o 15.7. Na presente se√ß√£o, apresentaremos alguns outros tipos de depend√™ncias que foram identificadas.

## 16.6.1 Depend√™ncias de inclus√£o

As depend√™ncias de inclus√£o foram definidas a fim de formalizar dois tipos de restri√ß√µes inter-relacionais:

- ¬Ñ A restri√ß√£o de chave estrangeira (ou integridade  referencial)  n√£o  pode  ser  especificada como uma depend√™ncia funcional ou multivalorada, pois se relaciona aos atributos entre as rela√ß√µes.
- ¬Ñ A restri√ß√£o entre duas rela√ß√µes que representam  um  relacionamento  de  classe/subclasse (ver cap√≠tulos 8 e 9) tamb√©m n√£o tem defini√ß√£o formal nos termos das depend√™ncias funcionais, multivaloradas e de jun√ß√£o.

Defini√ß√£o. Uma depend√™ncia de inclus√£o R X . &lt; S Y . entre  dois  conjuntos  de  atributos  X do esquema de rela√ß√£o R , e Y do esquema de rela√ß√£o S - especifica a restri√ß√£o de que, a qualquer momento espec√≠fico em que   for um estado de r rela√ß√£o de R e s um estado de rela√ß√£o de S , devemos ter

œÄ X ( r R ( )) ‚äÜ œÄ Y ( s S ( ))

O relacionamento ‚äÜ (subconjunto) n√£o necessariamente precisa ser um subconjunto pr√≥prio. Obviamente,  os  conjuntos  de  atributos  em  que  a  depend√™ncia de inclus√£o √© especificada X de R e Y de S - devem ter o mesmo n√∫mero de atributos. Al√©m disso, os dom√≠nios para cada par de atributos correspondentes  devem  ser  compat√≠veis.  Por  exemplo,  se X = { A 1 , A 2 , ..., A n } e Y = { B 1 , B 2 , ..., B n }, uma correspond√™ncia poss√≠vel √© ter dom( A i ) compat√≠vel com dom( B i ) para 1 ‚â§ i ‚â§ n . Nesse caso, dizemos que A i corresponde a B i .

Por  exemplo,  podemos  especificar  as  seguintes depend√™ncias de inclus√£o no esquema relacional da Figura 15.1:

DEPARTAMENTO.Cpf\_gerente &lt; FUNCIONARIO.

Cpf

TRABALHA\_EM.Fcpf &lt; FUNCIONARIO.Cpf UNCIONARIO.Dnr F &lt; DEPARTAMENTO.Dnumero PROJETO.Dnum &lt; DEPARTAMENTO.Dnumero TRABALHA\_EM.Projr &lt; PROJETO.Projnumero OCALIZACAO\_DEP .Dnumero L &lt; DEPARTAMENTO. Dnumero

Todas essas  depend√™ncias  de  inclus√£o  representam restri√ß√µes de integridade referencial . Tamb√©m podemos usar depend√™ncias de inclus√£o para representar relacionamentos de classe/subclasse . Por exemplo, no esquema relacional da Figura 9.6, podemos especificar as seguintes depend√™ncias de inclus√£o:

FUNCIONARIO.Cpf &lt; PESSOA.Cpf TITULO\_ALUNO.Cpf &lt; PESSOA.Cpf

ALUNO.Cpf &lt; PESSOA.Cpf

Assim como outros tipos de depend√™ncias, existem regras de infer√™ncia de depend√™ncia de inclus√£o - RIDI  IDIRs ( -Inclusion Dependency Inference Rules ). Veja tr√™s exemplos a seguir:

RIDI1 (reflexividade): R X . &lt; R X . .

RIDI2 (correspond√™ncia  de  atributo):  se R X . &lt; S Y . , onde X = { A 1 , A 2 , ..., A n } e Y = { B 1 , B 2 , ..., B n }  e A i corresponde  a B i ,  ent√£o R A . i &lt; S B . i para 1 ‚â§ i ‚â§ n .

RIDI3 (transitividade): se R X . &lt; S Y . e S Y . &lt; T Z . , ent√£o R X . &lt; T Z . .

As regras de infer√™ncia anteriores foram consideradas leg√≠timas e completas para depend√™ncias de inclus√£o. At√© aqui, nenhuma forma normal foi desenvolvida com base nas depend√™ncias de inclus√£o.

## 16.6.2 Depend√™ncias de modelo

Depend√™ncias de modelo (ou template) oferecem uma t√©cnica para representar restri√ß√µes em rela√ß√µes que normalmente n√£o t√™m defini√ß√µes f√°ceis e formais. N√£o importa quantos tipos de depend√™ncias desenvolvemos,  alguma  restri√ß√£o  peculiar  poder√°  surgir com  base  na  sem√¢ntica  dos  atributos  nas  rela√ß√µes que n√£o podem ser representadas por qualquer uma delas. A ideia por tr√°s das depend√™ncias de modelo √© especificar um modelo - ou exemplo - que define cada restri√ß√£o ou depend√™ncia.

Existem dois tipos de modelos: modelos de gera√ß√£o de tupla e modelos de gera√ß√£o de restri√ß√£o. Um consiste em uma s√©rie de tuplas de hip√≥tese que servem para mostrar um exemplo das tuplas que podem aparecer em uma ou mais rela√ß√µes. A outra parte do modelo √© a conclus√£o  do  modelo .  Para  modelos  de gera√ß√£o de tupla, a conclus√£o √© um conjunto de tuplas que tamb√©m deve existir nas rela√ß√µes se houver tuplas de hip√≥tese. Para modelos de gera√ß√£o de restri√ß√£o, a conclus√£o do modelo √© uma condi√ß√£o que deve ser mantida nas tuplas de hip√≥tese. Ao usar modelos de gera√ß√£o de restri√ß√£o, podemos definir as restri√ß√µes sem√¢nticas - aquelas que est√£o al√©m do escopo do modelo relacional em rela√ß√£o a sua linguagem de defini√ß√£o de dados e nota√ß√£o.

modelos. A Figura 16.6 mostra como podemos especificar a restri√ß√£o de que o sal√°rio do funcion√°rio n√£o pode ser maior que o sal√°rio de seu supervisor direto no esquema de rela√ß√£o FUNCIONARIO da Figura 3.5.

## 16.6.3 Depend√™ncias funcionais baseadas em fun√ß√µes aritm√©ticas e procedimentos

√Äs vezes, alguns atributos em uma rela√ß√£o podem estar relacionados por meio de alguma fun√ß√£o aritm√©tica  ou  um  relacionamento  funcional  mais complicado. Contanto que um valor exclusivo de Y esteja associado a cada X , ainda podemos considerar que a DF X ‚Üí Y existe. Por exemplo, na rela√ß√£o

ITEM\_PEDIDO ( Pedido\_num , Item\_num , Quanti -dade , Preco\_unitario  Total\_item , , Desconto\_preco )

cada tupla representa um item de um pedido com determinada quantidade, e o pre√ßo por unidade para esse item. Nessa rela√ß√£o, ( Quantidade, Preco\_unitario ) ‚Üí Total\_item pela f√≥rmula

Total\_item = Preco\_unitario √© Quantidade.

A Figura 16.5 mostra como podemos definir depend√™ncias funcionais, multivaloradas e de inclus√£o por

Logo, existe um valor exclusivo para Total\_item para cada par ( Quantidade, Preco\_unitario ) e, portanto,  est√°  de  acordo  com  a  defini√ß√£o  de  depend√™ncia funcional.



Figura 16.5

Modelos para alguns tipos comuns de depend√™ncias. (a) Modelo para depend√™ncia funcional X ‚Üí Y. (b) Modelo para a depend√™ncia multivalorada X ‚Üí ‚Üí Y. (c) Modelo para a depend√™ncia de inclus√£o R.X &lt; S.Y.

FUNCIONARIO = {Nome, Cpf,  . . . , Salario, Cpf\_supervisor}

## Hipotese

Conclus¬™o

Figura 16.6

| a   | b   | c     | d   |
|-----|-----|-------|-----|
| e   | d   | f     | g   |
|     |     | c < f |     |

Modelos para a restri√ß√£o de que o sal√°rio de um funcion√°rio deve ser menor que o sal√°rio do supervisor.

Al√©m do mais, pode haver um procedimento que leve em considera√ß√£o os descontos por quantidade, o tipo de item, e assim por diante, e calcule um pre√ßo com desconto para a quantidade total pedida para esse item. Portanto, podemos dizer

( Item# , Quantidade , Preco\_unitario ) ‚Üí Descon- to\_preco , ou

( Item# , Quantidade , Total\_item ) ‚Üí Desconto\_preco.

Para verificar a DF acima, um procedimento mais complexo CALCULAR\_PRECO\_TOTAL pode ser colocado em a√ß√£o. Embora os tipos mostrados de DFs estejam tecnicamente presentes na maioria das rela√ß√µes, eles n√£o recebem aten√ß√£o em particular durante a normaliza√ß√£o.

## 16.6.4 orma normal de dom√≠nio-chave F

N√£o existe uma regra estrita sobre a defini√ß√£o de formas normais apenas at√© a 5FN. Historicamente, o processo de normaliza√ß√£o e o processo de descoberta de depend√™ncias indesej√°veis eram executados at√© a 5FN, mas tem sido poss√≠vel definir formas normais mais rigorosas que levam em conta outros tipos de depend√™ncias e restri√ß√µes. A ideia por tr√°s da forma normal de dom√≠nio-chave (FNDC) √© especificar (pelo menos, de maneira te√≥rica) a forma normal definitiva que considera todos os tipos poss√≠veis de depend√™ncias e restri√ß√µes. Um esquema de rela√ß√£o √© considerado na FNDC se todas as restri√ß√µes e depend√™ncias que devem ser mantidas nos estados v√°lidos da rela√ß√£o puderem ser impostas simplesmente ao impor as restri√ß√µes de dom√≠nio e restri√ß√µes de chave sobre a rela√ß√£o. Para uma rela√ß√£o na FNDC, torna-se muito simples impor todas as restri√ß√µes baseadas em dados simplesmente verificando se cada valor de atributo em uma tupla tem o dom√≠nio apropriado e se cada restri√ß√£o de chave √© imposta.

Contudo, devido √† dificuldade de incluir restri√ß√µes  complexas em uma rela√ß√£o FNDC, sua utilidade  pr√°tica  √©  limitada,  pois  pode  ser  muito  dif√≠cil  especificar  restri√ß√µes  de  integridade  gerais.  Por exemplo,  considere  uma  rela√ß√£o CARRO  (Marca, Vnum) (onde Vnum √© o n√∫mero de identifica√ß√£o do ve√≠culo)  e  outra  rela√ß√£o FABRICANTE (Vnum, Pais) (em  que Pais √©  o  pa√≠s  de  fabrica√ß√£o).  Uma  restri√ß√£o geral pode ter a seguinte forma: se a marca for 'Toyota' ou 'Lexus', ent√£o o primeiro caractere da Vnum √© 'J' se o pa√≠s de fabrica√ß√£o for 'Jap√£o'; se a marca for 'Honda' ou 'Acura', o segundo caractere da Vnum √© um 'J' se o pa√≠s de fabrica√ß√£o for 'Jap√£o' . N√£o  existe  um  modo  simplificado  de  representar essas restri√ß√µes al√©m de escrever um procedimento (ou asser√ß√µes gerais) para test√°-los. O procedimento CALCULAR\_PRECO\_TOTAL √© um exemplo desses procedimentos necess√°rios para impor uma restri√ß√£o de integridade apropriada.

## Resumo

Neste  cap√≠tulo,  apresentamos  outro  conjunto  de t√≥picos relacionados a depend√™ncias, uma discuss√£o da decomposi√ß√£o e diversos algoritmos relacionados a eles e tamb√©m √† normaliza√ß√£o. Na Se√ß√£o 16.1, apresentamos regras de infer√™ncia para depend√™ncias funcionais (DFs), a no√ß√£o de fechamento de um atributo, fechamento de um conjunto  de  depend√™ncias  funcionais,  equival√™ncia entre conjuntos de depend√™ncias funcionais e algoritmos para  encontrar  o  fechamento  de  um  atributo  (Algoritmo 16.1) e a cobertura m√≠nima de um conjunto de DFs (Algoritmo 16.2). Depois, discutimos duas propriedades importantes das decomposi√ß√µes: a propriedade de jun√ß√£o n√£o aditiva e a propriedade de preserva√ß√£o de depend√™ncia. Um algoritmo para testar a decomposi√ß√£o n√£o aditiva (Algoritmo 16.3) e um teste mais simples para verificar a  propriedade  sem  perdas  das  decomposi√ß√µes  bin√°rias (Propriedade NJB) foram descritos. Depois, abordamos o projeto relacional pela s√≠ntese, com base em um conjunto de depend√™ncias funcionais dadas. Os algoritmos de s√≠ntese relacional (como os algoritmos 16.4 e 16.6) criam rela√ß√µes 3FN de um esquema de rela√ß√£o universal com base em determinado conjunto de depend√™ncias funcionais que foram especificadas pelo projetista do banco de dados. Os algoritmos de decomposi√ß√£o relacional (como os algoritmos 16.5 e 16.7) criam rela√ß√µes FNBC (ou 4FN) pela decomposi√ß√£o n√£o aditiva sucessiva de rela√ß√µes n√£o normalizadas para duas rela√ß√µes componentes de cada vez. Vimos que √© poss√≠vel sintetizar esquemas de rela√ß√£o 3FN que atendem a ambas as propriedades; por√©m, no caso das FNBC, √© poss√≠vel visar apenas a n√£o aditividade das jun√ß√µes - a preserva√ß√£o da depend√™ncia n√£o pode ser garantida. Se o projetista tiver de visar a uma dessas duas, a condi√ß√£o de jun√ß√£o n√£o aditiva √© uma necessidade absoluta. Na Se√ß√£o 16.4, mostramos como certas necessidades surgem em uma cole√ß√£o de rela√ß√µes devido a valores nulos que podem existir em rela√ß√µes, apesar de estas estarem individualmente na 3FN ou na FNBC. √Äs vezes, quando a decomposi√ß√£o √© indevidamente levada muito adiante, certas 'tuplas suspensas' podem acontecer, as quais n√£o participam dos resultados das jun√ß√µes e, portanto, podem se tornar invis√≠veis. Tamb√©m mostra-

mos como √© poss√≠vel ter projetos alternativos que atendem a determinada forma normal desejada.

Depois, revisamos as depend√™ncias multivaloradas (MVDs) na Se√ß√£o 16.5, as quais surgem de uma combina√ß√£o impr√≥pria de dois ou mais atributos multivalorados independentes na mesma rela√ß√£o, e que resultam em uma expans√£o combinat√≥ria das tuplas usadas para definir a quarta forma normal (4FN). Discutimos as regras de infer√™ncia aplic√°veis √†s MVDs e abordamos a import√¢ncia da 4FN. Finalmente, na Se√ß√£o 16.6, discutimos as depend√™ncias de inclus√£o, que s√£o utilizadas para especificar a integridade referencial e restri√ß√µes de classe/subclasse, e depend√™ncias de modelo, que podem ser usadas para especificar quaisquer tipos de restri√ß√µes. Indicamos a necessidade de fun√ß√µes aritm√©ticas ou procedimentos mais complexos para impor certas restri√ß√µes de depend√™ncia funcional. Conclu√≠mos com uma breve discuss√£o da forma normal de dom√≠nio-chave (FNDC).

## Perguntas de revis√£o

- 16.1. Qual √© o papel das regras de infer√™ncia de Armstrong (regras de infer√™ncia de RI1 a RI3) no desenvolvimento da teoria do projeto relacional?
- 16.2. O que significa a completude e confian√ßa das regras de infer√™ncia de Armstrong?
- 16.3. O que significa o fechamento de um conjunto de depend√™ncias funcionais? Ilustre com um exemplo.
- 16.4. Quando dois conjuntos de depend√™ncias funcionais s√£o equivalentes? Como podemos determinar sua equival√™ncia?
- 16.5. O que √© um conjunto m√≠nimo de depend√™ncias funcionais? Cada conjunto de depend√™ncias tem um conjunto equivalente m√≠nimo? Ele √© sempre exclusivo?
- 16.6. O  que  significa  a  condi√ß√£o  de  preserva√ß√£o  de atributo em uma decomposi√ß√£o?
- 16.7. Por que as formas normais isoladas s√£o insuficientes como uma condi√ß√£o para um bom projeto de esquema?
- 16.8. O que √© a propriedade de preserva√ß√£o de depend√™ncia para uma decomposi√ß√£o? Por que ela √© importante?
- 16.9. Por que n√£o garantimos que os esquemas de rela√ß√£o FNBC ser√£o produzidos pelas decomposi√ß√µes de preserva√ß√£o de depend√™ncia dos esquemas de rela√ß√£o n√£o FNBC? D√™ um contraexemplo para ilustrar esse ponto.
- 16.10. O que √© a propriedade de jun√ß√£o sem perda (ou n√£o aditiva) de uma decomposi√ß√£o? Por que ela √© importante?
- 16.11. Entre as propriedades da preserva√ß√£o de depend√™ncia e 'sem perdas', qual deve definitivamente ser satisfeita? Por qu√™?
- 16.12. Discuta os problemas do valor NULL e da tupla suspensa.
- 16.13. Ilustre como o processo de cria√ß√£o de rela√ß√µes na primeira forma normal pode levar a depend√™ncias multivaloradas. Como a primeira normaliza√ß√£o deve ser feita corretamente de modo que as MVDs sejam evitadas?
- 16.14. Que tipos de restri√ß√µes as depend√™ncias de inclus√£o pretendem representar?
- 16.15. Como as depend√™ncias de modelo diferem dos outros tipos de depend√™ncias que discutimos?
- 16.16. Por que a forma normal de dom√≠nio-chave (FNDC) √© conhecida como a forma normal definitiva?

## Exerc√≠cios

- 16.17. Mostre que os esquemas de rela√ß√£o produzidos pelo Algoritmo 16.4 est√£o na 3FN.
- 16.18.

Mostre que, se a matriz S resultante do Algoritmo 16.3 n√£o tiver uma linha contendo todos os s√≠mbolos a , projetar S na decomposi√ß√£o e junt√°-la  novamente  sempre  produzir√°  pelo  menos uma tupla falsa.

- 16.19. Mostre que os esquemas de rela√ß√£o produzidos pelo Algoritmo 16.5 est√£o na FNBC.
- 16.20. Mostre que os esquemas de rela√ß√£o produzidos pelo Algoritmo 16.6 est√£o na 3FN.
- 16.21. Especifique  uma  depend√™ncia  de  modelo  para depend√™ncias de jun√ß√£o.
- 16.22. Especifique  todas  as  depend√™ncias  de  inclus√£o para o esquema relacional da Figura 3.5.
- 16.23. Prove que uma depend√™ncia funcional satisfaz a defini√ß√£o formal da depend√™ncia multivalorada.
- 16.24. Considere o exemplo de normaliza√ß√£o da rela√ß√£o LOTES nas se√ß√µes 15.4 e 15.5. Determine se a decomposi√ß√£o de LOTES em { LOTES1AX, LOTES1AY, LOTES1B, LOTES2 } tem  uma propriedade de jun√ß√£o sem perdas, aplicando o Algoritmo 16.3 e tamb√©m usando o teste sob a Propriedade NJB.
- 16.25. Mostre  como  as  MVDs Fnome ‚Üí ‚Üí Projnome e Fnome ‚Üí ‚Üí Dnome da Figura 15.5(a) podem surgir  durante  a  normaliza√ß√£o  para  a  1FN  de uma rela√ß√£o,  na  qual  os  atributos Projnome e Nome\_dependente s√£o multivalorados.
- 16.26. Aplique o Algoritmo 16.2(a) √† rela√ß√£o do Exerc√≠cio 15.24 para determinar uma chave para R . Crie um conjunto m√≠nimo de depend√™ncias G que seja equivalente a F e aplique o algoritmo de s√≠ntese (Algoritmo 16.6) para decompor R em rela√ß√µes 3FN.
- 16.27. Repita o Exerc√≠cio 16.26 para as depend√™ncias funcionais do Exerc√≠cio 15.25.
- 16.28. Aplique o algoritmo de decomposi√ß√£o (Algoritmo 16.5) √† rela√ß√£o R e o conjunto de depend√™ncias F ao Exerc√≠cio 15.24. Repita para as depend√™ncias G no Exerc√≠cio 15.25.
- 16.29.
- Aplique  o  Algoritmo  16.2(a)  √†s  rela√ß√µes  nos exerc√≠cios  15.27  e  15.28  para  determinar  uma

16.30.

16.31.

16.32.

chave  para R .  Aplique  o  algoritmo  de  s√≠ntese (Algoritmo 16.6) para decompor R em rela√ß√µes 3FN e o algoritmo de decomposi√ß√£o (Algoritmo 16.5) para decompor R em rela√ß√µes FNBC.

Escreva programas que implementem os algoritmos 16.5 e 16.6.

Considere  as  seguintes  decomposi√ß√µes  para  o esquema de rela√ß√£o R do  Exerc√≠cio 15.24. Determine se cada decomposi√ß√£o tem (1) a propriedade de preserva√ß√£o de depend√™ncia, e (2) a propriedade de jun√ß√£o sem perdas, com rela√ß√£o a F . Determine tamb√©m em qual forma normal cada rela√ß√£o na decomposi√ß√£o se encontra.

- a. D 1 = { R  R 1 , 2 , R 3 , R 4 , R 5 } ; R 1 = { A  B  C , , } , R 2 = { A  D  E , , } , R 3 = { B  F , } , R 4 = { F , G H , } , R 5 = { D I J , , }
- b. D 2 = { R  R 1 , 2 , R 3 } ; R 1 = { A  B  C  D  E , , , , } , R 2 = { B  F  G  H , , , } , R 3 = { D  I  J , , }
- c. D 3 = { R  R 1 , 2 , R 3 , R 4 , R 5 } ; R 1 = { A  B  C  D , , , } , R 2 = { D  E , } , R 3 = { B  F , } , R 4 = { F , G H , } , R 5 = { D I J , , }

Considere a rela√ß√£o GELADEIRA (Modelo\_num, Ano, Preco, Fabrica, Cor) , que √© abreviada como GELADEIRA  M A P F C ( , , , , ), e o seguinte conjunto F de depend√™ncias funcionais: F = { M ‚Üí F , { M , A } ‚Üí P F , ‚Üí C }

- a. Avalie cada um dos seguintes como uma chave candidata para GELADEIRA, dando motivos pelos quais ela pode ou n√£o pode ser uma chave: { M }, { M A , }, { M C , }.
- b. Com base na determina√ß√£o de chave acima, indique se a rela√ß√£o GELADEIRA est√° na 3FN e na FNBC, dando motivos apropriados.
- c. Considere  a  decomposi√ß√£o  de GELADEIRA em D = { R 1 ( M A P , , ), R 2 ( M F C , , )}. Essa decomposi√ß√£o √© sem perdas? Mostre por qu√™. (Voc√™ pode consultar o teste sob a Propriedade NJB na Se√ß√£o 16.2.4.)

## Exerc√≠cios de laborat√≥rio

Nota: estes exerc√≠cios usam o sistema DBD ( Data Base Designer ) que √© descrito no manual do laborat√≥rio. O esquema relacional R e o conjunto de depend√™ncias funcionais F precisam  ser  codificados  como  listas.  Como um exemplo, R e F para o Problema 15.24 s√£o codificados como:

R = [ a  b  c  d  e  f  g  h  i  j , , , , , , , , , F = [[[ a  b , ],[ c ]], [[ a ],[ d , e ]], [[ b ],[ f ]], [[ f ],[ g , h ]], [[ d ],[ ,  ]]] i j

]

Como o DBD √© implementado em Prolog, o uso de termos em mai√∫sculas √© reservado para vari√°veis na linguagem e, portanto, constantes min√∫sculas s√£o utilizadas para codificar os atributos. Para outros detalhes sobre o uso do sistema DBD, consulte o manual do laborat√≥rio.

16.33. Usando o sistema DBD, verifique suas respostas para os seguintes exerc√≠cios:

a. 16.24

b. 16.26

c. 16.27

d. 16.28

e. 16.29

f. 16.31 (a) e (b)

g. 16.32 (a) e (c)

## Bibliografia selecionada

Os livros de Maier (1983) e Atzeni e De Antonellis (1993) incluem uma discuss√£o abrangente sobre a teoria da depend√™ncia relacional. O algoritmo de decomposi√ß√£o (Algoritmo 16.5) √© atribu√≠do a Bernstein (1976). O algoritmo  16.6  √©  baseado  no  algoritmo  de  normaliza√ß√£o apresentado em Biskup et al. (1979). Tsou e Fischer (1982) d√£o um algoritmo de tempo polinomial para a decomposi√ß√£o da FNBC.

A teoria da preserva√ß√£o de depend√™ncia e jun√ß√µes sem perdas √© explicada em Ullman (1988), onde aparecem provas de alguns dos algoritmos discutidos aqui. A propriedade de jun√ß√£o sem perda √© analisada em Aho et al. (1979). Os algoritmos para determinar as chaves de uma rela√ß√£o com base em depend√™ncias funcionais s√£o dados em Osborn (1977); o teste para a FNBC √© discutido em Osborn (1979). O teste para a 3FN √© discutido em Tsou e Fischer (1982). Os algoritmos para projetar rela√ß√µes FNBC s√£o dados em Wang (1990) e Hernandez e Chan (1991).

As  depend√™ncias  multivaloradas  e  a  quarta  forma normal s√£o definidas em Zaniolo (1976) e Nicolas (1978). Muitas das formas normais avan√ßadas s√£o atribu√≠das a Fagin: a quarta forma normal em Fagin (1977), FNPJ em Fagin (1979)  e  FNDC  em  Fagin  (1981).  O conjunto de regras confi√°veis e completas para depend√™ncias funcionais e multivaloradas foi dado por Beeri et al. (1977). As depend√™ncias de jun√ß√£o s√£o discutidas por Rissanen (1977) e Aho et al. (1979). As regras de infer√™ncia para depend√™ncias de jun√ß√£o s√£o dadas por Sciore (1982). As depend√™ncias de inclus√£o s√£o discutidas por Casanova et al. (1981) e analisadas ainda mais em Cosmadakis et al.  (1990).  Seu  uso  na  otimiza√ß√£o de esquemas relacionais √© discutido em Casanova et al. (1989). As depend√™ncias de modelo s√£o discutidas por Sadri e Ullman (1982). Outras depend√™ncias s√£o discutidas em Nicolas (1978), Furtado (1978) e Mendelzon e  Maier  (1979).  Abiteboul  et  al.  (1995)  oferecem  um tratamento  te√≥rico  de  muitas  das  ideias  apresentadas neste cap√≠tulo e no Cap√≠tulo 15.



Estruturas de arquivo, indexa√ß√£o e hashing



## Armazenamento de disco, estruturas de arquivo b√°sicas e hashing

O s bancos de dados s√£o armazenados fisicamente como arquivos de registros, que em geral ficam em discos magn√©ticos. Este cap√≠tulo e o seguinte tratam da organiza√ß√£o dos bancos de dados em locais de armazenamento e as t√©cnicas para acess√°-los de modo  eficiente  usando  diversos  algoritmos,  alguns dos  quais  exigindo  estruturas  de  dados  auxiliares, chamadas √≠ndices . Essas estruturas costumam ser conhecidas como estruturas f√≠sicas de arquivo de banco de  dados ,  e  est√£o  no  n√≠vel  f√≠sico  da  arquitetura  de tr√™s esquemas descrita no Cap√≠tulo 2. Come√ßamos a Se√ß√£o 17.1 introduzindo os conceitos de hierarquias de armazenamento de computador e como elas s√£o usadas nos sistemas de banco de dados. A Se√ß√£o 17.2 √© dedicada a uma descri√ß√£o dos dispositivos de armazenamento de disco magn√©tico e suas caracter√≠sticas, e tamb√©m descrevemos rapidamente os dispositivos de armazenamento de fita magn√©tica. Depois de discutir diferentes tecnologias de armazenamento, voltamos nossa aten√ß√£o para os m√©todos para organizar fisicamente os dados nos discos. A Se√ß√£o 17.3 aborda  a  t√©cnica  de  buffering  duplo,  que  √©  usada  para agilizar a recupera√ß√£o de m√∫ltiplos blocos de disco. Na Se√ß√£o 17.4, discutimos diversas maneiras de formatar e armazenar registros de arquivo no disco. A Se√ß√£o 17.5 discute os diversos tipos de opera√ß√µes que s√£o normalmente aplicadas aos registros do arquivo. Apresentamos tr√™s m√©todos principais para organizar registros de arquivo no disco: registros desordenados, na Se√ß√£o 17.6; registros ordenados, na Se√ß√£o 17.7; e registros com hashing, na Se√ß√£o 17.8.

A Se√ß√£o 17.9  apresenta  rapidamente  os  arquivos de registros mistos e outros m√©todos principais para organizar registros, como as B-trees. Estas s√£o particularmente  relevantes  para  o  armazenamento de bancos de dados orientados a objeto, que discutimos no Cap√≠tulo 11. A Se√ß√£o 17.10 descreve o RAID

( Redundant Arrays of Inexpensive (ou Independent) Disks )  -  uma arquitetura de sistema de armazenamento de dados que normalmente √© usada em grandes organiza√ß√µes para obter melhor confiabilidade e desempenho.  Por  fim,  na  Se√ß√£o  17.11,  descrevemos tr√™s  desenvolvimentos  na  √°rea  de  sistemas  de  armazenamento: √°rea  de  armazenamento  em  rede ( SAN , do  ingl√™s, Storage  Area  Networks ),  armazenamento conectado √† rede ( NAS , do ingl√™s, Network-Attached Storage )  e  iSCSI  ( Internet  SCSI -Small  Computer System Interface ), a tecnologia mais recente, que torna as redes de √°rea de armazenamento mais acess√≠veis sem o uso da infraestrutura canais de fibra e, portanto, est√° obtendo grande aceita√ß√£o na ind√∫stria. No final do cap√≠tulo h√° um resumo. No Cap√≠tulo 18, discutimos as t√©cnicas para criar estruturas de dados auxiliares, chamadas de √≠ndices, que agilizam a busca e a recupera√ß√£o  de  registros.  Essas  t√©cnicas  envolvem  o armazenamento de dados auxiliares, chamados arquivos de √≠ndice, al√©m dos pr√≥prios registros do arquivo.

Os  cap√≠tulos  17  e  18  podem  ser  folheados  ou mesmo omitidos pelos leitores que j√° estudaram organiza√ß√µes e indexa√ß√£o de arquivos em outro curso. O material abordado aqui, em particular as se√ß√µes 17.1 a 17.8, √© necess√°rio para se entender os cap√≠tulos 19 e 20, que tratam do processamento, da otimiza√ß√£o de consulta e do ajuste do banco de dados para melhorar o desempenho das consultas.

## 17.1 ntrodu√ß√£o I

A cole√ß√£o de dados que comp√µem um banco de dados computadorizado deve ser armazenada fisicamente em algum meio de armazenamento no computador. O software de SGBD pode ent√£o recuperar, atualizar e processar esses dados conforme a necessidade. A m√≠dia de armazenamento de computador

forma uma hierarquia de armazenamento que inclui duas categorias principais:

- ¬Ñ Armazenamento prim√°rio. Essa categoria inclui a m√≠dia de armazenamento que pode ser operada diretamente pela unidade central de processamento (CPU) do computador, como a  mem√≥ria  principal  do  computador  e  mem√≥rias cache menores, por√©m mais r√°pidas. O  armazenamento  prim√°rio  normalmente oferece  acesso  r√°pido  aos  dados,  mas  tem capacidade de armazenamento limitada. Embora  as  capacidades  da  mem√≥ria  principal estejam  crescendo  rapidamente  nos  √∫ltimos anos,  elas  ainda  s√£o  mais  caras  e  t√™m  menos capa  cidade de armazenamento do que os dispositivos  de  armazenamento secund√°rios e terci√°rios.
- ¬Ñ Armazenamento secund√°rio e terci√°rio. Essa categoria  inclui discos magn√©ticos,  discos √≥pticos  (CD-ROMs,  DVDs  e  outros  meios de  armazenamento  semelhantes)  e  fitas.  As unidades  de  disco  r√≠gido  s√£o  classificadas como armazenamento secund√°rio, enquanto a m√≠dia remov√≠vel, como discos √≥pticos e as fitas, √© considerada armazenamento terci√°rio. Esses dispositivos costumam ter uma capacidade maior, menor custo e oferecem acesso mais lento aos dados do que os dispositivos de  armazenamento  prim√°rios.  Os  dados  no armazenamento secund√°rio ou terci√°rio n√£o podem  ser processados diretamente pela CPU;  primeiro,  eles  precisam  ser  copiados para  o  armazenamento  prim√°rio  e,  depois, processados pela CPU.

Primeiro,  damos  uma  vis√£o  geral  dos  diversos dispositivos de armazenamento usados para armazenamento prim√°rio e secund√°rio na Se√ß√£o 17.1.1 e, depois, discutimos como os bancos de dados normalmente s√£o tratados na hierarquia de armazenamento na Se√ß√£o 17.1.2.

## 17.1.1 Hierarquias de mem√≥ria e dispositivos de armazenamento

Em  um  sistema  de  computador  moderno,  os dados residem e s√£o transportados por uma hierarquia  de  meios  de  armazenamento.  A  mem√≥ria  de velocidade mais alta √© a mais cara e, portanto, est√° dispon√≠vel com a menor capacidade. A mem√≥ria de velocidade  mais  lenta  √©  o  armazenamento  em  fita off-line, que basicamente est√° dispon√≠vel em capacidade de armazenamento indefinida.

No n√≠vel  de  armazenamento  prim√°rio ,  a  hierarquia de mem√≥ria inclui, no extremo mais caro, a mem√≥ria cache ,  que  √©  uma  RAM  ( Random Access Memory ) est√°tica. A mem√≥ria cache normalmente √© usada pela CPU para agilizar a execu√ß√£o de instru√ß√µes de programa usando t√©cnicas como pr√©-busca e pipelining . O pr√≥ximo n√≠vel de armazenamento prim√°rio  √©  a  DRAM  ( Dynamic RAM),  que  oferece  a √°rea de trabalho principal para a CPU, para manter instru√ß√µes de programa e dados. Ela √© popularmente  chamada  de mem√≥ria principal .  A  vantagem  da DRAM √© seu baixo custo, que continua a diminuir; a desvantagem √© sua volatilidade 1  e menor velocidade em compara√ß√£o com a RAM est√°tica. No n√≠vel  de armazenamento secund√°rio e terci√°rio , a hierarquia inclui discos magn√©ticos, bem como armazenamento em massa na forma de dispositivos de CD-ROM ( Compact Disk-Read-Only Memory ) e DVD ( Digital Video Disk ou Digital Versatile Disk ) e, por fim, fitas  no  extremo  mais  barato  da  hierarquia.  A capacidade de armazenamento √© medida em kilobytes (Kbyte ou 1.000 bytes), megabytes (MB ou 1 milh√£o de bytes), gigabytes (GB ou 1 bilh√£o de bytes) e at√© mesmo  terabytes  (1.000  GB).  A  palavra  petabyte (1.000 terabytes ou 10 ÔÉ©ÔÉ© 15 bytes) agora est√° se tornando relevante no contexto de reposit√≥rios muito grandes de dados na f√≠sica, astronomia, ci√™ncias terrestres e outras aplica√ß√µes cient√≠ficas.

Os  programas  residem  e  s√£o  executados  na DRAM. Em geral, grandes bancos de dados permanentes residem no armazenamento secund√°rio (discos magn√©ticos) e partes do banco de dados s√£o lidas e escritas de buffers na mem√≥ria principal conforme a necessidade. Atualmente, os computadores pessoais e as esta√ß√µes de trabalho possuem grandes mem√≥rias principais  de  centenas  de  megabytes  de  RAM  ou DRAM, de modo que est√° se tornando poss√≠vel carregar uma grande parte do banco de dados na mem√≥ria principal. Oito a 16 GB de mem√≥ria principal em um √∫nico servidor est√° se tornando algo comum. Em alguns casos, bancos de dados inteiros podem ser mantidos na mem√≥ria principal (com uma c√≥pia de backup no disco magn√©tico), levando a bancos de dados de mem√≥ria principal . Estes s√£o particularmente √∫teis em aplica√ß√µes de tempo real que exigem tempos de resposta extremamente r√°pidos. Um exemplo s√£o as  aplica√ß√µes  de  comuta√ß√£o de telefone, que armazenam bancos de dados que cont√™m informa√ß√µes de roteamento e linha na mem√≥ria principal.

Entre  a  DRAM  e  o  armazenamento  em  disco magn√©tico,  outra  forma  de  mem√≥ria,  a mem√≥ria flash , est√° se tornando comum, principalmente porque ela √© n√£o vol√°til. As mem√≥rias flash s√£o de alta

1 A mem√≥ria vol√°til normalmente perde seu conte√∫do em caso de falta de energia, mas com a mem√≥ria n√£o vol√°til isso n√£o acontece.

densidade,  alto  desempenho,  e  usam  a  tecnologia EEPROM ( Electrically Erasable Programmable Read-Only Memory ). A vantagem da mem√≥ria flash √© a velocidade de acesso r√°pida; a desvantagem √© que um bloco inteiro  precisa  ser  apagado  e  gravado  simultaneamente. As placas de mem√≥ria flash est√£o aparecendo como o meio de armazenamento de dados em aparelhos dom√©sticos com capacidades variando de alguns megabytes at√© alguns gigabytes. Est√£o presentes em c√¢meras, MP3 players, telefones celulares, PDAs, e assim por diante. Unidades flash USB ( Universal Serial Bus )  se  tornaram o meio mais port√°til para transportar dados entre computadores pessoais; elas  t√™m  um  dispositivo  de  armazenamento de mem√≥ria flash integrado a uma interface USB.

Discos de CD-ROM armazenam dados opticamente e s√£o lidos por um laser. Os CD-ROMs cont√™m dados pr√©-gravados que n√£o podem ser modificados. Os discos WORM ( Write-Once-Read-Many ) s√£o uma forma de armazenamento √≥ptico usado para arquivar  dados;  eles  permitem  que  os  dados  sejam gravados uma vez e lidos qualquer n√∫mero de vezes sem  a  possibilidade  de  apagamento.  Eles  mant√™m cerca de meio gigabyte de dados por disco e duram muito mais do que os discos magn√©ticos. 2 Mem√≥rias de  jukebox  √≥ptico utilizam  um  conjunto  de  placas de CD-ROM, que s√£o carregadas em unidades por demanda. Embora os jukeboxes √≥pticos tenham capacidades na ordem de centenas de gigabytes, seus tempos de recupera√ß√£o est√£o na ordem de centenas de milissegundos, muito mais lento do que os discos magn√©ticos. Esse tipo de armazenamento continua a diminuir devido √† r√°pida diminui√ß√£o no custo e ao aumento nas capacidades dos discos magn√©ticos. O DVD √© outro padr√£o para discos √≥pticos, permitindo 4,5 a 15 GB de armazenamento por disco. A maioria das unidades de disco de computador pessoal agora l√™ discos de CD-ROM e DVD. Normalmente, as unidades s√£o CD-R ( Compact Disk Recordable ) que podem criar CD-ROMs e CDs de √°udio ( Compact Disks ), bem como gravar DVDs.

Muitas  organiza√ß√µes  grandes  j√°  est√£o  achando normal ter bancos de dados com tamanhos na ordem dos terabytes. O termo banco de dados muito grande n√£o pode mais ser definido com exatid√£o, pois as capacidades de armazenamento em disco est√£o aumentando e os custos, diminuindo. Logo, o termo pode ser reservado para bancos de dados com dezenas de terabytes.

## 17.1.2 Armazenamento de bancos de dados

Os bancos de dados costumam armazenar grande quantidade de dados que precisam persistir por longos per√≠odos de tempo e, portanto, eles costumam ser considerados dados persistentes . Partes desses dados s√£o  acessadas  e  processadas  repetidamente  durante esse per√≠odo. Isso √© contr√°rio √† no√ß√£o de dados transientes , que persistem apenas por um tempo limitado durante a execu√ß√£o do programa. A maioria dos bancos de dados √© armazenada de maneira permanente (ou persistentemente ) no armazenamento secund√°rio do disco magn√©tico, pelos seguintes motivos:

- ¬Ñ Em geral, os bancos de dados s√£o muito grandes para caber inteiramente na mem√≥ria principal.
- ¬Ñ As  circunst√¢ncias  que  causam  perda  permanente de dados armazenados surgem com menos frequ√™ncia para o armazenamento de disco secund√°rio do que para o armazenamento prim√°rio. Logo, referimo-nos ao disco - e a outros dispositivos de armazenamento secund√°rio  -  como armazenamento  n√£o  vol√°til , enquanto a mem√≥ria principal normalmente √© chamada de armazenamento vol√°til .
- ¬Ñ O custo de armazenamento por unidade de dados est√° na ordem de grandeza menor para o armazenamento de disco secund√°rio do que para o armazenamento prim√°rio.

Finalmente, as fitas magn√©ticas s√£o usadas para arquivamento e armazenamento de backup dos dados. Os jukeboxes de fita - que cont√™m um banco de fitas que s√£o catalogadas e podem ser carregadas automaticamente  nas  unidades  de  fita  -  est√£o  se tornando populares como armazenamento terci√°rio , para manter terabytes de dados. Por exemplo, o sistema sat√©lite de observa√ß√£o da Terra ( EOS -Earth Observation Satellite ) da NASA armazena bancos de dados arquivados dessa forma.

Algumas das tecnologias mais novas - como discos  √≥pticos,  DVDs  e  jukeboxes  de  fita  -  provavelmente oferecem alternativas vi√°veis ao uso de discos magn√©ticos. No futuro, portanto, os bancos de dados poder√£o residir em diferentes n√≠veis de hierarquia de mem√≥ria, com base naquelas descritas na Se√ß√£o 17.1.1. Contudo, j√° se sabe que os discos magn√©ticos continuar√£o a ser o meio de escolha principal para bancos de dados grandes por muitos anos. Logo, √© importante estudar e entender as propriedades e as caracter√≠sticas dos discos magn√©ticos e o modo como os arquivos podem ser organizados neles a fim de projetar bancos de dados eficazes, com desempenho aceit√°vel.

2 Suas velocidades de rota√ß√£o s√£o mais baixas (em torno de 400 rpm), gerando maiores atrasos de lat√™ncia e baixas taxas de transfer√™ncia (em torno de 100 a 200 KB/segundo).

As  fitas  magn√©ticas  s√£o  frequentemente  usadas como meio de armazenamento para o backup de bancos de dados, pois o armazenamento em fita custa ainda menos que o armazenamento em disco. No entanto, o acesso aos dados na fita √© muito lento. Os dados armazenados nas fitas s√£o off-line ; ou seja, alguma interven√ß√£o por um operador - ou um dispositivo  de  carga  autom√°tica  -  para  carregar uma fita √© necess√°rio antes que os dados se tornem dispon√≠veis.  Ao  contr√°rio,  os  discos  s√£o  dispositivos on-line , que podem ser acessados diretamente a qualquer momento.

As  t√©cnicas  utilizadas  para  armazenar  grande  quantidade  de  dados  estruturados  em  disco  s√£o importantes para os projetistas de banco de dados, para o DBA e para implementadores de um SGBD. Os projetistas de banco de dados e o DBA precisam conhecer as vantagens e desvantagens de cada t√©cnica de armazenamento quando projetam, implementam e operam um banco de dados em um SGBD espec√≠fico. Em geral, o SGBD tem v√°rias op√ß√µes dispon√≠veis para organizar os dados. O processo de projeto f√≠sico de banco de dados envolve a escolha das t√©cnicas de organiza√ß√£o de dados em particular que mais se ajustam a determinados requisitos da aplica√ß√£o dentre as op√ß√µes. Os implementadores de sistema de SGBD devem estudar as t√©cnicas de organiza√ß√£o de dados de modo que possam implement√°-las de modo eficaz e, portanto, oferecer ao DBA e aos usu√°rios do SGBD op√ß√µes suficientes.

As aplica√ß√µes de banco de dados t√≠picas s√≥ precisam  de  uma  pequena  parte  do  banco  de  dados de cada vez para processamento. Sempre que certa parte dos dados √© necess√°ria, ela precisa ser localizada  no  disco,  copiada  para  a  mem√≥ria  principal para processamento e, depois, reescrita para o disco se  os  dados  forem  alterados.  Os  dados  armazenados no disco s√£o organizados como arquivos de registros .  Cada registro √© uma cole√ß√£o de valores de dados que podem ser interpretados como fatos sobre entidades, seus atributos e relacionamentos. Os registros devem ser armazenados em disco de uma maneira que torne poss√≠vel localiz√°-los de modo eficiente quando necess√°rio.

Existem v√°rias organiza√ß√µes de arquivo prim√°rio , que determinam como os registros de arquivo s√£o colocados fisicamente no disco, e da√≠ como os registros podem ser acessados. Um arquivo de heap (ou arquivo  desordenado )  coloca  os  registros  no disco sem qualquer ordem em particular, acrescentando novos registros ao final do arquivo, enquanto um arquivo classificado (ou arquivo sequencial ) mant√©m os registros ordenados pelo valor de um campo em particular (chamado campo de classifi- ca√ß√£o ). Um arquivo em hashing usa uma fun√ß√£o de hash aplicada a um campo em particular (chamado chave hash ) para determinar o posicionamento de um registro no disco. Outras organiza√ß√µes de arquivo prim√°rias, como B-trees , usam estruturas em √°rvore.  Discutimos  as  principais  organiza√ß√µes  de arquivo nas se√ß√µes 17.6 at√© 17.9. Uma organiza√ß√£o secund√°ria ou estrutura de acesso auxiliar permite acesso eficiente aos registros do arquivo com base em campos alternativos , al√©m dos que foram usados para a organiza√ß√£o de arquivo prim√°rio. A maioria destes existe como √≠ndices e ser√° discutida no Cap√≠tulo 18.

## 17.2 Dispositivos de armazenamento secund√°rios

Nesta  se√ß√£o,  descrevemos  algumas  caracter√≠sticas  dos  dispositivos  de  armazenamento  em  disco magn√©tico e fita magn√©tica. Os leitores que j√° estudaram esses dispositivos podem simplesmente folhear esta se√ß√£o.

## 17.2.1 Descri√ß√£o de hardware dos dispositivos de disco

Os discos magn√©ticos s√£o usados para armazenar grande quantidade de dados. A unidade de dados mais b√°sica no disco √© um √∫nico bit de informa√ß√£o.  Ao  magnetizar  uma  √°rea  do  disco  de certas  maneiras,  pode-se  fazer  que  ele  represente um valor de bit de 0 (zero) ou 1 (um). Para codificar a informa√ß√£o, os bits s√£o agrupados em bytes (ou caracteres ). Os tamanhos de byte normalmente variam de 4 a 8 bits, dependendo do computador e do dispositivo. Consideramos que um caractere √© armazenado em um √∫nico byte, e usamos os termos byte e caractere para indicar a mesma coisa. A capacidade de um disco √© o n√∫mero de bytes que ele pode armazenar, que em geral √© muito grande. Pequenos disquetes usados com microcomputadores costumam manter de 400 KB a 1,5 MB; mas eles est√£o rapidamente saindo de circula√ß√£o. Os discos r√≠gidos para computadores pessoais normalmente mant√™m de v√°rias centenas de MB at√© dezenas de GB; e grandes pacotes de disco usados com servidores  e  mainframes  t√™m  capacidades  de  centenas de GB. As capacidades de disco continuam a crescer √† medida que a tecnologia se aperfei√ßoa.

Independentemente de sua capacidade, todos os discos s√£o feitos de um material magn√©tico modelado como um disco circular fino, como mostra a Figura 17.1(a), e protegidos por uma camada de pl√°stico ou acr√≠lico.



Movimento do acionador

Figura 17.1

(a) Um disco de face simples com hardware de leitura/grava√ß√£o. (b) Um disk pack com hardware de leitura/grava√ß√£o.

Um  disco  √©  de face  simples se  armazenar  informa√ß√µes apenas em uma de suas superf√≠cies, e de face dupla se as duas superf√≠cies forem usadas. Para aumentar a capacidade  de  armazenamento,  os  discos  s√£o  montados  em  um disk pack ,  como  mostra a Figura 17.1(b), que pode incluir muitos discos e, portanto, muitas superf√≠cies. As informa√ß√µes s√£o armazenadas em uma superf√≠cie do disco em c√≠rculos conc√™ntricos de pequena largura , 3 cada um com um di√¢metro distinto. Cada c√≠rculo √© chamado de trilha . Em disk packs, as trilhas com o mesmo di√¢metro nas diversas  superf√≠cies  formam  um cilindro ,  devido  √† forma que elas teriam se fossem conectadas no espa√ßo. O conceito de cilindro √© importante porque os dados armazenados em um cilindro podem ser recuperados muito mais rapidamente do que se fossem distribu√≠dos entre diferentes cilindros.

blocos ou setores menores. A divis√£o de uma trilha em setores √© fixada na superf√≠cie do disco e n√£o pode ser alterada. Um tipo de organiza√ß√£o de setor, como mostra a Figura 17.2(a), chama uma parte da trilha que se estende por um √¢ngulo fixo no centro de um setor. V√°rias outras organiza√ß√µes de setor s√£o poss√≠veis, e uma delas √© fazer que os setores se estendam por √¢ngulos menores no centro √† medida que se move para fora, mantendo assim uma densidade de grava√ß√£o uniforme, como mostra a Figura 17.2(b). Uma t√©cnica chamada ZBR ( Zone Bit Recording ) permite que um intervalo de cilindros tenha o mesmo n√∫mero de setores por arco. Por exemplo, os cilindros 0-99 podem ter um setor por trilha, 100-199 podem ter dois por trilha, e assim por diante. Nem todos os discos t√™m suas trilhas divididas em setores.

O n√∫mero de trilhas em um disco varia de algumas centenas at√© alguns milhares, e a capacidade de cada trilha normalmente varia de dezenas de KB at√© 150 KB. Como uma trilha em geral cont√©m uma grande quantidade de informa√ß√µes, ela √© dividida em

A divis√£o de uma trilha em blocos de disco (ou p√°ginas ) de mesmo tamanho √© definida pelo sistema operacional durante a formata√ß√£o (ou inicializa√ß√£o ) do disco. O tamanho do bloco √© fixado no decorrer da inicializa√ß√£o e n√£o pode ser trocado dinamicamente. Os tamanhos de bloco de disco t√≠picos variam de

3 Em alguns discos, os c√≠rculos agora s√£o conectados em um tipo de espiral cont√≠nua.

Figura 17.2



Diferentes organiza√ß√µes de setor no disco. (a) Setores se estendendo por um √¢ngulo fixo. (b) Setores mantendo uma densidade de grava√ß√£o uniforme.

512 a 8.192 bytes. Um disco com setores fixos costuma ter os setores subdivididos em blocos durante a inicializa√ß√£o. Os blocos s√£o separados por lacunas entre blocos de tamanho fixo, que incluem informa√ß√µes de controle especialmente codificadas, gravadas durante  a  inicializa√ß√£o  do  disco.  Essa  informa√ß√£o

√© usada para determinar qual bloco da trilha segue cada lacuna entre blocos. A Tabela 17.1 ilustra as especifica√ß√µes dos discos t√≠picos usados em grandes servidores na ind√∫stria. Os prefixos 10K e 15K nos nomes de disco referem-se √†s velocidades de rota√ß√£o em rpm (rota√ß√µes por minuto).

Tabela 17.1 Especifica√ß√µes de discos Cheetah t√≠picos de alto n√≠vel da Seagate.

| Descri√ß√£o                              | Cheetah 15K.6   | Cheetah NS 10K   |
|----------------------------------------|-----------------|------------------|
| N√∫mero do modelo                       | ST3450856SS/FC  | ST3400755FC      |
| Altura                                 | 25,4 mm         | 26,11 mm         |
| Largura                                | 101,6 mm        | 101,85 mm        |
| Comprimento                            | 146,05 mm       | 147 mm           |
| Peso                                   | 0,709 kg        | 0,771 kg         |
| Capacidade                             |                 |                  |
| Capacidade formatada                   | 450 GB          | 400 GB           |
| Configura√ß√£o                           |                 |                  |
| N√∫mero de discos (f√≠sicos)             | 4               | 4                |
| N√∫mero de cabe√ßas (f√≠sicas)            | 8               | 8                |
| Desempenho                             |                 |                  |
| Taxas de transfer√™ncia                 |                 |                  |
| Taxa de transfer√™ncia interna (m√≠nima) | 1.051 Mb/s      |                  |
| Taxa de transfer√™ncia interna (m√°xima) | 2.225 Mb/s      | 1.211 Mb/s       |
| Tempo m√©dio entre falhas (MTBF)        |                 | 1,4 M horas      |
| Tempos de busca                        |                 |                  |
| Tempo de busca m√©dio (leitura)         | 3,4 ms (t√≠pica) | 3,9 ms (t√≠pica)  |
| Tempo de busca m√©dio (grava√ß√£o)        | 3,9 ms (t√≠pica) | 4,2 ms (t√≠pica)  |
| Busca trilha a trilha, leitura         | 0,2 ms (t√≠pica) | 0,35 ms (t√≠pica) |
| Busca trilha a trilha, grava√ß√£o        | 0,4 ms (t√≠pica) | 0,35 ms (t√≠pica) |
| Lat√™ncia m√©dia                         | 2 ms            | 2,98 msec        |

Fonte: Cortesia da Seagate Technology

H√°  uma  melhoria  cont√≠nua  na  capacidade  de armazenamento e taxas de transfer√™ncia associadas aos discos. Eles tamb√©m est√£o ficando cada vez mais baratos - hoje, custam apenas uma fra√ß√£o de um d√≥lar por megabyte de armazenamento em disco. Os custos est√£o reduzindo t√£o rapidamente que j√° chegaram a 0,025 centavos/MB - que se traduz em US$ 0,25/GB e US$ 250/TB.

Um disco √© um dispositivo endere√ß√°vel por acesso aleat√≥rio .  A transfer√™ncia de dados entre a mem√≥ria principal e o disco ocorre em unidades de blocos de disco. O endere√ßo de hardware de um bloco - uma combina√ß√£o de n√∫mero de cilindro, n√∫mero de trilha (n√∫mero de superf√≠cie no cilindro em que a trilha est√° localizada) e n√∫mero de bloco (dentro da trilha) √© fornecido ao hardware de E/S (entrada/sa√≠da) do disco. Em  muitas  unidades  de  disco  modernas,  um  √∫nico n√∫mero, chamado LBA ( Logical Block Address ), que √© um n√∫mero entre 0 e n (considerando que a capacidade total do disco √© n + 1 blocos), √© mapeado automaticamente para o bloco correto pelo controlador da unidade de disco. O endere√ßo de um buffer - uma √°rea reservada cont√≠gua no armazenamento principal, que mant√©m um bloco de disco - tamb√©m √© fornecido. Para um comando de leitura , o bloco de disco √© copiado para o buffer, ao passo que, para um comando de grava√ß√£o , o conte√∫do do buffer √© copiado para o bloco de disco. √Äs vezes, v√°rios blocos cont√≠guos podem ser transferidos como uma unidade, denominada cluster .  Nesse caso, o tamanho do buffer √© ajustado para corresponder ao n√∫mero de bytes no cluster.

O mecanismo de hardware real que l√™ ou grava um bloco √© a cabe√ßa de leitura/grava√ß√£o do  disco, que faz parte de um sistema chamado unidade de disco . Um disco ou disk pack √© montado na unidade de disco, que inclui um motor que gira os discos. Uma cabe√ßa  de  leitura/grava√ß√£o  inclui  um  componente eletr√¥nico conectado a um bra√ßo mec√¢nico . Os disk packs com superf√≠cies m√∫ltiplas s√£o controlados por v√°rias cabe√ßas de leitura/grava√ß√£o - uma para cada superf√≠cie, como mostra a Figura 17.1(b). Todos os bra√ßos s√£o conectados a um acionador conectado a outro motor el√©trico, que move as cabe√ßas de leitura/ grava√ß√£o em harmonia e as posiciona exatamente sobre o cilindro de trilhas especificado em um endere√ßo de bloco.

As unidades de disco r√≠gido giram o disk pack continuamente a uma velocidade constante (em geral, variando entre 5.400 e 15.000 rpm). Quando a cabe√ßa de leitura/grava√ß√£o est√° posicionada na trilha correta e o bloco especificado no endere√ßo de bloco move-se  sob  a  cabe√ßa  de  leitura/grava√ß√£o,  o  componente  eletr√¥nico  da  cabe√ßa  de  leitura/grava√ß√£o  √© ativado para transferir os dados. Algumas unidades de disco possuem cabe√ßas de leitura/grava√ß√£o fixas, com o n√∫mero de cabe√ßas correspondente ao de trilhas. Estes s√£o chamados discos de cabe√ßa fixa ,  enquanto as unidades de disco com um acionador s√£o chamadas de discos de cabe√ßa m√≥vel . Para os discos de cabe√ßa fixa, uma trilha ou cilindro √© selecionado eletronicamente, passando para a cabe√ßa de leitura/ grava√ß√£o apropriada, em vez de por um movimento mec√¢nico; em consequ√™ncia, isso √© muito mais r√°pido. Por√©m, o custo das cabe√ßas de leitura/grava√ß√£o adicionais √© muito alto, de modo que os discos com cabe√ßa fixa n√£o s√£o muito utilizados.

Um controlador de disco, comumente embutido na unidade de disco, controla a unidade de disco e  a  interliga  ao  sistema  de  computa√ß√£o.  Uma  das interfaces-padr√£o usadas hoje para unidades de disco  nos  PCs  e  esta√ß√µes  de  trabalho  se  chama SCSI ( Small  Computer  System  Interface ). O  controlador aceita comandos de E/S de alto n√≠vel e age de maneira apropriada para posicionar o bra√ßo e fazer  que  aconte√ßa  a  a√ß√£o  de  leitura/grava√ß√£o.  Para transferir um bloco de disco, dado seu endere√ßo, o controlador de disco primeiro deve posicionar mecanicamente a cabe√ßa de leitura/grava√ß√£o na trilha correta. O tempo exigido para fazer isso √© chamado tempo de busca . Os tempos de busca t√≠picos s√£o de 5 a 10 ms em desktops e de 3 a 8 ms em servidores. Depois disso, existe outro atraso - chamado de atraso rotacional ou lat√™ncia - enquanto o in√≠cio do bloco desejado gira at√© a posi√ß√£o sob a cabe√ßa de leitura/grava√ß√£o. Isso depende das rpm do disco. Por exemplo, a 15.000 rpm, o tempo por rota√ß√£o √©  de  4  ms  e  o  atraso  rotacional  m√©dio  √©  o  tempo por meia rota√ß√£o, ou 2 ms. A 10.000 rpm, o atraso rotacional m√©dio aumenta para 3 ms. Finalmente, algum tempo adicional √© necess√°rio para transferir os dados; este √© chamado tempo de transfer√™ncia de bloco . Logo, o tempo total necess√°rio para localizar e transferir um bloco qualquer, dado seu endere√ßo, √© a soma do tempo de busca, do atraso rotacional e do tempo de transfer√™ncia de bloco. O tempo de busca e o atraso rotacional costumam ser muito maiores do que o tempo de transfer√™ncia de bloco. Para tornar a transfer√™ncia de m√∫ltiplos blocos mais eficiente, √© comum transferir v√°rios blocos consecutivos na mesma trilha ou cilindro. Isso elimina o tempo de busca e o atraso rotacional para todos, menos o primeiro bloco, e pode resultar em uma economia de tempo substancial quando v√°rios blocos cont√≠guos s√£o transferidos. Normalmente, o fabricante do disco oferece uma taxa de transfer√™ncia em massa a fim de calcular o tempo exigido para transferir blocos consecutivos. O Ap√™ndice B cont√©m uma discuss√£o sobre esses e outros par√¢metros de disco.

O  tempo  necess√°rio  para  localizar  e  transferir um bloco de disco est√° na ordem de milissegundos, em geral variando de 9 a 60 ms. Para blocos cont√≠guos, localizar o primeiro bloco leva de 9 a 60 ms, mas  transferir  os  blocos  subsequentes  pode  levar apenas  0,4  a  2  ms  cada.  Muitas  t√©cnicas  de  busca tiram proveito da recupera√ß√£o consecutiva de blocos ao procurar dados no disco. De qualquer forma, um tempo de transfer√™ncia  na  ordem  de  milissegundos √©  considerado bastante alto em compara√ß√£o com o tempo exigido para processar os dados na mem√≥ria principal pelas CPUs atuais. Logo, a localiza√ß√£o dos dados no disco √© um gargalo principal nas aplica√ß√µes de banco de dados. As estruturas de arquivo que discutimos aqui e no Cap√≠tulo 18 tentam minimizar o n√∫mero de transfer√™ncias de bloco necess√°rias para localizar e transferir os dados exigidos do disco para a mem√≥ria principal. Colocar 'informa√ß√µes relacionadas'  em  blocos  cont√≠guos  √©  o  objetivo  b√°sico  de qualquer organiza√ß√£o de armazenamento no disco.

## 17.2.2 Dispositivos de armazenamento de fita magn√©tica

Discos  s√£o  dispositivos  de  armazenamento  secund√°rio de acesso aleat√≥rio , pois um bloco de disco qualquer  pode  ser  acessado aleatoriamente depois que especificamos seu endere√ßo. As fitas magn√©ticas s√£o dispositivos de acesso sequencial; para acessar o en√©simo bloco na fita, primeiro temos de varrer os n - 1 blocos anteriores. Os dados s√£o armazenados em bobinas de fita magn√©tica de alta capacidade, semelhantes √†s fitas de √°udio ou v√≠deo. Uma unidade de fita precisa ler os dados ou grav√°-los em uma bobina de fita . Em geral, cada grupo de bits que forma um byte √© armazenado na fita, e os pr√≥prios bytes s√£o armazenados consecutivamente nela.

Uma cabe√ßa de leitura/grava√ß√£o √© usada para ler ou gravar dados na fita. Os registros de dados na fita tamb√©m s√£o armazenados em blocos - embora os blocos possam ser substancialmente maiores do que os dos discos, e as lacunas entre blocos tamb√©m sejam muito grandes. Com densidades de fita t√≠picas de 1.600 a 6.250 bytes por polegada, uma lacuna entre blocos t√≠pica 4 de 0,6 polegada corresponde a 960 at√© 3.750 bytes de espa√ßo de armazenamento desperdi√ßado. √â comum agrupar muitos registros em um bloco para melhorar a utiliza√ß√£o do espa√ßo.

A principal caracter√≠stica de uma fita √© seu requisito  de  que  acessemos os blocos de dados em ordem sequencial . Para chegar at√© um bloco no meio da bobina de fita, a fita √© montada e depois varrida at√© que o bloco solicitado passe sob a cabe√ßa de leitura/grava√ß√£o.

4 Chamadas de lacunas entre registros em terminologia de fita.

Por esse motivo, o acesso da fita pode ser lento e elas n√£o s√£o usadas para armazenar dados on-line, exceto para algumas aplica√ß√µes especializadas. Por√©m, as fitas t√™m uma fun√ß√£o muito importante backup do banco de dados. Uma raz√£o para haver backup √© para manter c√≥pias de arquivos de disco no caso de perda de dados por uma falha no disco, que pode acontecer se a sua cabe√ßa de leitura/grava√ß√£o tocar na superf√≠cie por defeito mec√¢nico. Por esse motivo, os arquivos de disco s√£o copiados periodicamente para a fita. Para muitas aplica√ß√µes cr√≠ticas on-line, como sistemas de reserva a√©rea, para evitar qualquer tempo de paralisa√ß√£o, s√£o usados sistemas espelhados para manter tr√™s conjuntos de discos id√™nticos - dois em opera√ß√£o on-line e um como backup. Aqui, os discos off-line tornam-se um dispositivo de backup. Os tr√™s s√£o usados de modo que possam ser trocados caso haja uma falha em uma das unidades de disco ativas. As fitas tamb√©m podem ser utilizadas para armazenar arquivos de banco de dados excessivamente grandes. Os arquivos do banco de dados que raramente s√£o usados ou est√£o desatualizados, mas s√£o necess√°rios para manuten√ß√£o de registro hist√≥rico, podem ser arquivados em fita. Originalmente, as unidades de fita com bobina de meia polegada eram usadas para o armazenamento de dados, empregando as chamadas fitas de nove trilhas. Mais tarde, fitas magn√©ticas menores, de 8mm (semelhantes √†s usadas em filmadoras port√°teis), que podem armazenar at√© 50 GB, bem como os cartuchos de dados de varredura helicoidal de 4mm e CDs e DVDs grav√°veis, tornaram-se m√≠dia popular para o backup de arquivos de dados dos PCs e esta√ß√µes de trabalho. Eles tamb√©m s√£o usados para armazenar imagens e bibliotecas de sistemas.

O backup de bancos de dados corporativos, de modo  que  nenhuma  informa√ß√£o  de  transa√ß√£o  seja perdida,  √©  uma  tarefa  importante.  Atualmente,  as bibliotecas  de  fitas  com  slots  para  v√°rias  centenas de cartuchos s√£o usadas com Digital e Superdigital Linear Tapes (DLTs e SDLTs), com capacidades na ordem de centenas de gigabytes, que registram dados em trilhas lineares. Bra√ßos rob√≥ticos s√£o usados para gravar em v√°rios cartuchos em paralelo, utilizando v√°rias  unidades  de  fita  com  software  de  rotulagem autom√°tico para identificar os cartuchos de backup. Um exemplo de uma biblioteca gigante √© o modelo SL8500 da Sun Storage Technology, que pode armazenar at√© 70 petabytes (1 petabyte = 1.000 TB) de dados usando at√© 448 unidades com uma taxa de vaz√£o m√°xima de 193,2 TB/hora. Vamos adiar a discuss√£o sobre a tecnologia de armazenamento de disco chamada RAID, e sobre as √°reas de armazenamento em rede, armazenamento conectado √† rede e sistemas de armazenamento iSCSI para o final do cap√≠tulo.

## 17.3 Buffering de blocos

Quando v√°rios blocos precisam ser transferidos do disco para a mem√≥ria principal e todos os endere√ßos de bloco s√£o conhecidos, v√°rios buffers podem ser reservados na mem√≥ria principal para agilizar a transfer√™ncia. Enquanto um buffer est√° sendo lido ou gravado, a CPU pode processar dados em outro buffer, pois existe um processador (controlador) de E/S de disco separado que, uma vez iniciado, pode prosseguir para transferir um bloco de dados entre a mem√≥ria e o disco independente e em paralelo com o processamento da CPU.

A Figura 17.3 ilustra como dois processos podem  prosseguir  em  paralelo.  Os  processos  A  e  B est√£o  rodando simultaneamente em  um  padr√£o intervalado ,  onde  os  processos  C  e  D  est√£o  rodando simultaneamente em  um  padr√£o paralelo .  Quando uma √∫nica CPU controla v√°rios processos, a execu√ß√£o paralela n√£o √© poss√≠vel. Contudo, os processos ainda podem ser executados de maneira simult√¢nea de  uma forma intervalada. O buffering √© mais √∫til quando os processos podem ser executados simultaneamente em um padr√£o paralelo, seja porque existe um processador de E/S de disco separado ou porque h√° v√°rios processadores (CPUs).

A Figura 17.4 ilustra como a leitura e o processamento podem prosseguir em paralelo quando o tempo exigido para processar um bloco de disco na mem√≥ria √© menor que o tempo exigido para ler o pr√≥ximo bloco e preencher um buffer. A CPU pode come√ßar a processar um bloco quando sua transfer√™ncia para a mem√≥ria principal termina; ao mesmo tempo, o processador de E/S de disco pode estar lendo e transferindo o pr√≥ximo bloco para um buffer diferente. Essa t√©cnica √© chamada de buffering duplo , e tamb√©m pode ser usada para ler um fluxo cont√≠nuo de blocos do disco para a mem√≥ria. O buffering duplo permite a leitura ou grava√ß√£o cont√≠nua de dados em blocos de disco consecutivos, o que elimina o tempo de busca e o atraso rotacional para todas as transfer√™ncias de bloco, com exce√ß√£o da primeira. Al√©m do mais, os dados ficam prontos para processamento, reduzindo assim o tempo de espera nos programas.

## 17.4 Gravando registros de arquivo no disco

Nesta se√ß√£o, definimos os conceitos de registros, tipos de registro e arquivos. Depois, discutimos sobre as t√©cnicas para gravar registros de arquivo no disco.

Figura 17.3



Concorr√™ncia intervalada versus execu√ß√£o paralela.

Tempo



## 17.4.1 Registros e tipos de registro

Os dados costumam ser armazenados na forma de registros .  Cada  registro  cont√©m  uma cole√ß√£o de valores ou itens de dados relacionados, no qual cada valor √© formado por um ou mais bytes e corresponde a um campo em particular do registro. Os registros normalmente descrevem entidades e seus atributos. Por exemplo, um registro de FUNCIONARIO representa  uma  entidade  de  funcion√°rio,  e  o  valor  de  cada campo  no  registro  especifica  algum  atributo  desse funcion√°rio,  como Nome, Data\_nascimento, Salario ou Supervisor. Uma  cole√ß√£o  de  nomes  de  campo  e seus tipos de dados correspondentes constituem uma defini√ß√£o de tipo de registro ou formato de registro . Um tipo de dado , associado a cada campo, especifica os tipos de valores que um campo pode assumir.

O tipo de dado de um campo normalmente √© um  dos  tipos  de  dado  padr√£o  usados  na  programa√ß√£o. Estes incluem os tipos de dados num√©ricos (inteiro,  inteiro  longo  ou  ponto  flutuante),  cadeia de caracteres (tamanho fixo ou vari√°vel), booleanos (tendo apenas valores 0 e 1, ou TRUE e FALSE ) e, √†s vezes, tipos data e tempo especialmente codificados. O n√∫mero de bytes exigidos para cada tipo de dado √©  fixo  para  determinado  sistema  de  computa√ß√£o. Um inteiro pode exigir 4 bytes, um inteiro longo, 8 bytes, um n√∫mero real, 4 bytes, um booleano, 1 byte, e uma data, 10 bytes (considerando um formato DD-MM-AAAA), e uma string de tamanho fixo de k caracteres, k bytes. As strings de tamanho vari√°vel podem exibir tantos bytes quantos caracteres existirem no valor de cada campo. Por exemplo, um tipo de registro FUNCIONARIO pode ser definido usando a nota√ß√£o da linguagem de programa√ß√£o C - com a seguinte estrutura:

```
struct  funcionario{ char  nome[30]; char  cpf[9]; int   salario; int   cod_cargo; char  departamento[20]; }  ;
```

Em algumas aplica√ß√µes de banco de dados, pode haver necessidade de armazenar itens de dados que consistem em grandes objetos n√£o estruturados, que representam  imagens,  v√≠deo  digitalizado  ou  streams de √°udio, ou ent√£o texto livre. Estes s√£o conhecidos como BLOB s (objetos bin√°rios grandes). Um item de dados BLOB costuma ser armazenado separadamente de seu registro, em um conjunto de blocos de disco, e um ponteiro para o BLOB √© inclu√≠do no registro.

## 17.4.2 Arquivos, registros de tamanho fixo e registros de tamanho vari√°vel

Um arquivo √©  uma sequ√™ncia de  registros.  Em muitos casos, todos os registros em um arquivo s√£o do mesmo tipo de registro. Se cada registro no arquivo tem exatamente o mesmo tamanho (em bytes), o  arquivo  √©  considerado  composto  de registros  de tamanho  fixo . Se  diferentes  registros  no  arquivo possuem diversos tamanhos, o arquivo √© considerado composto de registros de tamanho vari√°vel .  Um arquivo pode ter registros de tamanho vari√°vel por v√°rios motivos:

- ¬Ñ Os registros do arquivo s√£o do mesmo tipo de registro,  mas  um  ou  mais  dos  campos  s√£o de tamanho vari√°vel ( campos de tamanho vari√°vel ). Por exemplo, o campo Nome de FUNCIONARIO pode  ser  um  campo  de  tamanho vari√°vel.
- ¬Ñ Os registros do arquivo s√£o do mesmo tipo de registro, mas um ou mais dos campos podem ter m√∫ltiplos valores para registros individuais; esse campo √© chamado de campo repetitivo , e um grupo de valores para o campo normalmente √© chamado de grupo repetitivo .
- ¬Ñ Os registros do arquivo s√£o do mesmo tipo de registro, mas um ou mais dos campos s√£o opcionais ,  ou  seja,  eles  podem  ter  valores  para alguns, mas n√£o para todos os registros do arquivo ( campos opcionais ).
- ¬Ñ O arquivo cont√©m registros de tipos de registro diferentes e, portanto, de tamanho vari√°vel ( arquivo misto ). Isso ocorreria se registros relacionados de diferentes tipos fossem agrupados (colocados juntos) em blocos de disco; por exemplo, os registros de HISTORICO\_ES -COLAR de determinado aluno podem ser colocados ap√≥s o registro desse ALUNO .

Os registros de FUNCIONARIO de tamanho fixo na  Figura  17.5(a)  t√™m  um  tamanho  de  registro  de 71  bytes.  Cada  registro  tem  os  mesmos  campos,  e os  tamanhos  de  campo  s√£o  fixos,  de  modo  que  o sistema pode identificar a posi√ß√£o de byte inicial de cada campo em rela√ß√£o √† posi√ß√£o inicial do registro. Isso facilita a localiza√ß√£o de valores de campo pelos programas que acessam tais arquivos. Observe que √©  poss√≠vel  representar  um  arquivo  que  logicamente deveria ter registros de tamanho vari√°vel como um arquivo de registros de tamanho fixo. Por exemplo, no caso dos campos opcionais, poder√≠amos ter cada campo inclu√≠do em cada registro de arquivo , mas ar-

mazenar um valor especial NULL se n√£o houver valor para esse campo. Para um campo repetitivo, poder√≠amos alocar tantos espa√ßos em cada registro quanto o n√∫mero m√°ximo poss√≠vel de ocorr√™ncias do campo. De qualquer forma, o espa√ßo √© desperdi√ßado quando certos registros n√£o t√™m valores para todos os espa√ßos f√≠sicos fornecidos em cada registro. Agora, vamos considerar outras op√ß√µes para formatar registros de um arquivo de registros de tamanho vari√°vel.

Para campos de tamanho vari√°vel , cada registro tem um valor para cada campo, mas n√£o sabemos o tamanho exato de alguns valores de campo. Para determinar os bytes em um registro em particular que representa cada campo, podemos usar caracteres separadores especiais (como ? ou % ou $) - que n√£o aparecem em qualquer valor do campo - para terminar os campos de tamanho vari√°vel, como mostra a Figura 17.5(b), ou podemos armazenar o tamanho do campo em bytes no pr√≥prio registro, antes do valor do campo.

mas o n√∫mero de campos que realmente aparecem em um  registro  t√≠pico  for  pequeno,  podemos  incluir em  cada  registro  uma  sequ√™ncia  de  pares &lt; nome-campo, valor-campo &gt; em vez de apenas os valores de campo. Tr√™s tipos de caracteres separadores s√£o usados na Figura 17.5(c), embora pud√©ssemos usar o mesmo caractere separador para as duas primeiras finalidades - separar o nome do campo do valor do campo e separar um campo do campo seguinte. Uma op√ß√£o mais pr√°tica √© atribuir um c√≥digo curto de tipo de campo - digamos, um n√∫mero inteiro - a cada campo e incluir em cada registro uma sequ√™ncia de pares &lt; tipo-campo, valor-campo &gt; , em vez de pares &lt; nome-campo, valor-campo &gt; .

Um arquivo de registros com campos opcionais pode ser formatado de v√°rias maneiras. Se o n√∫mero total de campos para o tipo de registro for grande,

Um campo repetitivo precisa de um caractere separador para afastar os valores repetitivos do campo e  outro caractere separador para indicar o t√©rmino do campo. Finalmente, para um arquivo que inclui registros de diferentes tipos , cada registro √© precedido por um indicador de tipo de registro . √â compreens√≠vel  que  os  programas  que  processam arquivos de registros com tamanho vari√°vel - que em geral fazem parte do sistema de arquivos e, portanto, ficam

Figura 17.5





Tr√™s formatos de armazenamento de registro. (a) Um registro de tamanho fixo com seis campos e tamanho de 71 bytes. (b) Um registro com dois campos de tamanho vari√°vel e tr√™s campos de tamanho fixo. (c) Um registro de campo vari√°vel com tr√™s tipos de caracteres separadores.

ocultos dos programadores t√≠picos - tenham de ser mais complexos do que aqueles para registros de tamanho fixo, nos quais a posi√ß√£o inicial e o tamanho de cada campo s√£o conhecidos e fixos. 5

## 17.4.3 Blocagem de registros e registros espalhados versus n√£o espalhados

Os registros de um arquivo precisam ser alocados a blocos de disco, porque um bloco √© a unidade de transfer√™ncia de dados entre o disco e a mem√≥ria. Quando o tamanho do bloco √© maior que o tamanho do registro, cada bloco ter√° diversos registros, embora alguns arquivos possam ter registros excepcionalmente grandes que n√£o cabem em um bloco. Suponha que o tamanho do bloco seja B bytes. Para um arquivo de registros de tamanho fixo, com tamanho de R bytes, sendo B ‚â• R , podemos estabelecer bfr = Ô£∞ B R / Ô£ª registros por bloco, onde o  ( Ô£∞ x )  ( Ô£ª fun√ß√£o floor ) arredonda para baixo o n√∫mero x para um inteiro. O valor bfr √© chamado de fator de blocagem para o arquivo. Em geral, R pode n√£o dividir B exatamente, de modo que temos algum espa√ßo n√£o usado em cada bloco, igual a

<!-- formula-not-decoded -->

Para aproveitar esse espa√ßo n√£o usado, podemos armazenar parte de um registro em um bloco e o restante  em  outro.  Um ponteiro no  final  do  primeiro bloco aponta para o bloco que cont√©m o restante do registro, caso n√£o seja o pr√≥ximo bloco consecutivo no disco. Essa organiza√ß√£o √© chamada de espalhada porque os registros podem se espalhar por mais de um bloco. Sempre que um registro √© maior que um bloco, temos de usar uma organiza√ß√£o espalhada. Se os registros n√£o puderem atravessar os limites de bloco, a organiza√ß√£o √© chamada de n√£o espalhada . Isso √© usado com registros de tamanho fixo tendo B &gt; R , pois faz cada registro come√ßar em um local conhecido no bloco, simplificando o processamento do registro.  Para  registros  de  tamanho  vari√°vel,  pode-se usar uma organiza√ß√£o espalhada ou n√£o espalhada.

Se  o  registro  m√©dio  for  grande,  √©  vantajoso  usar  o espalhamento para reduzir o espa√ßo perdido em cada bloco. A Figura 17.6 ilustra a organiza√ß√£o espalhada versus a n√£o espalhada.

Para registros de tamanho vari√°vel que usam a organiza√ß√£o espalhada, cada bloco pode armazenar um n√∫mero diferente de registros. Nesse caso, o fator de bloco bfr representa o n√∫mero m√©dio de registros por  bloco  para  o  arquivo.  Podemos  usar bfr para calcular o n√∫mero de blocos b necess√°rios para um arquivo de   registros: r b =  ( / Ô£Æ r bfr )   blocos Ô£π

onde  o Ô£Æ ( x ) ÔÉ© Ô£π ( fun√ß√£o  ceiling )  arredonda  para cima o valor de x at√© o pr√≥ximo inteiro.

## 17.4.4 Alocando blocos de arquivo no disco

Existem v√°rias t√©cnicas-padr√£o para alocar os blocos de um arquivo no disco. Na aloca√ß√£o cont√≠gua , os blocos de arquivo s√£o alocados a blocos de disco consecutivos. Isso torna a leitura do arquivo inteiro muito r√°pida usando o buffering duplo, mas dificulta a expans√£o do arquivo. Na aloca√ß√£o ligada , cada bloco de arquivo cont√©m um ponteiro para o pr√≥ximo bloco de arquivo. Isso facilita a expans√£o  do  arquivo,  mas  torna  sua  leitura  mais  lenta. Uma combina√ß√£o dos dois aloca clusters de blocos de disco consecutivos, e os clusters s√£o ligados. Os clusters  √†s  vezes  s√£o  chamados  de segmentos ou extens√µes de arquivo . Outra possibilidade √© usar a aloca√ß√£o indexada ,  em que um ou mais blocos de √≠ndice cont√™m ponteiros para os blocos de arquivo reais.  Tamb√©m √© comum usar combina√ß√µes dessas t√©cnicas.

## 17.4.5 Cabe√ßalhos de arquivo

Um cabe√ßalho de arquivo ou descritor de arquivo cont√©m informa√ß√µes sobre um arquivo, que s√£o exigi-

Figura 17.6



Tipos de organiza√ß√£o de registro. (a) N√£o espalhada. (b) Espalhada.

5 Outros esquemas tamb√©m s√£o poss√≠veis para representar registros de tamanho vari√°vel.

das pelos programas do sistema que acessam os registros do arquivo. O cabe√ßalho inclui informa√ß√µes para determinar os endere√ßos de disco dos blocos de arquivo,  bem como para registrar descri√ß√µes de formato, que podem incluir tamanhos de campo e a ordem dos campos em um registro, para registros n√£o espalhados de tamanho fixo, e c√≥digos de tipo de campo, caracteres separadores e c√≥digos de tipo de registro, para registros de tamanho vari√°vel.

Para procurar um registro no disco, um ou mais blocos s√£o copiados para os buffers da mem√≥ria principal. Os programas ent√£o procuram o registro ou registros desejados nos buffers, usando a informa√ß√£o no cabe√ßalho de arquivo. Se o endere√ßo do bloco que cont√©m o registro desejado n√£o for conhecido, os programas de pesquisa devem realizar uma pesquisa linear pelos blocos de arquivo. Cada bloco de arquivo √© copiado para um buffer e pesquisado at√© que o registro seja localizado e todos os blocos do arquivo tenham sido pesquisados com sucesso. Isso pode ser muito demorado para um arquivo grande. O objetivo de uma boa organiza√ß√£o de arquivo √© localizar o bloco que cont√©m um registro desejado com um n√∫mero m√≠nimo de transfer√™ncias de bloco.

## 17.5 Opera√ß√µes em arquivos

Opera√ß√µes em arquivos costumam ser agrupadas em opera√ß√µes de recupera√ß√£o e opera√ß√µes de atualiza√ß√£o . O primeiro grupo n√£o muda quaisquer dados no arquivo, apenas localiza certos registros de modo que seus valores de campo possam ser examinados e processados. O segundo muda o arquivo pela inser√ß√£o ou exclus√£o de registros, ou pela modifica√ß√£o dos valores de campo. De qualquer forma, podemos ter de selecionar um ou mais registros para recupera√ß√£o, exclus√£o  ou  modifica√ß√£o  com  base  em  uma condi√ß√£o de sele√ß√£o (ou condi√ß√£o de filtragem ), que especifica crit√©rios que o registro ou registros desejado(s) deve(m) satisfazer.

Considere um arquivo FUNCIONARIO com os campos Nome, Cpf, Salario , Cod\_cargo e Departamento. Uma condi√ß√£o de sele√ß√£o simples pode envolver uma compara√ß√£o de igualdade em algum valor de campo por exemplo, ( Cpf = '12345678966') ou ( Departamento = 'Pesquisa'). Condi√ß√µes mais complexas podem envolver outros tipos de operadores de compara√ß√£o, como &gt; ou ‚â• ; um exemplo √© ( Salario ‚â• 30.000). O caso geral √© ter uma express√£o booleana qualquer nos campos do arquivo como condi√ß√£o de sele√ß√£o.

As opera√ß√µes de pesquisa em arquivos geralmente s√£o baseadas em condi√ß√µes de sele√ß√£o simples. Uma condi√ß√£o complexa deve ser decompos- ta pelo SGBD (ou pelo programador) para extrair uma  condi√ß√£o  simples  que  pode  ser  usada  para localizar  os  registros  no  disco.  Cada  registro  localizado √© ent√£o verificado para determinar se satisfaz a condi√ß√£o de sele√ß√£o inteira. Por exemplo, podemos extrair a condi√ß√£o simples ( Departamento = 'Pesquisa') da condi√ß√£o complexa (( Salario ‚â• 30.000) AND ( Departamento =  'Pesquisa');  cada registro  satisfazendo  ( Departamento =  'Pesquisa') √© localizado e depois testado para ver se tamb√©m satisfaz ( Salario ‚â• 30.000).

Quando v√°rios registros  de  arquivo  satisfazem uma condi√ß√£o de pesquisa, o primeiro registro - em rela√ß√£o √† sequ√™ncia f√≠sica de registros de arquivo - √© inicialmente localizado e designado como o registro atual .  Opera√ß√µes  de  busca  subsequentes  come√ßam desse registro e localizam o pr√≥ximo registro no arquivo que satisfaz a condi√ß√£o.

As opera√ß√µes reais para localizar e acessar registros  de  arquivo  variam  de  um  sistema  para  outro. A  seguir,  apresentamos  um  conjunto  de  opera√ß√µes representativas.  Normalmente,  programas  de  alto n√≠vel, como programas de software de SGBD, acessam registros usando esses comandos, de modo que √†s vezes nos referimos a vari√°veis de programa nas descri√ß√µes a seguir:

- ¬Ñ Open. Prepara o arquivo para leitura ou grava√ß√£o. Aloca buffers apropriados (em geral, pelo menos dois) para manter blocos de arquivo  do  disco,  e  recupera  o  cabe√ßalho  do arquivo. Define o ponteiro de arquivo para o in√≠cio do arquivo.
- ¬Ñ Reset. Define  o  ponteiro  do  arquivo  aberto para o in√≠cio do arquivo.
- ¬Ñ Find ( ou Locate). Procura o primeiro registro que satisfa√ßa uma condi√ß√£o de pesquisa. Transfere  o  bloco  que  cont√©m  esse  registro para o buffer da mem√≥ria principal (se ainda n√£o estiver l√°). O ponteiro de arquivo aponta para o registro no buffer e este se torna o registro atual . √Äs vezes, diferentes verbos s√£o usados para indicar se o registro localizado deve ser lido ou atualizado.
- ¬Ñ Read  ( ou Get). Copia  o  registro  atual  do buffer  para  uma  vari√°vel  de  programa  no programa  do  usu√°rio.  Esse  comando  tamb√©m pode avan√ßar o ponteiro do registro atual  para  o  pr√≥ximo registro no arquivo, que pode precisar ler o pr√≥ximo bloco de arquivo do disco.
- ¬Ñ FindNext. Procura o pr√≥ximo registro no arquivo que satisfaz a condi√ß√£o de pesquisa.

Transfere  o  bloco  que  cont√©m  esse  registro para um buffer da mem√≥ria principal (se ainda n√£o estiver l√°). O registro est√° localizado no buffer e torna-se o registro atual. V√°rias formas de FindNext (por exemplo, encontrar pr√≥ximo registro  dentro  de  um  registro  pai atual, encontrar pr√≥ximo registro de determinado tipo ou encontrar pr√≥ximo registro em que uma condi√ß√£o complexa √© atendida) est√£o dispon√≠veis em SGBDs legados com base nos modelos hier√°rquico e de rede.

- ¬Ñ Delete. Exclui o registro atual e (no fim) atualiza o arquivo no disco para refletir a exclus√£o.
- ¬Ñ Modify. Modifica  alguns  valores  de  campo para o registro atual e (no fim) atualiza o arquivo no disco para refletir a modifica√ß√£o.
- ¬Ñ Insert. Insere um novo registro no arquivo ao localizar o bloco onde o registro deve ser inserido, transferindo esse bloco para um buffer da mem√≥ria principal (se ainda n√£o estiver l√°), gravando o registro no buffer e (no fim) gravando o buffer em disco para refletir a inser√ß√£o.
- ¬Ñ Close. Completa o acesso ao arquivo liberando os buffers e realizando quaisquer outras opera√ß√µes de limpeza necess√°rias.

Estas (exceto por Open e Close) s√£o chamadas opera√ß√µes de um registro por vez , pois cada uma se aplica a um √∫nico registro. √â poss√≠vel resumir as opera√ß√µes Find, FindNext e Read em uma √∫nica opera√ß√£o, Scan, cuja descri√ß√£o √© a seguinte:

- ¬Ñ Scan. Se o arquivo j√° tiver sido aberto ou reiniciado, Scan retorna o primeiro registro; caso contr√°rio, ele retorna o pr√≥ximo registro. Se uma condi√ß√£o for especificada com a opera√ß√£o,  o  registro  retornado  √©  o  primeiro  ou  o pr√≥ximo registro que satisfaz a condi√ß√£o.

Em sistemas de banco de dados, opera√ß√µes adicionais de n√≠vel mais alto, de um conjunto de cada vez , podem  ser  aplicadas  a  um  arquivo.  Alguns exemplos s√£o os seguintes:

- ¬Ñ FindAll. Localiza todos os registros no arquivo que satisfazem uma condi√ß√£o de pesquisa.
- ¬Ñ Find ( ou Locate) n . Procura o primeiro registro que satisfaz uma condi√ß√£o de pesquisa e depois continua a localizar os pr√≥ximos n - 1 registros  que  satisfazem  a  mesma  condi√ß√£o. Transfere os blocos que cont√©m os n registros para o buffer da mem√≥ria principal (se ainda n√£o estiverem l√°).
- ¬Ñ FindOrdered. Recupera todos os registros no arquivo em alguma ordem especificada.
- ¬Ñ Reorganize. Inicia o processo de reorganiza√ß√£o.  Conforme  veremos,  algumas  organiza√ß√µes de arquivo exigem reorganiza√ß√£o peri√≥dica. Um exemplo √© reordenar os registros do arquivo classificando-os em um campo especificado.

Neste ponto, vale a pena notar a diferen√ßa entre os termos organiza√ß√£o de arquivo e m√©todo de acesso . Uma organiza√ß√£o de arquivo refere-se √† organiza√ß√£o dos dados de um arquivo em registros, blocos e estruturas de acesso; isso inclui o modo como registros  e  blocos  s√£o  colocados  no  meio  de  armazenamento e interligados. Um m√©todo de acesso , por sua vez, oferece um grupo de opera√ß√µes - como aquelas listadas anteriormente - que podem ser aplicadas a um arquivo. Em geral, √© poss√≠vel aplicar v√°rios m√©todos de acesso a uma organiza√ß√£o de arquivo. Alguns m√©todos de acesso, por√©m, s√≥ podem ser aplicados a arquivos organizados de certas maneiras. Por exemplo, n√£o podemos aplicar um m√©todo de acesso indexado a um arquivo sem um √≠ndice (ver Cap√≠tulo 18).

Normalmente,  esperamos  usar  algumas  condi√ß√µes de pesquisa mais do que outras. Certos arquivos podem ser est√°ticos ,  significando  que  opera√ß√µes  de atualiza√ß√£o raramente s√£o realizadas; outros arquivos, mais din√¢micos , podem mudar com frequ√™ncia, de modo que as opera√ß√µes de atualiza√ß√µes s√£o constantemente  aplicadas  a  eles.  Uma  organiza√ß√£o  de arquivo bem-sucedida deve realizar, do modo mais eficiente poss√≠vel, as opera√ß√µes que esperamos aplicar frequentemente ao arquivo. Por exemplo, considere o arquivo FUNCIONARIO , mostrado na Figura 17.5(a), que armazena os registros para os funcion√°rios ativos  em  uma  empresa.  Esperamos  inserir  registros (quando  os  funcion√°rios  s√£o  contratados),  excluir registros (quando os funcion√°rios saem da empresa) e modificar registros (por exemplo, quando o sal√°rio ou cargo de um funcion√°rio √© alterado). A exclus√£o ou modifica√ß√£o de um registro requer uma condi√ß√£o de sele√ß√£o para identificar um registro em particular ou conjunto de registros. A leitura de um ou mais registros tamb√©m requer uma condi√ß√£o de sele√ß√£o.

Se os usu√°rios esperam principalmente aplicar uma condi√ß√£o de pesquisa com base no Cpf, o projetista precisa escolher uma organiza√ß√£o de arquivo que facilita a localiza√ß√£o de um registro, dado seu valor de Cpf . Isso pode envolver a ordena√ß√£o f√≠sica dos registros pelo valor do Cpf ou a defini√ß√£o de um √≠ndice em Cpf (ver Cap√≠tulo 18). Suponha que uma segunda aplica√ß√£o utilize o arquivo para gerar contracheques de funcion√°rios e exija que os contracheques sejam agrupados por departamento. Para essa aplica√ß√£o, √© melhor ordenar os registros de funcion√°rios por departamento e depois por

nome dentro de cada departamento. O agrupamento de registros em blocos e a organiza√ß√£o de blocos em cilindros agora seriam diferentes. Por√©m, esse arranjo entra em conflito com a ordena√ß√£o dos registros por valores de Cpf . Se as duas aplica√ß√µes s√£o importantes, o projetista deve escolher uma organiza√ß√£o que permita que as duas opera√ß√µes sejam realizadas de modo eficiente. Infelizmente, em muitos casos, uma √∫nica organiza√ß√£o n√£o permite que todas as opera√ß√µes necess√°rias em um arquivo sejam implementadas de maneira eficiente. Isso requer que seja escolhido um meio-termo que leve em conta a import√¢ncia esperada e a mistura de opera√ß√µes de leitura e recupera√ß√£o.

Nas pr√≥ximas se√ß√µes e no Cap√≠tulo 18, discutimos m√©todos para organizar registros de um arquivo no disco. V√°rias t√©cnicas gerais, como ordena√ß√£o, hashing e indexa√ß√£o, s√£o usadas para criar m√©todos de acesso. Al√©m disso, diversas t√©cnicas gerais para lidar com inser√ß√µes e exclus√µes trabalham com muitas organiza√ß√µes de arquivo.

## 17.6 Arquivos de registros desordenados (arquivos de heap)

Neste tipo de organiza√ß√£o mais simples e mais b√°sico, os registros s√£o arquivados na ordem em que s√£o inseridos, de modo que novos registros s√£o inseridos ao final do arquivo. Essa organiza√ß√£o √© chamada arquivo de heap ou pilha . 6 Normalmente, ela √©  usada  com  caminhos  de  acesso  adicionais,  como os √≠ndices secund√°rios discutidos no Cap√≠tulo 18. Ela tamb√©m √© usada para coletar e armazenar registros de dados para uso futuro.

A inser√ß√£o de um novo registro √© muito eficiente . O √∫ltimo bloco de disco do arquivo √© copiado para um buffer, o novo registro √© acrescentado e o bloco √© ent√£o regravado de volta no disco. O endere√ßo do √∫ltimo bloco de arquivo √© mantido no cabe√ßalho do arquivo. No entanto, procurar um registro usando qualquer condi√ß√£o de pesquisa envolve uma pesquisa linear pelo bloco de arquivo por bloco - um procedimento dispendioso. Se apenas um registro satisfizer a condi√ß√£o de pesquisa, ent√£o, na m√©dia, um programa ler√° a mem√≥ria e pesquisar√° metade dos blocos de  arquivo  antes  de  encontrar  o  registro.  Para  um arquivo de b blocos, isso exige pesquisar ( b /2) blocos, na m√©dia. Se nenhum registro ou v√°rios registros satisfizerem a condi√ß√£o de pesquisa, o programa deve ler e pesquisar todos os b blocos no arquivo.

Para excluir um registro, um programa deve primeiro encontrar seu bloco, copi√°-lo para um buffer,

6 √Äs vezes, essa organiza√ß√£o √© chamada de arquivo sequencial .

excluir o registro do buffer e, finalmente, regravar o bloco de volta ao disco. Isso deixa um espa√ßo livre no bloco de disco. A exclus√£o de um grande n√∫mero de registros dessa maneira resulta em espa√ßo de armazenamento desperdi√ßado. Outra t√©cnica usada para exclus√£o de registro √© ter um byte ou bit extra, chamado marcador de exclus√£o , armazenado em cada registro. Um registro √© exclu√≠do ao se definir o marcador de exclus√£o com determinado valor. Um valor diferente para o marcador indica um registro v√°lido (n√£o exclu√≠do). Os programas de pesquisa consideram apenas registros v√°lidos em um bloco quando realizam sua  busca.  Essas  duas  t√©cnicas  de  exclus√£o  exigem reorganiza√ß√£o peri√≥dica do arquivo para retomar o espa√ßo n√£o usado dos registros exclu√≠dos. Durante a reorganiza√ß√£o, os blocos de arquivo s√£o acessados de maneira consecutiva, e os registros s√£o compactados pela  remo√ß√£o  de  registros  exclu√≠dos.  Depois  dessa reorganiza√ß√£o, os blocos s√£o preenchidos at√© a capacidade mais uma vez. Outra possibilidade √© usar o espa√ßo dos registros exclu√≠dos ao inserir novos registros, embora isso exija uma manuten√ß√£o extra para se manter informado sobre os locais vazios.

Podemos usar a organiza√ß√£o espalhada ou n√£o espalhada para um arquivo desordenado, e ela pode ser utilizada com registros de tamanho fixo ou vari√°vel.  A  modifica√ß√£o  de  um  registro  de  tamanho  vari√°vel pode exigir a exclus√£o do registro antigo e a inser√ß√£o de um registro modificado, pois o registro modificado pode n√£o se encaixar em seu antigo espa√ßo no disco.

Para ler todos os registros na ordem dos valores de algum campo, criamos uma c√≥pia classificada do arquivo. A classifica√ß√£o √© uma opera√ß√£o cara para um arquivo de disco grande, e t√©cnicas  especiais  para classifica√ß√£o externa s√£o utilizadas (ver Cap√≠tulo 19).

Para um arquivo de registros  de  tamanho  fixo desordenados usando blocos n√£o espalhados e aloca√ß√£o cont√≠gua , √© simples acessar qualquer registro por sua posi√ß√£o no arquivo. Se os registros de arquivo forem numerados com 0, 1, 2, ...,   - 1 e os registros r em cada bloco forem numerados com 0, 1, ..., bfr - 1, onde bfr √© o fator de bloco, ent√£o o  -√©simo registro i do arquivo est√° localizado no bloco  ( / Ô£∞ i bfr )   e  √©  o  ( Ô£ª i mod bfr )  registro nesse bloco. Tal arquivo costuma o ser chamado de arquivo relativo ou direto , pois os registros podem ser facilmente acessados por suas posi√ß√µes relativas. O acesso a um registro por sua posi√ß√£o n√£o ajuda a localizar um registro com base em uma condi√ß√£o de busca; contudo, ele facilita a constru√ß√£o de caminhos de acesso no arquivo, como os √≠ndices discutidos no Cap√≠tulo 18.

## 17.7 Arquivos de registros ordenados (arquivos classificados)

Podemos ordenar fisicamente os registros de um arquivo  no  disco  com  base  nos  valores  de  um  de seus  campos  -  chamado de campo de ordena√ß√£o . Isso leva a um arquivo ordenado ou sequencial . 7 Se o campo de ordena√ß√£o tamb√©m for um campo-chave do arquivo - um campo com garantias de ter um valor exclusivo em cada registro -, ent√£o o campo √© chamado de chave de ordena√ß√£o para o arquivo. A Figura 17.7 mostra um arquivo ordenado com Nome como campo-chave de ordena√ß√£o (supondo que os funcion√°rios t√™m nomes distintos).

Os registros ordenados t√™m algumas vantagens em rela√ß√£o aos arquivos desordenados. Primeiro, a leitura dos registros na ordem dos valores da chave de  ordena√ß√£o  torna-se  extremamente  eficiente  porque  nenhuma  classifica√ß√£o  √©  necess√°ria.  Segundo, encontrar o pr√≥ximo registro com base no atual na ordem da chave de ordena√ß√£o em geral n√£o requer acessos de bloco adicionais porque o pr√≥ximo registro  est√°  no  mesmo  bloco  do  atual  (a  menos  que  o registro atual seja o √∫ltimo no bloco). Terceiro, o uso de uma condi√ß√£o de pesquisa baseada no valor de um campo-chave de ordena√ß√£o resulta  em  acesso  mais r√°pido quando a t√©cnica de pesquisa bin√°ria √© usada, o que constitui uma melhoria em rela√ß√£o √†s pesquisas lineares, embora normalmente isso n√£o seja utilizado para arquivos de disco. Os arquivos ordenados est√£o em blocos e armazenados em cilindros cont√≠guos para minimizar o tempo de busca.

Uma pesquisa bin√°ria por arquivos de disco pode ser feita nos blocos, em vez de nos registros. Suponha que o arquivo tenha b blocos numerados com 1, 2, ..., b ; os registros s√£o ordenados por valor crescente de seu campo-chave de ordena√ß√£o; e estamos procurando um registro cujo valor do campo-chave de ordena√ß√£o seja K . Supondo que os endere√ßos de disco dos blocos de arquivo estejam dispon√≠veis no cabe√ßalho de arquivo, a pesquisa bin√°ria pode ser descrita pelo Algoritmo 17.1. Uma pesquisa bin√°ria normalmente acessa log ( 2 b )  blocos, n√£o importando se o registro foi localizado ou n√£o - uma melhoria em rela√ß√£o √†s pesquisas lineares, onde, na m√©dia, ( b /2) blocos s√£o acessados quando o registro √© encontrado e b blocos s√£o acessados quando o registro n√£o √© encontrado.

l ‚Üê 1; u ‚Üê b ; ( ÔÉ© b √© o n√∫mero de blocos de arquivo ÔÉ© ) enquanto ( u ‚â• l ) faca inicio i ‚Üê ( l + u ) div 2; leia bloco   do arquivo para o buffer; i e s K &lt; (valor do campo-chave de ordena√ß√£o do primeiro registro no bloco  ) i ent√£o u ‚Üê i - 1 en√£o se s K &gt; (valor do campo-chave de ordena√ß√£o do √∫ltimo registro no bloco   ) i ent√£o l ‚Üê + 1 i en√£o se o registro com valor do campo-chas ve de ordena√ß√£o = K est√° no buffer ent√£o vai para found sen√£o vai para notfound; fim ; vai para notfound;

Um crit√©rio de pesquisa envolvendo as condi√ß√µes &gt; &lt; ‚â• , , e ‚â§ no  campo  de  ordena√ß√£o  √©  muito  eficiente, pois a ordena√ß√£o f√≠sica dos registros significa que todos os registros que satisfazem a condi√ß√£o s√£o cont√≠guos no arquivo. Por exemplo, com rela√ß√£o √† Figura 17.7, se o crit√©rio de pesquisa for ( Nome &lt; 'G') - onde &lt; significa alfabeticamente antes de -, os registros que satisfazem o crit√©rio de pesquisa s√£o aqueles do in√≠cio do arquivo at√© o primeiro registro que tem um valor Nome come√ßando com a letra 'G'.

A  ordena√ß√£o  n√£o  oferece  quaisquer  vantagens para  o  acesso  aleat√≥rio  ou  ordenado  dos  registros com  base  nos  valores  dos  outros campos  n√£o  ordenados do  arquivo.  Nesses  casos,  realizamos uma pesquisa linear para acesso aleat√≥rio. Para acessar os registros em ordem baseados no campo n√£o ordenados, √© necess√°rio criar outra c√≥pia ordenada - em uma ordem diferente - do arquivo.

Algoritmo 17.1. Pesquisa bin√°ria em uma chave de ordena√ß√£o de um arquivo de disco

A inser√ß√£o e a exclus√£o de registros s√£o opera√ß√µes dispendiosas para um arquivo ordenado, pois os registros  devem  permanecer  fisicamente  ordenados.  Para inserir um registro, temos de encontrar sua posi√ß√£o correta no arquivo, com base no valor de seu campo de ordena√ß√£o, e depois criar espa√ßo no arquivo para inserir o registro nessa posi√ß√£o. Para um arquivo grande, isso pode ser muito demorado porque, na m√©dia, metade dos registros no arquivo precisa ser movida para criar espa√ßo para o novo registro. Isso significa que metade dos blocos de arquivo deve ser lida e regravada depois que os registros forem movidos entre eles. Para a exclus√£o de registro, o problema √© menos grave se os marcadores de exclus√£o e a reorganiza√ß√£o peri√≥dica forem usados.

7 O termo arquivo sequencial tamb√©m tem sido usado para se referir aos arquivos desordenados, embora seja mais apropriado para arquivos ordenados.

Figura 17.7

|            | Nome               | Cpf   | Data_nascimento   | Cargo   | Salario   | Sexo   |
|------------|--------------------|-------|-------------------|---------|-----------|--------|
| Bloco 1    | Aaron, Eduardo     |       |                   |         |           |        |
|            | Ab√≠lio, Diana      |       |                   |         |           |        |
|            |                    |       | . . .             |         |           |        |
|            | Acosta, Marcos     |       |                   |         |           |        |
| Bloco 2    | Adams, Jo¬™o        |       |                   |         |           |        |
|            | Adams, Roberto     |       |                   |         |           |        |
|            |                    |       | . . .             |         |           |        |
|            | Akers, Janete      |       |                   |         |           |        |
| Bloco 3    | Alexandre, Eduardo |       |                   |         |           |        |
|            | Alfredo, Roberto   |       |                   |         |           |        |
|            |                    |       | . . .             |         |           |        |
|            | Allen, Samuel      |       |                   |         |           |        |
| Bloco 4    | Allen, Tiago       |       |                   |         |           |        |
|            | Anderson, Kely     |       |                   |         |           |        |
|            |                    |       | . . .             |         |           |        |
|            | Anderson, Joel     |       |                   |         |           |        |
| Bloco 5    | Anderson, Isaac    |       |                   |         |           |        |
|            | Angeli, Jos√ò       |       |                   |         |           |        |
|            |                    |       | . . .             |         |           |        |
|            | Anita, Sueli       |       |                   |         |           |        |
| Bloco 6    | Arnoldo, Marcelo   |       |                   |         |           |        |
|            | Arnoldo, Estevan   |       |                   |         |           |        |
|            |                    |       | . . .             |         |           |        |
|            | At√≠lio, Tim√≥teo    |       |                   |         |           |        |
| Bloco n -1 | Wanderley, Jaime   |       |                   |         |           |        |
|            | Wesley, Ronaldo    |       |                   |         |           |        |
|            |                    |       | . . .             |         |           |        |
|            | Wong, Manuel       |       |                   |         |           |        |
| Bloco n    | Wong, P√¢mela       |       |                   |         |           |        |
|            | Wuang, Charles     |       |                   |         |           |        |
|            |                    |       | . . .             |         |           |        |
|            | Zimmer, Andr√ò      |       |                   |         |           |        |

Alguns blocos de um arquivo ordenado (sequencial) de registros de FUNCIONARIO com Nome como campo-chave de ordena√ß√£o.

Uma op√ß√£o para tornar a inser√ß√£o mais eficiente √© manter algum espa√ßo n√£o usado em cada bloco para novos registros. Por√©m, quando esse espa√ßo √© totalmente utilizado, o problema original reaparece. Outro m√©todo frequentemente empregado √© criar um arquivo desordenado tempor√°rio, chamado arquivo de overflow ou transa√ß√£o .  Com  essa  t√©cnica,  o  arquivo ordenado real √© chamado de arquivo principal ou mestre . Novos registros s√£o inseridos no final do arquivo de overflow, em vez de em sua posi√ß√£o correta no arquivo principal. De tempos em tempos, o arquivo de overflow √© classificado e mesclado ao arquivo mestre durante a reorganiza√ß√£o do arquivo. A  inser√ß√£o  torna-se  muito  eficiente,  mas  ao  custo de  maior  complexidade  no  algoritmo  de  pesquisa. O arquivo de overflow precisa ser pesquisado usando uma pesquisa linear se, ap√≥s a pesquisa bin√°ria, o registro n√£o for encontrado no arquivo principal. Para

aplica√ß√µes que n√£o exigem a informa√ß√£o mais atualizada, os registros de overflow podem ser ignorados durante uma pesquisa.

A modifica√ß√£o  do  valor  de  um  campo  de  um registro  depende  de  dois  fatores:  a  condi√ß√£o  de pesquisa para localizar o registro e o campo a ser modificado. Se a condi√ß√£o de pesquisa envolver o campo da chave de ordena√ß√£o, podemos localizar o registro com uma pesquisa bin√°ria; caso contr√°rio, temos de realizar uma pesquisa linear. Um campo n√£o ordenado pode ser modificado ao alterar o registro e regrav√°-lo no mesmo local f√≠sico no disco - considerando registros de tamanho fixo. A modifica√ß√£o  do  campo  de  ordena√ß√£o  significa  que  o registro  pode  alterar  sua  posi√ß√£o  no  arquivo.  Isso requer a exclus√£o do registro antigo, seguida pela inser√ß√£o do registro modificado.

A leitura dos registros do arquivo na ordem do campo de ordena√ß√£o √© muito eficiente se ignorarmos os registros no overflow, pois os blocos podem ser lidos  consecutivamente  ao  usar  o  buffering  duplo. Para incluir os registros no overflow, temos de mescl√°-los em suas posi√ß√µes atuais; nesse caso, primeiro podemos reorganizar o arquivo, e depois ler seus blocos na sequ√™ncia. Para reorganizar o arquivo, classificamos os registros no arquivo de overflow e, depois, os  mesclamos  com  o  arquivo  mestre.  Os  registros marcados para exclus√£o s√£o removidos durante a reorganiza√ß√£o.

A Tabela 17.2 resume o tempo de acesso m√©dio em acessos de bloco para encontrar um registro espec√≠fico em um arquivo com b blocos.

Os  arquivos  ordenados  raramente  s√£o  usados em aplica√ß√µes de banco de dados, a menos que um caminho  de  acesso  adicional,  chamado √≠ndice  prim√°rio , seja utilizado; isso resulta em um arquivo sequencial-indexado . Isso melhora ainda mais o tempo de  acesso  aleat√≥rio  ao  campo-chave  de  ordena√ß√£o. (Discutiremos √≠ndices no Cap√≠tulo 18.) Se o atributo de ordena√ß√£o n√£o for uma chave, o arquivo √© chamado de arquivo agrupado .

## 17.8 √©cnicas de hashing T

Outro tipo de organiza√ß√£o de arquivo principal √© baseado no hashing, que oferece acesso muito r√°pido aos registros sob certas condi√ß√µes de pesquisa. Essa organiza√ß√£o costuma ser chamada de arquivo de  hash . 8 A  condi√ß√£o  de  pesquisa  precisa  ser  uma condi√ß√£o de igualdade em um √∫nico campo, chamado campo de hash . Na maior parte dos casos, o campo de hash tamb√©m √© um campo-chave do arquivo, quando ele √© chamado de chave hash .  A  ideia  por tr√°s do hashing √© oferecer uma fun√ß√£o h ,  chamada fun√ß√£o de hash ou fun√ß√£o de randomiza√ß√£o ,  que  √© aplicada ao valor do campo de hash de um registro e gera o endere√ßo do bloco de disco em que o registro est√° armazenado. Uma pesquisa pelo registro no bloco pode ser executada em um buffer da mem√≥ria principal. Para a maioria dos registros, s√≥ precisamos de um acesso de √∫nico bloco para recuperar esse registro.

O hashing tamb√©m √© utilizado como uma estrutura  de  pesquisa  interna  em  um  programa  sempre que um grupo de registros √© acessado exclusivamente pelo uso do valor de um campo. Descrevemos o uso do hashing para arquivos internos na Se√ß√£o 17.8.1; depois, mostramos como ele √© modificado para armazenar arquivos externos no disco na Se√ß√£o 17.8.2. Na Se√ß√£o 17.8.3, discutimos t√©cnicas para estender o hashing a arquivos dinamicamente crescentes.

## 17.8.1 Hashing interno

Para arquivos internos, o hashing normalmente √© implementado como uma tabela de hash por meio do uso de um array de registros. Suponha que o intervalo de √≠ndice de array seja de 0 a M -  1,  como mostra a Figura 17.8(a). Ent√£o, temos M slots cujos endere√ßos correspondem aos √≠ndices de array. Escolhemos uma fun√ß√£o de hash que transforma o valor de campo de hash em um inteiro entre 0 e M -  1. Uma fun√ß√£o de hash comum √© h K ( ) = K mod M , que retorna o resto de um valor de campo de hash inteiro

Tabela 17.2 Tempos de acesso m√©dios para um arquivo de b

blocos sob organiza√ß√µes de arquivo b√°sicas.

| Tipo de organiza√ß√£o   | M√©todo de acesso/pesquisa              | M√©dia de blocos para acessar um registro espec√≠fico   |
|-----------------------|----------------------------------------|-------------------------------------------------------|
| Heap (n√£o ordenado)   | Varredura sequencial (pesquisa linear) | b /2                                                  |
| Ordenado              | Varredura sequencial                   | b /2                                                  |
| Ordenado              | Pesquisa bin√°ria                       | log 2 b                                               |

8 Um arquivo de hash tamb√©m √© chamado de arquivo direto .





- ponteiro de nulo = -1
- ponteiro de overflow refere-se √† posi√ß¬™o do pr√≥ximo registro na lista ligada

Figura 17.8

Estruturas de dados de hashing interno. (a) Array de M posi√ß√µes para uso no hashing interno. (b) Resolu√ß√£o de colis√£o ao encadear registros.

K ap√≥s a divis√£o por M ; esse valor √© ent√£o usado para o endere√ßo do registro.

Os valores de campo de hash n√£o inteiros podem ser transformados em inteiros antes que a fun√ß√£o mod seja aplicada. Para cadeias de caracteres, os c√≥digos num√©ricos  (ASCII)  associados  aos  caracteres  podem ser usados na transforma√ß√£o - por exemplo, ao multiplicar  esses  valores  de  c√≥digo.  Para  um  campo  de hash cujo tipo de dado √© uma string de 20 caracteres, o Algoritmo 17.2(a) pode ser utilizado para calcular o endere√ßo de hash. Assumimos que a fun√ß√£o de c√≥digo retorna o c√≥digo num√©rico de um caractere e que recebemos um valor de campo de hash K do tipo K array : [1..20] of char (em Pascal) ou char K [20] (em C).

Algoritmo  17.2. Dois  algoritmos  de  hashing simples: (a) aplicando a fun√ß√£o de hash mod a uma cadeia de caracteres K. (b) Resolu√ß√£o de colis√£o por endere√ßamento aberto.

(a)

temp

‚Üê

1;

para i ‚Üê 1 at√© 20 fa√ßa temp ‚Üê temp ÔÉ© code( Ki [  ] ) mod M ;

endereco\_hash ‚Üê temp mod M ;

- (b) i ‚Üê endereco\_hash K ( ); a ‚Üê i ;
- se local   est√° ocupado i

entao inicio i ‚Üê (  + 1) mod i M ;

enquanto ( i ‚â† a ) e local   est√° ocupado i

fa√ßa i ‚Üê (  + 1) mod i M ; se (  = i a ) ent√£o todas as posi√ß√µes est√£o cheias se n√£o novo\_endereco\_hash ‚Üê i ; fim ;

Outras  fun√ß√µes  de  hashing  podem  ser  usadas. Uma t√©cnica, chamada desdobramento , envolve aplicar  uma fun√ß√£o aritm√©tica, como a adi√ß√£o ,  ou  uma fun√ß√£o l√≥gica, como o or exclusivo a diferentes partes do valor do campo de hash para calcular o endere√ßo de hash (por exemplo, com um espa√ßo de endere√ßos de 0 a 999 para armazenar 1.000 chaves, uma chave de seis d√≠gitos 235469 pode ser desdobrada e armazenada no endere√ßo: (235+964) mod 1000 = 199). Outra t√©cnica  envolve  escolher  alguns  d√≠gitos  do  valor  do campo de hash - por exemplo, terceiro, quinto e oitavo d√≠gitos - para formar o endere√ßo de hash (por exemplo, armazenando 1.000 funcion√°rios com n√∫meros de CPF de 11 d√≠gitos em um arquivo de hash com  1.000  posi√ß√µes  daria  ao  n√∫mero  de  CPF  301-678-923-51 um valor de hash de 172 por essa fun√ß√£o de hash). 9 O problema com a maioria das fun√ß√µes de hashing √© que elas n√£o garantem que valores distintos ter√£o  endere√ßos  de  hash  distintos,  pois  o espa√ßo do campo de hash - o n√∫mero de valores poss√≠veis que um campo de hash pode ter - normalmente √© muito maior do que o espa√ßo de endere√ßos - o n√∫mero de endere√ßos dispon√≠veis para registros. A fun√ß√£o de hashing mapeia o espa√ßo do campo de hash ao espa√ßo de endere√ßos.

Uma colis√£o ocorre quando o valor do campo de hash de um registro que est√° sendo inserido √© calculado como um endere√ßo que j√° cont√©m um registro diferente. Nessa situa√ß√£o, temos de inserir o novo registro em alguma outra posi√ß√£o, pois o endere√ßo de hash est√° ocupado. O processo de localizar outra posi√ß√£o √© chamado de resolu√ß√£o de colis√£o . Existem v√°rios m√©todos para resolu√ß√£o de colis√£o, incluindo os seguintes:

- ¬Ñ Endere√ßamento aberto. Partindo  da  posi√ß√£o ocupada especificada pelo endere√ßo de hash, o programa verifica as posi√ß√µes subsequentes em ordem, at√© que uma posi√ß√£o n√£o usada (vazia) seja encontrada. O Algoritmo 17.2(b) pode ser usado para essa finalidade.
- ¬Ñ Encadeamento. Para  esse  m√©todo,  v√°rios  locais de overflow s√£o mantidos, normalmente estendendo o array com uma s√©rie de posi√ß√µes de overflow. Al√©m disso, um campo de ponteiro √© acrescentado ao local de cada registro. Uma  colis√£o  √©  resolvida  ao  colocar  o  novo registro em um local de overflow n√£o usado
- e  definir  o  ponteiro  do  local  do  endere√ßo  de hash ocupado como o endere√ßo desse local de overflow. Portanto, √© mantida uma lista ligada de registros de overflow para cada endere√ßo de hash, como mostra a Figura 17.8(b).
- ¬Ñ Hashing  m√∫ltiplo. O  programa  aplica  uma segunda fun√ß√£o de hash se a primeira resultar em uma colis√£o. Se houver outra colis√£o, o programa utiliza o endere√ßamento aberto ou aplica uma terceira fun√ß√£o de hash e, depois, usa o endere√ßamento aberto, se necess√°rio.

Cada m√©todo de resolu√ß√£o de colis√£o requer os pr√≥prios algoritmos para inser√ß√£o, recupera√ß√£o e exclus√£o de registros. Os algoritmos para encadeamento  s√£o  os  mais  simples.  Os  algoritmos  de  exclus√£o para  endere√ßamento  aberto  s√£o  mais  complicados. Os livros-texto sobre estruturas de dados abordam algoritmos de hashing interno com mais detalhes.

O objetivo de uma boa fun√ß√£o de hashing √© distribuir os registros de maneira uniforme pelo espa√ßo de endere√ßos de modo a minimizar as colis√µes enquanto n√£o deixam muitos locais n√£o usados. A simula√ß√£o e os estudos de an√°lise mostraram que normalmente √© melhor manter uma tabela de hash entre 70 e 90 por cento cheia, de modo que o n√∫mero de colis√µes permane√ßa baixo e n√£o desperdicemos muito espa√ßo. Logo, se esperamos ter   registros para armazenar na r tabela, devemos escolher M locais para o espa√ßo de endere√ßos, tal que ( / r M ) esteja entre 0,7 e 0,9. Tamb√©m pode ser √∫til escolher um n√∫mero primo para M , pois j√° foi demonstrado que isso distribui melhor os endere√ßos de hash pelo espa√ßo de endere√ßos quando a fun√ß√£o de hashing mod √© utilizada. Outras fun√ß√µes de hash podem exigir que M seja uma pot√™ncia de 2.

## 17.8.2 Hashing externo para arquivos de disco

O hashing para arquivos de disco √© chamado de hashing externo . Para se ajustar √†s caracter√≠sticas do armazenamento de disco, o espa√ßo de endere√ßos de destino √© feito em buckets , cada um mantendo v√°rios registros. Um bucket √© um bloco de disco ou um cluster de blocos de disco cont√≠guos. A fun√ß√£o de hashing mapeia uma chave em um n√∫mero de bucket relativo, em vez de atribuir um endere√ßo de bloco absoluto ao bucket. Uma tabela mantida no cabe√ßalho do arquivo converte o n√∫mero do bucket para o endere√ßo do bloco de disco correspondente, conforme ilustra a Figura 17.9.

O  problema  de  colis√£o  √©  menos  s√©rio  com  os buckets porque, independentemente de quantos regis-

9 Uma discuss√£o detalhada das fun√ß√µes de hashing est√° fora do escopo de nossa apresenta√ß√£o.

Figura 17.9 Correspondendo n√∫meros de bucket a endere√ßos de bloco de disco.



tros possam caber em um bucket, eles podem ser definidos por hashing ao mesmo bucket sem causar problemas. Por√©m, temos de prever o caso em que um bucket est√° cheio at√© sua capacidade e um novo registro a ser inserido tem um hash para esse bucket. Podemos usar uma varia√ß√£o do encadeamento em que um ponteiro √© mantido em cada bucket para uma lista ligada de registros de overflow para o bucket, como mostra a Figura 17.10. Os ponteiros na lista ligada devem ser ponteiros de registro , que incluem um endere√ßo de bloco e uma posi√ß√£o de registro relativa no bloco.

O hashing oferece o acesso mais r√°pido poss√≠vel para recuperar um registro qualquer dado o valor de seu campo de hash. Embora a maioria das boas fun√ß√µes de hash n√£o mantenha registros na ordem dos valores de campo de hash, algumas fun√ß√µes - chamadas preserva√ß√£o de ordem - o fazem. Um exemplo simples de uma fun√ß√£o de hash de preserva√ß√£o de ordem √© usar os tr√™s d√≠gitos mais √† esquerda de um n√∫mero de fatura para gerar um endere√ßo de bucket como um endere√ßo de hash e manter os registros classificados por n√∫mero de fatura em cada bucket. Outro exemplo √© usar uma chave hash inteira diretamente como um √≠ndice para um arquivo relativo, se os valores de chave hash preencherem determinado intervalo; por exemplo, se os n√∫meros de funcion√°rio em uma empresa forem definidos como 1, 2, 3, ... at√© o n√∫mero total de funcion√°rios, podemos usar a fun√ß√£o de hash de identidade que mant√©m a ordem. Infelizmente, isso s√≥ funciona se as chaves forem geradas em ordem por alguma aplica√ß√£o.

O esquema de hashing descrito at√© aqui √© chamado de hashing est√°tico ,  pois  um n√∫mero fixo de buckets M √©  alocado.  Essa  pode  ser  uma  desvantagem  s√©ria para arquivos din√¢micos. Suponha que aloquemos M buckets para o espa√ßo de endere√ßos e deixemos m como o n√∫mero m√°ximo de registros que podem caber em um bucket; ent√£o, no m√°ximo ( m ÔÉ© M ) registros caber√£o no espa√ßo alocado. Se o n√∫mero de registros for substancialmente menor que ( m ÔÉ© M ), ficamos com muito espa√ßo n√£o usado. Por sua vez, se o n√∫mero de registros aumentar para muito mais do que ( m ÔÉ© M ), v√°rias colis√µes acontecer√£o, e a recupera√ß√£o ser√° mais lenta devido √†s longas listas de registros de overflow. Em ambos os casos, podemos ter de alterar o n√∫mero de blocos M alocados e depois usar uma nova fun√ß√£o de hashing (com base no novo valor de M ) para redistribuir os registros. Essas reorganiza√ß√µes podem ser muito demoradas para arquivos grandes. Organiza√ß√µes de arquivo din√¢mico mais recentes, baseadas em hashing, permitem que o n√∫mero de buckets varie dinamicamente apenas com a reorganiza√ß√£o localizada (ver Se√ß√£o 17.8.3).

Ao usar o hashing externo, a busca por um registro, dado um valor de algum campo diferente do campo de hash, √© t√£o dispendiosa quanto no caso de um arquivo desordenado. A exclus√£o de registro pode ser implementada pela remo√ß√£o do registro de seu bucket. Se o bucket tiver uma cadeia de overflow, podemos mover um dos registros de overflow para o bucket e substituir o registro exclu√≠do. Se o registro a ser exclu√≠do j√° estiver em overflow, simplesmente o removemos da lista ligada. Observe que a remo√ß√£o de um registro de overflow implica que devemos registrar a posi√ß√µes vazias no overflow. Isso √© feito facilmente pela manuten√ß√£o de uma lista interligada de locais de overflow n√£o usados.

A modifica√ß√£o do valor de campo de um registro especificado depende de dois fatores: da condi√ß√£o de pesquisa para localizar esse registro espec√≠fico e do campo a ser  modificado.  Se  a  condi√ß√£o  de  pesquisa for uma compara√ß√£o de igualdade no campo de hash, podemos localizar o registro de modo eficiente



NULL

Figura 17.10

Tratamento de overflow para buckets por encadeamento.

usando a fun√ß√£o de hashing; caso contr√°rio, temos de realizar uma pesquisa linear. Um campo n√£o de hash pode ser modificado pela mudan√ßa do registro e sua regrava√ß√£o no mesmo bucket. A modifica√ß√£o do campo de hash significa que o registro pode se mover para outro bucket, o que exige a exclus√£o do registro antigo seguida pela inser√ß√£o do registro modificado.

## 17.8.3 √©cnicas de hashing que permitem T a expans√£o din√¢mica do arquivo

Uma grande desvantagem do esquema de hashing est√°tico que acabamos de ver √© que o espa√ßo de endere√ßos de hash √© fixo. Logo, √© dif√≠cil expandir ou encolher o arquivo dinamicamente. Os esquemas descritos nesta se√ß√£o tentam solucionar essa situa√ß√£o. O primeiro esquema - o hashing extens√≠vel - armazena uma estrutura de acesso al√©m do arquivo e, portanto, √© semelhante √† indexa√ß√£o (ver Cap√≠tulo 18). A principal diferen√ßa √© que a estrutura de acesso se baseia nos valores que resultam ap√≥s a aplica√ß√£o da fun√ß√£o de hash ao campo de pesquisa. Na indexa√ß√£o, a estrutura de acesso √©

baseada nos valores do pr√≥prio campo de pesquisa. A segunda t√©cnica, chamada hashing linear, n√£o requer estruturas  de  acesso  adicionais.  Outro  esquema,  chamado hashing din√¢mico , usa uma estrutura de acesso baseada em estruturas de dados de √°rvore bin√°ria.

Esses esquemas de hashing tiram proveito do fato de  que  o  resultado  da  aplica√ß√£o  de  uma  fun√ß√£o  de hashing √© um inteiro n√£o negativo e, portanto, pode ser representado como um n√∫mero bin√°rio. A estrutura de acesso √© feita com base na representa√ß√£o bin√°ria do resultado da fun√ß√£o de hashing, que √© uma string de bits . Chamamos isso de valor de hash de  um registro. Os registros s√£o distribu√≠dos entre buckets com base nos valores dos bits iniciais em seus valores de hash.

Hashing extens√≠vel. No hashing extens√≠vel, um tipo de diret√≥rio - um array de 2  endere√ßos de bucket - √© d mantido, onde d √©  chamado de profundidade global do diret√≥rio. O valor inteiro correspondente aos primeiros d' bits (ordem alta) de um valor de hash √© utilizado como um √≠ndice para o array para determinar uma entrada de diret√≥rio, e o endere√ßo nessa entrada

determina o bucket em que os registros correspondentes s√£o armazenados. Por√©m, n√£o √© preciso haver um bucket distinto para cada um dos 2  locais de diret√≥rio. d V√°rios locais de diret√≥rio com os mesmos primeiros d ' bits para seus valores de hash podem conter o mesmo endere√ßo de bucket se todos os registros que possuem hash para esses locais couberem em um √∫nico bucket. Uma profundidade local d' - armazenada com cada bucket - especifica o n√∫mero de bits em que os conte√∫dos dos buckets s√£o baseados. A Figura 17.11 mostra um diret√≥rio com profundidade global d = 3.

tade ocorre se d &gt; d' para todos os buckets ap√≥s ocorrer algumas exclus√µes. A maioria das recupera√ß√µes de registro exige dois acessos de bloco - um para o diret√≥rio e outro para o bucket.

O valor de d pode ser aumentado ou diminu√≠do em um de cada vez, dobrando ou reduzindo √† metade, o n√∫mero de entradas no array do diret√≥rio. Dobrar √© necess√°rio se um bucket, cuja profundidade local d' √© igual √† profundidade global d , estourar. Reduzir √† me-

Para ilustrar a divis√£o de bucket, suponha que um novo registro inserido cause overflow no bucket cujos valores de hash come√ßam com 01 - o terceiro bucket na Figura 17.11. Os registros ser√£o distribu√≠dos entre dois buckets: o primeiro cont√©m todos os registros cujos valores de hash come√ßam com 010, e o segundo, todos aqueles cujos valores de hash come√ßam com 011. Agora, os dois locais de diret√≥rio para 010 e 011 apontam para os dois novos buckets distintos. Antes da divis√£o, eles apontavam para o mesmo bucket. A profundidade local d ' dos dois novos buckets √© 3, que √© um a mais que a profundidade local do bucket antigo.

Figura 17.11 Estrutura do esquema de hashing extens√≠vel.



Se um bucket que estoura e √© dividido costumava ter uma profundidade local d ' igual √† profundidade global d do  diret√≥rio,  ent√£o  o  tamanho  do  diret√≥rio  agora  precisa  ser  dobrado  de  modo  que  possamos usar um bit extra para distinguir os dois novos buckets.  Por  exemplo,  se  o  bucket  para  registros cujos valores de hash come√ßam com 111 na Figura 17.11 estourar, os dois novos buckets precisam de um diret√≥rio com profundidade global d = 4, pois os dois buckets agora s√£o rotulados com 1110 e 1111, e, portanto, suas profundidades locais s√£o ambas 4. O tamanho do diret√≥rio, ent√£o, √© dobrado, e cada um dos outros locais originais no diret√≥rio tamb√©m √© dividido em dois locais, ambos com o mesmo valor de ponteiro que o local original tinha.

A principal  vantagem  do  hashing  extens√≠vel  que o torna atraente √© que o desempenho do arquivo n√£o degrada  enquanto  o  arquivo  cresce,  ao  contr√°rio  do hashing externo est√°tico, onde as colis√µes aumentam e o encadeamento correspondente efetivamente aumenta o n√∫mero m√©dio de acessos por chave. Al√©m disso, nenhum espa√ßo √© alocado no hashing extens√≠vel para crescimento futuro, mas buckets adicionais podem ser alocados de maneira din√¢mica conforme a necessidade. O overhead de espa√ßo para a tabela de diret√≥rio √© insignificante.  O  tamanho  de  diret√≥rio  m√°ximo  √©  2 , k onde k √©  o  n√∫mero  de  bits  no  valor  de  hash.  Outra vantagem √© que a divis√£o causa uma pequena reorganiza√ß√£o na maior parte dos casos, visto que apenas os registros em um bucket s√£o redistribu√≠dos para os dois novos buckets. A √∫nica ocasi√£o em que a reorganiza√ß√£o √© mais dispendiosa √© quando o diret√≥rio precisa ser dobrado (ou reduzido √† metade). Uma desvantagem √© que o diret√≥rio precisa ser pesquisado antes do acesso aos pr√≥prios buckets, resultando em dois acessos a bloco em vez de um no hashing est√°tico. Essa penalidade no desempenho √© considerada pequena e, portanto, o esquema √© tido como bastante desej√°vel para arquivos din√¢micos.

Hashing din√¢mico. Um precursor do hashing extens√≠vel  foi  o  hashing  din√¢mico,  em  que  os  endere√ßos dos buckets eram os n bits de ordem alta ou n -  1 bits de ordem alta, dependendo do n√∫mero total de chaves  pertencentes  ao  respectivo  bucket.  O  eventual armazenamento de registros em buckets para o hashing din√¢mico √© um tanto semelhante ao hashing extens√≠vel. A principal diferen√ßa est√° na organiza√ß√£o do  diret√≥rio.  Enquanto  o  hashing  extens√≠vel  usa  a no√ß√£o de profundidade global ( d bits de alta ordem) para o diret√≥rio plano e depois combina buckets redut√≠veis  adjacentes  em  um  bucket  de  profundidade local d - 1, o hashing din√¢mico mant√©m um diret√≥rio estruturado em √°rvore com dois tipos de n√≥s:

- ¬Ñ N√≥s  internos  que  t√™m  dois  ponteiros  -  o ponteiro  esquerdo  correspondente  ao  bit  0
- (no endere√ßo hashed) e um ponteiro direito correspondente ao bit 1.
- ¬Ñ N√≥s folha - estes mant√™m um ponteiro para o bucket real com registros.

Um exemplo  do  hashing  din√¢mico  aparece  na Figura 17.12. Quatro buckets s√£o mostrados ('000', '001', '110' e '111') com endere√ßos de tr√™s bits de ordem alta (correspondentes √† profundidade global de 3) e dois buckets ('01' e '10') s√£o mostrados com endere√ßos de dois bits de ordem alta (correspondentes √† profundidade local de 2). Os dois √∫ltimos s√£o o resultado de reduzir o '010' e '011' para '01' e reduzir '100' e '101' para '10'. Observe que os n√≥s de diret√≥rio  s√£o  usados  implicitamente  para  determinar as profundidades 'global' e 'local' dos buckets no hashing din√¢mico. A procura por um registro, dado  o  endere√ßo  hashed,  envolve  atravessar  a  √°rvore de diret√≥rios, que leva ao bucket que mant√©m esse registro. Fica para o leitor a tarefa de desenvolver algoritmos para inser√ß√£o, exclus√£o e pesquisa de registros para o esquema de hashing din√¢mico.

Hashing linear. A ideia por tr√°s do hashing linear √© permitir que um arquivo de hash expanda e encolha seu  n√∫mero  de  buckets  dinamicamente  sem  precisar de um diret√≥rio. Suponha que o arquivo comece com M buckets numerados com 0, 1, ..., M - 1 e use mod a fun√ß√£o de hash h (K) = K mod M ; essa fun√ß√£o de hash √© chamada de fun√ß√£o de hash inicial h i .  O overflow devido a colis√µes ainda √© necess√°rio e pode ser tratado ao manterem-se as cadeias de overflow individuais  para  cada  bucket.  Contudo,  quando uma colis√£o leva a um registro de estouro em qualquer bucket de arquivo, o primeiro bucket no arquivo bucket 0 - √© dividido em dois buckets: o bucket original 0 e um novo bucket M ao final do arquivo. Os registros originalmente no bucket 0 s√£o distribu√≠dos entre os dois buckets com base em uma fun√ß√£o de hashing diferente h i +1 ( K ) = K mod 2 M . Uma propriedade-chave das duas fun√ß√µes de hash h i e h i +1 √© que quaisquer registros que receberam hash para o bucket 0 baseados em h i ter√£o um hash para o bucket 0 ou para o bucket M com base em h i +1 . Isso √© necess√°rio para que o hashing linear funcione.

√Ä medida que mais colis√µes levam a registros de overflow, buckets adicionais s√£o divididos na ordem linear 1, 2, 3, .... Se houver overflows suficientes, todos os buckets de arquivo originais 0, 1, ..., M - 1 ter√£o sido divididos, de modo que o arquivo agora tem 2 M em vez de M buckets, e todos os buckets usam a fun√ß√£o de hash h i +1 . Logo, os registros no overflow por  fim  s√£o  redistribu√≠dos  em  buckets  regulares, usando a fun√ß√£o h i +1 por meio de uma divis√£o adiada

Figura 17.12 Estrutura do esquema de hashing din√¢mico.



de  seus  buckets.  N√£o  existe  diret√≥rio;  somente  um valor n - que √© inicialmente definido como 0 e incrementado por 1 sempre que ocorre uma divis√£o - √© necess√°rio para determinar quais buckets foram divididos. Para recuperar um registro com valor de chave hash K , primeiro aplique a fun√ß√£o h i a K ; se h K i ( ) &lt; n , ent√£o aplique a fun√ß√£o h i +1 em K , porque o bucket j√° est√° dividido. Inicialmente, n = 0, indicando que a fun√ß√£o h i se aplica a todos os buckets; n cresce linearmente enquanto os buckets s√£o divididos.

Quando n = M depois de ser incrementado, isso significa que todos os buckets originais foram divididos  e  a  fun√ß√£o  de  hash h i +1 se  aplica  a  todos  os registros no arquivo. Nesse ponto, n √© retornado a 0 (zero), e quaisquer novas colis√µes que causem overflow levam ao uso de uma nova fun√ß√£o de hashing h i +2 ( K ) = K mod 4 M . Em geral, uma sequ√™ncia de fun√ß√µes de hashing h i + j ( K ) = K mod (2 M) √© utilizada, na j qual   = 0, 1, 2, ...; uma nova fun√ß√£o de hashing j h i + +1 j √©  necess√°ria  sempre  que  todos  os  buckets  0,  1,  ...,

(2 M) - 1 tiverem sido divididos e j n for retornado a 0. A busca por um registro com valor de chave hash K √© dada pelo Algoritmo 17.3.

A divis√£o  pode  ser  controlada  ao  monitorar  o fator de carga de arquivo em vez de dividir sempre que ocorre um overflow. Em geral, o fator de carga de arquivo l pode ser definido como   = l r /( bfr ÔÉ© N ), onde   √© o n√∫mero atual de registros do arquivo, r bfr √© o n√∫mero m√°ximo de registros que podem caber em um bucket, e N √© o n√∫mero atual de buckets de arquivo. Os buckets que foram divididos tamb√©m podem ser recombinados se o fator de carga do arquivo ficar abaixo de certo patamar. Os blocos s√£o combinados de maneira linear, e N √©  reduzido  adequadamente. A carga do arquivo pode ser usada para disparar divis√µes  e  combina√ß√µes.  Dessa  maneira,  ela  pode  ser mantida em um intervalo desejado. As divis√µes podem ser disparadas quando a carga excede determinado patamar - digamos, 0,9 - e as combina√ß√µes podem ser disparadas quando a carga cai abaixo de

outro patamar - digamos, 0,7. As principais vantagens do hashing linear s√£o que ele mant√©m o fator de carga razoavelmente constante enquanto o arquivo aumenta e diminui, e ele n√£o requer um diret√≥rio. 10

Algoritmo  17.3. O  procedimento  de  pesquisa para o hashing linear se n = 0 nt√£o e m ‚Üê h j ( K ) ( ÔÉ© m √© o valor de hash do registro com chave K ÔÉ© ) se n√£o inicio m ‚Üê h j ( K ); se m &lt; n ent√£o m ‚Üê h j +1 ( K ) fim ;

rocura o bucket cujo valor de hash √© p m (e seu overflow, se houver).

## 17.9 Outras organiza√ß√µes de arquivo prim√°rias

## 17.9.1 Arquivos de registros mistos

As organiza√ß√µes de arquivo que estudamos at√© aqui consideram que todos os registros de determinado arquivo s√£o do mesmo tipo. Os registros poderiam ser de FUNCIONARIO , PROJETO ALUNO , ou DEPARTAMENTO ,  mas cada arquivo cont√©m registros de apenas um tipo. Na maioria das aplica√ß√µes de banco de dados, encontramos situa√ß√µes em que diversos  tipos  de  entidades  s√£o  inter-relacionadas de v√°rias maneiras, como vimos no Cap√≠tulo 7. Os relacionamentos entre registros em v√°rios arquivos podem ser representados por campos de conex√£o . 11 Por exemplo, um registro de ALUNO pode ter um campo  de  conex√£o Dep\_princ cujo  valor  indica  o nome do DEPARTAMENTO em que o aluno est√° se formando. Esse  campo Dep\_princ refere-se a  uma entidade DEPARTAMENTO ,  que  deve  ser  representada por um registro pr√≥prio no arquivo DEPARTA -MENTO . Se quisermos recuperar valores de campo de dois registros relacionados, temos de recuperar um dos registros primeiro. Depois, podemos usar seu  valor  de  campo  de  conex√£o  para  recuperar  o registro relacionado no outro arquivo. Logo, os relacionamentos s√£o implementados por refer√™ncias de  campo  l√≥gicas entre  os  registros  em  arquivos distintos.

mentam relacionamentos entre registros como relacionamentos f√≠sicos realizados pela continuidade f√≠sica (ou agrupamento) de registros relacionados ou por ponteiros f√≠sicos. Essas organiza√ß√µes de arquivo em geral atribuem uma √°rea do disco para manter registros de mais de um tipo, de modo que registros de diferentes tipos podem ser fisicamente agrupados no disco.  Se  for  esperado  que  um  relacionamento em particular seja usado com frequ√™ncia, a implementa√ß√£o f√≠sica do relacionamento pode aumentar a efici√™ncia do sistema na recupera√ß√£o de registros relacionados.  Por  exemplo,  se  a  consulta  para  recuperar um registro de DEPARTAMENTO e todos os registros  de ALUNO s  que  est√£o  se  formando  nesse departamento for frequente, seria desej√°vel colocar cada  registro  de DEPARTAMENTO e  seu  cluster  de registros de ALUNO continuamente no disco em um arquivo  misto.  O  conceito  de agrupamento  f√≠sico dos tipos de objeto √© utilizado nos SGBDs de objeto para armazenar objetos relacionados juntos em um arquivo misto.

Para distinguir os registros em um arquivo misto,  cada  registro  tem  -  al√©m  de  seus  valores  de campo - um campo de tipo de registro ,  que especifica esse item. Esse costuma ser o primeiro campo em cada registro e √© usado pelo software do sistema para determinar o tipo de registro que ele est√° prestes a processar. Usando a informa√ß√£o do cat√°logo, o SGBD pode determinar os campos desse tipo de registro e seus tamanhos, a fim de interpretar os valores de dados nele.

## 17.9.2 B-trees e outras estruturas de dados como organiza√ß√£o prim√°ria

As  organiza√ß√µes  de  arquivos  em  SGBDs  de objeto,  bem  como  em  sistemas  legados  como  os SGBDs hier√°rquicos e de rede, normalmente imple-

Outras  estruturas  de  dados  podem  ser  usadas para organiza√ß√µes de arquivo prim√°rias. Por exemplo, se tanto o tamanho do registro quanto o n√∫mero de registros em um arquivo forem pequenos, alguns SGBDs oferecem a op√ß√£o de uma estrutura de dados B-tree como organiza√ß√£o de arquivo prim√°ria.  Descreveremos as B-trees na Se√ß√£o 18.3.1, quando discutiremos o uso da estrutura de dados B-tree para indexa√ß√£o. Em geral, qualquer estrutura de dados que possa ser adaptada √†s caracter√≠sticas dos dispositivos de disco pode ser utilizada como uma organiza√ß√£o de arquivo prim√°ria para posicionamento de registro no disco. Recentemente, o armazenamento de dados baseado em coluna foi proposto como um m√©todo prim√°rio para armazenamento de rela√ß√µes nos bancos de dados relacionais. Vamos apresent√°-lo rapidamente no Cap√≠tulo

10 Para ver os detalhes sobre inser√ß√£o e exclus√£o em arquivos com hashing linear, consulte Litwin (1980) e Salzberg (1988).

11 O conceito de chaves estrangeiras no modelo de dados relacional (Cap√≠tulo 3) e as refer√™ncias entre os objetos nos modelos orientados a objeto (Cap√≠tulo 11) s√£o exemplos de campos de conex√£o.

18 como um poss√≠vel esquema de armazenamento alternativo para bancos de dados relacionais.

## 17.10 Paralelizando o acesso de disco usando tecnologia RAID

Com o crescimento exponencial no desempenho e na capacidade dos dispositivos semicondutores e mem√≥rias, microprocessadores mais r√°pidos, com mem√≥rias prim√°rias cada vez maiores, est√£o continua  mente se tornando dispon√≠veis. Para corresponder a esse crescimento, √© natural esperar que a tecnologia de armazenamento secund√°rio tamb√©m deva acompanhar a tecnologia do processador em desempenho e confiabilidade.

Um avan√ßo importante na tecnologia de armazenamento  secund√°rio  √©  representado  pelo  desenvolvimento do RAID ,  que originalmente significava Redundant Array of Inexpensive Disks . Mais recentemente, o I em RAID passou a significar Independent .  A  ideia  do  RAID  recebeu  um  endosso  muito positivo  da  ind√∫stria,  e  desenvolveu-se  em  um  elaborado conjunto de arquiteturas RAID alternativas (RAID n√≠veis 0 a 6). Destacamos os principais recursos da tecnologia nesta se√ß√£o.

O objetivo principal do RAID √© nivelar as diferentes taxas de melhoria de desempenho dos discos contra  aquelas  na  mem√≥ria  e  nos  microprocessadores. 12 Enquanto as capacidades da RAM t√™m se quadruplicado a cada dois ou tr√™s anos, os tempos de acesso do disco est√£o melhorando em menos de

10 por cento ao ano, e as taxas de transfer√™ncia do disco est√£o melhorando em aproximadamente 20 por cento ao ano. As capacidades do  disco  est√£o realmente melhorando em mais de 50 por cento ao ano, mas as melhorias em velocidade e tempo de acesso s√£o de uma grandeza muito menor.

Existe  uma  segunda  disparidade  qualitativa entre  a  capacidade  dos  microprocessadores  especiais  de  atender  a  novas  aplica√ß√µes  envolvendo v√≠deo,  √°udio,  imagem  e  processamento  de  dados espaciais (veja, nos cap√≠tulos 26 e 30, os detalhes sobre essas aplica√ß√µes), com a correspondente falta de acesso r√°pido a conjuntos de dados grandes e compartilhados.

A solu√ß√£o natural √© um grande array de pequenos discos independentes, que atuam como um √∫nico disco l√≥gico de maior desempenho. Utiliza-se um conceito chamado striping de dados , que emprega o paralelismo para melhorar o desempenho do disco. O striping de dados distribui os dados transparentemente por v√°rios discos, para que pare√ßam ser um √∫nico disco grande e r√°pido. A Figura 17.13 mostra um arquivo distribu√≠do ou striped por quatro discos. O striping melhora o desempenho geral de E/S, permitindo que v√°rias E/S sejam atendidas em paralelo, oferecendo assim altas taxas de transfer√™ncia gerais. O striping de dados tamb√©m consegue balancear a carga entre os discos. Al√©m do mais, ao armazenar informa√ß√µes redundantes em discos com paridade ou algum outro  c√≥digo  de  corre√ß√£o  de  erro,  a  confiabilidade pode ser melhorada. Nas se√ß√µes 17.10.1 e 17.10.2,  discutimos  como  o  RAID  alcan√ßa  os  dois

Figura 17.13



Striping de dados em v√°rios discos. (a) Striping em n√≠vel de bit em quatro discos. (b) Striping em n√≠vel de bloco em quatro discos.

12 Isso foi previsto por Gordon Bell para ser cerca de 40 por cento a cada ano entre 1974 e 1984, e agora deve ultrapassar os 50 por cento ao ano.

objetivos  importantes  de  melhor  confiabilidade  e maior desempenho. A Se√ß√£o 17.10.3 discute as organiza√ß√µes e os n√≠veis de RAID.

## 17.10.1 Melhorando a confiabilidade com RAID

Para um array de n discos,  a  probabilidade de falha √© de n vezes, assim como a de um √∫nico disco. Portanto, se o MTBF ( Mean Time Between Failures ) de uma unidade de disco √© considerado com 200.000 horas ou cerca de 22,8 anos (para a unidade de disco da Tabela 17.1, chamada Cheetah NS, ela √© de 1,4 milh√£o de horas), o MTBF para um banco de 100 unidades de disco torna-se apenas 2.000 horas, ou 83,3 dias (para 1.000 discos Cheetah NS, ele seria de 1.400 horas, ou 58,33 dias). Manter uma √∫nica c√≥pia de dados nesse tipo de array de discos causar√° uma perda de confiabilidade significativa.  Uma  solu√ß√£o √≥bvia √© empregar a redund√¢ncia de dados de modo que as falhas de disco possam ser toleradas. As desvantagens s√£o muitas: opera√ß√µes de E/S adicionais para grava√ß√£o, computa√ß√£o extra para manter redund√¢ncia e realizar recupera√ß√£o de erros, e capacidade de disco adicional para armazenar informa√ß√µes redundantes.

Uma t√©cnica para introduzir redund√¢ncia √© chamada de espelhamento ou sombreamento . Os dados s√£o gravados  de  maneira  redundante  em  dois  discos  f√≠sicos id√™nticos, que s√£o tratados como um disco l√≥gico. Quando os dados s√£o lidos, eles podem ser apanhados do disco com menores atrasos de fila, busca e rotacionais. Se um disco falhar, o outro √© usado at√© que o primeiro seja reparado. Supondo que o tempo m√©dio para reparo seja de 24 horas, ent√£o o tempo m√©dio para a perda de dados de um sistema de disco espelhado que usa 100 discos com MTBF de 200.000 horas cada √© (200.000) 2 /(2 ÔÉ© 24) = 8,33 ÔÉ© 10 8 horas, que corresponde a 95.028 anos. 13  O espelhamento de disco tamb√©m dobra a taxa em que as solicita√ß√µes de leitura s√£o tratadas, pois uma leitora pode ir para qualquer disco. A taxa de transfer√™ncia de cada leitura, por√©m, permanece igual √† taxa para um √∫nico disco.

Outra solu√ß√£o para o problema de confiabilidade √© armazenar informa√ß√µes extras que n√£o s√£o necess√°rias normalmente, mas que podem ser usadas para reconstruir a informa√ß√£o pedida no caso de falha no disco. A incorpora√ß√£o de redund√¢ncia precisa considerar dois problemas: selecionar uma t√©cnica  para  calcular  a  informa√ß√£o  redundante  e selecionar um m√©todo de distribui√ß√£o da informa√ß√£o  redundante  pelo  array  de  disco.  O  primeiro problema √© resolvido usando c√≥digos de corre√ß√£o

13 As f√≥rmulas para c√°lculo do MTBF podem ser vistas em Chen et al. (1994).

de erro que envolvem bits de paridade, ou c√≥digos especializados como os c√≥digos de Hamming. Sob o esquema de paridade, um disco redundante pode ser  considerado como tendo a soma de todos os dados nos outros discos. Quando um disco falha, a informa√ß√£o que falta pode ser constru√≠da por um processo semelhante √† subtra√ß√£o.

Para o segundo problema, as duas t√©cnicas principais s√£o armazenar a informa√ß√£o redundante em um pequeno n√∫mero de discos ou distribu√≠-las uniformemente por todos os discos. A √∫ltima resulta em melhor balanceamento de carga. Os diferentes n√≠veis de RAID escolhem uma combina√ß√£o dessas op√ß√µes para implementar a redund√¢ncia e melhorar a confiabilidade.

## 17.10.2 Melhorando o desempenho com RAID

Os arrays de disco empregam a t√©cnica de strip  ing de dados para obter taxas de transfer√™ncia mais altas. Observe que os dados podem ser lidos ou gravados em apenas um bloco de cada vez, de modo que uma transfer√™ncia t√≠pica cont√©m de 512 a 8.192 bytes. O striping de disco pode ser aplicado em uma granularidade mais fina dividindo um byte de dados em bits e espalhando os bits em diferentes discos. Assim, o striping de dados em n√≠vel de bit consiste em dividir um byte de dados e gravar o bit   no  -√©simo disco. j j Com bytes de 8 bits, oito discos f√≠sicos podem ser considerados um disco l√≥gico, com um aumento de oito vezes na taxa de transfer√™ncia de dados. Cada disco participa em cada solicita√ß√£o de E/S e a quantidade total de dados lidos por solicita√ß√£o √© oito vezes maior. O striping em n√≠vel de bit pode ser generalizado para um n√∫mero de discos que √© ou um m√∫ltiplo ou um fator de oito. Assim, em um array de quatro discos, o bit n vai para o disco que √© ( n mod 4). A Figura 17.13(a) mostra o striping de dados em n√≠vel de bit.

A granularidade da intercala√ß√£o de dados pode ser mais alta do que um bit. Por exemplo, os blocos de um arquivo podem ser espalhados pelos discos, fazendo surgir o striping em n√≠vel de bloco . A Figura 17.13(b) mostra o striping de dados em n√≠vel de bloco considerando que o arquivo de dados cont√©m quatro blocos. Com o striping em n√≠vel de bloco, v√°rias solicita√ß√µes independentes que acessam blocos isolados (pequenas solicita√ß√µes) podem ser atendidas em paralelo por discos separados, diminuindo assim o tempo de enfileiramento das solicita√ß√µes de E/S. As solicita√ß√µes que acessam m√∫ltiplos blocos (grandes solicita√ß√µes) podem ser feitas em paralelo, reduzindo assim o tempo de resposta.

Em geral, quanto maior o n√∫mero de discos em um array, maior o benef√≠cio do desempenho em potencial.  Por√©m,  considerando  falhas  independentes, o array de disco de 100 discos coletivamente tem 1/100 da confiabilidade de um √∫nico disco. Portanto, a redund√¢ncia por meio de c√≥digos de corre√ß√£o de erro e espelhamento de disco √© necess√°ria para fornecer confiabilidade junto com um desempenho alto.

## 17.10.3 Organiza√ß√µes e n√≠veis de RAID

Diferentes organiza√ß√µes de RAID foram definidas com base em diversas combina√ß√µes dos dois fatores de detalhamento da intercala√ß√£o (striping) e do padr√£o de dados usados para calcular informa√ß√µes redundantes. Na proposta inicial, os n√≠veis  de  1  a  5  de  RAID  foram  propostos,  e  dois n√≠veis adicionais - 0 e 6 - foram acrescentados depois.

O RAID n√≠vel 0 usa striping de dados, n√£o tem dados redundantes e, portanto, tem o melhor desempenho de grava√ß√£o, pois as atualiza√ß√µes n√£o precisam ser  duplicadas.  Ele  divide  os  dados  uniformemente entre  dois  ou  mais  discos.  Por√©m,  seu  desempenho de leitura  n√£o  √©  t√£o  bom  quanto  o  do  RAID  n√≠vel 1, que usa discos espelhados. Neste, a melhoria do desempenho √© poss√≠vel pelo escalonamento de uma solicita√ß√£o de leitura ao disco com o menor atraso esperado de busca e rotacional. O RAID n√≠vel 2 usa a redund√¢ncia no estilo da mem√≥ria ao empregar c√≥digos de Hamming, que cont√™m bits de paridade para subconjuntos sobrepostos distintos de componentes. Assim, em uma vers√£o em particular desse n√≠vel, tr√™s discos redundantes s√£o suficientes para quatro discos originais, enquanto com espelhamento - como no n√≠vel 1 -, quatro seriam necess√°rios. O n√≠vel 2 inclui detec√ß√£o e corre√ß√£o de erro, embora a detec√ß√£o geralmente n√£o seja exigida, pois discos defeituosos se identificam.

O  RAID  n√≠vel  3  utiliza  um  √∫nico  disco  de paridade  contando  com  o  controlador  de  disco para  descobrir  qual  disco  falhou.  Os  n√≠veis  4  e 5  usam  o  striping  de  dados  em  n√≠vel  de  bloco, com o n√≠vel 5 distribuindo informa√ß√µes de dados e paridade por todos os discos. A Figura 17.14(b) mostra uma ilustra√ß√£o de RAID n√≠vel 5, em que a paridade aparece com o subscrito p. Se um disco falha, os dados que faltam s√£o calculados com base na paridade dispon√≠vel dos discos restantes. Finalmente, o RAID n√≠vel 6 se aplica ao chamado esquema  de  redund√¢ncia P + Q usando c√≥digos de  Reed-Soloman para proteger  contra  at√©  duas falhas de disco usando apenas dois discos redundantes.











## Figura 17.14

Alguns n√≠veis de RAID populares. (a) RAID n√≠vel 1: espelhamento de dados em dois discos. (b) RAID n√≠vel 5: striping de dados com paridade distribu√≠da por quatro discos.

A reconstru√ß√£o em caso de falha de disco √© mais f√°cil para RAID n√≠vel 1. Outros n√≠veis exigem a reconstru√ß√£o de um disco defeituoso com a leitura de m√∫ltiplos discos. O n√≠vel 1 √© usado para aplica√ß√µes cr√≠ticas,  como o armazenamento de logs de transa√ß√µes. Os n√≠veis 3 e 5 s√£o preferidos para armazenamento em grande volume, com o n√≠vel 3 oferecendo taxas  de  transfer√™ncia  mais  altas.  O  uso  mais  popular  da  tecnologia  RAID  atualmente  usa  n√≠vel  0 (com striping), n√≠vel 1 (com espelhamento) e n√≠vel 5 com uma unidade extra para paridade. Uma combina√ß√£o de v√°rios n√≠veis RAID tamb√©m √© utilizada por exemplo, 0+1 combina striping e espelhamento usando um m√≠nimo de quatro discos. Outros n√≠veis de  RAID fora do padr√£o s√£o: RAID 1,5, RAID 7, RAID-DP, RAID S ou Parity RAID, Matrix RAID, RAID-K,  RAID-Z,  RAIDn,  Linux  MD  RAID  10, IBM ServeRAID 1E e unRAID. Uma discuss√£o sobre esses n√≠veis fora do padr√£o n√£o est√° no escopo deste livro. Os projetistas de uma configura√ß√£o RAID para determinada  mistura  de  aplica√ß√µes  precisam  confrontar muitas decis√µes de projeto, como o n√≠vel de RAID, o n√∫mero de discos, a escolha de esquemas de paridade e o agrupamento de discos para o striping em n√≠vel de bloco. Estudos de desempenho detalhados sobre leituras e grava√ß√µes (referindo-se a solicita√ß√µes de E/S para uma unidade de striping) e grandes leituras e grava√ß√µes (referindo-se a solicita√ß√µes de E/S para uma unidade de stripe de cada disco em um grupo de corre√ß√£o de erro) t√™m sido realizados.

## 17.11 Novos sistemas de armazenamento

Nesta se√ß√£o, descrevemos tr√™s desenvolvimentos recentes em sistemas de armazenamento que est√£o se tornando parte integrante da maioria das arquiteturas dos sistemas de informa√ß√£o nas empresas.

## 17.11.1 Redes de √°rea de armazenamento

Com o r√°pido crescimento do com√©rcio eletr√¥nico,  sistemas  de Planejamento de Recursos Empresariais ( ERP -Enterprise Resource Planning ) que integram dados da aplica√ß√£o entre as organiza√ß√µes, e data warehouses (armaz√©ns de dados) que mant√™m informa√ß√µes hist√≥ricas agregadas (ver Cap√≠tulo 29), a demanda por armazenamento tem crescido substancialmente. Para as organiza√ß√µes voltadas para a Internet de hoje, torna-se necess√°rio passar de uma opera√ß√£o est√°tica,  orientada  a  um  centro  de  dados  fixo,  para uma infraestrutura mais flex√≠vel e din√¢mica para seus requisitos de processamento de informa√ß√£o. O custo total  de  gerenciamento de todos os dados est√° crescendo t√£o rapidamente que, em muitos casos, o custo de gerenciar o armazenamento ligado ao servidor ultrapassa o custo do pr√≥prio servidor. Al√©m do mais, o custo de aquisi√ß√£o de armazenamento √© apenas uma pequena fra√ß√£o - em geral, apenas 10 a 15 por cento do custo geral do gerenciamento do armazenamento. Muitos usu√°rios de sistemas RAID n√£o podem usar a capacidade de modo eficaz porque ela precisa estar ligada de uma maneira fixa a um ou mais servidores. Portanto, a maioria das grandes organiza√ß√µes mudou para um conceito chamado √°reas de armazenamento em rede (SANs -Storage Area Networks) . Em uma SAN,  os  perif√©ricos  de  armazenamento  on-line  s√£o configurados como n√≥s em uma rede de alta velocidade e podem ser conectados e desconectados dos servidores de uma maneira bastante flex√≠vel. V√°rias empresas t√™m surgido como provedores de SAN e fornecem as  pr√≥prias  topologias  propriet√°rias.  Elas  permitem que os sistemas de armazenamento sejam colocados a dist√¢ncias maiores dos servidores e oferecem diferentes op√ß√µes de desempenho e conectividade. As aplica√ß√µes de gerenciamento de armazenamento existentes podem ser transportadas para configura√ß√µes SAN por meio de redes Canal de Fibra, que encapsulam o protocolo SCSI legado. Como resultado, os dispositivos conectados √† SAN aparecem como dispositivos SCSI.

As alternativas arquitet√¥nicas atuais para SAN incluem  o  seguinte:  conex√µes  ponto  a  ponto  entre servidores  e  sistemas  de  armazenamento  por  canal de fibra; uso de um canal de fibra para conectar v√°rios sistemas RAID, bibliotecas de fita, e assim por diante, aos servidores; e o uso de hubs e switches de canal de fibra para conectar servidores e sistemas de armazenamento em diferentes configura√ß√µes. As organiza√ß√µes  podem  lentamente  passar  de  topologias mais simples para as mais complexas, acrescentando servidores e dispositivos de armazenamento conforme a necessidade. N√£o oferecemos mais detalhes aqui porque eles variam entre os vendedores de SAN. As principais vantagens alegadas s√£o:

- ¬Ñ Conectividade flex√≠vel de muitos-para-muitos entre servidores e dispositivos de armazenamento  usando  hubs  e  switches  de  canal  de fibra.
- ¬Ñ At√© 10 km de separa√ß√£o entre um servidor e um sistema de armazenamento usando cabos de fibra √≥tica apropriados.
- ¬Ñ Melhores capacidades de isolamento, permitindo o acr√©scimo transparente de novos perif√©ricos e servidores.

As  SANs  est√£o  crescendo  muito  rapidamente, mas  ainda  enfrentam  muitos  problemas,  como  a combina√ß√£o de op√ß√µes de armazenamento de v√°rios vendedores e o tratamento dos padr√µes em evolu√ß√£o de software e hardware de gerenciamento de armazenamento. As principais empresas est√£o avaliando as SANs como uma op√ß√£o vi√°vel para o armazenamento de banco de dados.

## 17.11.2 Armazenamento conectado √† rede

Com  o  crescimento  fenomenal  nos  dados  digitais,  particularmente  gerados  pela  multim√≠dia  e  outras aplica√ß√µes da empresa, a necessidade de solu√ß√µes de armazenamento de alto desempenho a um baixo custo tornou-se extremamente importante. Os dispositivos de armazenamento conectado √† rede  NAS ( -Network-Attached Storage ) est√£o entre os dispositivos de armazenamento usados para essa finalidade. Esses dispositivos, de fato, s√£o servidores que n√£o oferecem quaisquer dos servi√ßos comuns do servidor, mas simplesmente  permitem  o  acr√©scimo  de  armazenamento  para  compartilhamento de arquivos. Dispositivos NAS permitem que uma grande quantidade de espa√ßo de armazenamento de disco r√≠gido seja acrescentada a uma rede e podem tornar esse espa√ßo dispon√≠vel a m√∫ltiplos  servidores  sem  ter  de  interromp√™-los  para manuten√ß√£o  e  atualiza√ß√µes.  Dispositivos  NAS  residem em qualquer lugar em uma rede local (LAN) e podem ser combinados em diferentes configura√ß√µes. Um √∫nico dispositivo de hardware, normalmente chamado caixa NAS ou cabe√ßa NAS , atua como a interface entre o sistema NAS e os clientes da rede. Esses dispositivos  NAS  n√£o  exigem  monitor,  teclado  ou mouse. Uma ou mais unidades de disco ou fita podem

ser conectadas a muitos sistemas NAS para aumentar a capacidade total. Os clientes se conectam √† cabe√ßa NAS, em vez de aos dispositivos de armazenamento individuais. Um NAS pode armazenar quaisquer dados que apare√ßam na forma de arquivos, como caixas de e-mail, conte√∫do Web, backups de sistema remoto, e assim por diante. Nesse sentido, os dispositivos NAS est√£o sendo implantados como uma substitui√ß√£o para os servidores de arquivos tradicionais.

Os sistemas NAS trabalham por opera√ß√£o confi√°vel  e  administra√ß√£o  f√°cil.  Eles  incluem  recursos embutidos,  como  autentica√ß√£o  segura,  ou  o  envio autom√°tico  de  alertas  de  e-mails  em  caso  de  erro no dispositivo. Os dispositivos NAS (ou appliances , como alguns vendedores se referem a eles) est√£o sendo oferecidos com um alto grau de escalabilidade, confiabilidade,  flexibilidade  e  desempenho.  Esses dispositivos normalmente suportam RAID n√≠veis 0, 1 e 5. As √°reas de armazenamento em rede (SANs) tradicionais  diferem  da  NAS  de  v√°rias  maneiras. Especificamente, as SANs costumam utilizar Canal de Fibra em vez de Ethernet, e uma SAN em geral incorpora v√°rios dispositivos de rede ou end points em uma LAN autocontida ou privativa , enquanto a NAS conta com dispositivos individuais conectados diretamente a uma LAN p√∫blica existente. Enquanto servidores de arquivo Windows, UNIX e NetWare  exigem  um  suporte  de  protocolo  espec√≠fico  no lado do cliente, os sistemas NAS alegam ter maior independ√™ncia do sistema operacional dos clientes.

## 17.11.3 Sistemas de armazenamento iSCSI

Um  novo  protocolo,  chamado iSCSI (Internet SCSI)  foi  proposto  recentemente.  Ele  permite  que os  clientes  (chamados iniciadores )  enviem  comandos SCSI para dispositivos de armazenamento SCSI em canais remotos. A principal vantagem do iSCSI √© que ele n√£o exige o cabeamento especial necess√°rio pelo Canal de Fibra e pode se estender por dist√¢ncias maiores  usando  a  infraestrutura  de  rede  existente. Ao transportar comandos SCSI por redes IP, o iSCSI facilita  as  transfer√™ncias  de  dados  pelas  intranets  e gerencia o armazenamento por longas dist√¢ncias. Ele pode transferir dados por redes locais (LANs), redes remotas (WANs) ou pela Internet.

O  iSCSI  funciona  da  seguinte  forma.  Quando um SGBD precisa acessar dados, o sistema operacional gera os comandos SCSI apropriados e a requisi√ß√£o de dados, que ent√£o passam por procedimentos de encapsulamento e, se for preciso, criptografia. Um cabe√ßalho de pacote √© acrescentado antes que os pacotes IP resultantes sejam transmitidos por uma conex√£o Ethernet. Quando um pacote √© recebido, ele √© descriptografado (se foi criptografado antes da trans- miss√£o) e desmontado, separando os comandos SCSI e a solicita√ß√£o. Os comandos SCSI seguem por meio do controlador SCSI para o dispositivo de armazenamento SCSI. Como o iSCSI √© bidirecional, o protocolo tamb√©m pode ser usado para retornar dados em resposta √† solicita√ß√£o original. A Cisco e a IBM comercializaram switches e roteadores com base nessa tecnologia.

- O armazenamento iSCSI afetou principalmente empresas de pequeno e m√©dio porte por causa de sua combina√ß√£o de simplicidade, baixo custo e funcionalidade dos dispositivos iSCSI. Ele permite que elas n√£o  tenham  de  entender  os  detalhes  da  tecnologia Canal  de  fibra  (FC)  e,  em  vez  disso,  beneficiam-se de sua familiaridade com o protocolo IP e hardware Ethernet.  As  implementa√ß√µes  iSCSI  nos  centros  de dados de empresas muito grandes s√£o lentas no desenvolvimento por causa de seu investimento pr√©vio em SANs baseadas em Canal de Fibra.

O iSCSI √© uma das principais t√©cnicas de transmiss√£o de dados de armazenamento por redes IP. O outro m√©todo, Canal de Fibra sobre IP (CFIP) , traduz c√≥digos de controle Canal de Fibra e dados em pacotes IP para transmiss√£o entre redes de √°rea de armazenamento Canal de Fibra geograficamente distantes. Esse protocolo, tamb√©m conhecido como tunelamento Canal de Fibra ou tunelamento de armazenamento , s√≥ pode ser usado junto com a tecnologia Canal de Fibra, ao passo que o iSCSI pode utilizar as redes Ethernet existentes.

A ideia mais recente a entrar na corrida do armazenamento IP da empresa √© o Canal de Fibra over Ethernet  (FCoE) ,  que  pode  ser  imaginado  como  o iSCSI sem o IP. Ele utiliza muitos elementos de SCSI e FC (assim como o iSCSI), mas n√£o inclui os componentes TCP/IP. Isso promete excelente desempenho, especialmente na 10 Gigabit Ethernet (10GbE), e √© relativamente f√°cil para os vendedores acrescentarem em seus produtos.

## Resumo

Come√ßamos este cap√≠tulo discutindo as caracter√≠sticas das hierarquias de mem√≥ria e depois nos concentramos nos dispositivos de armazenamento secund√°rios. Em particular, focalizamos os discos magn√©ticos porque eles s√£o usados mais frequentemente para armazenar arquivos de banco de dados on-line.

Os dados no disco s√£o armazenados em blocos; o acesso a um bloco de disco √© caro devido ao tempo de busca,  atraso  rotacional  e  tempo  de  transfer√™ncia  de bloco. Para reduzir o tempo de acesso de bloco m√©dio, o buffering duplo pode ser usado ao acessar blocos de disco  consecutivos.  (Outros  par√¢metros  de  disco  ser√£o

discutidos no Ap√™ndice B.) Apresentamos diferentes maneiras  de  armazenar  registros  de  arquivo  no  disco.  Os registros de arquivo s√£o agrupados em blocos de disco e podem ser de tamanho fixo ou vari√°vel, espalhados ou n√£o espalhados, e do mesmo tipo de registro ou de tipos mistos.  Discutimos  sobre  o  cabe√ßalho  de  arquivo,  que descreve os formatos de registro e mant√©m os endere√ßos de disco dos blocos de arquivo. As informa√ß√µes no cabe√ßalho de arquivo s√£o usadas pelo software do sistema que acessa os registros de arquivo.

Depois,  apresentamos  um  conjunto  de  comandos t√≠picos  para  acessar  registros  de  arquivo  individuais  e discutimos o conceito do registro atual de um arquivo. Discutimos  como  as  condi√ß√µes  complexas  de  pesquisa de registro s√£o transformadas em condi√ß√µes de pesquisa simples, utilizadas para localizar registros no arquivo.

Tr√™s organiza√ß√µes de arquivo prim√°rios foram ent√£o abordadas: as n√£o ordenadas, as ordenadas e as hashed.  Os  arquivos  desordenados  exigem  uma  pesquisa linear para localizar registros, mas a inser√ß√£o de registro √© muito simples. Discutimos o problema da exclus√£o e o uso de marcadores de exclus√£o.

Os arquivos ordenados encurtam o tempo exigido para ler registros na ordem do campo de ordena√ß√£o. O tempo exigido para procurar um registro qualquer, dado o valor de seu campo-chave de ordena√ß√£o, tamb√©m √© reduzido se uma pesquisa bin√°ria for usada. Por√©m, manter os registros em ordem torna a inser√ß√£o muito dispendiosa. Assim, a t√©cnica de usar um arquivo de overflow desordenado para reduzir o custo de inser√ß√£o de registro foi discutida. Registros de overflow s√£o mesclados com o arquivo mestre periodicamente durante a reorganiza√ß√£o do arquivo.

O hashing oferece acesso muito r√°pido a um registro qualquer de um arquivo, dado o valor de sua chave hash. O m√©todo mais adequado para o hashing externo √© a t√©cnica de bucket, com um ou mais blocos cont√≠guos correspondendo a cada bucket. As colis√µes que causam overflow de bucket s√£o tratadas pelo encadeamento. O acesso em qualquer campo n√£o de hash √© lento, e o mesmo vale para o acesso ordenado dos registros em qualquer  campo.  Discutimos  tr√™s  t√©cnicas  de  hashing  para arquivos que crescem e encolhem no n√∫mero de registros dinamicamente: extens√≠veis, din√¢micos e hashing linear. Os dois primeiros usam os bits de mais alta ordem do endere√ßo de hash para organizar um diret√≥rio. O hashing linear √© preparado para manter o fator de carga do arquivo dentro de determinado intervalo e acrescentar novos buckets linearmente.

Discutimos rapidamente outras possibilidades para organiza√ß√µes  de  arquivo  prim√°rias,  como  as  B-trees,  e arquivos de registros mistos, que implementam relacionamentos entre registros de diferentes tipos fisicamente como parte da estrutura de armazenamento. Revisamos os avan√ßos recentes em tecnologia de disco representados por RAID (Redundant Arrays of Inexpensive - ou Independent - Disks), que se tornou uma t√©cnica-padr√£o em grandes empresas para oferecer melhor confiabilidade e recursos de toler√¢ncia a falhas no armazenamento. Por fim, revisamos as tr√™s op√ß√µes atualmente populares nos sistemas de armazenamento empresarial: as √°reas de armazenamento em rede (SANs), o armazenamento conectado √† rede (NAS) e os sistemas de armazenamento iSCSI.

## Perguntas de revis√£o

- 17.1. Qual √© a diferen√ßa entre armazenamento prim√°rio e secund√°rio?
- 17.2. Por que os discos, e n√£o as fitas, s√£o usados para armazenar arquivos de banco de dados on-line?
- 17.3. Defina os seguintes termos: disco , disk pack , trilha , bloco , cilindro , setor , lacuna entre blocos , cabe√ßa de leitura grava√ß√£o / .
- 17.4. Discuta o processo de inicializa√ß√£o de disco.
- 17.5. Discuta o mecanismo usado para ler ou gravar dados no disco.
- 17.6. Quais s√£o os componentes de um endere√ßo de bloco de disco?
- 17.7. Por que o acesso a um bloco de disco √© dispendioso? Discuta os componentes de tempo envolvidos no acesso a um bloco de disco.
- 17.8. Como  o  buffering  duplo  melhora  o  tempo  de acesso ao bloco?
- 17.9. Quais s√£o os motivos para a exist√™ncia de registros de tamanho vari√°vel? Que tipos de caracteres separadores s√£o necess√°rios para cada um?
- 17.10. Discuta as t√©cnicas para alocar blocos de arquivo no disco.
- 17.11. Qual √© a diferen√ßa entre uma organiza√ß√£o de arquivo e um m√©todo de acesso?
- 17.12. Qual √© a diferen√ßa entre arquivos est√°ticos e din√¢micos?
- 17.13. Quais s√£o as opera√ß√µes t√≠picas de um registro de cada vez para acessar um arquivo? Quais delas dependem do registro de arquivo atual?
- 17.14. Discuta as t√©cnicas para exclus√£o de registro.
- 17.15. Discuta as vantagens e desvantagens do uso de (a) um arquivo desordenado, (b) um arquivo ordenado e (c) um arquivo de hash est√°tico com buckets e encadeamento. Que opera√ß√µes podem ser realizadas de modo eficiente em cada uma dessas organiza√ß√µes, e quais opera√ß√µes s√£o dispendiosas?
- 17.16. Discuta as t√©cnicas para permitir que um arquivo de hash se expanda e encolha dinamicamente. Quais s√£o as vantagens e desvantagens de cada uma?
- 17.17. Qual √© a diferen√ßa entre os diret√≥rios de hashing extens√≠vel e din√¢mico?
- 17.18. Para que s√£o usados arquivos mistos? Quais s√£o os outros tipos de organiza√ß√µes de arquivo prim√°rias?

- 17.19. Descreva  a  diverg√™ncia  entre  as  tecnologias  de processador e disco.
- 17.20. Quais s√£o os principais objetivos da tecnologia RAID? Como ela os alcan√ßa?
- 17.21. Como o espelhamento de disco ajuda a melhorar a confiabilidade? D√™ um exemplo quantitativo.
- 17.22. O  que  caracteriza  os  n√≠veis  na  organiza√ß√£o RAID?
- 17.23. Quais s√£o os destaques dos n√≠veis de RAID populares 0, 1 e 5?
- 17.24. O  que  s√£o  √°reas  de  armazenamento  em  rede? Que flexibilidade e vantagens elas oferecem?
- 17.25. Descreva  os  principais  recursos  do  armazenamento conectado √† rede como uma solu√ß√£o de armazenamento empresarial.
- 17.26. Como os novos sistemas iSCSI melhoraram a aplicabilidade das redes da √°rea de armazenamento?

## Exerc√≠cios

- 17.27. Considere um disco com as seguintes caracter√≠sticas (estes n√£o s√£o par√¢metros de qualquer unidade de disco em particular): tamanho de bloco B = 512 bytes; tamanho da lacuna entre blocos G = 128 bytes; n√∫mero de blocos por trilha = 20; n√∫mero de trilhas por superf√≠cie = 400. Um disk pack consiste em 15 discos de dupla face.
- a. Qual  √©  a  capacidade  total  de  uma  trilha  e qual √© sua capacidade √∫til (excluindo as lacunas entre blocos)?
- b. Quantos cilindros existem?
- c. O que s√£o a capacidade total e a capacidade √∫til de um cilindro?
- d. O que s√£o a capacidade total e a capacidade √∫til de um disk pack?
- e. Suponha que a unidade de disco gire o disk pack a uma velocidade de 2.400 rpm (rota√ß√µes por minuto); quais s√£o a taxa de transfer√™ncia ( tr ) em bytes/ms e o tempo de transfer√™ncia em bloco ( btt ) em ms? Qual √© o atraso rotacional ( rd ) m√©dio em ms? Qual √© a taxa de transfer√™ncia em massa? (Ver Ap√™ndice B.)
- f. Suponha que o tempo de busca m√©dio seja de  30  ms.  Quanto  tempo  √©  necess√°rio  (em m√©dia) em ms para localizar e transferir um √∫nico bloco, dado seu endere√ßo de bloco?
- g. Calcule o tempo m√©dio que seria necess√°rio para transferir 20 blocos aleat√≥rios e compare isso com o tempo exigido para transferir 20  blocos  consecutivos  usando  o  buffering duplo  para  economizar  tempo  de  busca  e atraso rotacional.
- 17.28. Um arquivo tem   = 20.000 registros de r ALUNO de tamanho fixo . Cada registro tem os seguintes campos: Nome (30 bytes), Cpf (9 bytes), Endere-

17.30.

co (40 bytes), TELEFONE (10 bytes), Data\_nas-cimento (8 bytes), Sexo (1 byte), Dep\_princ (4 bytes), Dep\_sec (4 bytes), Tipo\_aluno (4 bytes, integer) e Titulo\_academico (3 bytes). Um byte adicional √© usado como um marcador de exclus√£o. O arquivo √© armazenado no disco cujos par√¢metros s√£o dados no Exerc√≠cio 17.27.

- a. Calcule o tamanho do registro R em bytes.
- b. Calcule o fator de bloco bfr e  o  n√∫mero de blocos de arquivo b , considerando uma organiza√ß√£o n√£o espalhada.
- c. Calcule o tempo m√©dio necess√°rio para localizar um registro ao realizar uma pesquisa linear no arquivo se (i) os blocos do arquivo forem armazenados consecutivamente e o buffering duplo for utilizado; (ii) os blocos de arquivo n√£o forem armazenados de maneira consecutiva.
- d. Suponha que o arquivo esteja ordenado por Cpf ; ao realizar uma pesquisa bin√°ria, calcule o tempo necess√°rio para procurar um registro dado seu valor de Cpf .
- 17.29. Suponha que apenas 80 por cento dos registros de ALUNO do Exerc√≠cio 17.28 tenham um valor para Telefone, 85 por cento para Dep\_princ, 15 por cento para Dep\_sec e 90 por cento para Titulo\_academico ; e suponha ainda que usemos um arquivo com registro de tamanho vari√°vel. Cada registro tem um tipo de campo de 1 byte para cada campo no registro, mais o marcador de exclus√£o de 1 byte e um marcador de fim de registro  de  1  byte.  Suponha  que  usemos  uma organiza√ß√£o de registro espalhada , em que cada bloco tem um ponteiro de 5 bytes para o pr√≥ximo bloco (esse espa√ßo n√£o √© usado para armazenamento de registro).
- a. Calcule o tamanho m√©dio do registro R em bytes.
- b. Calcule o n√∫mero de blocos necess√°rios para o arquivo.
- Suponha que uma unidade de disco tenha os seguintes par√¢metros: tempo de busca s =  20  ms; atraso  rotacional rd =  10  ms;  tempo  de  transfer√™ncia de bloco btt = 1 ms; tamanho de bloco B =  2.400  bytes;  tamanho  da  lacuna  entre  blocos G =  600  bytes.  Um  arquivo FUNCIONA -RIO tem os seguintes campos: Cpf, 9  bytes; Ul-timo\_nome, 20 bytes; Primeiro\_nome, 20 bytes; Minicial, 1 byte; Data\_nascimento, 10  bytes; Endereco, 35 bytes; Telefone, 12 bytes; Cpf\_su -pervisor, 9  bytes; Departamento, 4  bytes; Co -digo\_cargo, 4 bytes; marcador  de exclus√£o, 1 byte. O arquivo FUNCIONARIO tem   = 30.000 r registros,  formato  de  tamanho  fixo  e  blocagem n√£o  espalhada.  Escreva  f√≥rmulas  apropriadas e calcule os seguintes valores para o arquivo FUNCIONARIO acima:

- a. O tamanho do registro R (incluindo o marcador de exclus√£o), o fator de bloco bfr e o n√∫mero de blocos de disco b .
- b. Calcule o espa√ßo desperdi√ßado em cada bloco de disco devido √† organiza√ß√£o n√£o espalhada.
- c. Calcule a taxa de transfer√™ncia tr e a taxa de transfer√™ncia em massa btf para essa unidade de disco (veja no Ap√™ndice B as defini√ß√µes de tr e btr ).
- d. Calcule o n√∫mero de acessos de bloco m√©dio necess√°rio  para  pesquisar  um  registro  qualquer no arquivo, usando a pesquisa linear.
- e. Calcule,  em  ms,  o tempo m√©dio  necess√°rio para pesquisar um registro qualquer no arquivo, usando a pesquisa linear, se os blocos forem armazenados em blocos de disco consecutivos e o buffering duplo for usado.
- f. Calcule,  em  ms,  o tempo m√©dio  necess√°rio para pesquisar um registro qualquer no arquivo, usando a pesquisa linear, se os blocos de  arquivo n√£o estiverem  armazenados  em blocos de disco consecutivos.
- g. Suponha que os registros estejam ordenados por algum campo-chave. Calcule o n√∫mero de acessos a bloco m√©dio e o tempo m√©dio necess√°rio para pesquisar um registro qualquer no arquivo, usando a pesquisa bin√°ria.
- 17.31. Um  arquivo PECAS com Num\_peca como chave  hash  inclui  registros  com  os  seguintes valores  de Num\_peca : 2369,  3760,  4692, 4871,  5659,  1821,  1074,  7115,  1620,  2428, 3943,  4750,  6975,  4981  e  9208.  O  arquivo usa  oito  buckets,  numerados  de  0  a  7.  Cada bucket √© um bloco de disco e mant√©m dois registros.  Carregue  esses  registros  no  arquivo na ordem indicada, usando a fun√ß√£o de hash h K ( ) = K mod 8. Calcule o n√∫mero m√©dio de acessos a bloco para uma leitura aleat√≥ria em Num\_peca.
- 17.32. Carregue os registros do Exerc√≠cio 17.31 em arquivos de hash expans√≠veis com base no hashing expans√≠vel. Mostre a estrutura do diret√≥rio em cada etapa, e as profundidades global e local. Use a fun√ß√£o de hash h K ( ) = K mod 128.
- 17.33. Carregue os registros do Exerc√≠cio 17.31 em um arquivo  de  hash  expans√≠vel,  usando  o  hashing linear.  Comece  com  um  √∫nico  bloco  de  disco, usando a fun√ß√£o de hash h 0 = K mod 2 0 , e mostre como o arquivo cresce e como as fun√ß√µes de hash mudam √† medida que os registros s√£o inseridos. Suponha que os blocos sejam divididos sempre que ocorre um overflow, e mostre o valor de n em cada est√°gio.
- 17.34. Compare os comandos de arquivo listados na Se√ß√£o 17.5 aos dispon√≠veis em um m√©todo de acesso a arquivo com que voc√™ esteja acostumado.
- 17.35. Suponha que tenhamos um arquivo desordenado de registros de tamanho fixo que use uma organiza√ß√£o de registro n√£o espalhada. Esboce algoritmos para inser√ß√£o, exclus√£o e modifica√ß√£o de  um  registro  de  arquivo.  Informe  quaisquer suposi√ß√µes que voc√™ fizer.
- 17.36. Suponha  que  tenhamos  um  arquivo  ordenado de  registros  de  tamanho  fixo  e  um  arquivo  de overflow desordenado para lidar com a inser√ß√£o. Os  dois  arquivos  usam  registros  n√£o  espalhados. Esboce algoritmos para inser√ß√£o, exclus√£o e modifica√ß√£o de um registro de arquivo e para a  reorganiza√ß√£o do arquivo. Indique quaisquer suposi√ß√µes que voc√™ fizer.
- 17.37. Voc√™ consegue pensar em t√©cnicas que n√£o sejam um arquivo de overflow desordenado, que possam ser usadas para tornar as inser√ß√µes em um arquivo ordenado mais eficiente?
- 17.38. Suponha  que  tenhamos  um  arquivo  de  hash  e registros  de  tamanho  fixo,  e  suponha  tamb√©m que  o  overflow  seja  tratado  pelo  encadeamento. Esboce algoritmos para inser√ß√£o, exclus√£o e modifica√ß√£o de um registro de arquivo. Indique quaisquer suposi√ß√µes que voc√™ fizer.
- 17.39. Voc√™ consegue pensar em t√©cnicas al√©m do encadeamento para lidar com o estouro de bucket no hashing externo?
- 17.40. Escreva o pseudoc√≥digo para os algoritmos de inser√ß√£o para hashing linear e para hashing extens√≠vel.
- 17.41. Escreva  o  c√≥digo  de  programa  para  acessar campos individuais de registros sob cada uma das seguintes circunst√¢ncias. Para cada caso, indique  as  suposi√ß√µes  que  voc√™  faz  com  rela√ß√£o  a  ponteiros,  caracteres  separadores,  e assim por diante. Determine o tipo de informa√ß√£o necess√°ria no cabe√ßalho de arquivo a fim de que seu c√≥digo seja gen√©rico em cada caso.
- a. Registros  de  tamanho  fixo  com  blocagem n√£o espalhada.
- b. Registros de tamanho fixo com blocagem espalhada.
- c. Registros de tamanho vari√°vel com campos de tamanho vari√°vel e blocagem espalhada.
- d. Registros  de  tamanho  vari√°vel  com  grupos repetitivos e blocagem espalhada.
- e. Registros de tamanho vari√°vel com campos opcionais e blocagem espalhada.
- f. Registros de tamanho vari√°vel que permitem todos os tr√™s casos nas partes c, d e e.
- 17.42. Suponha  que  um  arquivo  contenha  inicialmente   = 120.000 registros de r R = 200 bytes cada  em  um  arquivo  desordenado  (heap).  O tamanho do bloco B = 2.400 bytes, o tempo de busca m√©dio s =  16  ms,  a  lat√™ncia  rotacional

17.43.

17.44.

17.45.

m√©dia rd =  8,3  ms  e  o  tempo  de  transfer√™ncia  de  bloco btt =  0,8  ms.  Suponha  que  um registro seja exclu√≠do para cada dois registros acrescentados at√© que o n√∫mero total de registros ativos seja 240.000.

- a. Quantas transfer√™ncias de bloco s√£o necess√°rias para reorganizar o arquivo?
- b. Quanto tempo levar√° para encontrar um registro imediatamente antes da reorganiza√ß√£o?
- c. Quanto tempo levar√° para encontrar um registro imediatamente ap√≥s a reorganiza√ß√£o?

Suponha que tenhamos um arquivo sequencial (ordenado) de 10.000 registros, onde cada registro tem 240 bytes. Suponha que B =  2.400 bytes, s =  16  ms, rd =  8,3  ms  e btt = 0,8 ms. Suponha que queiramos fazer X leituras de registro aleat√≥rio independentes do arquivo. Poder√≠amos fazer X leituras de bloco aleat√≥rias ou poder√≠amos  realizar  uma  leitura  completa  do arquivo  inteiro  procurando  esses X registros. A quest√£o √© decidir quando seria mais eficiente rea  lizar uma leitura completa do arquivo inteiro do que realizar X leituras aleat√≥rias individuais. Ou seja, qual √© o valor de X quando uma leitura completa do arquivo √© mais eficiente do que X leituras aleat√≥rias? Desenvolva isso como uma fun√ß√£o de X .

Suponha que um arquivo de hash est√°tico inicialmente tenha 600 buckets na √°rea principal e que registros sejam inseridos para criar uma √°rea de overflow  de  600  buckets.  Se  reorganizarmos  o arquivo de hash, podemos assumir que a maior parte do overflow √© eliminada. Se o custo de reorganizar o arquivo √© o custo das transfer√™ncias de bucket (leitura e grava√ß√£o de todos os buckets) e a √∫nica opera√ß√£o de arquivo peri√≥dica √© a opera√ß√£o de busca, ent√£o quantas vezes ter√≠amos de realizar uma busca (bem-sucedida) para tornar o custo da reorganiza√ß√£o econ√¥mico? Ou seja, o custo de reorganiza√ß√£o e o custo de pesquisa subsequente s√£o menores que o custo de pesquisa antes da reorganiza√ß√£o. Explique sua resposta. Considere s = 16 ms, rd = 8,3 ms e btt = 1 ms.

Suponha que queiramos criar um arquivo de hash linear com um fator de carga de arquivo de 0,7 e um fator de bloco de 20 registros por bucket, que deve conter 112.000 registros inicialmente.

- a. Quantos  buckets  devemos  alocar  na  √°rea principal?
- b. Qual deve ser o n√∫mero de bits usados para endere√ßos de bucket?

## Bibliografia selecionada

Wiederhold (1987) possui uma discuss√£o e an√°lise detalhadas  de  dispositivos  de  armazenamento  secund√°rios  e  organiza√ß√µes  de  arquivo  como  uma  parte  do projeto  de  banco  de  dados.  Os  discos  √≥ticos  s√£o  descritos  em  Berg  e  Roth  (1989)  e  analisados  em  Ford  e Christodoulakis (1991). A mem√≥ria flash √© discutida por Dipert e Levy (1993). Ruemmler e Wilkes (1994) apresentam um estudo da tecnologia de disco magn√©tico. A maioria  dos  livros-texto  sobre  bancos  de  dados  inclui discuss√µes do material apresentado aqui. A maioria dos livros-texto  de  estruturas  de  dados,  incluindo  Knuth (1998),  discute  o  hashing  est√°tico  com  mais  detalhes; Knuth traz uma discuss√£o completa das fun√ß√µes de hash e t√©cnicas de resolu√ß√£o de colis√£o, bem como sua compara√ß√£o  de  desempenho.  Knuth  tamb√©m  oferece  uma discuss√£o detalhada sobre as t√©cnicas para classifica√ß√£o de arquivos externos. Os livros-texto sobre estruturas de arquivo incluem Claybrook (1992), Smith e Barnes (1987) e Salzberg (1988). Eles discutem organiza√ß√µes de arquivo adicionais, incluindo arquivos estruturados em √°rvore, e possuem algoritmos detalhados para opera√ß√µes sobre arquivos. Salzberg et al. (1990) descrevem um algoritmo de classifica√ß√£o externa distribu√≠da. As organiza√ß√µes de arquivo com um alto grau de toler√¢ncia a falhas s√£o descritas  por  Bitton  e  Gray  (1988)  e  por  Gray  et  al. (1990).  O  striping  de  disco  foi  proposto  em  Salem  e Garcia Molina (1986). O primeiro artigo sobre RAID √©  de  Patterson  et  al.  (1988).  Chen  e  Patterson  (1990) e  o  excelente  estudo de RAID por Chen et al. (1994) s√£o refer√™ncias adicionais. Grochowski e Hoyt (1996) discutem as tend√™ncias futuras em unidades de disco. Diversas f√≥rmulas para a arquitetura RAID aparecem em Chen et al. (1994).

Morris  (1968)  √©  um  artigo  antigo  sobre  hashing. O hashing extens√≠vel √© descrito em Fagin et al. (1979). O hashing  linear  √©  descrito  por  Litwin  (1980).  Os  algoritmos  para  inser√ß√£o  e  exclus√£o  para  o  hashing  linear s√£o  discutidos  com  ilustra√ß√µes  em  Salzberg  (1988).  O hashing din√¢mico, que apresentamos resumidamente, foi proposto por Larson (1978). Existem muitas varia√ß√µes propostas  para  o  hashing  extens√≠vel  e  linear;  para  ver exemplos, consulte Cesarini e Soda (1991), Du e Tong (1991) e Hachem e Berra (1992).

Os detalhes dos dispositivos de armazenamento em disco podem ser encontrados nos sites do fabricante (por exemplo, &lt; http://www.seagate.com &gt; &lt; , http://www.ibm.com &gt; , &lt; http://www.emc.com &gt; , &lt; http://www.hp.com &gt; , &lt; http:// www.storagetek.com &gt; . A IBM tem um centro de pesquisa de tecnologia de armazenamento na IBM Almaden ( &lt; http:// www.almaden.ibm.com/ &gt; ).



## Estruturas de indexa√ß√£o para arquivos

N este  cap√≠tulo,  consideramos  que  um  arquivo  j√° exista com alguma organiza√ß√£o prim√°ria, como as  organiza√ß√µes desordenada, ordenada ou hashed, que foram descritas no Cap√≠tulo 17. Vamos descrever outras estruturas de acesso auxiliares, chamadas √≠ndices , que s√£o utilizadas para agilizar a recupera√ß√£o de registros em resposta a certas condi√ß√µes de pesqui¬≠ sa. As estruturas de √≠ndice s√£o arquivos adicionais no disco que oferecem caminhos de acesso secund√°rios , os quais oferecem formas alternativas de acessar os registros sem afetar seu posicionamento f√≠sico no ar¬≠ quivo de dados prim√°rio no disco. Elas permitem o acesso eficiente aos registros com base nos campos de indexa√ß√£o que s√£o usados para construir o √≠ndi¬≠ ce.  Basicamente, qualquer  campo do  arquivo  pode servir  para  criar  um  √≠ndice,  e m√∫ltiplos  √≠ndices em diferentes campos - bem como √≠ndices em m√∫ltiplos campos - podem ser constru√≠dos no mesmo arqui¬≠ vo. V√°rios √≠ndices s√£o poss√≠veis; cada um deles uti¬≠ liza determinada estrutura de dados para agilizar a pesquisa. Para encontrar um registro ou registros no arquivo de dados com base em uma condi√ß√£o de pes¬≠ quisa em um campo de √≠ndice, o √≠ndice √© pesquisado, o que leva a ponteiros para um ou mais blocos de disco no arquivo de dados onde os registros exigi¬≠ dos est√£o localizados. Os tipos mais predominantes de √≠ndices s√£o baseados em arquivos ordenados (√≠n¬≠ dices de √∫nico n√≠vel) e estruturas de dados em √°rvore (√≠ndices multin√≠vel, B ¬≠trees). Os √≠ndices tamb√©m po¬≠ + dem ser constru√≠dos com base no hashing ou em ou¬≠ tras estruturas de dados de pesquisa. Tamb√©m vamos abordar os √≠ndices que s√£o vetores de bits, chamados √≠ndices bitmap .

Descrevemos diferentes tipos de √≠ndices ordena¬≠ dos de √∫nico n√≠vel - prim√°rios, secund√°rios e agru¬≠ pamento - na Se√ß√£o 18.1. Ao visualizar um √≠ndice de  √∫nico  n√≠vel  como  um  arquivo  ordenado,  pode¬≠

¬≠se  desenvolver √≠ndices adicionais para ele, fazendo surgir o conceito de √≠ndices multin√≠veis. Um esque¬≠ ma de indexa√ß√£o popular, chamado ISAM ( Indexed Sequential  Access Method ) √©  baseado  nessa  ideia. Discutimos  os  √≠ndices  multin√≠veis  estruturados  em √°rvore na Se√ß√£o 18.2. Na Se√ß√£o 18.3, descrevemos as B¬≠trees e as B + ¬≠trees, que s√£o estruturas de dados nor¬≠ malmente usadas em SGBDs para implementar dina¬≠ micamente √≠ndices multin√≠veis mut√°veis. As B + ¬≠trees se tornaram uma estrutura padr√£o comumente aceita para a gera√ß√£o de √≠ndices por demanda na maioria dos SGBDs relacionais. A Se√ß√£o 18.4 √© dedicada a maneiras  alternativas  de  acessar  dados  com  base em uma combina√ß√£o de m√∫ltiplas chaves. Na Se√ß√£o 18.5, discutimos os √≠ndices de hash e apresentamos o conceito de √≠ndices l√≥gicos, que d√£o um n√≠vel adi¬≠ cional  de  indire√ß√£o  dos  √≠ndices  f√≠sicos,  permitindo que o √≠ndice f√≠sico seja flex√≠vel e extens√≠vel em sua organiza√ß√£o. Na Se√ß√£o 18.6, discutimos a indexa√ß√£o de chaves m√∫ltiplas e os √≠ndices bitmap usados para pesquisar uma ou mais chaves. No final do cap√≠tulo h√° um resumo.

## 18.1 Tipos de √≠ndices ordenados de √∫nico n√≠vel

A ideia por tr√°s de um √≠ndice ordenado √© seme¬≠ lhante √† que est√° por tr√°s do √≠ndice usado em um livro, que lista termos importantes ao final, em ordem alfab√©¬≠ tica, junto com uma lista dos n√∫meros de p√°gina onde o termo aparece no livro. Podemos pesquisar o √≠ndice do livro  em  busca  de  certo  termo  em  seu  interior  e encontrar uma lista de endere√ßos - n√∫meros de p√°gi¬≠ na, nesse caso - e usar esses endere√ßos para localizar as p√°ginas especificadas primeiro e depois procurar o termo em cada p√°gina citada. A alternativa, se nenhu¬≠

ma outra indica√ß√£o for dada, seria folhear lentamente o livro inteiro, palavra por palavra, para encontrar o termo em que estamos interessados. Isso corresponde a fazer uma pesquisa linear , que varre o arquivo inteiro. Naturalmente, a maioria dos livros possui informa√ß√µes adicionais, como t√≠tulos de cap√≠tulo e se√ß√£o, que nos ajudam a localizar um termo sem ter de folhear o livro inteiro. No entanto, o √≠ndice √© a √∫nica indica√ß√£o exata das p√°ginas onde o termo ocorre no livro.

Para um arquivo com determinada estrutura de registro  consistindo  em  v√°rios  campos  (ou  atribu¬≠ tos), uma estrutura de acesso a √≠ndice normalmen¬≠ te  √©  definida  em  um  √∫nico  campo de um arquivo, chamado campo de √≠ndice (ou atributo de indexa√ß√£o ). 1 O  √≠ndice  costuma  armazenar  cada  valor  do campo de √≠ndice junto com uma lista de ponteiros para todos os blocos de disco que cont√™m registros com esse valor de campo. Os valores no √≠ndice s√£o ordenados de modo que possamos realizar uma pesquisa bin√°ria no √≠ndice. Se tanto o arquivo de dados quanto o arquivo de √≠ndice estiverem ordenados, e visto que este normalmente √© muito menor do que o arquivo de dados, a procura no √≠ndice que usa pes¬≠ quisa bin√°ria √© uma op√ß√£o melhor. √çndices multin√≠¬≠ veis estruturados em √°rvore (ver Se√ß√£o 18.2) imple¬≠ mentam uma extens√£o da ideia de pesquisa bin√°ria, que reduz o espa√ßo de pesquisa pelo particionamen¬≠ to duplo em cada etapa de pesquisa, criando assim uma t√©cnica mais eficiente, que divide o espa√ßo de pesquisa no arquivo em n maneiras a cada est√°gio.

secund√°rios al√©m de seu m√©todo de acesso prim√°rio. Discutimos esses tipos de √≠ndices de √∫nico n√≠vel nas tr√™s pr√≥ximas subse√ß√µes.

## 18.1.1 ndices prim√°rios √ç

Um √≠ndice prim√°rio √© um arquivo ordenado cujos registros s√£o de tamanho fixo com dois campos, e ele atua como uma estrutura de acesso para procurar e acessar de modo eficiente os registros de dados em um arquivo. O primeiro campo √© do mesmo tipo de dado do campo de chave de ordena√ß√£o - chamado de chave prim√°ria - do arquivo de dados, e o segundo campo √© um ponteiro para um bloco de disco (um endere√ßo de bloco). Existe uma entrada de √≠ndice (ou registro de √≠ndice ) no arquivo de √≠ndice para cada bloco no arquivo de dados. Cada entrada de √≠ndice tem o valor do cam¬≠ po de chave prim√°ria para o primeiro registro em um bloco e um ponteiro para esse bloco como seus dois valores de campo. Vamos nos referir aos dois valores de campo da entrada de √≠ndice   como &lt; i K i ( ), P i ( )&gt;.

Para  criar  um  √≠ndice  prim√°rio  no  arquivo  or¬≠ denado mostrado na Figura 17.7, usamos o campo Nome como chave prim√°ria, pois esse √© o campo de chave de ordena√ß√£o do arquivo (supondo que cada valor de Nome seja exclusivo). Cada entrada no √≠n¬≠ dice tem um valor de Nome e um ponteiro. As tr√™s primeiras entradas de √≠ndice s√£o as seguintes:

&lt; K (1)  =  (Aaron,  Eduardo), P (1)  =  endere√ßo  de bloco 1&gt;

Existem v√°rios tipos de √≠ndices ordenados. Um √≠ndice prim√°rio √©  especificado  no campo de chave de ordena√ß√£o de um arquivo ordenado de registros. Lembre¬≠se, da Se√ß√£o 17.7, que um campo de cha¬≠ ve  de  ordena√ß√£o  √©  usado  para ordenar  fisicamente os registros de arquivo no disco, e cada registro tem um valor √∫nico para esse campo. Se o campo de  ordena√ß√£o  n√£o  for  um  campo  de  chave  -  ou seja,  se  diversos  registros  no  arquivo  puderem  ter o mesmo valor para o campo de ordena√ß√£o -, ou¬≠ tro tipo de √≠ndice, chamado √≠ndice de agrupamento (clustering) ,  pode  ser  utilizado.  O  arquivo  de  da¬≠ dos √© chamado de arquivo agrupado nesse  √∫ltimo caso.  Observe  que  um  arquivo  pode  ter  no  m√°xi¬≠ mo um campo de ordena√ß√£o f√≠sico,  de  modo  que pode ter no m√°ximo um √≠ndice prim√°rio ou um √≠ndice de agrupamento, mas n√£o ambos . Um terceiro tipo de √≠ndice, chamado √≠ndice secund√°rio , pode ser especi¬≠ ficado em qualquer campo n√£o ordenado de um ar¬≠ quivo. Um arquivo de dados pode ter v√°rios √≠ndices

&lt; K (2) = (Adams, Jo√£o), P (2) = endere√ßo de bloco 2&gt; &lt; K (3) = (Alexandre, Eduardo), P (3) = endere√ßo de bloco 3&gt;

A Figura 18.1 ilustra esse √≠ndice prim√°rio. O n√∫¬≠ mero total de entradas no √≠ndice √© igual ao n√∫mero de blocos de disco no arquivo de dados ordenado. O primeiro registro em cada bloco do arquivo de dados √© chamado de registro de √¢ncora do bloco ou, sim¬≠ plesmente, √¢ncora de bloco . 2

Os  √≠ndices  tamb√©m  podem  ser  caracterizados como densos ou esparsos. Um √≠ndice denso tem uma entrada de √≠ndice para cada valor de chave de pesquisa (e, portanto, cada registro) no arquivo de dados. Um √≠ndice esparso (ou n√£o denso ), por sua vez, tem entradas de √≠ndice para somente alguns dos valores de pesquisa. Um √≠ndice esparso tem menos entradas do que o n√∫mero de registros no arquivo. Assim, um √≠ndice prim√°rio √© um √≠ndice n√£o denso (esparso), pois inclui uma entrada para cada bloco de disco do ar¬≠

1 Usamos os termos campo e atributo para indicar a mesma coisa neste cap√≠tulo.

2 Podemos usar um esquema semelhante ao que foi descrito aqui, com o √∫ltimo registro em cada bloco (em vez do primeiro) como a √¢ncora de bloco. Isso melhora ligeiramente a efici√™ncia do algoritmo de pesquisa.

Figura 18.1



√çndice prim√°rio no campo de chave de ordena√ß√£o do arquivo mostrado na Figura 17.7.

quivo de dados e as chaves de seu registro de √¢ncora, em vez de cada valor de pesquisa (ou cada registro).

O arquivo de √≠ndice  para  um  √≠ndice  prim√°rio ocupa  um  espa√ßo  muito  menor  do  que  o  arquivo de dados, por dois motivos. Primeiro, existem menos entradas de √≠ndice do que registros no arquivo de dados. Segundo, cada entrada de √≠ndice normal¬≠ mente √© menor em tamanho do que um registro de dados, pois tem apenas dois campos; em consequ√™n¬≠ cia,  mais  entradas  de  √≠ndice  do  que  registros  de dados  podem  caber  em  um  bloco.  Portanto,  uma pesquisa bin√°ria no arquivo de √≠ndice requer menos acessos de bloco do que uma pesquisa bin√°ria no ar¬≠ quivo de dados. Com rela√ß√£o √† Tabela 17.2, observe que a pesquisa bin√°ria para um arquivo de dados ordenado exigia log 2 b acessos de bloco. Mas, se o arquivo de √≠ndice prim√°rio tiver apenas b i blocos, ent√£o localizar um registro com um valor de chave de pesquisa exige uma pesquisa bin√°ria desse √≠ndice e  o  acesso  ao  bloco  que  cont√©m  esse  registro:  um total de log 2 b i + 1 acessos.

Um registro cujo valor da chave prim√°ria √© K se en¬≠ contra no bloco cujo endere√ßo √© P i ( ), onde K i ( ) ‚â§ K &lt; K i ( + 1). O  ¬≠√©simo bloco no arquivo de dados cont√©m todos i os registros por causa da ordena√ß√£o f√≠sica dos registros do arquivo no campo de chave prim√°ria. Para recupe¬≠ rar um registro, dado o valor K de seu campo de chave prim√°ria, realizamos uma pesquisa bin√°ria no arquivo

de √≠ndice para encontrar a entrada de √≠ndice apropria¬≠ da  , e depois recuperamos o bloco do arquivo de dados i cujo endere√ßo √© P i ( ).  O Exemplo 1 ilustra a economia 3 em acessos a bloco que pode ser alcan√ßada quando um √≠ndice prim√°rio √© utilizado para procurar um registro.

Exemplo 1. Suponha que tenhamos um arquivo or¬≠ denado com r =  30.000  registros  armazenados  em um disco com tamanho de bloco B =  1.024  bytes. Os registros de arquivo s√£o de tamanho fixo e n√£o espalhados, com tamanho de registro R = 100 bytes. O fator de bloco para o arquivo seria bfr =  (B/R) Ô£∞ Ô£ª =  (1.024/100)  = 10 registros por bloco. O n√∫mero Ô£Æ Ô£π de blocos necess√°rios para o arquivo √© b =  ( Ô£Æ r bfr / )  = Ô£π Ô£Æ (30.000/10)  = 3.000 blocos. Uma pesquisa bin√°ria Ô£π no arquivo de dados precisaria de aproximadamente Ô£Æ log 2 b Ô£π =  (log 3.000)  = 12 acessos de bloco. Ô£Æ 2 Ô£π

Agora,  suponha  que  o  campo  de  chave  de  or¬≠ dena√ß√£o  do  arquivo  seja V = 9  bytes  de  extens√£o, um ponteiro de bloco seja P = 6 bytes de extens√£o e tenhamos constru√≠do um √≠ndice prim√°rio para o ar¬≠ quivo. O tamanho de cada entrada de √≠ndice √© R i = (9 + 6) = 15 bytes, de modo que o fator de bloco para o √≠ndice √© bfr i =  (B/R )  =  (1.024/15)  = 68 entradas Ô£∞ i Ô£ª Ô£∞ Ô£ª por bloco. O n√∫mero total de entradas de √≠ndice r i √© igual ao n√∫mero de blocos no arquivo de dados, que √© 3.000. O n√∫mero de blocos de √≠ndice √©, portanto, b i =  ( Ô£Æ r i / bfr i )  =  (3.000/68)  = 45 blocos. Para realizar Ô£π Ô£Æ Ô£π uma pesquisa  bin√°ria  no  arquivo  de  √≠ndice,  seriam necess√°rios  (log Ô£Æ 2 b i )  =  (log 45)  = 6 acessos de bloco. Ô£π Ô£Æ 2 Ô£π Para procurar um registro usando o √≠ndice, precisa¬≠ mos de um acesso de bloco adicional ao arquivo de dados, para um total de 6 + 1 = 7 acessos de bloco uma melhoria em rela√ß√£o √† pesquisa bin√°ria no arqui¬≠ vo de dados, que exigiu 12 acessos a bloco de disco.

melhorar o tempo de recupera√ß√£o. A exclus√£o de re¬≠ gistro √© tratada com marcadores de exclus√£o.

## 18.1.2 ndices de agrupamento √ç

Se os registros de arquivo forem fisicamente or¬≠ denados em um campo n√£o chave - que n√£o tem um valor distinto para cada registro -, esse campo √© chamado de campo de agrupamento ,  e  o  arquivo de dados √© chamado de arquivo agrupado . Podemos criar um tipo de √≠ndice diferente, chamado √≠ndice de agrupamento ,  para  agilizar  a  recupera√ß√£o  de  todos os registros que t√™m o mesmo valor para o campo de agrupamento. Isso difere de um √≠ndice prim√°rio, que exige que o campo de ordena√ß√£o do arquivo de dados tenha um valor distinto para cada registro.

Um √≠ndice de agrupamento tamb√©m √© um arqui¬≠ vo  ordenado  com  dois  campos;  o  primeiro  campo √© do mesmo tipo do campo de agrupamento do ar¬≠ quivo de dados, e o segundo campo √© um ponteiro de bloco de disco. H√° uma entrada no √≠ndice de agru¬≠ pamento para cada valor distinto do campo de agrupa¬≠ mento, e ele cont√©m o valor e um ponteiro para o primeiro bloco no arquivo de dados que tem um re¬≠ gistro com esse valor para seu campo de agrupamen¬≠ to. A Figura 18.2 mostra um exemplo. Observe que a inser√ß√£o e exclus√£o de registro ainda causam pro¬≠ blemas, pois os registros de dados est√£o fisicamen¬≠ te  ordenados.  Para  aliviar  o  problema  de  inser√ß√£o, √©  comum reservar um bloco inteiro (ou um cluster de blocos cont√≠nuos) para cada valor do campo de agrupamento; todos os registros com esse valor s√£o colocados no bloco (ou cluster de bloco). Isso torna a inser√ß√£o e exclus√£o relativamente simples. A Figura 18.3 mostra esse esquema.

Um problema importante com √≠ndice prim√°rio assim como com qualquer arquivo ordenado - √© a in¬≠ ser√ß√£o e exclus√£o de registros. Com um √≠ndice prim√°¬≠ rio, o problema √© aumentado porque, se tentarmos inserir um registro em sua posi√ß√£o correta no arquivo de dados, temos de n√£o apenas mover registros para criar espa√ßo para o novo registro, mas tamb√©m mu¬≠ dar algumas entradas de √≠ndice, pois a movimenta√ß√£o de registros mudar√° os registros de √¢ncora de alguns blocos. Ao usar um arquivo de overflow desordena¬≠ do, conforme discutimos na Se√ß√£o 17.7, podemos re¬≠ duzir esse problema. Outra possibilidade √© usar uma lista ligada de registros de overflow para cada bloco no arquivo de dados. Isso √© semelhante ao m√©todo de tratar de registros de overflow descrito com hashing na Se√ß√£o 17.8.2. Os registros em cada bloco e sua lista ligada de overflow podem ser classificados para

Um √≠ndice de agrupamento √© outro exemplo de um √≠ndice n√£o denso , pois ele tem uma entrada para cada valor distinto do campo de √≠ndice, que √© uma n√£o chave por defini√ß√£o e, portanto, tem valores du¬≠ plicados em vez de um valor √∫nico para cada regis¬≠ tro  no  arquivo.  Existe  alguma  semelhan√ßa entre as figuras 18.1, 18.2 e 18.3 e as figuras 17.11 e 17.12. Um √≠ndice √© de alguma forma semelhante ao hashing din√¢mico (descrito na Se√ß√£o 17.8.3) e √†s estruturas de diret√≥rio usadas para o hashing extens√≠vel. Ambos s√£o pesquisados para encontrar um ponteiro para o bloco de dados que cont√©m o registro desejado. Uma diferen√ßa principal √© que uma pesquisa de √≠ndice usa os  valores  do  pr√≥prio  campo  de  pesquisa,  enquan¬≠ to uma pesquisa de diret√≥rio de hash usa o valor de hash bin√°rio que √© calculado pela aplica√ß√£o da fun¬≠ √ß√£o de hash ao campo de pesquisa.

3 Observe que a f√≥rmula dada n√£o seria correta se o arquivo de dados fosse ordenado por um campo n√£o chave ; nesse caso, o mesmo valor de √≠ndice na √¢ncora de bloco poderia ser repetido nos √∫ltimos registros do bloco anterior.

(Campo de

Figura 18.2



|                               |                         | agrupamento)   |           |
|-------------------------------|-------------------------|----------------|-----------|
|                               |                         | 1              |           |
|                               |                         | 1              |           |
|                               |                         | 1              |           |
|                               |                         | 2              |           |
| Arquivo de < K                | √≠ndice ( i ), P ( i )>) | 2              |           |
|                               |                         | 3              | (entradas |
|                               |                         | 3              |           |
| Valor do campo de agrupamento | Ponteiro de bloco       | 3              |           |
| 1                             |                         |                |           |
| 2                             |                         | 3              |           |
|                               |                         | 3              |           |
| 3                             |                         | 4              |           |
| 4                             |                         | 4              |           |
| 5                             |                         |                |           |
| 6                             |                         | 5              |           |
| 8                             |                         | 5              |           |
|                               |                         | 5              |           |
|                               |                         | 5              |           |
|                               |                         | 6              |           |
|                               |                         | 6              |           |
|                               |                         | 6              |           |
|                               |                         | 6              |           |
|                               |                         | 6              |           |
|                               |                         | 8              |           |
|                               |                         | 8              |           |

Um √≠ndice de agrupamento no campo n√£o chave de ordena√ß√£o Numero\_departamento de um arquivo FUNCIONARIO.

## 18.1.3 ndices secund√°rios √ç

Um √≠ndice secund√°rio oferece um meio secund√°¬≠ rio  para  acessar  um  arquivo  de  dados  para  o  qual algum acesso prim√°rio j√° existe. Os registros do ar¬≠ quivo de dados poderiam ser ordenados, desordena¬≠ dos ou hashed. O √≠ndice secund√°rio pode ser criado em um campo que √© uma chave candidata e tem um valor √∫nico em cada registro, ou em um campo n√£o chave com valores duplicados. O √≠ndice √© novamente um arquivo ordenado com dois campos. O primei¬≠ ro campo √© do mesmo tipo de dado de algum campo n√£o ordenado do arquivo de dados que seja um campo de √≠ndice .  O  segundo campo √© um ponteiro de bloco ou um ponteiro de registro . Muitos √≠ndices secund√°rios (e, portanto, campos de indexa√ß√£o) po¬≠ dem ser criados para o mesmo arquivo - cada um representa um meio adicional de acessar esse arquivo com base em algum campo espec√≠fico.

Primeiro, consideramos uma estrutura de acesso de  √≠ndice  secund√°rio  em  um  campo  de  chave  (√∫ni¬≠ co) que tem um valor distinto para cada registro. Tal campo √†s vezes √© chamado de chave secund√°ria . No modelo  relacional,  isso  corresponderia  a  qualquer atributo de chave UNIQUE ou ao atributo de chave prim√°ria de uma tabela. Nesse caso, existe uma en¬≠ trada de √≠ndice para cada registro no arquivo de da¬≠

## Arquivo de dados

(Campo de agrupamento)

Figura 18.3



O √≠ndice de agrupamento com um cluster de bloco separado para cada grupo de registros que compartilham o mesmo valor para o campo de agrupamento.

dos, que cont√©m o valor do campo para o registro e um ponteiro para o bloco em que o registro est√° armazenado ou para o pr√≥prio registro. Logo, tal √≠n¬≠ dice √© denso .

Mais uma vez, referimo¬≠nos aos dois valores de campo da entrada de √≠ndice   como &lt; i K i ( ), P i ( )&gt;. As entradas s√£o ordenadas pelo valor de K i ( ), de modo que podemos realizar uma pesquisa bin√°ria. Como os registros do arquivo de dados n√£o s√£o fisicamente ordenados pelos valores do campo de chave secund√°¬≠ rio, n√£o podemos usar √¢ncoras de bloco. √â por isso que uma entrada de √≠ndice √© criada para cada regis¬≠

tro no arquivo de dados, em vez de para cada bloco, como no caso de um √≠ndice prim√°rio. A Figura 18.4 ilustra  um  √≠ndice  secund√°rio  em  que  os  ponteiros P i ( ) nas entradas de √≠ndice s√£o ponteiros de bloco , e n√£o ponteiros de registro. Quando o bloco de disco apropriado √© transferido para um buffer da mem√≥¬≠ ria principal, uma pesquisa pelo registro desejado no bloco pode ser executada.

Um √≠ndice secund√°rio em geral precisa de mais espa√ßo de armazenamento e tempo de busca maior do que um √≠ndice prim√°rio, devido a seu maior n√∫¬≠ mero de entradas. Por√©m, a melhoria no  tempo de

## Arquivo de dados

| (entradas < K            | (entradas < K     | ( i ),   | ( i ),   |
|--------------------------|-------------------|----------|----------|
| Valor do campo de √≠ndice | Ponteiro de bloco |          | 9        |
| 1                        |                   |          | 5        |
| 2                        |                   |          | 13       |
| 3                        |                   |          | 8        |
| 4                        |                   |          | 6        |
| 5                        |                   |          |          |
| 6                        |                   |          | 15       |
| 7                        |                   |          | 3        |
| 8                        |                   |          | 17       |
|                          |                   |          | 21       |
| 9 10                     |                   |          | 11 16    |
| 11                       |                   |          | 2        |
| 12 13                    |                   |          | 24       |
| 14                       |                   |          | 10       |
| 15                       |                   |          | 20       |
| 16                       |                   |          | 1        |
| 17                       |                   |          | 4        |
| 18                       |                   |          | 23       |
| 19                       |                   |          | 18       |
| 20                       |                   |          | 14       |
| 21                       |                   |          |          |
| 22                       |                   |          | 12       |
| 23                       |                   |          | 7        |
| 24                       |                   |          |          |
|                          |                   |          | 19 22    |

Um √≠ndice secund√°rio denso (com ponteiros de bloco) em um campo de chave n√£o ordenado de um arquivo.

pesquisa  para  um  registro  qualquer  √©  muito  maior para  um  √≠ndice  secund√°rio  do  que  para  um  √≠ndice prim√°rio, visto que ter√≠amos de fazer uma pesquisa linear no arquivo de dados se o √≠ndice secund√°rio n√£o existisse. Para um √≠ndice prim√°rio, poder√≠amos ainda usar uma pesquisa bin√°ria no arquivo principal, mes¬≠ mo que o √≠ndice n√£o existisse. O Exemplo 2 ilustra a melhoria no n√∫mero de blocos acessados.

Exemplo 2. Considere o arquivo do Exemplo 1 com r = 30.000 registros de tamanho fixo de tamanho R = 100 bytes armazenados em um disco com tamanho de bloco B = 1.024 bytes. O arquivo tem b = 3.000 blocos, conforme calculado no Exemplo 1. Suponha que  queiramos  procurar  um  registro  com  um  valor espec√≠fico para a chave secund√°ria - um campo de chave n√£o ordenado do arquivo que tem V = 9 bytes de extens√£o. Sem o √≠ndice secund√°rio, para fazer uma pesquisa linear no arquivo, seriam necess√°rios b /2 = 3.000/2 = 1.500 acessos de bloco na m√©dia. Suponha que constru√≠ssemos um √≠ndice secund√°rio nesse campo de chave n√£o ordenado do arquivo. Como no Exem¬≠ plo 1, um ponteiro de bloco tem P = 6 bytes de exten¬≠ s√£o, de modo que cada entrada de √≠ndice tem R i = (9 + 6) = 15 bytes, e o fator de bloco para o √≠ndice √© de bfr i =  ( Ô£∞ B R / i )   =  (1.024/15)  = 68 entradas por bloco. Em Ô£ª Ô£∞ Ô£ª um √≠ndice secund√°rio denso como este, o n√∫mero total de entradas de √≠ndice r i √© igual ao n√∫mero de registros no arquivo de dados, que √© 30.000. O n√∫mero de blo¬≠ cos necess√°rios para o √≠ndice √©, portanto, b i =  ( Ô£Æ r i / bfr i ) Ô£π =  (3.000/68)  = 442 blocos. Ô£Æ Ô£π

Uma pesquisa bin√°ria nesse √≠ndice secund√°rio pre¬≠ cisa de  (log Ô£Æ 2 b i )  =  (log 442)  = 9 acessos de bloco. Para Ô£π Ô£Æ 2 Ô£π procurar um registro usando o √≠ndice, precisamos de um acesso de bloco adicional ao arquivo de dados para um total de 9 + 1 = 10 acessos de bloco - uma gran¬≠ de melhoria em rela√ß√£o aos 1.500 acessos de bloco necess√°rios na m√©dia para uma pesquisa linear, mas ligeiramente pior que os 7 acessos de bloco exigidos para o √≠ndice prim√°rio. Essa diferen√ßa surgiu porque o √≠ndice prim√°rio era n√£o denso e, portanto, menor, com apenas 45 blocos de extens√£o.

Tamb√©m podemos criar um √≠ndice secund√°rio em um campo n√£o chave, n√£o ordenado de um arquivo. Nesse caso, diversos registros no arquivo de dados podem ter o mesmo valor para o campo de √≠ndice. Existem v√°rias op√ß√µes para implementar tal √≠ndice:

- ¬Ñ A op√ß√£o 1 √© incluir entradas de √≠ndice dupli¬≠ cadas com o mesmo valor K i ( )  -  um  para cada registro. Este seria um √≠ndice denso.
- ¬Ñ A op√ß√£o 2 √© ter registros de tamanho vari√°vel para as entradas de √≠ndice, com um campo re¬≠ petitivo para o ponteiro. Mantemos uma lista de ponteiros &lt; P i ( ,  1),  ..., P i ( , k )&gt; na entrada

de √≠ndice para K i ( ) - um ponteiro para cada bloco que cont√©m um registro cujo valor do campo de √≠ndice √© igual a K i ( ). Na op√ß√£o 1 ou na op√ß√£o 2, o algoritmo de pesquisa bin√°ria no √≠ndice deve ser modificado apropriadamen¬≠ te para considerar um n√∫mero vari√°vel de en¬≠ tradas de √≠ndice por valor de chave de √≠ndice.

- ¬Ñ A op√ß√£o 3, a mais usada, √© manter as pr√≥prias entradas de √≠ndice em um tamanho fixo e ter uma √∫nica entrada para cada valor de campo de √≠ndice , mas criar um n√≠vel de indire√ß√£o extra para lidar com os m√∫ltiplos ponteiros. Nesse esquema n√£o denso, o ponteiro P i ( ) na entrada de √≠ndice &lt; K i ( ), P i ( )&gt; aponta para um bloco de disco, que cont√©m um conjunto de ponteiros de registro . Cada ponteiro de regis¬≠ tro nesse bloco de disco aponta para um dos registros de arquivo de dados com valor K i ( ) para o campo de √≠ndice. Se algum valor K i ( ) ocorrer  em  muitos  registros,  de  modo  que seus ponteiros de registro n√£o possam caber em um √∫nico bloco de disco, um cluster ou lista ligada de blocos √© utilizada. Essa t√©cnica √© ilustrada na Figura 18.5. A recupera√ß√£o por meio do √≠ndice requer um ou mais acessos de bloco adicionais, devido ao n√≠vel extra, mas os algoritmos para pesquisar o √≠ndice e (mais importante)  para  inserir  novos  registros  no arquivo de dados s√£o simples. Al√©m disso, re¬≠ cupera√ß√µes em condi√ß√µes de sele√ß√£o comple¬≠ xas podem ser tratadas referindo¬≠se aos pon¬≠ teiros de registro, sem ter de recuperar muitos registros desnecess√°rios do arquivo de dados (ver Exerc√≠cio 18.23).

Observe que um √≠ndice secund√°rio oferece uma ordena√ß√£o l√≥gica nos registros pelo campo de √≠ndi¬≠ ce. Se acessarmos os registros na ordem das entradas no √≠ndice secund√°rio, n√≥s os obteremos na ordem do campo de √≠ndice. Os √≠ndices prim√°rio e de agrupa¬≠ mento assumem que o campo utilizado para a ordena√ß√£o f√≠sica dos registros no arquivo √© o mesmo que o campo de √≠ndice.

## 18.1.4 Resumo

Para concluir esta se√ß√£o, resumimos a discuss√£o dos tipos de √≠ndice em duas tabelas. A Tabela 18.1 mostra as caracter√≠sticas do campo de √≠ndice de cada tipo de √≠ndice ordenado de √∫nico n√≠vel discutido prim√°rio,  de  agrupamento  e  secund√°rio.  A  Tabela 18.2 resume as propriedades de cada tipo de √≠ndice ao comparar o n√∫mero de entradas de √≠ndice e espe¬≠ cificar quais √≠ndices s√£o densos e quais usam √¢ncoras de bloco do arquivo de dados.

## Arquivo de dados

(Campo de √≠ndice)

Figura 18.5



Um √≠ndice secund√°rio (com ponteiros de registro) em um campo n√£o chave implementado usando um n√≠vel de indire√ß√£o, de modo que as entradas de √≠ndice s√£o de tamanho fixo e t√™m valores de campo √∫nicos.

Tabela 18.1

Tipos de √≠ndices baseados nas propriedades do campo de √≠ndice.

|                             | Campo de √≠ndice usado para ordena√ß√£o f√≠sica do arquivo   | Campo de √≠ndice n√£o usado para ordena√ß√£o f√≠sica do arquivo   |
|-----------------------------|----------------------------------------------------------|--------------------------------------------------------------|
| Campo de √≠ndice √© chave     | √çndice prim√°rio                                          | √çndice secund√°rio (chave)                                    |
| Campo de √≠ndice √© n√£o chave | √çndice de agrupamento                                    | √çndice secund√°rio (n√£o chave)                                |

Tabela 18.2

Propriedades dos tipos de √≠ndice.

| Tipo de √≠ndice         | N√∫mero de entradas de √≠ndice (primeiro n√≠vel)                             | Denso ou n√£o denso (esparso)   | Ancoragem de bloco no arquivo de dados   |
|------------------------|---------------------------------------------------------------------------|--------------------------------|------------------------------------------|
| Prim√°rio               | N√∫mero de blocos no arquivo de dados                                      | N√£o denso                      | Sim                                      |
| Agrupamento            | N√∫mero de valores de campo de √≠ndice distintos                            | N√£o denso                      | Sim/n√£o a                                |
| Secund√°rio (chave)     | N√∫mero de registros no arquivo de dados                                   | Denso                          | N√£o                                      |
| Secund√°rio (n√£o chave) | N√∫mero de registros b ou n√∫mero de valores de campo de √≠ndice distintos c | Denso ou n√£o denso             | N√£o                                      |

- a Sim, se cada valor distinto do campo de ordena√ß√£o iniciar um novo bloco; caso contr√°rio, n√£o.

b Para a op√ß√£o 1.

c Para as op√ß√µes 2 e 3.

## 18.2 ndices multin√≠veis √ç

Os esquemas de indexa√ß√£o que descrevemos at√© aqui envolvem um arquivo de √≠ndice ordenado. Uma pesquisa bin√°ria √© aplicada ao √≠ndice para localizar ponteiros para um bloco de disco ou para um registro (ou registros) no arquivo que tem um valor espec√≠fi¬≠ co de campo de √≠ndice. Uma pesquisa bin√°ria requer aproximadamente (log 2 b i ) acessos de bloco para um √≠ndice com b i blocos, porque cada etapa do algoritmo reduz a parte do arquivo de √≠ndice que continuamos a pesquisar por um fator de 2. √â por isso que recu¬≠ peramos a fun√ß√£o log √† base 2. A ideia por tr√°s de um √≠ndice multin√≠vel √© reduzir a parte do √≠ndice que continuamos a pesquisar por bfr i ,  o  fator  de  bloco para o √≠ndice, que √© maior que 2. Logo, o espa√ßo de pesquisa √© reduzido muito mais rapidamente. O va¬≠ lor bfr i √© chamado de fan-out do √≠ndice multin√≠vel, e vamos nos referir a ele com o s√≠mbolo fo . Enquanto dividimos o espa√ßo de pesquisa de registro em duas metades a cada passo durante uma pesquisa bin√°ria, n√≥s o dividimos n vezes (onde n = o fan¬≠out) a cada passo de pesquisa, usando o √≠ndice multin√≠vel. A pes¬≠ quisa em um √≠ndice multin√≠vel requer aproximada¬≠ mente (log fo b i )  acessos  de  bloco,  que  √©  um  n√∫mero substancialmente menor do que para uma pesquisa bin√°ria se o fan¬≠out for maior que 2. Na maioria dos casos, o fan¬≠out √© muito maior que 2.

cado, podemos criar um √≠ndice prim√°rio para o pri¬≠ meiro n√≠vel; esse √≠ndice para o primeiro n√≠vel √© cha¬≠ mado de segundo n√≠vel do √≠ndice multin√≠vel. Como o segundo n√≠vel √© um √≠ndice prim√°rio, podemos usar √¢ncoras de bloco de modo que o segundo n√≠vel tenha uma entrada para cada bloco do  primeiro n√≠vel. O fator  de  bloco bfr i para  o  segundo  n√≠vel  -  e  para todos os n√≠veis subsequentes - √© o mesmo daquele para o √≠ndice do primeiro n√≠vel porque todas as en¬≠ tradas de √≠ndice s√£o do mesmo tamanho; cada uma tem um valor de campo e um endere√ßo de bloco. Se o primeiro n√≠vel tiver r 1 entradas, e o fator de bloco - que tamb√©m √© o fan¬≠out - para o √≠ndice for bfr i = fo , ent√£o o primeiro n√≠vel precisar√° de  ( Ô£Æ r 1 / fo )  blocos, Ô£π que √©, portanto, o n√∫mero de entradas r 2 necess√°rias no segundo n√≠vel do √≠ndice.

Um √≠ndice multin√≠vel considera o arquivo de √≠n¬≠ dice, ao qual nos referimos agora como o primeiro n√≠vel (ou de base ) de um √≠ndice multin√≠vel, como um arquivo ordenado com um valor distinto para cada K i ( ). Portanto, considerando o arquivo de √≠ndice de primeiro  n√≠vel  como  um  arquivo  de  dados  classifi¬≠

Podemos repetir  esse  processo  para  o  segundo n√≠vel. O terceiro n√≠vel , que √© um √≠ndice prim√°rio para o segundo n√≠vel, tem uma entrada para cada bloco do segundo n√≠vel, de modo que o n√∫mero de entradas do terceiro n√≠vel √© r 3 =  ( Ô£Æ r 2 / fo ) . Observe que s√≥ exigimos Ô£π um segundo n√≠vel se o primeiro n√≠vel precisar de mais de um bloco de armazenamento de disco e, de modo semelhante, exigimos um terceiro n√≠vel somente se o segundo n√≠vel precisar de mais de um bloco. Pode¬≠ mos repetir o processo anterior at√© que todas as en¬≠ tradas de algum n√≠vel de √≠ndice   caibam em um √∫nico t bloco. Esse bloco no  ¬≠√©simo n√≠vel √© chamado de n√≠vel t de  √≠ndice  do topo . 4 Cada  n√≠vel  reduz  o  n√∫mero  de entradas nos n√≠veis anteriores por um fator de fo - o fan¬≠out do √≠ndice -, de modo que podemos usar a f√≥rmula 1 ‚â§ ( r 1 /(( fo ) )) para calcular  . Portanto, um t t √≠ndice multin√≠vel com r 1 entradas de primeiro n√≠vel ter√° aproximadamente   n√≠veis, onde   =  (log t t Ô£Æ fo ( r 1 )) . Ô£π

4 O esquema de numera√ß√£o para os n√≠veis de √≠ndice usados aqui √© o contr√°rio do modo como os n√≠veis normalmente s√£o definidos para estruturas de dados de √°rvore. Nas estruturas de dados de √°rvore,   √© referenciado como o n√≠vel 0 (zero),   - 1 √© o n√≠vel 1, e assim por diante. t t

Ao  pesquisar  o  √≠ndice,  um  √∫nico  bloco  de  disco  √© recuperado em cada n√≠vel. Logo, t blocos  de  disco s√£o acessados para uma pesquisa de √≠ndice, onde   √© t o n√∫mero de n√≠veis de √≠ndice .

O esquema multin√≠vel descrito aqui pode ser usa¬≠ do em qualquer tipo de √≠ndice - seja ele prim√°rio, de agrupamento ou secund√°rio -, desde que o √≠ndice de primeiro n√≠vel tenha valores distintos para K(i) e entradas de tamanho fixo . A Figura 18.6 mostra um √≠ndice multin√≠vel constru√≠do em um √≠ndice prim√°rio. O Exemplo 3 ilustra a melhoria no n√∫mero de blocos acessados  quando  um  √≠ndice  multin√≠vel  √©  utilizado para procurar um registro.

Exemplo 3. Suponha que o √≠ndice secund√°rio denso do Exemplo 2 seja convertido em um √≠ndice multin√≠¬≠ vel. Calculamos o fator de bloco de √≠ndice bfr i = 68 entradas de √≠ndice por bloco, que √© tamb√©m o fan¬≠out fo para o √≠ndice multin√≠vel; o n√∫mero de blocos de primeiro n√≠vel b 1 = 442 tamb√©m foi calculado. O n√∫¬≠ mero de blocos de segundo n√≠vel ser√° b 2 =  ( Ô£Æ b 1 / fo )  = Ô£π Ô£Æ (442/68)  = 7 blocos, e o n√∫mero de blocos de tercei¬≠ Ô£π ro n√≠vel ser√° b 3 =  ( Ô£Æ b 2 / fo )  =  (7/68)  = 1 bloco. Logo, Ô£π Ô£Æ Ô£π o terceiro n√≠vel √© o n√≠vel topo do √≠ndice, e   = 3. Para t acessar um registro ao pesquisar um √≠ndice multin√≠¬≠ vel, temos de acessar um bloco em cada n√≠vel mais um bloco do arquivo de dados, de modo que precisa¬≠ mos de   + 1 = 3 + 1 = 4 acessos de bloco. Compare t isso  com  o  Exemplo  2,  onde  foram  necess√°rios  10 acessos de bloco quando um √≠ndice de √∫nico n√≠vel e a pesquisa bin√°ria foram utilizados.

Observe que tamb√©m poder√≠amos ter um √≠ndice prim√°rio multin√≠vel, que seria n√£o denso. O Exer¬≠ c√≠cio  18.18(c)  ilustra  esse  caso,  em  que temos de acessar o bloco de dados do arquivo antes de po¬≠ dermos determinar se o registro sendo pesquisado est√°  no  arquivo.  Para  um √≠ndice denso, isso pode ser determinado acessando o primeiro n√≠vel de √≠n¬≠ dice (sem ter de acessar um bloco de dados), pois existe uma entrada de √≠ndice para cada registro no arquivo.

Uma organiza√ß√£o de arquivo comum usada no processamento de dados comercial √© um arquivo ordenado com um √≠ndice prim√°rio multin√≠vel em seu campo de chave de ordena√ß√£o. Essa organiza¬≠ √ß√£o √© chamada de arquivo sequencial indexado , e foi  empregada  em  muitos  dos  primeiros  sistemas IBM. A organiza√ß√£o ISAM da IBM incorpora um √≠ndice de dois n√≠veis que est√° relacionado de perto com a organiza√ß√£o do disco em rela√ß√£o a cilindros e trilhas (ver Se√ß√£o 17.2.1). O primeiro n√≠vel √© um √≠ndice de cilindro, que tem o valor de chave de um registro de √¢ncora para cada cilindro de um disk pack ocupado pelo arquivo e um ponteiro para o √≠ndice  de  trilha  para  o  cilindro.  O  √≠ndice  de  tri¬≠

lha tem o valor de chave de um registro de √¢ncora para cada trilha no cilindro e um ponteiro para a trilha. Esta trilha pode ent√£o ser pesquisada de for¬≠ ma sequencial para o registro ou bloco desejado. A inser√ß√£o √© tratada por alguma forma de arquivo de overflow, que √© mesclado periodicamente com o arquivo de dados. O √≠ndice √© recriado durante a reorganiza√ß√£o do arquivo.

O  Algoritmo  18.1  esbo√ßa  o  procedimento  de pesquisa para um registro em um arquivo de dados que utiliza um √≠ndice prim√°rio multin√≠vel n√£o denso com   n√≠veis. Referimo¬≠nos √† entrada   no n√≠vel   do t i j √≠ndice como &lt; K i j ( ), P i j ( )&gt; e procuramos um registro cujo valor de chave prim√°ria seja K .  Consideramos que quaisquer registros de overflow s√£o ignorados. Se o registro estiver no arquivo, dever√° haver algu¬≠ ma entrada no n√≠vel 1 com K i 1 ( ) ‚â§ K &lt; K i 1 (  + 1) e o registro  estar√°  no  bloco  do  arquivo  de  dados  cujo endere√ßo √© P 1 ( ). O Exerc√≠cio 18.23 discute a modifi¬≠ i ca√ß√£o do algoritmo de pesquisa para outros tipos de √≠ndices.

Algoritmo 18.1. Pesquisando um √≠ndice prim√°¬≠ rio multin√≠vel n√£o denso com   n√≠veis t

- ( * Consideramos  que  a  entrada  de  √≠ndice  seja uma √¢ncora de bloco que √© a primeira chave por bloco. )

fim; l √© p ; pesquisa bloco p pelo registro com chave = K ;

* p ‚Üê endere√ßo do bloco do n√≠vel topo do √≠ndice; para j ‚Üê t step - 1 at√© 1 fa√ßa in√≠cio l√™ o bloco de √≠ndice (no n√≠vel de √≠ndice j ) cujo endere√ßo √© p ; pesquisa bloco p para entrada   tal que i K j ( ) i ‚â§ K &lt; K j (  + 1) i ( * se K j ( ) i a √∫ltima entrada no bloco, √© suficiente √© satisfazer K j ( ) i ‚â§ K * ); p ‚Üê P j ( i ) ( * recupera ponteiro apropria¬≠ do no n√≠vel de √≠ndice    ) j * √™ o bloco do arquivo de dados cujo endere√ßo

Como vimos, um √≠ndice multin√≠vel reduz o n√∫¬≠ mero  de  blocos  acessados  quando  se  pesquisa  um registro, dado seu valor de campo de indexa√ß√£o. Ain¬≠ da enfrentamos os problemas de lidar com inser√ß√µes e exclus√µes de √≠ndice, pois todos os n√≠veis de √≠ndice s√£o arquivos  ordenados  fisicamente .  Para  reter  os benef√≠cios do uso da indexa√ß√£o multin√≠vel enquanto reduzimos  os  problemas  de  inser√ß√£o  e  exclus√£o  de √≠ndice, os projetistas adotaram um √≠ndice multin√≠vel

## Àùndice de dois n√≠veis

## Arquivo de dados



Figura 18.6 Um √≠ndice prim√°rio de dois n√≠veis semelhante √† organiza√ß√£o ISAM ( Indexed Sequential Access Method ).

chamado √≠ndice  multin√≠vel  din√¢mico ,  que  deixa  al¬≠ gum espa√ßo em cada um de seus blocos para inserir novas entradas e usa algoritmos apropriados de in¬≠ ser√ß√£o/exclus√£o para criar e excluir novos blocos de √≠ndice quando o arquivo de dados cresce e encolhe. Ele normalmente √© implementado ao usar estruturas de dados chamadas B¬≠trees e B + ¬≠trees, que descreve¬≠ remos na pr√≥xima se√ß√£o.

## 18.3 ndices multin√≠veis din√¢micos √ç usando B-trees e B + -trees

B¬≠trees  e  B ¬≠trees  s√£o  casos  especiais  da  famo¬≠ + sa  estrutura  de  dados  de  pesquisa,  conhecida  como √°rvore . Apresentamos  rapidamente  a  terminologia usada na discuss√£o de estruturas de dados de √°rvore. Uma √°rvore √©  formada de n√≥s .  Cada n√≥ na √°rvore,

exceto pelo n√≥ especial chamado raiz , tem um n√≥ pai e zero ou mais n√≥s filhos . O n√≥ raiz n√£o tem pai. Um n√≥ que n√£o tem filho algum √© denominado n√≥ folha ; um n√≥ n√£o folha √© chamado de n√≥ interno . O n√≠vel de um n√≥ √© sempre um a mais que o n√≠vel de seu pai, com o n√≠vel do n√≥ raiz sendo zero . 5 Uma sub√°rvore de um n√≥ consiste nesse n√≥ e todos os seus n√≥s descendentes - seus n√≥s filhos, os n√≥s filhos de seus n√≥s filhos,  e  assim  por  diante.  Uma  defini√ß√£o  recursiva exata de uma sub√°rvore √© que ela consiste em um n√≥ n e as sub√°rvores de todos os n√≥s filhos de n . A Fi¬≠ gura 18.7 ilustra uma estrutura de dados em √°rvore. Nessa figura, o n√≥ raiz √© A, e seus n√≥s filhos s√£o B, C e D. Os n√≥s E, J, C, G, H e K s√£o n√≥s folha. Como os n√≥s folha est√£o em diferentes n√≠veis da √°rvore, essa √°rvore √© chamada de desbalanceada .

## 18.3.1 √Årvores de pesquisa e B-trees

Uma √°rvore de pesquisa √© um tipo especial de √°r¬≠ vore utilizada para orientar a pesquisa por um regis¬≠ tro, dado o valor de um dos campos do registro. Os √≠ndices multin√≠veis discutidos na Se√ß√£o 18.2 podem ser  imaginados como uma varia√ß√£o de uma √°rvore de pesquisa; cada n√≥ no √≠ndice multin√≠vel pode ter in√∫meros ponteiros fo e valores de chave fo , onde fo √© o fan¬≠out do √≠ndice. Os valores de campo de √≠ndice em cada n√≥ nos guiam para o pr√≥ximo n√≥, at√© que alcancemos o bloco do arquivo de dados que cont√©m os registros solicitados. Ao seguir um ponteiro, res¬≠ tringimos nossa pesquisa em cada n√≠vel a uma sub√°r¬≠ vore da √°rvore de pesquisa e ignoramos todos os n√≥s fora dessa sub√°rvore.

Na Se√ß√£o 18.3.1, apresentamos √°rvores de pes¬≠ quisa e depois discutimos sobre B¬≠trees, que podem ser usadas como √≠ndices multin√≠veis din√¢micos para orientar a busca por registros em um arquivo de da¬≠ dos. N√≥s de B¬≠tree s√£o mantidos entre 50 e 100 por cento cheios, e os ponteiros para blocos de dados s√£o armazenados nos n√≥s internos e n√≥s folha da estrutu¬≠ ra da B¬≠tree. Na Se√ß√£o 18.3.2, abordamos as B + ¬≠trees, uma varia√ß√£o das B¬≠trees em que os ponteiros para os blocos de dados de um arquivo s√£o armazenados apenas em n√≥s folha, que podem levar a menos n√≠veis e √≠ndices de maior capacidade. Nos SGBDs prevalen¬≠ tes no mercado hoje em dia, a estrutura comum usa¬≠ da para indexa√ß√£o √© B + ¬≠trees.

√Årvores de pesquisa. Uma √°rvore de pesquisa √© li¬≠ geiramente  diferente  de  um  √≠ndice  multin√≠vel.  Uma √°rvore de pesquisa de ordem p √© uma √°rvore tal que cada n√≥ cont√©m no m√°ximo p - 1 valores de pesquisa e p ponteiros na ordem &lt; P  K 1 , 1 , P 2 , K 2 , ..., P q-1 , K q-1 , P q &gt;, onde q ‚â§ p . Cada P i √© um ponteiro para um n√≥ filho (ou um ponteiro NULL ), e cada K i √© um valor de pesquisa de algum conjunto ordenado de valores. To¬≠ dos os valores de pesquisa s√£o considerados √∫nicos. 6 A Figura 18.8 ilustra um n√≥ em uma √°rvore de pes¬≠ quisa. Duas restri√ß√µes precisam ser mantidas o tempo todo na √°rvore de pesquisa:

<!-- formula-not-decoded -->

(N√≥s E, J, C, G, H e K s¬™o n√≥s folha da √Ürvore)



Figura 18.7 Uma estrutura de dados em √°rvore que mostra uma √°rvore desbalanceada.

5 Essa defini√ß√£o-padr√£o do n√≠vel de um n√≥ de √°rvore, que usamos ao longo da Se√ß√£o 18.3, √© diferente daquela que demos para √≠ndices multin√≠veis na Se√ß√£o 18.2.

6 Essa restri√ß√£o pode ser relaxada. Se o √≠ndice for em um campo n√£o chave, pode haver valores de pesquisa duplicados, e a estrutura do n√≥ e as regras de navega√ß√£o para a √°rvore podem ser modificadas.

Figura 18.8



Um n√≥ em uma √°rvore de pesquisa com ponteiros para sub√°rvores abaixo dela.

- 2. Para todos os valores X na sub√°rvore apon¬≠ tada por P i , temos K i -1 &lt; X &lt; K i para 1 &lt; i &lt; q  X ; &lt; K i para i = 1; e K i -1 &lt; X para i = q (ver Figura 18.8).

Sempre que procuramos um valor X , seguimos o ponteiro P i apropriado, de acordo com as f√≥rmulas na condi√ß√£o 2. A Figura 18.9 ilustra uma √°rvore de pesquisa de ordem p = 3 e valores de pesquisa intei¬≠ ros. Observe que alguns dos ponteiros P i em um n√≥ podem ser ponteiros NULL .

S√£o necess√°rios algoritmos para inserir e excluir valo¬≠ res de pesquisa na √°rvore de pesquisa enquanto se mant√™m as duas restri√ß√µes anteriores. Em geral, esses algoritmos n√£o garantem que uma √°rvore de pesquisa seja balanceada ,  significando  que  todos  os  seus  n√≥s  folha  est√£o  no mesmo n√≠vel. 7 A √°rvore da Figura 18.7 n√£o √© balanceada porque tem n√≥s folha nos n√≠veis 1, 2 e 3. Os objetivos para balancear uma √°rvore de pesquisa s√£o os seguintes:

Podemos usar uma √°rvore de pesquisa como um mecanismo para procurar registros armazenados em um arquivo de disco. Os valores na √°rvore podem ser os valores de um dos campos do arquivo, chamado campo de pesquisa (que √© o mesmo que o campo de √≠ndice se um √≠ndice multin√≠vel guiar a pesquisa). Cada valor de chave na √°rvore √© associado a um ponteiro para o registro no arquivo de dados que tem esse va¬≠ lor. Como alternativa, o ponteiro poderia ser para o bloco de disco contendo esse registro. A pr√≥pria √°rvo¬≠ re de pesquisa pode ser armazenada no disco ao atri¬≠ buir cada n√≥ de √°rvore a um bloco de disco. Quando um novo registro √© inserido no arquivo, temos de atua¬≠ lizar a √°rvore de pesquisa inserindo uma entrada na √°rvore que cont√©m o valor do campo de pesquisa do novo registro e um ponteiro para o novo registro.

- ¬Ñ Garantir  que  os  n√≥s  sejam  distribu√≠dos  por igual, de modo que a profundidade da √°rvore seja minimizada para determinado conjunto de chaves e que a √°rvore n√£o fique distorcida, com alguns n√≥s em n√≠veis muito profundos.
- ¬Ñ Tornar  a  velocidade  de  pesquisa  uniforme, de modo que o tempo m√©dio para encontrar qualquer  chave  aleat√≥ria  seja  aproximada¬≠ mente o mesmo.

Embora minimizar o n√∫mero de n√≠veis na √°rvo¬≠ re seja um objetivo, outro objetivo impl√≠cito √© ga¬≠ rantir que a √°rvore de √≠ndice n√£o precise de muita reestrutura√ß√£o quando os registros s√£o inseridos e exclu√≠dos  do  arquivo  principal.  Assim,  queremos que  os  n√≥s  sejam  os  mais  cheios  poss√≠veis  e  n√£o queremos que quaisquer n√≥s sejam vazios se houver

Figura 18.9



Uma √°rvore de pesquisa de ordem p = 3.

Figura 18.10





Estruturas B-tree. (a) Um n√≥ em uma B-tree com q - 1 valores de pesquisa. (b) Uma B-tree de ordem p = 3. Os valores foram inseridos na ordem 8, 5, 1, 7, 3, 12, 9, 6.

muitas exclus√µes. A exclus√£o de registro pode dei¬≠ xar alguns n√≥s na √°rvore quase vazios, desperdi√ßan¬≠ do assim o espa√ßo de armazenamento e aumentando o n√∫mero de n√≠veis. A B¬≠tree resolve esses dois pro¬≠ blemas, especificando restri√ß√µes adicionais na √°rvo¬≠ re de pesquisa.

- 1. Cada n√≥ interno na B¬≠tree (Figura 18.10(a)) tem a forma

B-trees. A  B¬≠tree  tem  restri√ß√µes  adicionais  que garantem  que  a  √°rvore  sempre  esteja  balancea¬≠ da e que o espa√ßo desperdi√ßado pela exclus√£o, se houver, nunca se torne excessivo. Os algoritmos para inser√ß√£o e exclus√£o, por√©m, tornam¬≠se mais complexos a fim de manter essas restri√ß√µes. Ape¬≠ sar disso, a maioria das inser√ß√µes e exclus√µes s√£o processos  simples.  Elas  se  tornam  complicadas somente sob circunst√¢ncias especiais - a saber, sempre que tentamos uma inser√ß√£o em um n√≥ que j√° est√° cheio ou uma exclus√£o de um n√≥ que o tor¬≠ ne cheio em menos da metade. De maneira mais formal,  uma B-tree  de  ordem p ,  quando  usada como uma estrutura de acesso em um campo de chave para pesquisar registros em um arquivo de dados, pode ser definida da seguinte forma:

&lt; P 1 , &lt; K 1 , Pr 1 &gt;, P 2 , &lt; K 2 , Pr 2 &gt;, ..., &lt; K q -1 , Pr q -1 &gt;, P q &gt; onde q ‚â§ p . Cada P i √© um ponteiro de √°rvore -um ponteiro  para  outro  n√≥  na  B¬≠tree.  Cada Pr i √©  um ponteiro de dados 8 - um ponteiro para o registro cujo valor do campo de chave de pesquisa √© igual a K i (ou ao bloco do arqui¬≠ vo de dados que cont√©m esse registro).

- 2. Em cada n√≥, K 1 &lt; K 2 &lt; ... &lt; K q -1 .
- 3. Para todos os valores de campo da chave de pes¬≠ quisa X na sub√°rvore apontada por P i (a  ¬≠√©sima i sub√°rvore; ver Figura 18.10(a)), temos:

K i -1 &lt; X &lt; K i para 1 &lt; i &lt; q  X ; &lt; K i para i = 1; e K i -1 &lt; X para i = q .

- 4. Cada n√≥ tem no m√°ximo p ponteiros de √°rvore.
- 5. Cada n√≥, exceto os n√≥s raiz e folha, tem pelo menos  ( Ô£Æ p /2) Ô£π ponteiros de √°rvore. O n√≥ raiz tem pelo menos dois ponteiros de √°rvore, a menos que seja o √∫nico n√≥ na √°rvore.

8 Um ponteiro de dados √© um endere√ßo de bloco ou um endere√ßo de registro; o √∫ltimo √© basicamente um endere√ßo de bloco e um deslocamento de registro dentro do bloco.

9 Para detalhes sobre algoritmos de inser√ß√£o e exclus√£o para B-trees, consulte Ramakrishnan e Gehrke (2003).

- 6. Um n√≥ com q ponteiros  de  √°rvore, q ‚â§ p , tem q -  1  valores  de  campo  de  chave  de pesquisa (e, portanto, tem q -  1  ponteiros de dados).
- 7. Todos os n√≥s folha est√£o no mesmo n√≠vel. Os n√≥s folha t√™m a mesma estrutura dos n√≥s in¬≠ ternos, exceto que todos os seus ponteiros de √°rvore P i s√£o NULL .

A  Figura  18.10(b)  ilustra  uma  B¬≠tree  de  ordem p = 3. Observe que todos os valores de pesquisa K na B¬≠tree  s√£o  √∫nicos,  pois  consideramos  que  a  √°rvore  √© usada como uma estrutura de acesso em um campo de chave. Se  usarmos uma B¬≠tree em um campo n√£o chave , temos de mudar a defini√ß√£o dos ponteiros de ar¬≠ quivo Pr i para apontar para um bloco - ou um cluster de blocos - que contenha os ponteiros para os re¬≠ gistros de arquivo. Esse n√≠vel de indire√ß√£o extra √© semelhante √† op√ß√£o 3, discutida na Se√ß√£o 18.1.3, para √≠ndices secund√°rios.

Uma B¬≠tree come√ßa com um √∫nico n√≥ raiz (que tamb√©m √© um n√≥ folha) no n√≠vel 0 (zero). Quando o n√≥ raiz est√° cheio com p - 1 valores de chave de pes¬≠ quisa e tentamos inserir outra entrada na √°rvore, o n√≥ raiz se divide em dois n√≥s no n√≠vel 1. Somente o valor do meio √© mantido no n√≥ raiz, e o restante dos valores √© dividido por igual entre os outros dois n√≥s. Quando um n√≥ n√£o raiz est√° cheio e uma nova entrada √© inse¬≠ rida nele, esse n√≥ √© dividido em dois n√≥s no mesmo n√≠vel,  e  a  entrada  do  meio  √©  movida  para  o  n√≥  pai junto com dois ponteiros para os novos n√≥s divididos. Se  o  n√≥  pai  estiver  cheio,  ele  tamb√©m  √©  dividido.  A divis√£o pode propagar por todo o caminho at√© o n√≥ raiz, criando um novo n√≠vel se a raiz for dividida. N√£o vamos discutir os algoritmos para B¬≠trees com deta¬≠ lhes neste livro,  mas esbo√ßamos os procedimentos de 9 pesquisa e inser√ß√£o para B + ¬≠trees na pr√≥xima se√ß√£o.

Se a exclus√£o de um valor fizer que um n√≥ fique com menos da metade cheio, ele √© combinado com seus n√≥s vizinhos, e isso tamb√©m pode se propagar at√© a raiz. Logo, a exclus√£o pode reduzir o n√∫mero de n√≠veis da √°rvore. Foi demonstrado pelos analistas e pela simula√ß√£o que, ap√≥s diversas inser√ß√µes e exclu¬≠ s√µes aleat√≥rias em uma B¬≠tree, os n√≥s ficam aproxi¬≠ madamente 69 por cento cheios quando o n√∫mero de valores na √°rvore se estabiliza. Isso tamb√©m vale para B + ¬≠trees. Se isso acontecer, a divis√£o e a combina√ß√£o de n√≥s ocorrer√£o apenas raramente, de modo que a inser√ß√£o e exclus√£o se tornam muito eficientes. Se o n√∫mero de valores crescer, a √°rvore se expandir√° sem problema - embora a divis√£o dos n√≥s possa ocorrer, algumas inser√ß√µes levar√£o mais tempo. Cada n√≥ de B¬≠tree  pode  ter no  m√°ximo p ponteiros  de  √°rvore, p - 1 ponteiros de dados, e p - 1 valores de campo de chave de pesquisa (ver Figura 18.10(a)).

Em geral, um n√≥ de B¬≠tree pode conter infor¬≠ ma√ß√µes adicionais necess√°rias pelos algoritmos que manipulam a √°rvore, como o n√∫mero de entradas q no n√≥ e um ponteiro para o n√≥ pai. A seguir, ilus¬≠ tramos como calcular o n√∫mero de blocos e n√≠veis para uma B¬≠tree.

Exemplo 4. Suponha que o campo de pesquisa seja um campo de chave n√£o ordenado, e construamos uma B¬≠tree nesse campo com p =  23. Suponha que cada n√≥ da B¬≠tree esteja 69 por cento cheio. Cada n√≥, na m√©dia, ter√° p * 0,69 = 23 * 0,69 ou, aproxi¬≠ madamente, 16 ponteiros e, portanto, 15 valores de campo de chave de pesquisa. O fan¬≠out m√©dio fo = 16. Podemos come√ßar na raiz e ver quantos valores e ponteiros podem existir, na m√©dia, em cada n√≠vel subsequente:

| Raiz:    | 1 n√≥      | 15 entradas de chave     | 16 ponteiros    |
|----------|-----------|--------------------------|-----------------|
| N√≠vel 1: | 16 n√≥s    | 240 entradas de chave    | 256 ponteiros   |
| N√≠vel 2: | 256 n√≥s   | 3.840 entradas de chave  | 4.096 ponteiros |
| N√≠vel 3: | 4.096 n√≥s | 61.440 entradas de chave |                 |

Em cada n√≠vel, calculamos o n√∫mero de entradas de chave multiplicando o n√∫mero total de ponteiros no n√≠vel anterior por 15, o n√∫mero m√©dio de entra¬≠ das em cada n√≥. Assim, para determinado tamanho de bloco, tamanho de ponteiro e tamanho do cam¬≠ po de chave de pesquisa, uma B¬≠tree de dois n√≠veis mant√©m 3.840 + 240 + 15 = 4.095 entradas na m√©¬≠ dia; uma B¬≠tree de tr√™s n√≠veis mant√©m 65.535 entra¬≠ das na m√©dia.

As B¬≠trees √†s vezes s√£o usadas como organiza√ß√µes de arquivo prim√°rias .  Nesse caso, registros inteiros s√£o  armazenados  nos  n√≥s  da  B¬≠tree,  em  vez de  apenas  as  entradas  &lt;chave  de  pesquisa,  pontei¬≠ ro de registro&gt;. Isso funciona bem para arquivos com um n√∫mero relativamente pequeno de registros e um tamanho de registro pequeno . Caso contr√°rio, o fan¬≠ ¬≠out e o n√∫mero de n√≠veis tornam¬≠se muito grande para permitir um acesso eficiente.

Resumindo, as B¬≠trees oferecem uma estrutura de acesso multin√≠vel que √© uma estrutura de √°rvore balanceada em que cada n√≥ est√° cheio pelo menos at√© a metade. Cada n√≥ em uma B¬≠tree de ordem p pode ter no m√°ximo p - 1 valores de pesquisa.

## 18.3.2 B + -trees

A maioria das implementa√ß√µes de um √≠ndice mul¬≠ tin√≠vel din√¢mico utiliza uma varia√ß√£o da estrutura de dados da B¬≠tree chamada B -tree + . Em uma B¬≠tree, cada valor do campo de pesquisa aparece uma vez em al¬≠ gum n√≠vel na √°rvore, junto com um ponteiro de dados. Em uma B + ¬≠tree, os ponteiros de dados s√£o armazena¬≠ dos apenas nos n√≥s folha da √°rvore; logo, a estrutura

dos n√≥s folha difere da estrutura dos n√≥s internos. Os n√≥s folha t√™m uma entrada para cada valor do campo de pesquisa, junto com um ponteiro de dados para o registro (ou para o bloco que cont√©m esse registro), se o campo de pesquisa for um campo de chave. Para um campo de pesquisa n√£o chave, o ponteiro aponta para um bloco que cont√©m ponteiros para os registros do arquivo de dados, criando um n√≠vel de indire√ß√£o extra.

Os n√≥s folha da B + ¬≠tree normalmente s√£o ligados para oferecer acesso ordenado no campo de pesquisa aos registros. Esses n√≥s folha s√£o semelhantes ao pri¬≠ meiro  n√≠vel  (base)  de  um  √≠ndice.  Os  n√≥s  internos  da B + ¬≠tree  correspondem  aos  outros  n√≠veis  de  um  √≠ndice multin√≠vel. Alguns valores de campo de pesquisa dos n√≥s folha s√£o repetidos nos n√≥s internos da B + ¬≠tree para guiar a pesquisa. A estrutura dos n√≥s internos de uma B + ¬≠tree de ordem p (Figura 18.11(a)) √© a seguinte:

- 1. Cada n√≥ interno tem a forma

<!-- formula-not-decoded -->

onde q ‚â§ p e cada P i √© um ponteiro de √°rvore .

- 2. Em cada n√≥ interno, K 1 &lt; K 2 &lt; ... &lt; K q -1 .
- 3. Para todos os valores de campo de pesquisa X na sub√°rvore apontada por P i , temos K i -1 &lt; X ‚â§ K i para 1 &lt; i &lt; q  X ; ‚â§ K i para i = 1; e K i -1 &lt; X para i = q (ver Figura 18.11(a)). 10
- 5. Cada n√≥ interno, exceto a raiz, tem pelo me¬≠ nos  ( Ô£Æ p /2)  ponteiros de √°rvore. O n√≥ raiz tem Ô£π pelo menos dois ponteiros de √°rvore, se for um n√≥ interno.
- 6. Um n√≥ interno com q ponteiros, q ‚â§ p ,  tem q - 1 valores de campo de pesquisa.

A estrutura dos n√≥s folha de uma B + ¬≠tree de or¬≠ dem p (Figura 18.11(b)) √© a seguinte:

- 1. Cada n√≥ folha tem a forma
- &lt;&lt; K 1 , Pr 1 &gt;, &lt; K 2 , Pr 2 &gt;, ..., &lt; K q -1 , Pr q -1 &gt;, P pr√≥ximo &gt; onde q ‚â§ p , cada Pr i √© um ponteiro de dados e P pr√≥ximo aponta para o pr√≥ximo n√≥ folha da B + ¬≠tree.
- 2. Em cada n√≥ folha, K 1 ‚â§ K 2 ... , K q -1 , q ‚â§ p .
- 3. Cada Pr i √© um ponteiro de dados que aponta para o registro cujo valor do campo de pes¬≠ quisa √© K i , ou para um bloco de arquivo que cont√©m o registro (ou para um bloco de pon¬≠ teiros  de  registro  que  aponta  para  registros cujo  valor  do  campo  de  pesquisa  √© K i se  o campo de pesquisa n√£o for uma chave).
- 4. Cada n√≥ folha tem pelo menos ( Ô£Æ p /2) valores. Ô£π
- 5. Todos os n√≥s folha est√£o no mesmo n√≠vel.
- 4. Cada n√≥ interno tem, no m√°ximo, p pontei¬≠ ros de √°rvore.

Os ponteiros nos n√≥s internos s√£o tr√™s  ponteiros para blocos que s√£o n√≥s de √°rvore, enquanto os ponteiros nos n√≥s folha s√£o ponteiros de dados para os registros ou blocos do arquivo de dados - exceto para o ponteiro P pr√≥ximo , que √© um ponteiro de √°rvore para o pr√≥ximo n√≥ folha. Ao come√ßar no n√≥ folha mais √† es¬≠

Figura 18.11 - 1 valores de pesquisa. (b) N√≥ folha de uma B -tree com



Os n√≥s de uma B -tree. (a) N√≥ interno de uma B -tree com + + q + q - 1 valores de pesquisa e q - 1 ponteiros de dados.

10 Nossa defini√ß√£o segue Knuth (1998). Pode-se definir uma B -tree de forma diferente ao trocar os s√≠mbolos &lt; e ‚â§ ( + K i-1 ‚â§ X &lt; K K i ; q-1 ‚â§ X), mas os princ√≠pios continuam sendo os mesmos.

querda, √© poss√≠vel atravessar os n√≥s folha como uma lista ligada, usando os ponteiros P pr√≥ximo . Isso oferece acesso ordenado aos registros de dados no campo de √≠ndice. Um ponteiro P anterior tamb√©m pode ser inclu¬≠ √≠do.  Para  uma  B + ¬≠tree  em  um  campo  n√£o  chave,  √© necess√°rio  um  n√≠vel  extra  de  indire√ß√£o,  semelhante ao que mostramos na Figura 18.5, de modo que os Pr ponteiros s√£o ponteiros de bloco para os blocos que cont√™m um conjunto de ponteiros de registro para os registros reais no arquivo de dados, conforme discu¬≠ timos na op√ß√£o 3 da Se√ß√£o 18.1.3.

Como  as  entradas  nos n√≥s  internos de  uma B + ¬≠tree  incluem  valores  de  pesquisa  e  ponteiros  de √°rvore sem quaisquer ponteiros de dados, mais en¬≠ tradas podem ser compactadas em um n√≥ interno de uma B + ¬≠tree do que para uma B¬≠tree semelhante. As¬≠ sim, para o mesmo tamanho de bloco (n√≥), a ordem p ser√°  maior  para  a  B ¬≠tree  do  que  para  a  B¬≠tree, + conforme ilustramos no Exemplo 5. Isso pode levar a  menos n√≠veis de B + ¬≠tree,  melhorando o tempo de pesquisa. Como as estruturas para n√≥s internos e fo¬≠ lha  de  uma  B + ¬≠tree  s√£o  diferentes,  a  ordem p pode ser diferente. Usaremos p para indicar a ordem para n√≥s internos e p folha para  indicar  a  ordem  para n√≥s folha , que definimos como sendo o n√∫mero m√°ximo de ponteiros de dados em um n√≥ folha.

Exemplo 5. Para  calcular  a  ordem p de  uma  B + ¬≠tree,  su¬≠ ponha  que  o  campo  de  chave  de  pesquisa  seja  V  =  9  bytes de extens√£o, o tamanho do bloco seja B = 512  bytes, um ponteiro de registro seja Pr = 7 bytes e um pon¬≠ teiro de bloco seja P =  6  bytes. Um n√≥ interno da B + ¬≠tree pode ter at√© p ponteiros de √°rvore e p -  1 valores de campo de pesquisa; estes precisam caber em um √∫nico bloco. Logo, temos:

<!-- formula-not-decoded -->

Podemos escolher p para ser o maior valor que satisfa√ßa a desigualdade acima, que gera p = 34. Isso √© maior do que o valor de 23 para a B¬≠tree (fica para o leitor a tarefa de calcular a ordem da B¬≠tree ao con¬≠ siderar  ponteiros  do  mesmo  tamanho),  resultando em um fan¬≠out maior e mais entradas em cada n√≥ interno de uma B + ¬≠tree do que na B¬≠tree correspon¬≠ dente. Os n√≥s folha da B + ¬≠tree ter√£o o mesmo n√∫mero de valores e ponteiros, exceto que os ponteiros s√£o ponteiros de dados e um ponteiro de pr√≥ximo. Logo, a ordem p folha para os n√≥s folha pode ser calculada da seguinte forma:

<!-- formula-not-decoded -->

Segue¬≠se  que  cada  n√≥  folha  pode  manter  at√© p folha = 31 combina√ß√µes de ponteiro de valor/dados de chave, considerando que os ponteiros de dados s√£o ponteiros de registro.

Assim como a B¬≠tree, podemos precisar de in¬≠ forma√ß√µes adicionais - para implementar os algo¬≠ ritmos de inser√ß√£o e exclus√£o - em cada n√≥. Essa informa√ß√£o pode incluir o tipo de n√≥ (interno ou fo¬≠ lha), o n√∫mero de entradas atuais q no n√≥ e ponteiros para os n√≥s pai e irm√£o. Logo, antes de fazermos os c√°lculos acima para p e p folha , devemos reduzir o ta¬≠ manho do bloco pela quantidade de espa√ßo necess√°¬≠ ria para toda essa informa√ß√£o. O pr√≥ximo exemplo ilustra como podemos calcular o n√∫mero de entradas em uma B + ¬≠tree.

Exemplo  6. Suponha  que  criemos  uma  B + ¬≠tree  no campo do Exemplo 5. Para calcular o n√∫mero apro¬≠ ximado  de  entradas  na  B + ¬≠tree,  consideramos  que cada  n√≥  est√°  69  por  cento  cheio.  Na  m√©dia,  cada n√≥ interno ter√° 34 * 0,69 ou, aproximadamente, 23 ponteiros e, portanto, 22 valores. Cada n√≥ folha, em m√©dia, manter√° 0,69 * p folha = 0,69 * 31 ou, aproxi¬≠ madamente, 21 ponteiros de registro de dados. Uma B + ¬≠tree ter√° o seguinte n√∫mero m√©dio de entradas em cada n√≠vel:

| Raiz:        | 1 n√≥       | 22 entradas de chave                   | 23 ponteiros     |
|--------------|------------|----------------------------------------|------------------|
| N√≠vel 1:     | 23 n√≥s     | 506 entradas de chave                  | 529 ponteiros    |
| N√≠vel 2:     | 529 n√≥s    | 11.638 entradas de chave               | 12.167 ponteiros |
| N√≠vel folha: | 12.167 n√≥s | 255.507 ponteiros de registro de dados |                  |

Para o tamanho do bloco, tamanho do ponteiro e tamanho do campo de pesquisa dados acima, uma B + ¬≠tree de tr√™s n√≠veis mant√©m at√© 255.507 ponteiros de registro, com a m√©dia de 69 por cento de ocupa√ß√£o de n√≥s. Compare isso com as 65.535 entradas para a B¬≠tree correspondente do Exemplo 4. Esse √© o princi¬≠ pal motivo para as B + ¬≠trees serem preferidas √†s B¬≠trees como √≠ndices para arquivos de banco de dados.

## Pesquisa, inser√ß√£o e exclus√£o com B + -trees. O

Algoritmo 18.2 esbo√ßa o procedimento usando a B + ¬≠tree como estrutura de acesso para pesquisar um registro.  O  Algoritmo  18.3  ilustra  o  procedimento para  inserir  um  registro  em  um  arquivo  com  uma estrutura de acesso de B + ¬≠tree. Esses algoritmos con¬≠ sideram  a  exist√™ncia  de  um  campo  de  pesquisa  de chave, e eles devem ser modificados apropriadamente para o caso de uma B + ¬≠tree em um campo n√£o chave. Ilustramos a inser√ß√£o e a exclus√£o com um exemplo.

| Algoritmo 18.2. Pesquisando um registro com o valor do campo de chave de pesquisa K , usando uma B + ¬≠tree n ‚Üê bloco contendo n√≥ raiz da B + ¬≠tree;                                                                                                                                                     |
|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| l√™ bloco n ;                                                                                                                                                                                                                                                                                          |
| enquanto ( n n√£o √© um n√≥ folha da B + ¬≠tree) do in√≠cio q ‚Üê n√∫mero de ponteiros de √°rvore no n√≥ se K ‚â§ n . K 1 ( * n . K i refere¬≠se ao i ¬≠√©simo valor campo de pesquisa no n√≥ n * ) ent√£o n ‚Üê n . P 1 ( * n . P i refere¬≠se ao i- ponteiro de √°rvore no n√≥ n * )                                          |
| n ; de √©simo se n√£o if K > n . K q -1 ent√£o n ‚Üê n . P q se n√£o in√≠cio procura no n√≥ n uma entrada i tal que n . K i-1 < K ‚â§ n.K i ; n ‚Üê n.P i                                                                                                                                                         |
| fim ; l√™ bloco n fim ; procura no bloco n uma entrada ( K , Pr ) com K                                                                                                                                                                                                                                |
| Algoritmo 18.3. Inserindo um registro com do campo de chave de pesquisa K em + ¬≠tree de ordem p ‚Üê bloco contendo n√≥ raiz da B + ¬≠tree;                                                                                                                                                                  |
| va¬≠ uma                                                                                                                                                                                                                                                                                                |
| bloco n ; define pilha S como vazia; ( n n√£o √© n√≥ folha da B + ¬≠tree) do in√≠cio coloca endere√ßo de n na pilha S ; ( * pilha S mant√©m n√≥s pai que s√£o rios no caso de divis√£o * ) q ‚Üê n√∫mero de ponteiros de √°rvore no n√≥ n se K ‚â§ n . K 1 ( * n.K i refere¬≠se ao i ¬≠√©simo do campo de pesquisa no n√≥ n ) |
| ; * ent√£o n ‚Üê n.P 1 ( * n.P i refere¬≠se ao i ponteiro de √°rvore no n√≥ n * )                                                                                                                                                                                                                            |
| necess√°¬≠ valor ¬≠√©simo se n√£o if K > n.K q -1                                                                                                                                                                                                                                                            |
| B n l√™                                                                                                                                                                                                                                                                                                |
| enquanto                                                                                                                                                                                                                                                                                              |
| lor                                                                                                                                                                                                                                                                                                   |
| ent√£o n ‚Üê n.P q                                                                                                                                                                                                                                                                                       |
| se n√£o in√≠cio                                                                                                                                                                                                                                                                                         |
| procura no n√≥ n uma entrada i tal que                                                                                                                                                                                                                                                                 |
| n.K < K ‚â§ n.K ;                                                                                                                                                                                                                                                                                       |

| l√™ bloco                                                                               | n                                                                                      |
|----------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------|
| fim ;                                                                                  | fim ;                                                                                  |
| procura no bloco n uma entrada ( K i , Pr i ) com K = K i ; ( * procura n√≥ folha n * ) | procura no bloco n uma entrada ( K i , Pr i ) com K = K i ; ( * procura n√≥ folha n * ) |
| se encontrado                                                                          | se encontrado                                                                          |
| ent√£o registro j√° no arquivo; n√£o pode inserir                                         | ent√£o registro j√° no arquivo; n√£o pode inserir                                         |
| se n√£o ( * insere registro na B + ¬≠tree para apontar                                    | se n√£o ( * insere registro na B + ¬≠tree para apontar                                    |
| para registro * )                                                                      | para registro * )                                                                      |
| in√≠cio                                                                                 | in√≠cio                                                                                 |
| se n√≥ folha n n√£o est√° cheio                                                           | se n√≥ folha n n√£o est√° cheio                                                           |
| ent√£o insere entrada ( K , Pr ) na posi√ß√£o                                             | ent√£o insere entrada ( K , Pr ) na posi√ß√£o                                             |
| correta no n√≥ folha n                                                                  | correta no n√≥ folha n                                                                  |
| se n√£o in√≠cio ( * n√≥ folha n est√° cheio com                                            | se n√£o in√≠cio ( * n√≥ folha n est√° cheio com                                            |
| ponteiros de registro p folha ; √© dividido * )                                         | ponteiros de registro p folha ; √© dividido * )                                         |
| copia n para temp ( * temp √© um n√≥ folha                                               | copia n para temp ( * temp √© um n√≥ folha                                               |
| maior para manter entradas extras * );                                                 | maior para manter entradas extras * );                                                 |
| insere entrada ( K , Pr ) em temp na posi¬≠                                              | insere entrada ( K , Pr ) em temp na posi¬≠                                              |
| √ß√£o correta;                                                                           | √ß√£o correta;                                                                           |
| ( * temp agora mant√©m p folha + 1 entradas                                             | ( * temp agora mant√©m p folha + 1 entradas                                             |
| new ‚Üê um novo n√≥ folha vazio para a √°rvore; new.P ‚Üê n.P ;                              | new ‚Üê um novo n√≥ folha vazio para a √°rvore; new.P ‚Üê n.P ;                              |
| pr√≥ximo pr√≥ximo j ‚Üê Ô£Æ ( p folha + 1)/2 Ô£π ;                                             | pr√≥ximo pr√≥ximo j ‚Üê Ô£Æ ( p folha + 1)/2 Ô£π ;                                             |
| n ‚Üê primeiras j entradas em temp (at√© entrada ( K , Pr )); n . P ‚Üê new ;               | n ‚Üê primeiras j entradas em temp (at√© entrada ( K , Pr )); n . P ‚Üê new ;               |
| j j pr√≥ximo                                                                            | j j pr√≥ximo                                                                            |
| new ‚Üê entradas restantes em temp ; K                                                   | new ‚Üê entradas restantes em temp ; K                                                   |
| ‚Üê K j ; ( * agora temos de mover ( K , new ) e inse¬≠                                    | ‚Üê K j ; ( * agora temos de mover ( K , new ) e inse¬≠                                    |
| rir no n√≥ interno pai;                                                                 | rir no n√≥ interno pai;                                                                 |
| por√©m, se o pai estiver cheio, a divis√£o                                               | por√©m, se o pai estiver cheio, a divis√£o                                               |
| pode se propagar * )                                                                   | pode se propagar * )                                                                   |
| finished ‚Üê false;                                                                      | finished ‚Üê false;                                                                      |
| repita                                                                                 | repita                                                                                 |
| se pilha S est√° vazia                                                                  | se pilha S est√° vazia                                                                  |
| ent√£o ( * nenhum n√≥ pai; novo n√≥ raiz √© criado para a √°rvore * )                       | ent√£o ( * nenhum n√≥ pai; novo n√≥ raiz √© criado para a √°rvore * )                       |
| in√≠cio                                                                                 | in√≠cio                                                                                 |
| root ‚Üê um novo n√≥ interno vazio                                                        | root ‚Üê um novo n√≥ interno vazio                                                        |
| para a √°rvore;                                                                         | para a √°rvore;                                                                         |
| root ‚Üê < n , K , new >; finished ‚Üê                                                     | root ‚Üê < n , K , new >; finished ‚Üê                                                     |
| true;                                                                                  | true;                                                                                  |
| fim                                                                                    | fim                                                                                    |
| se n√£o in√≠cio                                                                          | se n√£o in√≠cio                                                                          |
| n ‚Üê remove da pilha S ;                                                                | n ‚Üê remove da pilha S ;                                                                |
| se n√≥ interno n n√£o est√° cheio                                                         | se n√≥ interno n n√£o est√° cheio                                                         |
| ent√£o                                                                                  | ent√£o                                                                                  |
| in√≠cio ( * n√≥ pai n√£o n√£o divide )                                                     | in√≠cio ( * n√≥ pai n√£o n√£o divide )                                                     |
| cheio; *                                                                               | cheio; *                                                                               |
| insere ( K , new ) na posi√ß√£o                                                          | insere ( K , new ) na posi√ß√£o                                                          |

correta no n√≥ interno n ;

finished ‚Üê true fim se n√£o in√≠cio ( * n√≥ interno n est√° cheio  com  ponteiros  de  √°rvore p ;

condi√ß√£o de overflow; n√≥ √© di¬≠ vidido ) *

copia n para temp ( * temp √© um n√≥ interno maior ); *

insere ( K new , ) em temp na po¬≠ si√ß√£o correta;

( * temp agora tem p + 1 pontei¬≠ ros de √°rvore ) *

new ‚Üê um novo n√≥ interno va¬≠ zio para a √°rvore;

j ‚Üê (( p + 1)/2 ;

n ‚Üê entradas at√© o ponteiro de √°rvore P j em temp ;

( * n cont√©m  &lt; P 1 , K 1 , P 2 , K 2 ,  ..., P j -1 , K j -1 , P j &gt; ) *

new ‚Üê entradas at√© o ponteiro de √°rvore P j +1 em temp ;

( * new cont√©m  &lt; P j +1 , K j +1 , ..., K p -1 , P p , K p , P p +1 &gt; ) * K ‚Üê K j

( * agora temos  de mover  ( K , new ) e  inserir  no  n√≥  interno pai ) *

fim fim until terminado

fim ;

fim ;

A Figura 18.12 ilustra a inser√ß√£o de registros em uma B + ¬≠tree de ordem p = 3 e p folha = 2. Primeiro, ob¬≠ servamos que a raiz √© o √∫nico n√≥ na √°rvore, de modo que tamb√©m √© um n√≥ folha. Assim que mais de um n√≠vel √© criado, a √°rvore √© dividida em n√≥s internos e n√≥s folha. Observe que cada valor de chave precisa existir no n√≠vel de folha , pois todos os ponteiros de dados  est√£o  no  n√≠vel  de  folha.  Contudo,  somente alguns valores existem nos n√≥s internos para guiar a pesquisa. Observe tamb√©m que cada valor que apa¬≠ rece em um n√≥ interno tamb√©m aparece como o valor mais √† direita no n√≠vel de folha da sub√°rvore aponta¬≠ da pelo ponteiro de √°rvore √† esquerda do valor.

original s√£o mantidas l√°, e as entradas restantes s√£o movidas para um novo n√≥ folha. O  ¬≠√©simo valor de j pesquisa √© replicado no n√≥ interno pai, e um ponteiro extra para o novo n√≥ √© criado no pai. Estes precisam ser inseridos no n√≥ pai em sua sequ√™ncia correta. Se o n√≥ interno pai estiver cheio, o novo valor far√° que ele estoure tamb√©m, de modo que precisar√° ser dividido. As entradas no n√≥ interno at√© P j - o  ¬≠√©simo ponteiro j de √°rvore ap√≥s inserir o novo valor e ponteiro, onde j =  (( Ô£∞ p + 1)/2)  - s√£o mantidas, enquanto o  ¬≠√©simo Ô£ª j valor de pesquisa √© movido para o pai, n√£o replicado. Um novo n√≥ interno manter√° as entradas de P j +1 para o final das entradas no n√≥ (ver Algoritmo 18.3). Essa divis√£o pode se propagar para cima at√© criar um novo n√≥ raiz e, portanto, um novo n√≠vel para a B + ¬≠tree.

A Figura 18.13 ilustra a exclus√£o de uma B + ¬≠tree. Quando uma entrada √© exclu√≠da, ela sempre √© remo¬≠ vida do n√≠vel folha. Se ocorrer em um n√≥ interno, ela tamb√©m precisa ser removida de l√°. No √∫ltimo caso, o valor √† sua esquerda no n√≥ folha precisa substitu√≠¬≠ ¬≠lo  no n√≥ interno, pois esse valor agora √© a entrada mais √† direita na sub√°rvore. A exclus√£o pode causar underflow , reduzindo o n√∫mero de entradas no n√≥ fo¬≠ lha abaixo do m√≠nimo exigido. Nesse caso, tentamos encontrar um n√≥ folha irm√£o - um n√≥ folha direta¬≠ mente √† esquerda ou √† direita do n√≥ com underflow - e redistribuir as entradas entre o n√≥ e seu irm√£o , de modo que ambos estejam pelo menos cheios pela metade. Caso contr√°rio, o n√≥ √© mesclado com seus ir¬≠ m√£os e o n√∫mero de n√≥s folha √© reduzido. Um m√©todo comum √© tentar redistribuir entradas com o irm√£o da esquerda; se isso n√£o for poss√≠vel, √© feita uma tenta¬≠ tiva para redistribuir com o irm√£o da direita. Se isso tamb√©m n√£o for poss√≠vel, os tr√™s n√≥s s√£o mesclados em dois n√≥s folha. Nesse caso, o underflow pode se pro¬≠ pagar para n√≥s internos , porque s√£o necess√°rios me¬≠ nos ponteiro de √°rvore e valor de pesquisa. Isso pode propagar e reduzir os n√≠veis da √°rvore.

Observe que a implementa√ß√£o dos algoritmos de inser√ß√£o e exclus√£o pode exigir ponteiros pai e irm√£o para cada n√≥, ou o uso de uma pilha, como no Algo¬≠ ritmo 18.3. Cada n√≥ tamb√©m deve incluir o n√∫mero de entradas nele e seu tipo (folha ou interno). Uma alternativa  √©  implementar  a  inser√ß√£o  e  a  exclus√£o como procedimentos recursivos. 11

Quando um n√≥ folha est√° cheio e uma nova en¬≠ trada √© inserida l√°,  ele estoura e  precisa  ser  dividi¬≠ do. As primeiras entradas   =  (( j Ô£Æ p folha +  1)/2)   no  n√≥ Ô£π

Varia√ß√µes das B-trees e B + -trees. Para concluir esta se√ß√£o, mencionamos rapidamente algumas varia√ß√µes das B¬≠trees e B ¬≠trees. Em alguns casos, a restri√ß√£o 5 na + B¬≠tree (ou para os n√≥s internos da B + ¬≠tree, exceto o n√≥ raiz), que exige que cada n√≥ esteja cheio pelo menos pela metade, pode ser alterada para exigir que cada n√≥ esteja pelo menos dois ter√ßos cheio. Nesse caso, a

11 Para obter mais detalhes sobre algoritmos de inser√ß√£o e exclus√£o para B -trees, consulte Ramakrishnan e Gehrke (2003). +

## Sequ≈íncia de inser√ß¬™o: 8, 5, 1, 7, 3, 12, 9, 6



Figura 18.12 Exemplo de uma inser√ß√£o em uma B -tree com + p = 3 e p folha = 2.

B¬≠tree √© chamada de B -tree * . Em geral, alguns sistemas permitem que o usu√°rio escolha um fator de preenchimento entre 0,5 e 1,0, no qual o √∫ltimo significa que os n√≥s da B¬≠tree (√≠ndice) devem estar completamente cheios. Tamb√©m √© poss√≠vel especificar dois fatores de preenchimento para uma B + ¬≠tree: um para o n√≠vel fo¬≠ lha e um para os n√≥s internos da √°rvore. Quando o √≠ndice √© constru√≠do inicialmente, cada n√≥ √© preenchido at√© aproximadamente os fatores de preenchimento es¬≠ pecificados. Alguns investigadores sugeriram relaxar o requisito de que um n√≥ esteja cheio pela metade, e, em vez disso, permitir que um n√≥ se torne completamente vazio antes da mesclagem, para simplificar o algorit¬≠ mo de exclus√£o. Estudos de simula√ß√£o mostram que isso n√£o desperdi√ßa muito espa√ßo adicional sob inser¬≠ √ß√µes e exclus√µes distribu√≠das aleatoriamente.

Sequ≈íncia de exclus¬™o: 5, 12, 9



## Figura 18.13

Um exemplo de exclus√£o de uma B -tree. +

## 18.4 ndices em m√∫ltiplas chaves √ç

Em nossa discuss√£o at√© aqui, consideramos que as chaves prim√°ria ou secund√°ria nas quais os arqui¬≠ vos eram acessados eram atributos (campos) √∫nicos. Em muitas solicita√ß√µes de recupera√ß√£o e atualiza√ß√£o, v√°rios atributos s√£o envolvidos. Se certa combina√ß√£o de atributos for usada com frequ√™ncia, √© vantajoso configurar  uma  estrutura  de  acesso  para  oferecer acesso eficaz por um valor de chave que √© uma com¬≠ bina√ß√£o desses atributos.

Por exemplo, considere um arquivo FUNCIONA -RIO com os atributos Dnr (n√∫mero de departamen¬≠ to), Idade, Endereco, Cidade, Cep, Salario e Cod\_car -go, com a chave Cpf (n√∫mero do Cadastro de Pessoa F√≠sica). Considere a consulta: listar os funcion√°rios no  departamento  n√∫mero  4  cuja  idade  √©  59 .  Ob¬≠ serve que tanto Dnr quanto Idade s√£o atributos n√£o chave, o que significa que um valor de pesquisa para um deles apontar√° para v√°rios registros. As estra¬≠ t√©gias  de  pesquisa  alternativas  a  seguir  podem  ser consideradas:

- 1. Supondo que Dnr tenha um √≠ndice, mas Idade n√£o, acesse os registros com Dnr = 4 usando o √≠ndice, e depois selecione entre eles aqueles registros que satisfazem Idade = 59.
- 2. Como alternativa, se Idade for indexada, mas Dnr n√£o, acesse os registros com Idade = 59 usando o √≠ndice, e depois selecione entre eles aqueles registros que satisfazem Dnr = 4.

- 3. Se os √≠ndices tiverem sido criados sobre Dnr e Idade, os dois √≠ndices podem ser usados; cada um d√° um conjunto de registros ou um con¬≠ junto de ponteiros (para blocos ou registros). Uma interse√ß√£o desses conjuntos de registros ou ponteiros gera aqueles registros ou pontei¬≠ ros que satisfazem ambas as condi√ß√µes.

Todas essas alternativas por fim geram o resulta¬≠ do correto. Contudo, se o conjunto de registros que atendem a cada condi√ß√£o ( Dnr =  4  ou Idade =  59) individualmente  for  grande,  embora  apenas  alguns registros satisfa√ßam a condi√ß√£o combinada, ent√£o ne¬≠ nhuma das t√©cnicas anteriores √© uma t√©cnica eficiente para a solicita√ß√£o de pesquisa indicada. Diversas pos¬≠ sibilidades existem para tratar da combina√ß√£o &lt; Dnr, Idade &gt; ou &lt; Idade, Dnr &gt; como uma chave de pesqui¬≠ sa composta de v√°rios atributos. Esbo√ßaremos essas t√©cnicas  rapidamente  nas  pr√≥ximas  se√ß√µes.  Vamos nos referir √†s chaves que cont√©m m√∫ltiplos atributos como chaves compostas .

## 18.4.1 ndice ordenado em m√∫ltiplos √ç atributos

Toda a discuss√£o neste cap√≠tulo at√© aqui se aplica se criarmos um √≠ndice em um campo de chave que √© uma combina√ß√£o de &lt; Dnr , Idade &gt;. A chave de pesqui¬≠ sa √© um par de valores &lt;4, 59&gt; no exemplo dado. Em geral, se um √≠ndice for criado nos atributos &lt; A 1 , A 2 , ..., A n &gt;, os valores de chave de pesquisa s√£o tuplas com n valores: &lt; v 1 , v 2 , ..., v n &gt;.

Uma ordena√ß√£o lexicogr√°fica desses valores de tupla estabelece uma ordem nessa chave de pesquisa composta. Para nosso exemplo, todas as chaves de departamento para o departamento n√∫mero 3 prece¬≠ dem aquelas para o departamento n√∫mero 4. Assim, &lt;3, n &gt; precede &lt;4, m &gt; para quaisquer valores de m e n . A ordem de chave crescente para as chaves com Dnr = 4 seria &lt;4, 18&gt;, &lt;4, 19&gt;, &lt;4, 20&gt;, e assim por diante. A ordena√ß√£o lexicogr√°fica funciona de modo semelhante √† ordena√ß√£o de strings de caracteres. Um √≠ndice em uma chave composta de n atributos funcio¬≠ na de modo semelhante a qualquer √≠ndice discutido at√© aqui neste cap√≠tulo.

## 18.4.2 Hashing particionado

O  hashing  particionado  √©  uma  extens√£o  do hashing externo est√°tico (Se√ß√£o 17.8.2), que permite o acesso em m√∫ltiplas chaves. Ele √© adequado apenas para compara√ß√µes de igualdade; consultas de interva¬≠ lo n√£o s√£o admitidas. No hashing particionado, para uma chave consistindo em n componentes, a fun√ß√£o de hash √© projetada para produzir um resultado com n endere√ßos de hash separados. O endere√ßo do bucket √© uma concatena√ß√£o desses n endere√ßos. Ent√£o, √© poss√≠¬≠ vel procurar a chave de pesquisa composta exigida ao examinar os buckets apropriados, que correspondem √†s partes do endere√ßo em que estamos interessados.

Por exemplo, considere a chave de pesquisa com¬≠ posta &lt; Dnr, Idade &gt;. Se Dnr e Idade s√£o um hash para um endere√ßo de 3 bits e 5 bits, respectivamente, ob¬≠ temos um endere√ßo de bucket de 8 bits. Suponha que Dnr = 4 tenha um endere√ßo de hash '100' e Idade = 59 tenha endere√ßo de hash '10101'. Ent√£o, para procu¬≠ rar o valor de pesquisa combinado, Dnr = 4 e Idade = 59, temos de ir ao endere√ßo de bucket 100 10101; s√≥ para procurar todos os funcion√°rios com Idade = 59, ser√£o pesquisados todos os buckets (oito deles) cujos endere√ßos s√£o '000 10101', '001 10101', ..., e assim por diante. Uma vantagem do hashing particionado √© que ele pode ser facilmente estendido para qualquer n√∫mero de atributos. Os endere√ßos de bucket podem ser atribu√≠dos de modo que os bits de alta ordem nos endere√ßos  correspondam  a  atributos  acessados  mais frequentemente.  Al√©m  disso,  nenhuma  estrutura  de acesso separada precisa ser mantida para os atributos individuais. A principal desvantagem do hashing par¬≠ ticionado √© que ele n√£o pode lidar com consultas de in¬≠ tervalo em qualquer um dos atributos de componente.

## 18.4.3 Arquivos de grade

Uma alternativa √© organizar o arquivo FUNCIO -NARIO como  um  arquivo  de  grade.  Se  quisermos acessar um arquivo em duas chaves, digamos, Dnr e Idade , como em nosso exemplo, podemos construir um vetor de grade com uma escala (ou dimens√£o) linear para cada um dos atributos de pesquisa. A Fi¬≠ gura 18.14 mostra um vetor de grade para o arqui¬≠ vo FUNCIONARIO com uma escala linear para Dnr e outra para o atributo Idade . As escalas s√£o feitas de modo a alcan√ßar  uma  distribui√ß√£o  uniforme  desse atributo. Assim, em nosso exemplo, mostramos que a  escala  linear  para Dnr tem Dnr =  1,  2  combina¬≠ do como um valor 0 na escala, enquanto Dnr =  5 corresponde ao valor 2 nessa escala. De modo se¬≠ melhante, Idade √©  dividido  em sua escala de 0 a 5 ao agrupar idades de modo a distribuir os funcio¬≠ n√°rios  uniformemente. O vetor de grade mostrado para esse arquivo tem um total de 36 c√©lulas. Cada c√©lula aponta para algum endere√ßo de bucket onde os registros correspondentes a essa c√©lula s√£o armazena¬≠ dos. A Figura 18.14 tamb√©m mostra a atribui√ß√£o de c√©lulas a buckets (apenas de maneira parcial).

Assim, nossa solicita√ß√£o para Dnr = 4 e Idade = 59 √© mapeada para a c√©lula (1, 5) correspondente ao vetor de grade. Os registros para essa combina√ß√£o ser√£o encon¬≠

|   Dnr 0 | 1, 2   |
|---------|--------|
|       1 | 3, 4   |
|       2 | 5      |
|       3 | 6, 7   |
|       4 | 8      |
|       5 | 9, 10  |

| 0    | 1     | 2     | 3     | 4     | 5    |
|------|-------|-------|-------|-------|------|
| < 20 | 21-25 | 26-30 | 31-40 | 41-50 | > 50 |



Figura 18.14 Exemplo de um vetor de grade nos atributos Dnr e Idade.

trados no bucket correspondente. Esse m√©todo √© parti¬≠ cularmente √∫til para consultas de intervalo que seriam mapeadas para um conjunto de c√©lulas correspondente a um grupo de valores ao longo de escalas lineares. Se uma consulta de intervalo corresponde a uma combi¬≠ na√ß√£o em algumas das c√©lulas de grade, ela pode ser processada acessando exatamente os buckets para essas c√©lulas de grade. Por exemplo, uma consulta para Dnr ‚â§ 5 e Idade &gt; 40 refere¬≠se aos dados no bucket topo mos¬≠ trado na Figura 18.14. O conceito de arquivo de grade pode ser aplicado a qualquer quantidade de chaves de pesquisa. Por exemplo, para n chaves de pesquisa, o ve¬≠ tor de grade teria n dimens√µes. O vetor de grade, assim, permite um particionamento do arquivo ao longo das dimens√µes dos atributos de chave e oferece um acesso por combina√ß√µes de valores ao longo dessas dimens√µes. Os arquivos de grade funcionam bem em rela√ß√£o √† re¬≠ du√ß√£o no tempo para o acesso com m√∫ltiplas chaves. Contudo, eles representam um overhead de espa√ßo em mat√©ria de estrutura de vetor de grade. Al√©m do mais, com arquivos din√¢micos, uma reorganiza√ß√£o frequente do arquivo aumenta o custo de manuten√ß√£o. 12

## 18.5 Outros tipos de √≠ndices

## 18.5.1 ndices de hash √ç

Tamb√©m √© poss√≠vel criar estruturas de acesso se¬≠ melhantes aos √≠ndices que s√£o baseados no hashing . O √≠ndice de hash √© uma estrutura secund√°ria para acessar o arquivo usando hashing em uma chave de pesquisa diferente da que √© usada para a organiza√ß√£o do arqui¬≠ vo de dados prim√°rio. As entradas de √≠ndice s√£o do tipo &lt; K Pr , &gt; ou &lt; K P , &gt;, onde Pr √© um ponteiro para o registro que cont√©m a chave, ou P √©  um  ponteiro para o bloco que cont√©m o registro para essa chave. O arquivo de √≠ndice com essas entradas pode ser orga¬≠ nizado como um arquivo de hash dinamicamente ex¬≠ pans√≠vel, usando uma das t√©cnicas descritas na Se√ß√£o 17.8.3.  A  pesquisa  por  uma  entrada  usa  o  algorit¬≠ mo de pesquisa de hash em K . Quando uma entrada √©  localizada,  o  ponteiro Pr (ou P )  √©  utilizado  para localizar  o  registro  correspondente  no  arquivo  de dados. A Figura 18.15 ilustra um √≠ndice de hash no campo Func\_id para um arquivo que foi armazenado como um arquivo sequencial, ordenado por Nome . O Func\_id passa pelo hashing para obter um n√∫mero de bucket usando a fun√ß√£o de hashing: a soma dos d√≠gitos de Func\_id m√≥dulo 10. Por exemplo, para en¬≠ contrar o Func\_id 51024, a fun√ß√£o de hash resulta no n√∫mero de bucket 2; esse bucket √© acessado pri¬≠ meiro. Ele cont√©m a entrada de √≠ndice &lt; 51024, Pr &gt;; o ponteiro Pr nos leva ao registro real no arquivo. Em uma aplica√ß√£o pr√°tica, pode haver milhares de buckets;  o  n√∫mero  do  bucket,  que  pode  ter  v√°rios bits de extens√£o, estaria sujeito aos esquemas de di¬≠ ret√≥rio discutidos a respeito do hashing din√¢mico, na Se√ß√£o 17.8.3. Outras estruturas de pesquisa tamb√©m podem ser usadas como √≠ndices.

## 18.5.2 ndices bitmap √ç

O √≠ndice bitmap √© outra estrutura de dados po¬≠ pular que facilita a consulta em m√∫ltiplas chaves. A indexa√ß√£o bitmap √© usada para rela√ß√µes que cont√™m um grande n√∫mero de linhas. Ela cria um √≠ndice para uma ou mais colunas, e cada valor ou intervalo de valores  nessas  colunas  √©  indexado.  Normalmente, um √≠ndice bitmap √© criado para aquelas colunas que cont√™m um n√∫mero muito pequeno de valores √∫ni¬≠ cos. Para criar um √≠ndice bitmap em um conjunto de

12 Algoritmos de inser√ß√£o/exclus√£o para arquivos de grade podem ser encontrados em Nievergelt et al. (1984).

registros em uma rela√ß√£o, os registros precisam ser numerados de 0 a n com um id (um id de registro ou um id de linha) que pode ser mapeado para um en¬≠ dere√ßo f√≠sico composto de um n√∫mero de bloco e um deslocamento de registro dentro do bloco.

- ¬Ñ Para a consulta C 1 = V 1 , o bitmap correspon¬≠ dente para o valor V 1 retorna os Linha\_id con¬≠ tendo as linhas que qualificam.

Um √≠ndice bitmap √© criado em um valor espec√≠fico de um campo em particular (a coluna em uma rela√ß√£o) e √© apenas um vetor de bits. Considere um √≠ndice bit¬≠ map para a coluna C e um valor V para essa coluna. Para uma rela√ß√£o com n linhas, ele cont√©m n bits. O i ¬≠√©simo bit √© definido como 1 se a linha   tiver o valor i V para a coluna C ; caso contr√°rio, ele √© definido como 0. Se C contiver o conjunto de valores &lt; v 1 , v 2 , ..., v m &gt; com m valores distintos, ent√£o m √≠ndices bitmap se¬≠ riam criados para essa coluna. A Figura 18.16 mostra a rela√ß√£o FUNCIONARIO com colunas Func\_id, Unome, Sexo, Cep e Faixa\_salarial (com  apenas  8  linhas  por ilustra√ß√£o) e um √≠ndice bitmap para as colunas Sexo e Cep . Como um exemplo, se o bitmap para Sexo = F, os bits para Linha\_id 1, 3, 4 e 7 s√£o definidos como 1, e o restante dos bits √© definido como 0, os √≠ndices bitmap poderiam ter as seguintes aplica√ß√µes de consulta:

- ¬Ñ Para a consulta C 1 = V 1 e C 2 = V 2 (uma soli¬≠ cita√ß√£o de pesquisa de m√∫ltiplas chaves), os dois  bitmaps  correspondentes  s√£o  recupera¬≠ dos e passam por uma interse√ß√£o (AND l√≥¬≠ gico) para gerar o conjunto de Linha\_id que qualificam. Em geral, k vetores de bits podem passar por interse√ß√£o para lidar com k condi¬≠ √ß√µes de igualdade. Condi√ß√µes AND¬≠OR com¬≠ plexas tamb√©m podem ser admitidas usando a indexa√ß√£o bitmap.
- ¬Ñ Para recuperar uma contagem das linhas que se qualificam para a condi√ß√£o C 1 = V 1 , as en¬≠ tradas '1' no vetor de bits correspondente s√£o contadas.
- ¬Ñ As consultas com nega√ß√£o, como C 1 ¬¨ = V 1 , podem ser tratadas ao aplicar¬≠se a opera√ß√£o de complemento booleano no bitmap corres¬≠ pondente.

Indexa√ß√£o baseada em hash.



| Bucket 0                                  | Id_funcionario                                                                | Ultimo_nome                                                                      | Sexo   | ./nobreakspace ./nobreakspace . . .   |
|-------------------------------------------|-------------------------------------------------------------------------------|----------------------------------------------------------------------------------|--------|---------------------------------------|
| 13646                                     | ./nobreakspace ./nobreakspace . . .                                           | ./nobreakspace ./nobreakspace . . .                                              |        |                                       |
| 21124                                     | 12676                                                                         | Marcus                                                                           | M      | . .                                   |
| ./nobreakspace ./nobreakspace . . .       | ./nobreakspace ./nobreakspace . . . 13646                                     | ./nobreakspace ./nobreakspace . . . Hamilton M                                   |        | . .                                   |
| Bucket 1                                  | ./nobreakspace ./nobreakspace . . . 21124 ./nobreakspace ./nobreakspace . . . | ./nobreakspace ./nobreakspace . . . Donato M ./nobreakspace ./nobreakspace . . . |        | . .                                   |
| 81165 ./nobreakspace ./nobreakspace . . . | 23402 ./nobreakspace ./nobreakspace . . .                                     | Pires ./nobreakspace ./nobreakspace . . .                                        | F      | . .                                   |
| Bucket 2                                  | 34723 ./nobreakspace ./nobreakspace . . .                                     | Fernandes ./nobreakspace ./nobreakspace . . .                                    | F      | . .                                   |
| 51024 12676                               | 41301 ./nobreakspace ./nobreakspace . . .                                     | Zara ./nobreakspace ./nobreakspace . . .                                         | F      | . .                                   |
| ./nobreakspace ./nobreakspace . . .       | 51024 ./nobreakspace ./nobreakspace . . .                                     | Braga M                                                                          |        | . .                                   |
| Bucket                                    | 62104                                                                         | ./nobreakspace ./nobreakspace . . .                                              |        | . .                                   |
| 3 62104                                   | ./nobreakspace ./nobreakspace . . .                                           | ./nobreakspace ./nobreakspace . . .                                              |        |                                       |
|                                           |                                                                               | Brito M                                                                          |        |                                       |
| 71221                                     | ./nobreakspace ./nobreakspace . . .                                           | Antunes F                                                                        |        | . .                                   |
| ./nobreakspace ./nobreakspace . . .       | 71221                                                                         | ./nobreakspace ./nobreakspace . . .                                              |        |                                       |
|                                           | ./nobreakspace ./nobreakspace . . .                                           | Gouveia                                                                          |        | . .                                   |
|                                           | 81165                                                                         |                                                                                  |        |                                       |
| Bucket 9                                  |                                                                               |                                                                                  |        |                                       |
| 34723                                     |                                                                               |                                                                                  |        |                                       |
| 41301                                     |                                                                               |                                                                                  |        |                                       |
| ./nobreakspace ./nobreakspace . . .       |                                                                               |                                                                                  |        |                                       |
|                                           |                                                                               | F                                                                                |        |                                       |
|                                           |                                                                               | ./nobreakspace ./nobreakspace . . .                                              |        |                                       |

## Funcionario

|   Linha_id |   Func_id | Unome     | Sexo   |      Cep | Faixa_salarial   |
|------------|-----------|-----------|--------|----------|------------------|
|          0 |     51024 | Braga     | M      | 09404011 | ..               |
|          1 |     23402 | Pires     | F      | 03002211 | ..               |
|          2 |     62104 | Brito     | M      | 01904611 | ..               |
|          3 |     34723 | Fernandes | F      | 03002211 | ..               |
|          4 |     81165 | Gouveia   | F      | 01904611 | ..               |
|          5 |     13646 | Hamilton  | M      | 01904611 | ..               |
|          6 |     12676 | Marcus    | M      | 03002211 | ..               |
|          7 |     41301 | Zara      | F      | 09404011 | ..               |

## √çndice bitmap para Sexo

M

F

10100110

01011001

| √çndice bitmap para Cep   | √çndice bitmap para Cep   | √çndice bitmap para Cep   |
|--------------------------|--------------------------|--------------------------|
| Cep 01904655             | Cep 03002211             | Cep 09409433             |
| 00101100                 | 01010010                 | 100000001                |

Figura 18.16

√çndices bitmap para Sexo e Cep.

Considere  o  exemplo  da  Figura  18.16.  Para encontrar  funcion√°rios  com Sexo =  F  e Cep = 30022512345, realizamos a interse√ß√£o dos bitmaps '01011001'  e  '01010010',  resultando  nos Linha\_id 1  e  3.  Os  funcion√°rios  que  n√£o  moram  no Cep = 09404066 s√£o obtidos pelo complemento do vetor de  bits  '10000001',  produzindo Linha\_id de  1  a  6. Em geral, se considerarmos a distribui√ß√£o uniforme dos valores para determinada coluna, e se uma co¬≠ luna tiver cinco valores distintos e outra tiver dez valores distintos, a condi√ß√£o de jun√ß√£o nessas duas pode ser considerada como tendo uma seletivida¬≠ de de 1/50 (=1/5 * 1/10). Logo, cerca de dois por cento desses registros realmente teriam de ser recu¬≠ perados. Se uma coluna tem apenas alguns valores, como a coluna Sexo na Figura 18.16, a recupera¬≠ √ß√£o da condi√ß√£o Sexo = M na m√©dia recuperaria 50  por  cento  das  linhas.  Nesses  casos,  √©  melhor realizar uma varredura completa, em vez de usar a indexa√ß√£o bitmap.

Em geral, os √≠ndices bitmap s√£o eficientes em re¬≠ la√ß√£o ao espa√ßo de armazenamento de que eles pre¬≠ cisam. Se considerarmos um arquivo de 1 milh√£o de linhas (registros) com tamanho de registro de 100 bytes por linha, cada √≠ndice bitmap ocuparia apenas um bit  por  linha  e,  portanto,  usaria  1  milh√£o  de bits ou 125 Kbytes. Suponha que essa rela√ß√£o seja para um milh√£o de residentes de um estado, e eles estejam espalhados por 200 Ceps. Os 200 bitmaps em Cep s contribuem com 200 bits (ou 25 bytes) de espa√ßo por linha; logo, os 200 bitmaps ocupam ape¬≠

nas 25 por cento do espa√ßo ocupado pelo arquivo de dados. Eles permitem uma recupera√ß√£o exata de todos os residentes que moram em determinado Cep produzindo a Linha\_id .

Quando registros s√£o exclu√≠dos, a renumera√ß√£o de linhas e o deslocamento de bits nos bitmaps tor¬≠ nam¬≠se dispendiosos. Outro bitmap, chamado bitmap de exist√™ncia , pode ser usado para evitar esse gasto. Esse bitmap tem um bit 0 para as linhas que foram  exclu√≠das  mas  ainda  est√£o  presentes,  e  um bit 1 para as linhas que realmente existem. Sempre que uma linha for inserida na rela√ß√£o, uma entrada precisa ser criada em todos os bitmaps de todas as colunas que t√™m um √≠ndice bitmap. As linhas cos¬≠ tumam ser acrescentadas √† rela√ß√£o ou podem subs¬≠ tituir as linhas exclu√≠das. Esse processo representa um overhead de indexa√ß√£o.

Vetores de bits grandes s√£o manipulados tratan¬≠ do¬≠os como uma s√©rie de vetores de 32 ou 64 bits, e operadores AND, OR e NOT correspondentes s√£o usados com base no conjunto de instru√ß√µes para li¬≠ dar com vetores de entrada de 32 ou 64 bits em uma √∫nica instru√ß√£o. Isso torna as opera√ß√µes com vetor de bits computacionalmente muito eficientes.

Bitmaps para n√≥s folha de B + -tree. Os bitmaps po¬≠ dem ser usados nos n√≥s folha dos √≠ndices de B + ¬≠tree, bem como para apontar para o conjunto de registros que cont√™m cada valor espec√≠fico do campo indexado no n√≥ folha. Quando a B + ¬≠tree est√° embutida em um campo de pesquisa n√£o chave, o registro de folha pre¬≠ cisa conter uma lista de ponteiros de registro ao longo de cada valor do atributo indexado. Para valores que ocorrem com muita frequ√™ncia, ou seja, em uma gran¬≠ de porcentagem da rela√ß√£o, um √≠ndice bitmap pode ser armazenado em vez dos ponteiros. Como um exemplo, para uma rela√ß√£o com n linhas, suponha que um valor ocorra em 10 por cento dos registros de arquivo. Um vetor de bits teria n bits, com o bit '1' para as Linha\_id que cont√™m esse valor de pesquisa, que √© n /8 ou 0,125 n bytes em tamanho. Se o ponteiro de registro ocupar 4 bytes (32 bits), ent√£o os n /10 ponteiros de registro ocu¬≠ pariam 4 * n /10 ou 0,4 n bytes. Como 0,4 n √© mais de tr√™s vezes maior que 0,125 n , √© melhor armazenar o √≠ndice bitmap no lugar de ponteiros de registro. Logo, para valores de pesquisa que ocorrem com mais frequ√™ncia do que certa raz√£o (neste caso, seria 1/32), √© ben√©fico usar bitmaps como um mecanismo de armazenamento compactado para representar os ponteiros de registro em B + ¬≠trees que indexam um campo n√£o chave.

## 18.5.3 ndexa√ß√£o baseada em fun√ß√£o I

Nesta se√ß√£o, discutimos um novo tipo de indexa¬≠ √ß√£o, chamado indexa√ß√£o baseada em fun√ß√£o , que foi

introduzida no SGBD relacional Oracle, bem como em alguns outros produtos comerciais. 13

A ideia por tr√°s da indexa√ß√£o baseada em fun¬≠ √ß√£o √© criar um √≠ndice tal que o valor que resulta da aplica√ß√£o de alguma fun√ß√£o em um campo ou uma cole√ß√£o de campos torna¬≠se a chave para o √≠ndice. Os exemplos a seguir mostram como criar e usar √≠ndices baseados em fun√ß√£o.

Exemplo  1. A  instru√ß√£o  a  seguir  cria  um  √≠ndice baseado em fun√ß√£o sobre a tabela FUNCIONARIO com base em uma representa√ß√£o em mai√∫scula da coluna Unome ,  que  pode  ser  inserida  de  muitas maneiras, mas √© sempre consultada por sua repre¬≠ senta√ß√£o em mai√∫scula.

CREATE  INDEX  idx\_maiusc  ON  Funcionario (UPPER(Unome));

Essa  instru√ß√£o  criar√°  um  √≠ndice  com  base  na fun√ß√£o UPPER(Unome) , que retorna o sobrenome em letras mai√∫sculas; por exemplo, UPPER('Silva') retor¬≠ nar√° 'SILVA'.

Os √≠ndices baseados em fun√ß√£o garantem que o sis¬≠ tema Oracle Database usar√° o √≠ndice em vez de realizar uma varredura completa da tabela, mesmo quando uma fun√ß√£o √© usada no predicado de pesquisa de uma con¬≠ sulta. Por exemplo, a consulta a seguir usar√° o √≠ndice:

SELECT  Primeiro\_nome,  Unome FROM  Funcionario

WHERE  UPPER(Unome)=  'SILVA'.

Sem  o  √≠ndice  baseado  em  fun√ß√£o,  um  Oracle Database poderia realizar uma varredura completa da tabela, pois um √≠ndice de B + ¬≠tree s√≥ √© pesquisado pelo uso direto do valor da coluna; o uso de qual¬≠ quer  fun√ß√£o  em  uma  coluna  impede  que  tal  √≠ndice seja utilizado.

Exemplo 2. Neste exemplo, a tabela FUNCIONARIO supostamente cont√©m dois campos salario e pct\_ comissao (porcentagem de comiss√£o) - e um √≠ndice est√° sendo criado sobre a soma de salario e a comis¬≠ s√£o com base na pct\_comissao .

CREATE  INDEX  idx\_renda

ON  Funcionario(Salario  +  (Salario*pct\_Comissao));

A consulta a seguir usa o √≠ndice Idx\_renda embo¬≠ ra os campos salario e pct\_comissao estejam ocorren¬≠ do na ordem contr√°ria na consulta em compara√ß√£o com a defini√ß√£o do √≠ndice.

SELECT  Primeiro\_nome,  Unome FROM  Funcionario

13 Rafi Ahmed contribuiu com a maior parte desta se√ß√£o.

WHERE  ((Salario*pct\_Commissao)  +  Salario  ) &gt;  15.000;

Exemplo 3. Este  √©  um  exemplo mais avan√ßado do uso da indexa√ß√£o baseada em fun√ß√£o para definir a exclusividade condicional. A instru√ß√£o a seguir cria um √≠ndice √∫nico baseado em fun√ß√£o na tabela PEDI -DOS , que impede que um cliente tire proveito de um c√≥digo de promo√ß√£o mais de uma vez. Ele cria um √≠ndice composto nos campos Cod\_cliente e Cod\_pro -mocao juntos,  e  s√≥  permite  uma  entrada  no  √≠ndice para determinado Cod\_cliente com a Cod\_promocao de '2', declarando¬≠o como um √≠ndice √∫nico.

CREATE  UNIQUE  INDEX  idx\_promocao  ON Pedidos CASE    WHEN    Cod\_promocao    =    2    THEN ( Cod\_cliente  ELSE  NULL  END, CASE    WHEN    Cod\_promocao    =    2    THEN

Cod\_promocao  ELSE  NULL  END);

Observe que, usando a instru√ß√£o CASE ,  o  ob¬≠ jetivo √© remover do √≠ndice quaisquer linhas em que Cod\_promocao n√£o seja  igual  a  2.  O  Oracle  Data¬≠ base  n√£o  armazena  no  √≠ndice  da  B + ¬≠tree  quaisquer linhas em que todas as chaves s√£o NULL .  Portanto, neste exemplo, mapeamos tanto Cod\_cliente quanto Cod\_promocao para NULL , a menos que cod\_promo -cao seja igual a 2. O resultado √© que a restri√ß√£o de √≠ndice √© violada somente se Cod\_promocao for igual a 2, para duas (tentativas de inser√ß√£o de) linhas com o mesmo valor de Cod\_cliente.

## 18.6 Algumas quest√µes gerais referentes √† indexa√ß√£o

## 18.6.1 ndices l√≥gicos √ç versus f√≠sicos

Na discuss√£o anterior, consideramos que as en¬≠ tradas de √≠ndice &lt; K Pr , &gt; (ou &lt; K P , &gt;) sempre incluem um ponteiro f√≠sico Pr (ou P )  que especifica o ende¬≠ re√ßo do registro f√≠sico no disco como um n√∫mero de bloco e deslocamento. Este, √†s vezes, √© chamado de √≠ndice f√≠sico , e tem a desvantagem de o ponteiro precisar ser mudado se o registro for movimentado para outro local no disco. Por exemplo, suponha que uma organi¬≠ za√ß√£o de arquivo prim√°ria seja baseada no hashing li¬≠ near ou no hashing extens√≠vel. Ent√£o, toda vez que um bucket  for  dividido,  alguns  registros  ser√£o  alocados para novos buckets e, portanto, ter√£o novos endere√ßos f√≠sicos. Se houvesse um √≠ndice secund√°rio no arquivo, os ponteiros para esses registros teriam de ser locali¬≠ zados e atualizados, o que √© uma tarefa dif√≠cil.

Para solucionar essa situa√ß√£o, podemos usar uma estrutura chamada √≠ndice l√≥gico , cujas entradas de √≠n¬≠ dice t√™m a forma &lt; K K p , &gt;. Cada entrada tem um valor K para algum campo de √≠ndice secund√°rio combinado com o valor K p do campo usado para a organiza√ß√£o do  arquivo  prim√°rio.  Ao  pesquisar  o  √≠ndice  secun¬≠ d√°rio no valor de K ,  um programa pode localizar o valor  correspondente de K p e  usar  isso  para  acessar o registro pela organiza√ß√£o do arquivo prim√°rio. Os √≠ndices l√≥gicos, assim, introduzem um n√≠vel adicional de indire√ß√£o entre a estrutura de acesso e os dados. Eles s√£o usados quando se espera que os endere√ßos de registro f√≠sicos mudem com frequ√™ncia. O custo dessa indire√ß√£o √© a pesquisa extra baseada na organiza√ß√£o do arquivo prim√°rio.

## 18.6.2 Discuss√£o

Em muitos  sistemas,  um  √≠ndice  n√£o  faz  parte integral do arquivo de dados, mas pode ser criado e descartado dinamicamente. √â por isso que, em ge¬≠ ral, √© chamado de uma estrutura de acesso . Sempre que esperamos acessar um arquivo com frequ√™ncia com base em alguma condi√ß√£o de pesquisa envol¬≠ vendo um campo em particular, podemos solicitar que o SGBD crie um √≠ndice nesse campo. Normal¬≠ mente, um √≠ndice secund√°rio √© criado para evitar a ordena√ß√£o f√≠sica dos registros no arquivo de dados em disco.

A  principal  vantagem  dos  √≠ndices  secund√°rios  √© que - pelo menos, teoricamente - eles podem ser cria¬≠ dos junto com praticamente qualquer organiza√ß√£o de registro prim√°ria . Logo, um √≠ndice secund√°rio poderia ser usado para complementar outros m√©todos de acesso prim√°rios, como a ordena√ß√£o ou o hashing, ou ent√£o poderia ainda ser utilizado com arquivos mistos. Para criar um √≠ndice secund√°rio de B + ¬≠tree em algum campo de um arquivo, temos de percorrer todos os registros no arquivo para criar as entradas no n√≠vel de folha da √°rvore. Essas entradas s√£o ent√£o classificadas e preen¬≠ chidas de acordo com o fator de preenchimento espe¬≠ cificado; de maneira simult√¢nea, os outros n√≠veis de √≠ndice s√£o criados. √â mais dispendioso e muito mais dif√≠cil criar √≠ndices prim√°rios e √≠ndices de agrupamen¬≠ to  dinamicamente,  pois  os  registros  do  arquivo  de dados precisam ser fisicamente classificados no disco na ordem do campo de indexa√ß√£o. Por√©m, alguns sis¬≠ temas permitem que os usu√°rios criem esses √≠ndices dinamicamente em seus arquivos classificando o ar¬≠ quivo durante a cria√ß√£o do √≠ndice.

√â comum usar um √≠ndice para impor uma restri√ß√£o de chave em um atributo. Enquanto se pesquisa o √≠ndice para inserir um novo registro, √© f√°cil verificar ao mesmo tempo se outro registro no arquivo - e, portanto, na √°rvore de √≠ndice - tem o mesmo valor de atributo de chave que o novo registro. Nesse caso, a inser√ß√£o pode ser rejeitada.

Se um √≠ndice for criado em um campo n√£o chave, ocorrem duplicatas . O tratamento dessas duplicatas √© uma quest√£o com que os vendedores de produtos de  SGBD  precisam  lidar  e  afeta  o  armazenamento de dados, bem como a cria√ß√£o e o gerenciamento de √≠ndice. Os registros de dados para a chave duplica¬≠ da podem estar contidos no mesmo bloco ou podem se  espalhar por v√°rios blocos nos quais muitas du¬≠ plicatas  s√£o  poss√≠veis.  Alguns  sistemas  acrescentam uma identifica√ß√£o de linha para o registro, de modo que  os  registros  com  chaves  duplicadas  tenham  os pr√≥prios identificadores exclusivos. Nesses casos, o √≠ndice da B + ¬≠tree  pode  considerar  uma  combina√ß√£o de  &lt;chave,  linha\_id&gt;  como  a  chave  de  fato  para  o √≠ndice, transformando o √≠ndice em um √≠ndice exclusi¬≠ vo sem duplicatas. A exclus√£o de uma chave K de tal √≠ndice envolveria a exclus√£o de todas as ocorr√™ncias dessa chave K - da√≠ o algoritmo de exclus√£o ter de considerar isso.

Nos produtos de SGBD reais, a exclus√£o de √≠n¬≠ dices da B + ¬≠tree tamb√©m √© tratada de diversas ma¬≠ neiras para melhorar o desempenho e os tempos de resposta. Os registros exclu√≠dos podem ser marca¬≠ dos como exclu√≠dos e as entradas de √≠ndice corres¬≠ pondentes  tamb√©m  n√£o  podem  ser  removidas  at√© que o processo de coleta de lixo retome o espa√ßo no arquivo de dados; o √≠ndice √© reconstru√≠do on¬≠line ap√≥s a coleta de lixo.

Um arquivo que tem um √≠ndice secund√°rio em cada  um  de  seus  campos  costuma  ser  chamado  de arquivo  totalmente  invertido .  Como todos os √≠ndi¬≠ ces  s√£o  secund√°rios,  novos  registros  s√£o  inseridos ao final do arquivo. Portanto, o pr√≥prio arquivo de dados √© um arquivo desordenado (heap). Os √≠ndices normalmente s√£o implementados como B + ¬≠trees, de modo que s√£o atualizados de maneira din√¢mica para refletir a inser√ß√£o ou a exclus√£o de registros. Alguns SGBDs comerciais, como o Adabas da Software AG, utilizam esse m√©todo de modo extensivo.

Citamos  a  popular  organiza√ß√£o  de  arquivos IBM, chamada ISAM, na Se√ß√£o 18.2. Outro m√©to¬≠ do da IBM, o m√©todo de acesso de armazenamento virtual ( VSAM -Virtual Storage Access Method ), √© semelhante √† estrutura de acesso da B + ¬≠tree e ainda est√° sendo usado em muitos sistemas comerciais.

## 18.6.3 Armazenamento de rela√ß√µes baseado em coluna

H√° uma tend√™ncia recente em considerar um ar¬≠ mazenamento de rela√ß√µes baseado em coluna como uma alternativa ao modo tradicional de armazenar

rela√ß√µes linha por linha. Os SGBDs relacionais co¬≠ merciais  t√™m  oferecido  a  indexa√ß√£o  da  B + ¬≠tree  em chaves prim√°rias e secund√°rias como um mecanismo eficiente para admitir o acesso aos dados por diversos crit√©rios de pesquisa e a capacidade de gravar uma linha  ou  um  conjunto  de  linhas  em  disco  de  uma s√≥ vez, para produzir sistemas otimizados para gra¬≠ va√ß√£o.  Para  data  warehouses  (que  ser√£o  discutidos no Cap√≠tulo 29), que s√£o bancos de dados somen¬≠ te de leitura, o armazenamento baseado em coluna oferece  vantagens  em  particular  para  as  consultas somente de leitura. Em geral, os SGBDs com arma¬≠ zenamento de coluna consideram o armazenamento de cada coluna de dados individualmente e permitem vantagens de desempenho nas seguintes √°reas:

- ¬Ñ Particionamento vertical da tabela coluna por coluna, de modo que uma tabela de duas co¬≠ lunas pode ser constru√≠da para cada atributo e,  portanto,  somente  as  colunas  necess√°rias possam ser acessadas.
- ¬Ñ Uso de √≠ndices por colunas (semelhante aos √≠ndices  bitmap  discutidos  na  Se√ß√£o  18.5.2) e  √≠ndices  de  jun√ß√£o  em  v√°rias  tabelas  para responder √†s consultas sem ter de acessar as tabelas de dados.
- ¬Ñ Uso  de  vis√µes  materializadas  (ver  Cap√≠tulo 5) para dar suporte a consultas em m√∫ltiplas colunas.

O armazenamento de dados por coluna permite a liberdade adicional na cria√ß√£o de √≠ndices, como os √≠ndi¬≠ ces bitmap discutidos anteriormente. A mesma coluna pode estar presente em v√°rias proje√ß√µes de uma tabela e os √≠ndices podem ser criados em cada proje√ß√£o. Para ar¬≠ mazenar os valores na mesma coluna, estrat√©gias para compacta√ß√£o de dados, supress√£o de valor nulo, t√©cni¬≠ cas de codifica√ß√£o de dicion√°rio (onde valores distintos na coluna recebem c√≥digos mais curtos) e t√©cnicas de codifica√ß√£o run¬≠length t√™m sido idealizadas. MonetDB/ X100, C¬≠Store e Vertica s√£o exemplos desses sistemas. Mais sobre SGBDs de armazenamento de coluna pode ser encontrado nas refer√™ncias mencionadas na biblio¬≠ grafia selecionada deste cap√≠tulo.

## Resumo

Neste  cap√≠tulo,  apresentamos  organiza√ß√µes  de  ar¬≠ quivo que envolvem estruturas de acesso adicionais, cha¬≠ madas de √≠ndices, para melhorar a efici√™ncia da recupera¬≠ √ß√£o de registros de um arquivo de dados. Essas estruturas de acesso podem ser usadas junto com as organiza√ß√µes de arquivo prim√°rias, discutidas no Cap√≠tulo 17, que s√£o utilizadas para organizar os pr√≥prios registros de arqui¬≠ vo no disco.

Tr√™s tipos de √≠ndices de √∫nico n√≠vel ordenados foram apresentados:  prim√°rio,  de  agrupamento  e  secund√°rio. Cada √≠ndice √© especificado em um campo do arquivo. √çn¬≠ dices prim√°rios e de agrupamento s√£o constru√≠dos no cam¬≠ po de ordena√ß√£o f√≠sica de um arquivo, enquanto os √≠ndices secund√°rios  s√£o  especificados  em  campos  n√£o  ordenado como estruturas de acesso adicionais para melhorar o de¬≠ sempenho de consultas e transa√ß√µes. O campo para um √≠n¬≠ dice prim√°rio tamb√©m precisa ser uma chave do arquivo, enquanto um campo n√£o chave para um √≠ndice de agrupa¬≠ mento. Um √≠ndice de √∫nico n√≠vel √© um arquivo ordenado e √© pesquisado por meio de uma pesquisa bin√°ria. Mostramos como os  √≠ndices  multin√≠veis  podem  ser  constru√≠dos  para melhorar a efici√™ncia da pesquisa em um √≠ndice.

Em seguida, mostramos como os √≠ndices multin√≠veis podem ser implementados como B¬≠trees e B + ¬≠trees, que s√£o  estruturas  din√¢micas  que  permitem  que  um  √≠ndice se  expanda  e  encolha  dinamicamente.  Os  n√≥s  (blocos) dessas estruturas de √≠ndice s√£o mantidos entre metade e completamente cheios por algoritmos de inser√ß√£o e ex¬≠ clus√£o. Os n√≥s, por fim, se estabilizam em uma ocupa√ß√£o m√©dia de 69 por cento, permitindo espa√ßo para inser√ß√µes sem exigir reorganiza√ß√£o do √≠ndice para a maioria das inser√ß√µes. As B + ¬≠trees em geral podem manter mais entra¬≠ das em seus n√≥s internos do que as B¬≠trees, de modo que podem ter menos n√≠veis ou manter mais entradas do que uma B¬≠tree correspondente.

Demos uma vis√£o geral dos diversos m√©todos de acesso de chave e mostramos como um √≠ndice pode ser constru√≠do com base nas estruturas de dados de hash. Discutimos  o √≠ndice  de  hash com  alguns  detalhes  essa √© uma estrutura secund√°ria para acessar o arquivo, usando o hashing em uma chave de pesquisa diferen¬≠ te  daquela  para  a  organiza√ß√£o  prim√°ria.  A  indexa√ß√£o bitmap √© outro tipo importante de indexa√ß√£o utilizado para consulta por v√°rias chaves, sendo particularmente aplic√°vel a campos com um pequeno n√∫mero de valores √∫nicos. Os bitmaps tamb√©m podem ser usados nos n√≥s folha dos √≠ndices da B + ¬≠tree. Tamb√©m abordamos a in¬≠ dexa√ß√£o baseada em fun√ß√£o, que est√° sendo fornecida por vendedores relacionais para permitir √≠ndices espe¬≠ ciais em uma fun√ß√£o de um ou mais atributos.

Apresentamos  o  conceito  de  um  √≠ndice  l√≥gico  e  o comparamos aos √≠ndices f√≠sicos descritos anteriormente. Eles  permitem um n√≠vel de indire√ß√£o adicional na inde¬≠ xa√ß√£o,  a  fim  de  permitir  maior  liberdade  para  a  movi¬≠ menta√ß√£o dos locais de registro reais no disco. Tamb√©m revisamos algumas quest√µes gerais relacionadas √† indexa¬≠ √ß√£o e comentamos o armazenamento de rela√ß√µes baseado em colunas, que tem vantagens particulares para bancos de  dados  somente  de  leitura.  Por  fim,  discutimos  como podem ser usadas as combina√ß√µes das organiza√ß√µes. Por exemplo, os √≠ndices secund√°rios normalmente s√£o usados com arquivos mistos, bem como com arquivos desordena¬≠ dos e ordenados.

## Perguntas de revis√£o

- 18.1. Defina  os  seguintes  termos: campo  de  √≠ndice , campo de chave prim√°ria , campo de agrupamento , campo de chave secund√°ria , √¢ncora de bloco , √≠ndice denso e √≠ndice n√£o denso (esparso) .
- 18.2. Quais s√£o as diferen√ßas entre √≠ndices prim√°rio, secund√°rio  e  de  agrupamento?  Como  essas  di¬≠ feren√ßas afetam as maneiras como esses √≠ndices s√£o implementados? Quais dos √≠ndices s√£o den¬≠ sos e quais n√£o s√£o?
- 18.3. Por que podemos ter no m√°ximo um √≠ndice pri¬≠ m√°rio ou de agrupamento em um arquivo, mas v√°rios √≠ndices secund√°rios?
- 18.4. Como a indexa√ß√£o multin√≠vel melhora a efici√™n¬≠ cia da pesquisa em um arquivo de √≠ndice?
- 18.5. O que √© a ordem p de  uma B¬≠tree? Descreva a estrutura dos n√≥s da B¬≠tree.
- 18.6. O que  √©  a  ordem p de  uma  B + ¬≠tree?  Descreva a estrutura dos n√≥s internos e de folha de uma B + ¬≠tree.
- 18.7. Como uma B¬≠tree difere de uma B + ¬≠tree? Por que uma B + ¬≠tree normalmente √© preferida como uma estrutura de acesso para um arquivo de dados?
- 18.8. Explique que escolhas alternativas existem para acessar um arquivo com base em m√∫ltiplas cha¬≠ ves de pesquisa.
- 18.9. O que √© hashing particionado? Como ele funcio¬≠ na? Quais s√£o suas limita√ß√µes?
- 18.10. O que √© um arquivo de grade? Quais s√£o suas vantagens e desvantagens?
- 18.11. Mostre um exemplo de constru√ß√£o de um vetor de grade em dois atributos em algum arquivo.
- 18.12. O que √© um arquivo totalmente invertido? O que √© um arquivo sequencial indexado?
- 18.13. Como o hashing pode ser usado para construir um √≠ndice?
- 18.14. O  que  √©  indexa√ß√£o  bitmap?  Crie  uma  rela√ß√£o com duas colunas e dezesseis tuplas, e mostre um exemplo de um √≠ndice bitmap em uma ou ambas as colunas.
- 18.15. O  que  √©  o  conceito  de  indexa√ß√£o  baseada  em fun√ß√£o? Para que finalidade adicional ele serve?
- 18.16. Qual √© a diferen√ßa entre um √≠ndice l√≥gico e um √≠ndice f√≠sico?
- 18.17. O que √© armazenamento baseado em coluna de um banco de dados relacional?

## Exerc√≠cios

18.18.

Considere um disco com tamanho de bloco B = 512 bytes. Um ponteiro de bloco tem P =  6 bytes de extens√£o, e um ponteiro de registro tem P R = 7 bytes de extens√£o. Um arquivo tem r = 30.000 registros de FUNCIONARIO de tamanho

- fixo .  Cada  registro  tem  os  seguintes  campos: Nome (30 bytes), Cpf (9 bytes), Codigo\_depar -tamento (9 bytes), Endereco (40 bytes), Telefo -ne (10 bytes), Data\_nascimento (8 bytes), Sexo (1  byte), Codigo\_cargo (4  bytes)  e Salario (4 bytes, n√∫mero real). Um byte adicional √© usado como um marcador de exclus√£o.
- a. Calcule o tamanho do registro R em bytes.
- b. Calcule o fator de bloco bfr e  o  n√∫mero de blocos de arquivo b , considerando uma orga¬≠ niza√ß√£o n√£o estendida.
- c. Suponha que o arquivo seja ordenado pelo campo de chave Cpf e  queiramos  construir um √≠ndice prim√°rio em Cpf . Calcule (i) o fa¬≠ tor de bloco de √≠ndice bfr i (que tamb√©m √© o fan¬≠out do √≠ndice fo ); (ii) o n√∫mero de entra¬≠ das de √≠ndice de primeiro n√≠vel e o n√∫mero de blocos de √≠ndice de primeiro n√≠vel; (iii) o n√∫¬≠ mero de n√≠veis necess√°rios se o transformar¬≠ mos em um √≠ndice multin√≠vel; (iv) o n√∫mero total de blocos exigidos pelo √≠ndice multin√≠¬≠ vel; e (v) o n√∫mero de acessos de bloco necess√°¬≠ rios para pesquisar e recuperar um registro do arquivo - dado seu valor de Cpf - usando o √≠ndice prim√°rio.
- d. Suponha que o arquivo n√£o esteja ordenado pelo  campo  de  chave Cpf e  queremos construir  um √≠ndice  secund√°rio em Cpf. Repita o exerc√≠cio anterior (parte c) para o √≠ndice secund√°rio e compare com o √≠ndice prim√°rio.
- e. Suponha que o arquivo n√£o esteja ordenado pelo  campo  n√£o  chave Codigo\_depar -tamento e  queremos  construir  um √≠ndice secund√°rio em Codigo\_departamento, usando  a  op√ß√£o  3  da  Se√ß√£o  18.1.3,  com um n√≠vel extra de indire√ß√£o que armazena ponteiros de registro. Suponha que existam 1.000 valores distintos de Codigo\_departa -mento e que os registros de FUNCIONARIO estejam  distribu√≠dos  uniformemente  entre esses valores. Calcule (i) o fator de bloco de √≠ndice bfr i (que tamb√©m √© o fan¬≠out de √≠ndi¬≠ ce fo ); (ii) o n√∫mero de blocos necess√°rios pelo n√≠vel de indire√ß√£o que armazena pon¬≠ teiros de registro; (iii) o n√∫mero de entra¬≠ das de √≠ndice de primeiro n√≠vel e o n√∫mero de blocos de √≠ndice de primeiro n√≠vel; (iv) o n√∫mero de n√≠veis necess√°rios se o trans¬≠ formarmos em um √≠ndice multin√≠vel; (v) o n√∫mero total de blocos exigidos pelo √≠ndice multin√≠vel  e  os  blocos  usados  no  n√≠vel  de indire√ß√£o  extra;  e  (vi)  o  n√∫mero  aproxi¬≠ mado de acessos de bloco necess√°rios para pesquisar e recuperar todos os registros no arquivo que t√™m um valor espec√≠fico de Co -digo\_departamento , usando o √≠ndice.

- f. Suponha  que  o  arquivo  esteja ordenado pelo  campo  n√£o  chave Codigo\_departa -mento e que queremos construir um √≠ndice de agrupamento em Codigo\_departamen -to que  use  √¢ncoras  de  bloco  (cada  novo valor  de Codigo\_departamento come√ßa no in√≠cio de um novo bloco). Suponha que existam  1.000  valores  distintos  de Codi -go\_departamento e  que  os  registros  de FUNCIONARIO sejam distribu√≠dos unifor¬≠ memente entre esses valores. Calcule (i) o fator de bloco de √≠ndice bfr i (que tamb√©m √© o fan¬≠out do √≠ndice fo ); (ii) o n√∫mero de entradas  de  √≠ndice  de  primeiro  n√≠vel  e  o n√∫mero de blocos de √≠ndice de primeiro n√≠¬≠ vel; (iii) o n√∫mero de n√≠veis necess√°rios se o  transformarmos  em  um  √≠ndice  multin√≠¬≠ vel; (iv) o n√∫mero total de blocos exigidos pelo √≠ndice multin√≠vel; e (v) o n√∫mero de acessos de bloco necess√°rios para pesqui¬≠ sar  e  recuperar  todos  os  registros  no  ar¬≠ quivo que tenham um valor espec√≠fico de Codigo\_departamento , usando  o  √≠ndice de agrupamento (suponha que v√°rios blo¬≠ cos em um cluster sejam cont√≠nuos).
- g. Suponha que o arquivo n√£o esteja ordenado pelo  campo  de  chave Cpf e  que  queremos construir uma estrutura de acesso (√≠ndice) B +¬≠ ¬≠tree em Cpf. Calcule (i) as ordens p e p folha da B + ¬≠tree; (ii) o n√∫mero de blocos em n√≠vel de  folha  necess√°rios  se  os  blocos  estiverem aproximadamente 69 por cento cheios (arre¬≠ dondado por conveni√™ncia); (iii) o n√∫mero de n√≠veis necess√°rios se os n√≥s internos tamb√©m estiverem 69 por cento cheios (arredondado por conveni√™ncia); (iv) o n√∫mero total de blo¬≠ cos exigidos pela B + ¬≠tree; e (v) o n√∫mero de acessos de bloco necess√°rios para procurar e recuperar um registro do arquivo - dado seu valor de Cpf - usando a B + ¬≠tree.
- h. Repita  a  parte  g,  mas  para  uma  B¬≠tree  em vez de uma B + ¬≠tree. Compare seus resultados para a B¬≠tree e para a B + ¬≠tree.
- 18.19. Um  arquivo PECAS com Num\_peca como campo de chave inclui registros com os seguin¬≠ tes valores de Num\_peca : 23, 65, 37, 60, 46, 92, 48, 71, 56, 59, 18, 21, 10, 74, 78, 15, 16, 20, 24, 28, 39, 43, 47, 50, 69, 75, 8, 49, 33, 38. Suponha que os valores do campo de pes¬≠ quisa sejam inseridos na ordem dada em uma B + ¬≠tree de ordem p = 4 e p folha = 3; mostre como a √°rvore ser√° expandida e como ser√° sua apa¬≠ r√™ncia final.
- 18.20. Repita o exerc√≠cio 18.19, mas use uma B¬≠tree de ordem p = 4 no lugar de uma B + ¬≠tree.
- 18.21. Suponha que os valores de campo de pesquisa a seguir sejam exclu√≠dos, na ordem indicada, da B + ¬≠tree do Exerc√≠cio 18.19. Mostre como a √°rvo¬≠ re ser√° encolhida e sua forma final. Os valores exclu√≠dos s√£o 65, 75, 43, 18, 20, 92, 59, 37.
- 18.22. Repita o Exerc√≠cio 18.21, mas para a B¬≠tree do Exerc√≠cio 18.20.
- 18.23. O Algoritmo 18.1 esbo√ßa o procedimento de pes¬≠ quisa em um √≠ndice prim√°rio multin√≠vel n√£o denso para recuperar um registro do arquivo. Adapte o algoritmo para cada um dos seguintes casos:
- a. Um √≠ndice secund√°rio multin√≠vel em um campo n√£o ordenado n√£o chave de um arquivo. Supo¬≠ nha que a op√ß√£o 3 da Se√ß√£o 18.1.3 seja usada, em que um n√≠vel de indire√ß√£o extra armazena ponteiros para os registros individuais com o valor correspondente de campo de √≠ndice.
- b. Um √≠ndice secund√°rio multin√≠vel em um cam¬≠ po de chave n√£o ordenado de um arquivo.
- c. Um  √≠ndice  de  agrupamento  multin√≠vel  em um campo de ordena√ß√£o n√£o chave de um arquivo.
- 18.24. Suponha que existam v√°rios √≠ndices secund√°rios em campos n√£o chave de um arquivo, implemen¬≠ tados  usando  a  op√ß√£o  3  da  Se√ß√£o  18.1.3.  Por exemplo, poder√≠amos ter √≠ndices secund√°rios nos campos Codigo\_departamento, Codigo\_cargo e Salario do arquivo FUNCIONARIO do Exerc√≠cio 18.18. Descreva um modo eficiente de pesquisar e recuperar registros que satisfa√ßam uma condi¬≠ √ß√£o  de  sele√ß√£o  complexa  nesses  campos,  como ( Codigo\_departamento = 5 AND Codigo\_cargo = 12 AND Salario = 50.000), usando ponteiros de registro no n√≠vel de indire√ß√£o.
- 18.25. Adapte os algoritmos 18.2 e 18.3, que esbo√ßam procedimentos de pesquisa e indire√ß√£o para uma B + ¬≠tree, a uma B¬≠tree.
- 18.26. √â poss√≠vel modificar o algoritmo de inser√ß√£o da B + ¬≠tree para adiar o caso em que um novo n√≠¬≠ vel √© produzido ao verificar uma redistribui√ß√£o poss√≠vel de valores entre os n√≥s folha. A Figura 18.17 ilustra  como  isso  poderia  ser  feito  para o exemplo da Figura 18.12; em vez de dividir o n√≥ folha mais √† esquerda quando 12 √© inse¬≠ rido, realizamos uma redistribui√ß√£o √† esquerda movendo 7 para o n√≥ folha √† sua esquerda (se houver espa√ßo nesse n√≥). A Figura 18.17 mostra como a √°rvore ficaria  quando  a  redistribui√ß√£o √© considerada. Tamb√©m √© poss√≠vel considerar a redistribui√ß√£o √† direita . Tente modificar o algo¬≠ ritmo de inser√ß√£o da B + ¬≠tree para levar em conta a redistribui√ß√£o.
- 18.27. Esboce  um  algoritmo  para  exclus√£o  com  base em uma B + ¬≠tree.
- 18.28. Repita o Exerc√≠cio 18.27 para uma B¬≠tree.

## Bibliografia selecionada

Bayer e McCreight (1972) introduziram B¬≠trees e al¬≠ goritmos associados. Comer (1979) oferece um excelente estudo das B¬≠trees e sua hist√≥ria, al√©m de suas varia√ß√µes. Knuth (1998) faz uma an√°lise detalhada de muitas t√©c¬≠ nicas  de  pesquisa,  incluindo  B¬≠trees  e  algumas  de  suas varia√ß√µes.  Nievergelt  (1974)  discute  o  uso  das  √°rvores de  pesquisa  bin√°ria  para  organiza√ß√£o  de  arquivo.  Os livros¬≠texto sobre estruturas de arquivo, incluindo Clay¬≠ brook (1992), Smith e Barnes (1987) e Salzberg (1988), os livros¬≠texto sobre algoritmos e estruturas de dados de Wirth (1985), bem como o livro¬≠texto de banco de dados de Ramakrihnan e Gehrke (2003) discutem a indexa√ß√£o com detalhes, e podem ser consultados para algoritmos de pesquisa, inser√ß√£o e exclus√£o para B¬≠trees e B + ¬≠trees. Larson  (1981)  analisa  arquivos  sequenciais  indexados, e Held e Stonebraker (1978) comparam os √≠ndices mul¬≠ tin√≠veis est√°ticos com √≠ndices din√¢micos de B¬≠tree. Leh¬≠ man e Yao (1981) e Srinivasan e Carey (1991) realizaram mais an√°lise do acesso concorrente a B¬≠trees. Os livros de Wiederhold (1987), Smith e Barnes (1987) e Salzberg (1988),  entre  outros,  discutem  muitas  das  t√©cnicas  de pesquisa descritas neste cap√≠tulo. Arquivos de grade s√£o apresentados em Nievergelt et al. (1984). A recupera√ß√£o de combina√ß√£o parcial, que usa o hashing particionado, √© discutida em Burkhard (1976, 1979).

Novas t√©cnicas e aplica√ß√µes de √≠ndices e B + ¬≠trees s√£o discutidas em Lanka e Mays (1991), Zobel et al. (1992) e Faloutsos e Jagadish (1992). Mohan e Narang (1992) discutem a cria√ß√£o de √≠ndice. O desempenho de diver¬≠ sos algoritmos de B¬≠tree e B + ¬≠tree √© avaliado em Baeza¬≠ ¬≠Yates e Larson (1989) e Johnson e Shasha (1993). O gerenciamento  de  buffer  para  √≠ndices  √©  discutido  em Chan et al. (1992). O armazenamento de bancos de da¬≠ dos baseado em colunas foi proposto por Stonebraker et  al.  (2005)  no  sistema  de  banco  de  dados  C¬≠Store; MonetDB/X100, de Boncz et al. (2008), √© outra imple¬≠ menta√ß√£o da ideia. Abadi et al. (2008) discutem as van¬≠ tagens dos bancos de dados armazenados por colunas em rela√ß√£o aos armazenados por linhas para aplica√ß√µes de banco de dados somente de leitura.

Figura 18.17



Inser√ß√£o de B -tree com redistribui√ß√£o √† esquerda. +



Processamento de consulta, otimiza√ß√£o e ajuste de banco de dados



## Algoritmos para processamento e otimiza√ß√£o de consulta

N este cap√≠tulo, discutimos as t√©cnicas usadas internamente por um SGBD para processar, otimizar e executar consultas de alto n√≠vel. Uma consulta expressa em uma linguagem de consulta de alto n√≠vel, como SQL, primeiro precisa ser lida, analisada e validada. 1 A varredura identifica os tokens de consulta - como as palavras-chave SQL, nomes de atributo e nomes de rela√ß√£o - que aparecem no texto da consulta, enquanto o analisador sint√°tico verifica a sintaxe da consulta para determinar se ela est√° formulada de acordo com as regras de sintaxe (regras de gram√°tica) da linguagem de consulta. A consulta tamb√©m precisa ser validada verificando se todos os nomes de atributo e rela√ß√£o s√£o v√°lidos  e  semanticamente  significativos  no  esquema do  banco  de  dados  em  particular  sendo  consultado. Uma representa√ß√£o interna da consulta √© ent√£o criada, normalmente como uma estrutura de dados de √°rvore chamada √°rvore de consulta .  Tamb√©m √© poss√≠vel representar a consulta usando uma estrutura de dados de grafo chamada grafo de consulta . O SGBD precisa ent√£o idealizar uma estrat√©gia de execu√ß√£o ou plano de consulta para recuperar os resultados da consulta com base nos arquivos de banco de dados. Uma consulta costuma ter muitas estrat√©gias de execu√ß√£o poss√≠veis, e o processo de escolha de uma estrat√©gia adequada para process√°-la √© conhecido como otimiza√ß√£o de consulta .



## C√≥digo pode ser:

Executado diretamente (modo interpretado)

A  Figura  19.1  mostra  as  diferentes  etapas  do processamento de uma consulta de alto n√≠vel. O m√≥dulo otimizador de consulta tem a tarefa de produzir um bom plano de execu√ß√£o, e o gerador de c√≥digo d√° origem ao c√≥digo para executar esse plano.

Armazenado e executado mais tarde, sempre que poss√≠vel (modo compilado)

Figura 19.1

Etapas t√≠picas ao processar uma consulta de alto n√≠vel.

1 N√£o discutiremos aqui a fase de an√°lise e verifica√ß√£o de sintaxe do processamento da consulta; esse material √© discutido nos livros-texto sobre compilador.

O processador em tempo de execu√ß√£o do banco de dados tem a tarefa de rodar (executar) o c√≥digo da consulta, sejam no modo compilado ou interpretado, para produzir o resultado da consulta. Se houver um erro em tempo de execu√ß√£o, uma mensagem de erro √© gerada pelo processador em tempo de execu√ß√£o do banco de dados.

O termo otimiza√ß√£o √©,  na  realidade,  um  nome errado,  pois  em  alguns  casos  o  plano  de  execu√ß√£o escolhido n√£o √© a estrat√©gia √≥tima (ou a melhor absoluta) - trata-se apenas de uma estrat√©gia razoavelmente eficiente para executar a consulta. Encontrar a estrat√©gia ideal em geral √© muito demorado - exceto para a mais simples das consultas. Al√©m disso, tentar encontrar a estrat√©gia de execu√ß√£o de consulta ideal pode exigir informa√ß√µes detalhadas sobre como os  arquivos s√£o implementados e at√© mesmo sobre seu conte√∫do - informa√ß√µes que podem n√£o estar totalmente dispon√≠veis no cat√°logo do SGBD. Logo, o planejamento de uma boa estrat√©gia de execu√ß√£o pode ser uma descri√ß√£o mais precisa do que a otimiza√ß√£o de consulta .

Para as linguagens de banco de dados navegacionais de n√≠vel mais baixo nos sistemas legados - como a DML de rede ou a DL/1 hier√°rquica (ver Se√ß√£o 2.6) -, o programador deve escolher a estrat√©gia de execu√ß√£o de consulta enquanto escreve o programa de banco de dados. Se um SGBD oferece apenas uma linguagem navegacional, existe uma necessidade ou oportunidade limitada para otimiza√ß√£o de consulta extensiva pelo SGBD; em vez disso, o programador recebe a responsabilidade  de  escolher  a  estrat√©gia  de  execu√ß√£o  de consulta. Por sua vez, uma linguagem de consulta de alto n√≠vel - como SQL para SGBDs relacionais (SGBDRs) ou OQL (ver Cap√≠tulo 11) para SGBDs de objeto (SGBDOs) - √© mais declarativa por natureza, pois especifica quais s√£o os resultados intencionados da consulta, em vez de identificar os detalhes de como o resultado deve ser obtido. A otimiza√ß√£o de consulta √©, portanto, necess√°ria para consultas que s√£o especificadas em uma linguagem de consulta de alto n√≠vel.

lher uma estrat√©gia razoavelmente eficiente ou quase ideal.  Cada  SGBD  normalmente  tem  uma  s√©rie  de algoritmos gerais de acesso de banco de dados que implementam opera√ß√µes da √°lgebra relacional, como SELE√á√ÉO ou JUN√á√ÉO (ver Cap√≠tulo 6) ou combina√ß√µes dessas opera√ß√µes. Somente estrat√©gias de execu√ß√£o que podem ser implementadas pelos algoritmos de acesso do SGBD e que se aplicam √† consulta em particular, bem como ao projeto de banco de dados f√≠sico  em  particular ,  podem  ser  consideradas  pelo m√≥dulo de otimiza√ß√£o de consulta.

Este cap√≠tulo come√ßa com uma discuss√£o geral sobre como as consultas SQL costumam ser traduzidas para consultas da √°lgebra relacional e depois otimizadas na Se√ß√£o 19.1. Depois, discutimos algoritmos para implementar opera√ß√µes da √°lgebra relacional nas se√ß√µes 19.2 a 19.6. Na sequ√™ncia, damos uma vis√£o geral das estrat√©gias de otimiza√ß√£o de  consulta.  Existem  duas  t√©cnicas  principais  que s√£o empregadas durante a otimiza√ß√£o da consulta. A primeira t√©cnica √© baseada em regras heur√≠sticas para ordenar as opera√ß√µes em uma estrat√©gia de execu√ß√£o de consulta. Uma heur√≠stica √© uma regra que funciona bem na maioria dos casos, mas n√£o garante funcionar bem em todos eles. As regras em geral reordenam as opera√ß√µes em uma √°rvore de consulta. A segunda t√©cnica envolve estimar sistematicamente o custo de diferentes estrat√©gias de execu√ß√£o e escolher o plano de execu√ß√£o com a estimativa de custo mais baixa. Essas t√©cnicas normalmente s√£o combinadas em um otimizador de consulta. Abordamos a otimiza√ß√£o heur√≠stica na Se√ß√£o 19.7 e a estimativa de  custo  na  Se√ß√£o  19.8.  Depois,  oferecemos  uma breve vis√£o geral dos fatores considerados durante a otimiza√ß√£o de consulta no SGBD comercial Oracle na Se√ß√£o 19.9. A Se√ß√£o 19.10 introduz o assunto de otimiza√ß√£o de consulta sem√¢ntica, em que restri√ß√µes conhecidas s√£o usadas como um recurso para idealizar estrat√©gias de execu√ß√£o de consulta eficientes.

Vamos  nos  concentrar  na  descri√ß√£o  da  otimiza√ß√£o de consulta no contexto de um SGBDR , pois muitas das t√©cnicas que descrevemos tamb√©m foram adaptadas para outros tipos de sistemas de gerenciamento de banco de dados, como os SGBDOs. 2  Um SGBD relacional deve avaliar sistematicamente estrat√©gias  alternativas  de  execu√ß√£o  de  consulta  e  esco-

Os t√≥picos abordados neste cap√≠tulo exigem que o leitor esteja acostumado com o material apresentado em v√°rios cap√≠tulos anteriores. Em particular, os cap√≠tulos sobre SQL (cap√≠tulos 4 e 5), √°lgebra relacional (Cap√≠tulo 6) e estruturas e indexa√ß√£o de arquivo (cap√≠tulos 17 e 18) s√£o um pr√©-requisito para este cap√≠tulo. Al√©m disso, √© importante observar que o t√≥pico de processamento e otimiza√ß√£o de consulta √© vasto, e s√≥ podemos oferecer aqui uma introdu√ß√£o aos princ√≠pios e t√©cnicas b√°sicas.

2 Existem alguns problemas e t√©cnicas de otimiza√ß√£o de consulta que s√£o pertinentes apenas aos SGBDOs. Contudo, n√£o os discutimos aqui porque oferecemos apenas uma introdu√ß√£o ao assunto.

## 19.1 Traduzindo consultas SQL para √°lgebra relacional

Na  pr√°tica,  a  SQL  √©  a  linguagem  de  consulta usada na maioria dos SGBDRs comerciais. Uma consulta SQL √© primeiro traduzida para uma express√£o equivalente da √°lgebra relacional estendida - representada como uma estrutura de dados de √°rvore de consulta - que √©, ent√£o, otimizada. Normalmente, as consultas SQL s√£o decompostas em blocos de consulta , que formam as unidades b√°sicas que podem ser traduzidas  em  operadores  alg√©bricos  e  otimizadas. Um bloco de consulta cont√©m uma √∫nica express√£o SELECT-FROM-WHERE , bem como cl√°usulas GROUP BY e HAVING , se estas fizerem parte do bloco. Logo, as consultas aninhadas em uma consulta s√£o identificadas como blocos de consulta separados. Como a SQL inclui operadores de agrega√ß√£o - como MAX, MIN, SUM e COUNT esses operadores tamb√©m precisam ser inclu√≠dos na √°lgebra estendida, conforme discutimos na Se√ß√£o 6.4.

Considere  a  seguinte  consulta  SQL  na  rela√ß√£o FUNCIONARIO da Figura 3.5:

SELECT FROM WHERE

Unome, Pnome

FUNCIONARIO

Salario

&gt;

(

SELECT

MAX ( Salario )

FROM WHERE

FUNCIONARIO

Dnr = 5 );

Essa  consulta  recupera  os  nomes  dos  funcion√°rios (de qualquer departamento na empresa) que ganham  um  sal√°rio  maior  que  o maior  sal√°rio  no departamento 5 . A consulta inclui uma subconsulta aninhada e, portanto, seria decomposta em dois blocos. O bloco mais interno √©:

( SELECT MAX ( Salario )

FROM FUNCIONARIO

WHERE Dnr = 5 )

Isso recupera o sal√°rio mais alto no departamento 5. O bloco de consulta mais externo √©:

SELECT FROM WHERE

Unome, Pnome

FUNCIONARIO

Salario &gt; c

onde c representa o resultado retornado do bloco interno. O bloco interno poderia ser traduzido para a seguinte express√£o da √°lgebra relacional estendida:

I MAX Salario ( ùõî Dnr = 5 ( FUNCIONARIO ))

e o bloco externo para a express√£o :

<!-- formula-not-decoded -->

O otimizador  de  consulta , ent√£o,  escolheria um plano de execu√ß√£o para cada bloco de consulta. Observe que, no exemplo acima, o bloco interno s√≥ precisa ser avaliado uma vez para produzir o sal√°rio m√°ximo dos funcion√°rios no departamento 5, que √© ent√£o utilizado - como a constante c - pelo bloco externo. Chamamos isso de uma consulta aninhada ( sem  correla√ß√£o  com  a  consulta  externa )  na  Se√ß√£o 5.1.2. √â muito mais dif√≠cil otimizar as consultas aninhadas correlacionadas mais  complexas  (ver  Se√ß√£o 5.1.3),  em  que  uma  vari√°vel  de  tupla  do  bloco  de consulta externo aparece na cl√°usula WHERE do bloco de consulta interno.

## 19.2 Algoritmos para ordena√ß√£o externa

A intercala√ß√£o (sorting) √© um dos principais algoritmos  utilizados  no  processamento  de  consulta.  Por exemplo, sempre que uma consulta SQL especifica uma cl√°usula ORDER BY , o resultado da consulta precisa ser ordenado.  A  intercala√ß√£o  tamb√©m  √©  um  componente chave  nos  algoritmos  ordena√ß√£o-intercala√ß√£o  (sort-merge) usados para JUN√á√ÉO e outras opera√ß√µes (como UNI√ÉO e INTERSEC√á√ÉO) , e em algoritmos de elimina√ß√£o de duplicata para a opera√ß√£o PROJE√á√ÉO (quando uma consulta SQL especifica a op√ß√£o DISTINCT na cl√°usula SELECT) . Discutiremos um desses algoritmos nesta se√ß√£o. Observe que a intercala√ß√£o de determinado arquivo pode ser evitada se um √≠ndice apropriado - como um √≠ndice prim√°rio ou de agrupamento (ver Cap√≠tulo 18) - existir no atributo de arquivo desejado para permitir o acesso ordenado aos registros no arquivo.

Intercala√ß√£o externa refere-se a algoritmos de intercala√ß√£o que s√£o adequados para grandes arquivos de registros armazenados no disco que n√£o cabem inteiramente na mem√≥ria principal, como a maioria dos arquivos de banco de dados. 3 O algoritmo de classifica√ß√£o externa t√≠pico usa uma estrat√©gia ordena√ß√£o-intercala√ß√£o (sort-merge) , que come√ßa classificando pequenos subarquivos - chamados peda√ßos - do arquivo principal e depois mescla os peda√ßos classificados, criando subarquivos classificados maiores, que, por sua vez, s√£o intercalados. O algoritmo ordena√ß√£o-intercala√ß√£o (sort-merge), como outros algoritmos de banco de dados, exige espa√ßo de buffer na mem√≥ria principal, onde a classifica√ß√£o e mesclagem reais dos peda√ßos s√£o realizadas.

3 Algoritmos de classifica√ß√£o interna s√£o adequados para classifica√ß√£o de estruturas de dados, como tabelas e listas, que podem caber inteiramente na mem√≥ria principal. Esses algoritmos s√£o descritos com detalhes em livros de estruturas de dados e algoritmos, e incluem t√©cnicas como quick sort, heap sort, bubble sort e muitas outras. N√£o discutiremos esses algoritmos aqui.

O algoritmo b√°sico, esbo√ßado na Figura 19.2, consiste em duas fases: a fase de ordena√ß√£o e a fase de intercala√ß√£o. O espa√ßo de buffer na mem√≥ria principal faz parte do cache de SGBD - uma √°rea na mem√≥ria principal do computador que √© controlada  pelo  SGBD.  O  espa√ßo  de  buffer  √©  dividido  em buffers individuais, onde cada buffer tem o mesmo tamanho em bytes que o tamanho de um bloco de disco. Assim, um buffer pode manter o conte√∫do de exatamente um bloco de disco .

Na fase  de  ordena√ß√£o ,  os  peda√ßos  (ou  partes) do arquivo que podem caber no espa√ßo de buffer dispon√≠vel s√£o lidos para a mem√≥ria principal, ordenados usando um algoritmo de ordena√ß√£o interno e gravados de volta para o disco como subarquivos ordenados  (ou  peda√ßos)  tempor√°rios.  O  tamanho de cada peda√ßo e o n√∫mero de peda√ßos iniciais ( n R ) s√£o ditados pelo n√∫mero de blocos de arquivo ( b ) e o espa√ßo de buffer dispon√≠vel ( n B ) . Por exemplo, se o n√∫mero de buffers dispon√≠veis da mem√≥ria principal n B = 5  blocos de disco e o tamanho do arquivo b = 1.024 blocos de disco, ent√£o n R = Ô£Æ ( b n / B )  ou 205 Ô£π peda√ßos iniciais cada, com tamanho de cinco blocos (exceto o √∫ltimo peda√ßo, que ter√° apenas quatro blocos). Logo, ap√≥s a fase de ordena√ß√£o, 205 peda√ßos ordenados (ou 205 subarquivos ordenados do arquivo original) s√£o armazenados como subarquivos tempor√°rios no disco.

<!-- formula-not-decoded -->

## { Fase de Ordena√ß√£o }

enquanto ( i ‚â§ m )

fa√ßa {

l√™ pr√≥ximos k blocos do arquivo no buffer ou, se houver menos de k blocos restantes, ent√£o l√™ nos blocos restantes; ordena os registros no buffer e grava como um subarquivo tempor√°rio; i ‚Üê + i 1;

}

{ Fase de Intercala√ß√£o: intercala subarquivos at√© que apenas 1 permane√ßa}

atribua

i

‚Üê

1;

p

‚Üê

log

Ô£Æ

j

‚Üê

m

k-1

;

enquanto ( i ‚â§ p )

fa√ßa {

n

‚Üê

1;

q

‚Üê Ô£Æ

(  /(

j

k

-

enquanto (

1    ;

)

Ô£π

{ p √© o n√∫mero de passos para a fase de intercala√ß√£o}

{n√∫mero de subarquivos a gravar nesse passo}

n

‚â§

q

)

fa√ßa {

l√™ pr√≥ximos k -1 subarquivos ou subarquivos restantes (do passo anterior) um bloco por vez;

intercala e grava como novo subarquivo um bloco por vez;

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

m

Ô£π

Na fase de intercala√ß√£o , os peda√ßos ordenados s√£o intercalados usando um ou mais passos de intercala√ß√£o . Cada passo de intercala√ß√£o pode ter uma ou mais etapas de intercala√ß√£o. O grau de intercala√ß√£o ( d M ) √© o n√∫mero de subarquivos ordenados que podem ser mesclados em cada etapa de intercala√ß√£o. Durante cada etapa de intercala√ß√£o, um bloco de buffer √© necess√°rio para manter um bloco de disco de cada um dos subarquivos ordenados sendo intercalados, e um buffer adicional √© necess√°rio para manter um bloco de disco do resultado da intercala√ß√£o, que produzir√° um arquivo ordenado maior, que √© o resultado da intercala√ß√£o de v√°rios subarquivos ordenados menores. Logo, d M √© o menor de ( n B -1) e n R , e o n√∫mero de passos de intercala√ß√£o √© Ô£Æ (log dM ( n R )) . Em nosso exemplo, onde Ô£π n B = 5, d M = 4 (intercala√ß√£o qu√°drupla), de modo que os 205 peda√ßos iniciais ordenados seriam intercalados quatro de cada vez em cada etapa em 52 subarquivos ordenados maiores,  ao  final  do  primeiro passo de intercala√ß√£o. Esses 52 arquivos ordenados s√£o, ent√£o, intercalados quatro de cada vez em 13 arquivos ordenados, que s√£o depois intercalados em quatro arquivos ordenados, e, por fim, para um arquivo totalmente ordenado, o que significa que quatro passos s√£o necess√°rios.

- O  desempenho  do  algoritmo  ordena√ß√£o-intercala√ß√£o pode ser medido no n√∫mero de leituras e grava√ß√µes de bloco de disco (entre o disco e a mem√≥ria principal) antes que a ordena√ß√£o do arquivo inteiro seja conclu√≠da. A f√≥rmula a seguir aproxima esse custo:

<!-- formula-not-decoded -->

O primeiro termo (2 * b ) representa o n√∫mero de acessos  de  bloco  para  a  fase  de  ordena√ß√£o,  pois cada bloco de arquivo √© acessado duas vezes: uma para leitura em um buffer da mem√≥ria principal e uma para a grava√ß√£o dos registros ordenados de volta ao disco, em um dos subarquivos ordenados. O segundo termo representa o n√∫mero de acessos de bloco para a fase de intercala√ß√£o. Durante cada passada de intercala√ß√£o, uma quantidade de blocos de disco aproximadamente igual aos blocos do arquivo original b √© lida e gravada. Como o n√∫mero de passos de intercala√ß√£o √© (log dM n R ), obtemos um custo total de intercala√ß√£o de (2 * b * (log dM n R )).

O n√∫mero m√≠nimo de buffers da mem√≥ria principal necess√°rios √© n B = 3, que produz um d M de 2 e um n R de  ( Ô£Æ b 3 / ) . O Ô£π d M m√≠nimo de 2 gera o desempenho do pior caso do algoritmo, que √©:

<!-- formula-not-decoded -->

As pr√≥ximas se√ß√µes discutem os diversos algoritmos para as opera√ß√µes da √°lgebra relacional (ver Cap√≠tulo 6).

## 19.3 Algoritmos para opera√ß√µes SELE√á√ÉO e JUN√á√ÉO

## 19.3.1 mplementando a opera√ß√£o I SELE√ß√£o

Existem  muitos  algoritmos  para  executar  uma opera√ß√£o SELE√á√ÉO ,  que √© basicamente uma opera√ß√£o de pesquisa para localizar os registros em um arquivo de disco que satisfazem certa condi√ß√£o. Alguns dos algoritmos de pesquisa dependem de o arquivo ter caminhos de acesso espec√≠ficos, e eles s√≥ podem se aplicar a determinados tipos de condi√ß√µes de sele√ß√£o. Discutimos alguns dos algoritmos para implementar SELE√á√ÉO nesta se√ß√£o. Usaremos as opera√ß√µes a seguir, especificadas no banco de dados relacional da Figura 3.5, para ilustrar nossa discuss√£o:

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

M√©todos  de  pesquisa  para  sele√ß√£o  simples . Diversos algoritmos de pesquisa s√£o poss√≠veis para selecionar registros de um arquivo. Estes s√£o conhecidos como varreduras de arquivo porque varrem os registros de um arquivo para procurar e recuperar registros que satisfazem uma condi√ß√£o de sele√ß√£o. 4  Se o algoritmo de pesquisa envolve o uso de um √≠ndice, a pesquisa do √≠ndice √© denominada varredura de √≠ndice . Os m√©todos de pesquisa a seguir (S1 a S6) s√£o exemplos de alguns dos algoritmos de pesquisa que podem ser usados para implementar uma opera√ß√£o de sele√ß√£o:

- ¬Ñ S1 - Pesquisa linear (algoritmo de for√ßa bruta). Recupera cada registro no arquivo e testa se seus valores de atributo satisfazem a condi√ß√£o de sele√ß√£o. Como os registros s√£o agrupados em blocos de disco, cada um desses blocos √© lido para um buffer da mem√≥ria principal, e depois uma pesquisa pelos registros no bloco de disco √© realizada na mem√≥ria principal.
- ¬Ñ S2 - Pesquisa bin√°ria. Se a condi√ß√£o de sele√ß√£o envolver uma compara√ß√£o de igualdade em um atributo chave no qual o arquivo √© ordenado , a pesquisa bin√°ria - que √© mais eficiente do que a pesquisa linear - pode ser utilizada. Um exemplo √© OP1 se Cpf for o atributo de ordena√ß√£o para o arquivo FUNCIONARIO . 5

4 Uma opera√ß√£o de sele√ß√£o √†s vezes √© chamada de filtro , pois ela filtra os registros no arquivo que n√£o satisfazem a condi√ß√£o de sele√ß√£o.

5 Geralmente, a pesquisa bin√°ria n√£o √© usada em pesquisas de banco de dados porque os arquivos ordenados n√£o s√£o utilizados, a menos que tamb√©m tenham um √≠ndice prim√°rio correspondente.

- ¬Ñ S3a  -  Usando  um  √≠ndice  prim√°rio. Se  a condi√ß√£o de sele√ß√£o envolver uma compara√ß√£o de igualdade em um atributo chave com um √≠ndice  prim√°rio  -  por  exemplo, Cpf = '12345678966' em OP1 -, use o √≠ndice prim√°rio para recuperar o registro. Observe que essa condi√ß√£o recupera um √∫nico registro (no m√°ximo).
- ¬Ñ S3b  -  Usando  uma  chave  hash. Se  a  condi√ß√£o  de  sele√ß√£o  envolver  uma  compara√ß√£o de  igualdade  em  um atributo  chave com uma  chave  hash  -  por  exemplo, Cpf = '12345678966' em OP1 , use a chave hash para recuperar o registro. Observe que essa condi√ß√£o recupera um √∫nico registro (no m√°ximo).
- ¬Ñ S4  -  Usando  um  √≠ndice  prim√°rio  para  recuperar  v√°rios  registros. Se  a  condi√ß√£o  de compara√ß√£o  for &gt; &gt;= &lt; , , ou &lt;= em  um campo chave com um √≠ndice prim√°rio - por exemplo, Dnumero &gt; 5 em OP2 -, use o √≠ndice para encontrar o registro que satisfaz a condi√ß√£o de igualdade correspondente ( Dnumero = 5), depois recupere todos os registros subsequentes no arquivo (ordenado). Para a condi√ß√£o Dnumero &lt; 5, recupere todos os registros anteriores.
- ¬Ñ S5  -  Usando  um  √≠ndice  de  agrupamento para  recuperar  v√°rios  registros. Se  a  condi√ß√£o de sele√ß√£o envolver uma compara√ß√£o de igualdade em um atributo n√£o chave com um √≠ndice de agrupamento - por exemplo, Dnr = 5 em OP3 -, use o √≠ndice para recuperar todos os registros que satisfazem a condi√ß√£o.
- ¬Ñ S6 - Usando um √≠ndice secund√°rio (B -tree) + em uma compara√ß√£o de igualdade. Este m√©todo de pesquisa pode ser utilizado para recuperar um √∫nico registro se o campo de √≠ndice for uma chave (tiver valores √∫nicos) ou para recuperar m√∫ltiplos registros se o campo de √≠ndice n√£o for uma chave . Este tamb√©m pode ser  usado  para  compara√ß√µes  envolvendo &gt; , &gt;= &lt; , ou &lt;= .

Na Se√ß√£o 19.8, discutimos como desenvolver f√≥rmulas que estimam o custo de acesso desses m√©todos de pesquisa em rela√ß√£o ao n√∫mero de acessos de bloco e tempo de acesso. O m√©todo S1 ( pesquisa linear ) se aplica a qualquer arquivo, mas todos os outros m√©todos dependem de ter o caminho de acesso apropriado no atributo usado na condi√ß√£o de sele√ß√£o. O m√©todo

S2 ( pesquisa bin√°ria ) exige que o arquivo seja ordenado no atributo de pesquisa. Os m√©todos que usam um √≠ndice (S3a, S4, S5 e S6) geralmente s√£o conhecidos como pesquisas de √≠ndice , e exigem que exista um √≠ndice apropriado no atributo de pesquisa. Os m√©todos S4 e S6 podem ser usados para recuperar registros em certo intervalo - por exemplo, 30.000 &lt;= Salario &lt;= 35.000. As consultas que envolvem tais condi√ß√µes s√£o denominadas consultas de intervalo .

M√©todos de pesquisa para sele√ß√£o complexa . Se uma condi√ß√£o de uma opera√ß√£o SELE√á√ÉO for uma condi√ß√£o conjuntiva - ou seja, se ela for composta de v√°rias condi√ß√µes simples ligadas com o conectivo l√≥gico AND , como em OP4 acima -, o SGBD pode usar os seguintes m√©todos adicionais para implementar a opera√ß√£o:

- ¬Ñ S7  -  Sele√ß√£o  conjuntiva  usando  um  √≠ndice  individual. Se  um  atributo  envolvido  em qualquer condi√ß√£o simples isolada na condi√ß√£o de sele√ß√£o conjuntiva tiver um caminho de acesso que permita o uso de um dos m√©todos S2 a S6, use essa condi√ß√£o para recuperar os registros e depois verificar se cada registro recuperado satisfaz as condi√ß√µes simples restantes na condi√ß√£o de sele√ß√£o conjuntiva.
- ¬Ñ S8  -  Sele√ß√£o  conjuntiva  usando  um  √≠ndice composto. Se  dois  ou  mais  atributos  estiverem  envolvidos  nas  condi√ß√µes  de  igualdade na condi√ß√£o de sele√ß√£o conjuntiva e um √≠ndice composto (ou estrutura hash) existe nos campos combinados - por exemplo, se um √≠ndice  tiver  sido  criado  na  chave  composta ( Fcpf, Pnr )  do  arquivo TRABALHA\_EM para OP5 -, podemos usar o √≠ndice diretamente.
- ¬Ñ S9 - Sele√ß√£o conjuntiva por intersec√ß√£o de ponteiros de registro. 6 Se √≠ndices secund√°rios (ou  outros  caminhos  de  acesso)  estiverem dispon√≠veis em mais de um dos campos envolvidos em condi√ß√µes simples na condi√ß√£o de sele√ß√£o conjuntiva, e se os √≠ndices inclu√≠rem ponteiros de registro (em vez de ponteiros de bloco), ent√£o cada √≠ndice pode ser usado para recuperar o conjunto de ponteiros de registro que  satisfaz  a  condi√ß√£o  individual. A intersec√ß√£o desses conjuntos de ponteiros de registros gera os ponteiros de registro que satisfazem a condi√ß√£o de sele√ß√£o conjuntiva, que s√£o ent√£o usados para recuperar esses registros  diretamente. Se apenas algumas das

condi√ß√µes tiverem √≠ndices secund√°rios, cada registro  recuperado  √©  testado  ainda  mais para determinar se ele satisfaz as condi√ß√µes restantes. 7 Em  geral,  o  m√©todo  S9  assume que cada um dos √≠ndices est√° em um campo n√£o chave do  arquivo,  pois  se  uma  das condi√ß√µes  for  uma  condi√ß√£o  de  igualdade em um campo chave, somente um registro satisfar√° a condi√ß√£o inteira.

Sempre que uma √∫nica condi√ß√£o especifica a sele√ß√£o - como em OP1, OP2 ou OP3 , o SGBD s√≥ pode verificar se existe ou n√£o um caminho de acesso no atributo envolvido nessa condi√ß√£o. Se existir um caminho de acesso (como uma chave de √≠ndice ou hash ou um arquivo ordenado), o m√©todo correspondente a esse caminho de acesso √© utilizado. Caso contr√°rio, a t√©cnica de for√ßa bruta ou pesquisa linear de S1 pode ser usada. A otimiza√ß√£o de consulta para uma opera√ß√£o SELE√á√ÉO √©  necess√°ria principalmente para condi√ß√µes de sele√ß√£o conjuntivas sempre que mais de um dos atributos envolvidos nas condi√ß√µes tiver um caminho de acesso. O otimizador deve escolher o caminho de acesso que recupera menos registros da maneira mais eficiente, estimando os diferentes custos (ver Se√ß√£o 19.8) e escolhendo o m√©todo com o menor custo estimado.

Seletividade de uma condi√ß√£o . Quando o otimizador  est√°  escolhendo  entre  v√°rias  condi√ß√µes  simples em uma condi√ß√£o de sele√ß√£o conjuntiva, ele normalmente  considera  a seletividade de  cada  condi√ß√£o. A seletividade  ( sl ) √©  definida  como  a  raz√£o  entre  o n√∫mero de registros (tuplas) que satisfazem a condi√ß√£o e o n√∫mero total de registros (tuplas) no arquivo (rela√ß√£o), e, por isso, √© um n√∫mero entre zero e um. Seletividade zero significa que nenhum dos registros no arquivo satisfaz a condi√ß√£o de sele√ß√£o, e uma seletividade de um significa que todos os registros no arquivo satisfazem a condi√ß√£o. Em geral, a seletividade n√£o ser√° um desses dois extremos, mas uma fra√ß√£o que estima a porcentagem dos registros do arquivo a serem recuperados.

res distintos , s pode ser estimado por (| ( r R )|/ i )/| r R ( )| ou 1/ , supondo que os registros sejam igual ou i uniformemente distribu√≠dos entre os valores distintos. 8 Sob essa suposi√ß√£o, | ( r R )|/ i registros satisfar√£o uma condi√ß√£o  de  igualdade  nesse  atributo.  Em  geral,  o n√∫mero de registros  satisfazendo  uma  condi√ß√£o  de sele√ß√£o com seletividade sl √©  estimado como sendo | r R ( )| * sl. Quanto menor for essa estimativa, maior o desejo de usar tal condi√ß√£o primeiro para recuperar registros. Em certos casos, a distribui√ß√£o real dos registros entre os diversos valores distintos do atributo √© mantida pelo SGBD na forma de um histograma , a fim de obter estimativas mais precisas do n√∫mero de registros que satisfazem determinada condi√ß√£o.

Condi√ß√µes  de  sele√ß√£o  disjuntivas . Em  compara√ß√£o com uma condi√ß√£o de sele√ß√£o conjuntiva, uma condi√ß√£o disjuntiva (em  que  condi√ß√µes  simples  s√£o ligadas pelo conectivo l√≥gico OR em vez de AND )  √© muito mais dif√≠cil de processar e otimizar. Por exemplo, considere a OP4':

<!-- formula-not-decoded -->

Com tal condi√ß√£o, pouca otimiza√ß√£o pode ser feita, pois os registros que satisfazem a condi√ß√£o disjuntiva s√£o a uni√£o dos registros que satisfazem as condi√ß√µes individuais. Logo, se qualquer uma das condi√ß√µes n√£o tiver um caminho de acesso, somos atra√≠dos a usar a t√©cnica de for√ßa bruta, de pesquisa linear. Somente se  houver um caminho de acesso em cada condi√ß√£o simples na disjun√ß√£o √© que podemos otimizar a sele√ß√£o recuperando os registros que satisfazem cada condi√ß√£o - ou seus ids de registro - e depois aplicando a opera√ß√£o de uni√£o para eliminar duplicatas.

Um SGBD ter√° √† disposi√ß√£o muitos dos m√©todos j√° discutidos, e geralmente diversos m√©todos adicionais. O otimizador de consulta precisa escolher o m√©todo apropriado para executar cada opera√ß√£o SELE√á√ÉO em uma consulta. Essa otimiza√ß√£o usa f√≥rmulas que estimam os custos para cada m√©todo de acesso dispon√≠vel, conforme discutiremos na Se√ß√£o 19.8. O otimizador escolhe o m√©todo de acesso com o menor custo estimado.

Embora as seletividades exatas de todas as condi√ß√µes possam n√£o estar dispon√≠veis, estimativas de seletividades costumam ser mantidas no cat√°logo do SGBD e s√£o usadas pelo otimizador. Por exemplo, para  uma  condi√ß√£o  de  igualdade  em  um  atributo chave da rela√ß√£o r R ( ), s = 1/| r R ( )|,  onde  | r R ( )|  √©  o n√∫mero de tuplas na rela√ß√£o  ( r R ). Para uma condi√ß√£o de igualdade em um atributo n√£o chave com i valo-

## 19.3.2 mplementando a opera√ß√£o I JUN√ß√£o

A opera√ß√£o JUN√á√ÉO √©  uma  das  opera√ß√µes  mais demoradas no processamento da consulta. Muitas das opera√ß√µes  de  jun√ß√£o  encontradas  nas  consultas  s√£o das variedades EQUIJUN√á√ÉO e JUN√á√ÉO NATURAL , de modo que consideramos apenas essas duas aqui, pois

7 A t√©cnica pode ter muitas varia√ß√µes -por exemplo, se os √≠ndices forem √≠ndices l√≥gicos que armazenam valores de chave prim√°ria em vez de ponteiros de registro.

8 Em otimizadores mais sofisticados, histogramas que representam a distribui√ß√£o dos registros entre os diferentes valores de atributo podem ser mantidos no cat√°logo.

s√≥ estamos dando uma vis√£o geral do processamento e otimiza√ß√£o da consulta. Para o restante deste cap√≠tulo, o termo jun√ß√£o refere-se a uma EQUIJUN√á√ÉO (ou JUN√á√ÉO NATURAL ).

Existem muitas maneiras poss√≠veis de implementar  uma jun√ß√£o de duas vias ,  que  √©  uma  jun√ß√£o  em dois arquivos. As jun√ß√µes que envolvem mais de dois arquivos s√£o denominadas jun√ß√µes multivias .  O  n√∫mero de vias poss√≠veis  para  executar  jun√ß√µes  multivias cresce muito rapidamente. Nesta se√ß√£o, discutimos as t√©cnicas para implementar apenas jun√ß√µes de duas vias . Para ilustrar nossa discuss√£o, referimo-nos ao esquema relacional da Figura 3.5 mais uma vez especificamente, √†s rela√ß√µes FUNCIONARIO, DEPARTAMENTO e PROJETO . Os algoritmos que discutimos em seguida s√£o para uma opera√ß√£o de jun√ß√£o na forma:

<!-- formula-not-decoded -->

onde A e B s√£o  os atributos de jun√ß√£o ,  que devem ser atributos compat√≠veis por dom√≠nio de R e S , respectivamente. Os m√©todos que discutimos podem ser estendidos para formas mais gerais de jun√ß√£o. Ilustramos quatro das t√©cnicas  mais  comuns  para  realizar tal jun√ß√£o, usando as seguintes opera√ß√µes como exemplo:

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

## M√©todos para implementar jun√ß√µes

- ¬Ñ J1 - Jun√ß√£o de loop aninhado (ou jun√ß√£o de bloco  aninhado). Esse  √©  o  algoritmo  padr√£o (for√ßa bruta), pois n√£o exige quaisquer caminhos de acesso especiais em qualquer arquivo na  jun√ß√£o.  Para  cada  registro t em R (loop externo), recupere cada registro   de s S (loop interno) e teste se os dois registros satisfazem a condi√ß√£o de jun√ß√£o  [ t A ] = s B [ ]. 9
- ¬Ñ J2 - Jun√ß√£o de √∫nico loop (usando uma estrutura de acesso para recuperar os registros correspondentes). Se  houver  um  √≠ndice  (ou chave hash) para um dos dois atributos de jun√ß√£o - digamos, atributo B do arquivo S -, recupere cada registro t em R (loop no arquivo R ) e depois use a estrutura de acesso (como um √≠ndice ou uma chave hash) para recuperar  diretamente  todos  os  registros correspondentes s de S que satisfazem s B [ ] = t [ A ].
- ¬Ñ J3  -  Jun√ß√£o  ordena√ß√£o-intercala√ß√£o. Se  os registros de R e S estiverem fisicamente ordenados por  valor  dos  atributos  de  jun√ß√£o A e B , respectivamente,  podemos  implementar  a jun√ß√£o da maneira mais eficiente poss√≠vel. Os dois arquivos s√£o varridos simultaneamente na ordem dos atributos de jun√ß√£o, combinando os registros que t√™m os mesmos valores para A e B . Se os arquivos n√£o estiverem ordenados, eles podem s√™-lo, primeiro, usando a ordena√ß√£o externa (ver Se√ß√£o 19.2). Nesse m√©todo, pares de blocos de arquivo s√£o copiados para buffers de mem√≥ria na ordem e os registros de cada arquivo s√£o varridos apenas uma vez cada, para combinar com o outro arquivo - a menos que A e B sejam atributos n√£o chave, caso em que o m√©todo precisa ser ligeiramente modificado. Um esbo√ßo do algoritmo de jun√ß√£o ordena√ß√£o-intercala√ß√£o  aparece  na  Figura  19.3(a).  Usamos R i ( )  para  nos  referirmos  ao i -√©simo  registro no arquivo R .  Uma varia√ß√£o da jun√ß√£o ordena√ß√£o-intercala√ß√£o pode ser usada quando houver √≠ndices secund√°rios nos dois atributos de jun√ß√£o. Os √≠ndices oferecem a capacidade de acessar (varrer) os registros na ordem dos atributos de jun√ß√£o, mas os pr√≥prios registros est√£o fisicamente espalhados por todos os blocos do arquivo, de modo que esse m√©todo pode ser muito ineficaz, pois cada acesso a registro pode envolver o acesso a um bloco de disco diferente.
- ¬Ñ J4  -  Jun√ß√£o  de  parti√ß√£o-hash. Os registros dos  arquivos R e S s√£o  particionados  em arquivos menores. O  particionamento de cada  arquivo  √©  feito  usando  a  mesma  fun√ß√£o hashing h no atributo de jun√ß√£o A de R (para  o  particionamento  do  arquivo  R)  e B de S (para o particionamento do arquivo S). Primeiro, um √∫nico passo pelo arquivo com menos registros (digamos, R )  cria  hashes  de seus registros para as diversas parti√ß√µes de R; essa √© chamada fase de particionamento , pois os  registros  de R s√£o  particionados  nos  buckets  de  hash.  No  caso  mais  simples,  consideramos  que  o  arquivo  menor  pode  caber inteiramente na mem√≥ria principal depois de ser  particionado,  de  modo  que  os  subarquivos  particionados  de R s√£o  todos  mantidos na mem√≥ria principal. A cole√ß√£o de registros com  o  mesmo  valor  de h A ( )  √©  colocada  na mesma parti√ß√£o, que √© um bucket de hash em

9 Para arquivos de disco, √© √≥bvio que os loops ser√£o sobre blocos de disco, de modo que essa t√©cnica tamb√©m tem sido chamada de jun√ß√£o de bloco aninhado.

uma tabela hash na mem√≥ria principal. Na segunda fase, chamada fase de investiga√ß√£o , um √∫nico passo por outro arquivo ( S ) cria ent√£o o hash de cada um de seus registros usando a mesma fun√ß√£o de hash h B ( ) para investigar o bucket apropriado, e tal registro √© combinado com todos os registros correspondentes de R nesse bucket. Essa descri√ß√£o simplificada da jun√ß√£o de parti√ß√£o-hash pressup√µe que o menor  dos  dois  arquivos cabe  inteiramente nos buckets de mem√≥ria ap√≥s a primeira fase. Mais  adiante,  discutiremos  o  caso  geral  da jun√ß√£o de parti√ß√£o-hash que n√£o requer esse pressuposto. Na pr√°tica, as t√©cnicas de J1 a J4 s√£o implementadas ao acessar blocos de disco inteiros de um arquivo, em vez de registros individuais. Dependendo do n√∫mero dispon√≠vel de buffers na mem√≥ria, o n√∫mero de blocos lidos do arquivo pode ser ajustado.

Como o espa√ßo do buffer e a escolha do arquivo de loop externo afetam o desempenho da jun√ß√£o de  loop  aninhado. O  espa√ßo  dispon√≠vel  do  buffer tem um efeito importante em alguns dos algoritmos de jun√ß√£o. Primeiro, vamos considerar a t√©cnica de loop aninhado  (J1).  Examinando  novamente  a  opera√ß√£o OP6 , suponha que o n√∫mero de buffers dispon√≠veis na mem√≥ria principal para implementar a jun√ß√£o seja n B = 7 blocos (buffers). Lembre-se de que assumimos que cada buffer da mem√≥ria tem o mesmo tamanho de um bloco de disco. Por ilustra√ß√£o, suponha que o arquivo DEPARTAMENTO consista em r D = 50 registros armazenados em b D = 10 blocos de disco e que o arquivo FUNCIONARIO consista em r F = 6.000 registros armazenados em b F = 2.000 blocos de disco. √â vantajoso ler o m√°ximo de blocos poss√≠veis de uma s√≥ vez para a mem√≥ria com base no arquivo, cujos registros s√£o usados para o loop externo (ou seja, n B -2 blocos). O algoritmo pode ent√£o ler um bloco de cada vez para o arquivo de loop interno e usar seus registros

```
(a) ordena as tuplas em R sobre atributo A ; (* suponha que R tem n tuplas (registros) *) ordena as tuplas em S sobre atributo B ; (* suponha que S tem m tuplas (registros) *) atribua i ‚Üê 1, j ‚Üê 1; enquanto ( i ‚â§ n ) and ( j ‚â§ m ) fa√ßa {    se R i (   )[ A ] > S j (   )[ B ] ent√£o  atribua j ‚Üê + j 1 se n√£o se R i (   )[ A ] < S j (   )[ B ] ent√£o  atribua i ‚Üê + i 1 se n√£o  {      (* R i (   )[ A ] = S j (   )[ B ], de modo que enviamos uma tupla combinada *) envia a tupla combinada < R i (   ), S j (   ) > para T ; (* envia outras tuplas que combinam com R i ( ), se houver *) atribua I ‚Üê + j 1; enquanto ( l ‚â§ m ) and ( R  i ( )[ A ] = S l (   )[ B ]) fa√ßa { envia a tupla combinada < R i (   ), S l (   ) > para T ; atribua l ‚Üê + l 1 } (* envia outras tuplas que combinam com S j ( ), se houver *) atribua k ‚Üê + i 1; enquanto ( k ‚â§ n ) and ( R k ( )[ A ] = S j (   )[ B ]) fa√ßa {    envia a tupla combinada < R k ( ), S j (   ) > para T ; atribua k ‚Üê + k 1 } atribua i ‚Üê k , j ‚Üê l } }
```

( continua )

```
(   )  *)
```

```
(b) cria uma tupla  [ t < lista atributos > ] em T ' para cada tupla   em t R ; (* T '  cont√©m os resultados da proje√ß√£o antes da elimina√ß√£o de duplicatas *) se < lista atributos > inclui uma chave de R ent√£o T ‚Üê T ' se n√£o    {    ordena as tuplas em T ' ; atribua i ‚Üê 1, j ‚Üê 2; enquanto i ‚â§ n fa√ßa {    envia a tupla T ' [ i ]  para T ; enquanto T ' [ i ] = T ' [   ]  e j j ‚â§ n do j ‚Üê + j 1; (* elimina duplicatas *) i ‚Üê ; j j ‚Üê + i 1 } } (* T cont√©m o resultado da proje√ß√£o ap√≥s a elimina√ß√£o de tuplas *) (c) ordena as tuplas em R e S usando os mesmos atributos de ordena√ß√£o √∫nicos; atribua i ‚Üê 1, j ‚Üê 1; enquanto ( i ‚â§ n ) and ( j ‚â§ m ) fa√ßa { se R i (   ) > S j (   ) ent√£o { envia S j (   ) para T ; atribua j ‚Üê + j 1 } se n√£o se R i (   ) < S j (   ) ent√£o { envia R i (   ) para T ; atribua i ‚Üê + i 1 } se n√£o atribua j ‚Üê + j 1 (* Ri (  ) = S (   ), e pulamos uma das tuplas duplicadas *) j } se ( i ‚â§ n ) ent√£o acrescenta tuplas R i (   ) em R ( n ) para T ; se ( j ‚â§ m ) ent√£o acrescenta tuplas S j (   ) em S m ( ) para T ; (d) ordena as tuplas em R e S usando os mesmos atributos de ordena√ß√£o √∫nicos; atribua i ‚Üê 1, j ‚Üê 1; enquanto ( i ‚â§ n ) and ( j ‚â§ m ) fa√ßa {    se R i (   ) > S j (   ) ent√£o  atribua j ‚Üê + j 1 se n√£o se R i (   ) < S j (   ) ent√£o atribua i ‚Üê + i 1 se n√£o    {    envia R j (   )  para T ; (* R i (   ) = S j (   ), de modo que enviamos a tupla *) atribua i ‚Üê + i 1, j ‚Üê + j 1 } } (e) ordena as tuplas em R e S usando os mesmos atributos de ordena√ß√£o √∫nicos; atribua i ‚Üê 1, j ‚Üê 1; enquanto ( i ‚â§ n ) and ( j ‚â§ m ) fa√ßa {    se R i (   ) > S j ( ) ent√£o atribua j ‚Üê + j 1 se n√£o se R i ( ) < S j (   ) ent√£o   {    envia R i (   )  para T ; (* R i (   ) n√£o tem S j (   ) combinando, e enviamos R i atribua i ‚Üê + i 1 } se n√£o    atribua i ‚Üê + i 1, j ‚Üê + j 1 } se ( i ‚â§ n ) ent√£o acrescenta tuplas R i (   )  em R ( n )  para T ;
```

para investigar (ou seja, pesquisar) os blocos do loop externo  que  est√£o  atualmente  na  mem√≥ria  principal para combina√ß√£o dos registros. Isso reduz o n√∫mero total de acessos a bloco. Um buffer extra na mem√≥ria principal √© necess√°rio para conter os registros resultantes ap√≥s serem juntados, e o conte√∫do desse buffer de resultado pode ser anexado ao arquivo de resultado - o arquivo de disco que conter√° o resultado da jun√ß√£o - sempre que ele for preenchido. Esse bloco de buffer de resultado √© ent√£o reutilizado para manter registros adicionais de resultado de jun√ß√£o.

Na jun√ß√£o de loop aninhado, faz diferen√ßa qual arquivo  √©  escolhido  para  o  loop  externo  e  qual  o  √© para o loop interno. Se FUNCIONARIO for usado para o loop externo, cada bloco de FUNCIONARIO √© lido uma vez, e o arquivo DEPARTAMENTO inteiro (cada um de seus blocos) √© lido uma vez para cada vez que lemos ( n B -2)  blocos  do  arquivo FUNCIONARIO .  Obtemos as seguintes f√≥rmulas para o n√∫mero de blocos de disco que s√£o lidos do disco para a mem√≥ria principal:

N√∫mero total de blocos acessados (lidos) para o arquivo de loop externo = b F

N√∫mero de vezes ( n B - 2) que os blocos do arquivo  externo  s√£o  carregados  para  a  mem√≥ria principal = Ô£Æ b F /( n B -2) Ô£π

N√∫mero total de blocos acessados (lidos) para o arquivo de loop interno = b D * Ô£Æ b F /( n B -2) Ô£π

Logo, obtemos o seguinte n√∫mero total de acessos para leitura de bloco:

b F + Ô£Æ ( b F /( n B -2) Ô£π * b D ) = 2.000 + Ô£Æ (   (2.000/5) Ô£π * 10) = 6.000 acessos de bloco

Por sua vez, se usarmos os registros de DEPARTAMENTO no loop externo, por simetria, obtemos o seguinte n√∫mero total de acessos de bloco:

b D + Ô£Æ ( b D /( n B -2) Ô£π * b F ) = 10 + Ô£Æ (   (10/5) Ô£π * 2.000) = 4.010 acessos de bloco

O algoritmo de jun√ß√£o usa um buffer para manter  os  registros  juntados  do  arquivo  de  resultado. Quando o buffer estiver preenchido, ele ser√° gravado no disco e seu conte√∫do anexado ao arquivo de resultado,  e  depois  preenchido  novamente  com  os registros do resultado da jun√ß√£o. 10

desenvolvidas  mais  adiante  para  outros  algoritmos de jun√ß√£o. Como este exemplo mostra, √© vantajoso usar o arquivo com menos blocos como arquivo de loop externo na jun√ß√£o de loop aninhado.

Como o fator de sele√ß√£o de jun√ß√£o afeta o desempenho da jun√ß√£o. Outro fator que afeta o desempenho de uma jun√ß√£o, particularmente o m√©todo de √∫nico loop J2, √© a fra√ß√£o de registros em um arquivo que ser√° juntada com registros no outro arquivo. Chamamos isso de fator de sele√ß√£o de jun√ß√£o 11 de um arquivo em rela√ß√£o a uma condi√ß√£o de equijun√ß√£o com outro arquivo. Esse fator depende da condi√ß√£o de equijun√ß√£o em particular entre os dois arquivos. Para ilustrar isso, considere a opera√ß√£o OP7, que junta cada registro de DEPARTAMENTO com o registro de FUNCIONARIO para o gerente desse departamento. Aqui, cada registro de DEPARTAMENTO (existem 50 desses registros em nosso exemplo) ser√° juntado a um √∫nico registro de FUNCIONARIO , mas muitos registros de FUNCIONARIO (os 5.950 deles, que n√£o gerenciam um departamento) n√£o ser√£o juntados com qualquer registro de DEPARTAMENTO.

Suponha  que  existam  √≠ndices  secund√°rios  nos atributos Cpf de FUNCIONARIO e Cpf\_ger de DEPARTAMENTO , com o n√∫mero de n√≠veis de √≠ndice x Cpf = 4 e x Cpf\_ger = 2, respectivamente. Temos duas op√ß√µes para implementar o m√©todo J2. A primeira recupera cada registro de FUNCIONARIO e depois usa o √≠ndice em Cpf\_ger de DEPARTAMENTO para encontrar um registro  de DEPARTAMENTO correspondente.  Nesse caso, nenhum registro combinando ser√° encontrado para  funcion√°rios  que  n√£o  gerenciam  um  departamento. O n√∫mero de acessos de bloco para esse caso √© aproximadamente:

b F + ( r F * ( x Cpf\_ger + 1)) = 2.000 + (6.000 * 3) = 20.000 acessos de bloco

A  segunda  op√ß√£o  recupera  cada  registro  de DEPARTAMENTO e  depois  usa  o  √≠ndice  em Cpf de FUNCIONARIO para  encontrar  um registro de FUNCIONARIO gerente correspondente. Nesse caso, cada registro de DEPARTAMENTO ter√° um registro de FUNCIONARIO correspondente. O n√∫mero de acessos de bloco para esse caso √© aproximadamente:

Se o arquivo de resultado da opera√ß√£o de jun√ß√£o tem b RES blocos de disco, cada bloco √© gravado uma vez no disco, de modo que b RES acessos de bloco (grava√ß√µes) adicionais devem ser acrescentados √†s f√≥rmulas anteriores a fim de estimar o custo total da opera√ß√£o de jun√ß√£o. O mesmo vale para as f√≥rmulas b D + ( r D * ( x Cpf + 1)) = 10 + (50 * 5) = 260 acessos de bloco

A segunda op√ß√£o √© mais eficiente porque o fator de sele√ß√£o de jun√ß√£o de DEPARTAMENTO em rela√ß√£o √† condi√ß√£o de jun√ß√£o Cpf = Cpf\_ger √© 1 (cada registro em DEPARTAMENTO ser√° juntado), enquanto o fator

10 Se reservarmos dois buffers para o arquivo de resultado, o buffering duplo pode ser usado para agilizar o algoritmo (ver Se√ß√£o 17.3).

11 Isso √© diferente da seletividade de jun√ß√£o , que discutiremos na Se√ß√£o 19.8.

de sele√ß√£o de jun√ß√£o de FUNCIONARIO em rela√ß√£o √† mesma  condi√ß√£o  de  jun√ß√£o  √©  (50/6.000),  ou  0,008 (apenas 0,8 por cento dos registros em FUNCIONARIO ser√£o juntados). Para o m√©todo J2, o menor arquivo ou o arquivo que tem uma correspond√™ncia para cada registro (ou seja, o arquivo com o fator de sele√ß√£o de jun√ß√£o alto) deve ser usado no (√∫nico) loop de jun√ß√£o. Tamb√©m  √©  poss√≠vel  criar  um  √≠ndice  especificamente para realizar a opera√ß√£o de jun√ß√£o se ainda n√£o houver um.

A  jun√ß√£o  ordena√ß√£o-intercala√ß√£o  J3  √©  muito eficiente se os dois arquivos j√° estiverem ordenados por seu atributo de jun√ß√£o. Somente um √∫nico passo √© feito em cada arquivo. Logo, o n√∫mero de blocos acessados √© igual √† soma dos n√∫meros de blocos nos dois arquivos. Para esse m√©todo, tanto OP6 quanto OP7 precisariam de b F + b D = 2.000 + 10 = 2.010 acessos de bloco. No entanto, os dois arquivos precisam estar ordenados pelos atributos de jun√ß√£o; se um ou ambos n√£o estiverem, deve ser criada uma c√≥pia ordenada de cada arquivo especificamente para realizar a opera√ß√£o de jun√ß√£o. Se estimarmos aproximadamente o custo de ordena√ß√£o de um arquivo externo por ( b log 2 b ) acessos de bloco, e se os dois arquivos precisarem ser ordenados, o custo total de uma jun√ß√£o ordena√ß√£o-intercala√ß√£o pode ser estimado por ( b F + b D + b F log 2 b F + b D log 2 b D ). 12

Caso geral para a jun√ß√£o de parti√ß√£o-hash. O m√©todo de jun√ß√£o de hash J4 tamb√©m √© bastante eficiente. Nesse caso, apenas um √∫nico passo √© feito em cada arquivo, estejam os arquivos ordenados ou n√£o. Se a tabela hash para o menor dos dois arquivos puder ser mantida na mem√≥ria principal ap√≥s o hashing (particionamento)  em  seu  atributo  de  jun√ß√£o,  a  implementa√ß√£o √© simples. Por√©m, se as parti√ß√µes de ambos os arquivos tiverem de ser armazenadas em disco, o m√©todo torna-se mais complexo, e diversas varia√ß√µes para melhorar a efici√™ncia foram propostas. Discutimos duas t√©cnicas: o caso geral de jun√ß√£o de parti√ß√£o-hash e uma varia√ß√£o chamada algoritmo h√≠brido de jun√ß√£o de hash , que demonstrou ser muito eficiente.

No caso geral da jun√ß√£o de parti√ß√£o-hash , cada arquivo √© primeiro particionado em M partes usando a mesma fun√ß√£o hash de particionamento nos  atributos de jun√ß√£o. Depois, cada par de parti√ß√µes correspondentes √© juntado. Por exemplo, suponha que estejamos juntando rela√ß√µes R e S nos atributos de jun√ß√£o R A . e S B . :

Na fase  de  particionamento , R √©  particionado nas M parti√ß√µes R 1 , R 2 , ..., R M , e S nas M parti√ß√µes S 1 , S 2 , ..., S M . A propriedade de cada par de parti√ß√µes correspondentes R i , S i em rela√ß√£o √† opera√ß√£o de jun√ß√£o √© que os registros em R i s√≥ precisam ser juntados com registros em S i , e vice-versa. Essa propriedade √© garantida usando a mesma fun√ß√£o hash para particionar os dois arquivos em seus atributos de jun√ß√£o - atributo A para R e atributo B para S . O n√∫mero m√≠nimo de buffers na mem√≥ria necess√°rios para a fase de particionamento √© M + 1.  Cada um dos arquivos R e S √© particionado separadamente. Durante o particionamento de um arquivo, M buffers na mem√≥ria s√£o alocados para armazenar os registros que criam hash para cada parti√ß√£o, e um buffer adicional √© necess√°rio para manter um bloco de cada vez do arquivo de entrada que est√° sendo particionado. Sempre que o buffer na mem√≥ria para uma parti√ß√£o √© preenchido, seu conte√∫do √© anexado a um subarquivo de disco que armazena a parti√ß√£o. A fase de particionamento tem duas itera√ß√µes . Ap√≥s a primeira itera√ß√£o, o primeiro arquivo R √© particionado nos subarquivos R 1 , R 2 , ..., R M , nos quais todos os registros que tiveram hash para o mesmo buffer est√£o na mesma parti√ß√£o. Ap√≥s a segunda itera√ß√£o, o segundo arquivo S √© particionado de modo semelhante.

Na  segunda  fase,  chamada fase  de  jun√ß√£o ou investiga√ß√£o , M itera√ß√µes s√£o necess√°rias. Durante a itera√ß√£o  , duas parti√ß√µes correspondentes i R i e S i s√£o juntadas. O n√∫mero m√≠nimo de buffers necess√°rios para a itera√ß√£o   √© o n√∫mero de blocos na menor das i duas parti√ß√µes, digamos R i , mais dois buffers adicionais. Se usarmos uma jun√ß√£o de loop aninhado durante a itera√ß√£o  , os registros da menor das duas i parti√ß√µes R i s√£o copiados para buffers da mem√≥ria; depois, todos os blocos da outra parti√ß√£o S i s√£o lidos - um de cada vez - e cada registro √© usado para investigar (ou seja, pesquisar) a parti√ß√£o R i em busca  de  registro(s)  correspondente(s).  Quaisquer registros correspondentes s√£o juntados e gravados no arquivo de resultado. Para melhorar a efici√™ncia da investiga√ß√£o na mem√≥ria, √© comum usar uma tabela hash na mem√≥ria para armazenar os registros na parti√ß√£o R i usando uma fun√ß√£o hash diferente da fun√ß√£o hash de particionamento. 13

<!-- formula-not-decoded -->

Podemos aproximar o custo dessa jun√ß√£o de parti√ß√£o-hash como 3   ( * b R + b S ) + b RES para nosso exemplo, pois cada registro √© lido uma vez e gravado de volta no disco uma vez durante a fase de particionamento. No decorrer da fase de jun√ß√£o (investiga√ß√£o),

12 Podemos usar as f√≥rmulas mais exatas da Se√ß√£o 19.2 se soubermos o n√∫mero de buffers dispon√≠veis para ordena√ß√£o.

13 Se a fun√ß√£o hash para o particionamento for usada novamente, todos os registros em uma parti√ß√£o criar√£o hash para o mesmo bucket novamente.

cada registro √© lido uma segunda vez para realizar a jun√ß√£o. A principal dificuldade desse algoritmo √© garantir que a fun√ß√£o hash de particionamento seja uniforme - ou seja, os tamanhos de parti√ß√£o s√£o quase iguais em tamanho. Se a fun√ß√£o de particionamento for viesada (n√£o uniforme), ent√£o algumas parti√ß√µes podem ser muito grandes para caber no espa√ßo de mem√≥ria dispon√≠vel para a segunda fase de jun√ß√£o.

Observe que, se o espa√ßo de buffer dispon√≠vel na mem√≥ria n B &gt; ( b R + 2), onde b R √© o n√∫mero de blocos para o menor dos dois arquivos sendo juntados, digamos, R , ent√£o n√£o existe motivo para realizar o particionamento, pois nesse caso a jun√ß√£o pode ser realizada inteiramente na mem√≥ria, usando alguma varia√ß√£o  da  jun√ß√£o  de  loop  aninhado  baseada  no hashing e na investiga√ß√£o.

Por exemplo, suponha que estejamos realizando a opera√ß√£o de jun√ß√£o OP6, repetida a seguir:

<!-- formula-not-decoded -->

Nesse  exemplo,  o  arquivo  menor  √©  o  arquivo DEPARTAMENTO ;  logo,  se  o  n√∫mero  de  buffers  de mem√≥ria dispon√≠veis n B &gt; ( b D + 2),  o  arquivo DEPARTAMENTO inteiro poder√° ser lido para a mem√≥ria principal e organizado em uma tabela hash no atributo de jun√ß√£o. Cada bloco de FUNCIONARIO √© ent√£o lido para um buffer, e cada registro de FUNCIONARIO no  buffer  tem  um  hash  em  seu  atributo  de  jun√ß√£o e  √©  usado  para investigar o  bucket  correspondente na  mem√≥ria,  na  tabela  hash DEPARTAMENTO .  Se um registro  correspondente  for  achado,  os  registros  s√£o  juntados,  e  os  registros  do  resultado  s√£o gravados no buffer de resultado e, por fim, no arquivo de resultado em disco. O custo em termos de acessos de bloco √©, portanto, ( b D + b F ), mais b RES - o custo de gravar o arquivo de resultado.

Jun√ß√£o de hash h√≠brida. O algoritmo jun√ß√£o hash h√≠brido √© uma varia√ß√£o de parti√ß√£o de jun√ß√£o hash, em que a fase de jun√ß√£o para uma das parti√ß√µes est√° inclu√≠da  na  fase  de particionamento .  Para  ilustrar isso, vamos supor que o tamanho de um buffer de mem√≥ria seja um bloco de disco; que n B de tais bu  ffers estejam dispon√≠veis ; e que a fun√ß√£o hash de particionamento utilizada seja h K ( ) = K mod M ,  de modo que M parti√ß√µes  estejam  sendo  criadas,  onde M &lt; n B . Por exemplo, suponha que estejamos realizando a opera√ß√£o de jun√ß√£o OP6. No primeiro passo da fase de particionamento, quando o algoritmo h√≠brido de jun√ß√£o hash est√° particionando o menor dos dois arquivos ( DEPARTAMENTO em OP6) , o algoritmo divide o espa√ßo do buffer entre as M parti√ß√µes de modo que todos os blocos da primeira parti√ß√£o de DEPARTAMENTO residam completamente na mem√≥ria principal. Para cada uma das outras parti√ß√µes, somente um √∫nico buffer na mem√≥ria - cujo tamanho √© de um bloco de disco - √© alocado; o restante da parti√ß√£o √© gravado em disco, como na jun√ß√£o normal de parti√ß√£o-hash. Logo, ao final do primeiro passo da fase de particionamento , a primeira parti√ß√£o de DEPARTAMENTO reside  inteiramente  na  mem√≥ria principal, enquanto cada uma das outras parti√ß√µes de DEPARTAMENTO reside  em  um  subarquivo  do disco.

Para o segundo passo da fase de particionamento, os registros do segundo arquivo sendo juntado - o arquivo maior, FUNCIONARIO em OP6 - est√£o sendo particionados. Se um registro gera um hash para a primeira parti√ß√£o , ele √© juntado com o registro correspondente em DEPARTAMENTO e os registros juntados s√£o gravados no buffer de resultado (e, por fim, no disco). Se um registro de FUNCIONARIO gera um hash para uma parti√ß√£o que n√£o seja a primeira, ele √© particionado normalmente e armazenado no disco. Logo, ao final do segundo passo da fase de particionamento, todos os registros que geram hash para a primeira parti√ß√£o foram juntados. Nesse ponto, existem M -1  pares  de  parti√ß√µes  no  disco.  Portanto, durante a segunda fase de jun√ß√£o ou investiga√ß√£o , M -1 itera√ß√µes s√£o necess√°rias, em vez de M . O objetivo √© juntar o m√°ximo de registros durante a fase de particionamento de modo a economizar o custo de armazenar esses registros no disco e depois l√™-los pela segunda vez durante a fase de jun√ß√£o.

## 19.4 Algoritmos para opera√ß√µes PROJE√á√ÉO e de conjunto

Uma  opera√ß√£o PROJE√á√ÉO ùõë &lt; lista atributos &gt; ( R ) √© simples de se implementar se &lt; lista  atributos &gt; incluir uma chave da rela√ß√£o R , pois nesse caso o resultado da opera√ß√£o ter√° o mesmo n√∫mero de tuplas que R ,  mas com apenas os valores para os atributos  em &lt; lista  atributos &gt; em  cada  tupla.  Se &lt; lista atributos &gt; n√£o  incluir  uma  chave  de R ,  as tuplas duplicadas devem ser eliminadas . Isso pode ser feito ao ordenar o resultado da opera√ß√£o e depois ao eliminar tuplas duplicadas, que aparecem consecutivamente ap√≥s a ordena√ß√£o. Um esbo√ßo do algoritmo aparece na Figura 19.3(b). O hashing tamb√©m pode ser usado para eliminar duplicatas: √† medida que cada registro gera um hash e √© inserido em um bucket do arquivo hash na mem√≥ria, ele √© comparado com os registros que j√° est√£o no bucket; se for uma duplicata, ele n√£o √© inserido no bucket. √â √∫til lembrar  aqui  que,  nas  consultas  SQL,  o  padr√£o  √© n√£o  eliminar  duplicatas  do  resultado  da  consulta; estas s√≥ s√£o eliminadas do resultado da consulta se a palavra-chave DISTINCT for inclu√≠da.

Opera√ß√µes  de  conjunto  UNI√ÉO, INTERSEC√á√ÉO, DIFEREN√áA DE CONJUNTO e PRODUTO CARTESIANO -  √†s  vezes  s√£o  dispendiosas  de  se  implementar.  Em  particular,  a  opera√ß√£o  de PRODUTO CARTESIANO R √ó S √© muito dispendiosa porque seu resultado inclui um registro para cada combina√ß√£o de registros de R e S . Al√©m disso, cada registro no resultado inclui todos os atributos de R e S . Se R tem n registros e   atributos, e j S tem m registros e k atributos, a rela√ß√£o de resultado para R √ó S ter√° n * m registros e cada registro ter√° j + k atributos. Logo, √© importante evitar  a  opera√ß√£o PRODUTO CARTESIANO e  substitu√≠-la por outras opera√ß√µes, como a jun√ß√£o, durante a otimiza√ß√£o da consulta (ver Se√ß√£o 19.7).

As outras tr√™s opera√ß√µes de conjunto UNI√ÉO, INTERSEC√á√ÉO e DIFEREN√áA DE CONJUNTO 14 - s√≥ se aplicam a rela√ß√µes compat√≠veis no tipo (ou compat√≠veis na uni√£o), que t√™m o mesmo n√∫mero de atributos e os mesmos dom√≠nios de atributo. O modo comum de implementar essas opera√ß√µes √© usar varia√ß√µes da t√©cnica de ordena√ß√£o-intercala√ß√£o :  as duas rela√ß√µes s√£o ordenadas nos mesmos atributos e, depois da ordena√ß√£o, uma √∫nica varredura por cada rela√ß√£o √© suficiente para produzir o resultado. Por exemplo, podemos implementar a opera√ß√£o UNI√ÉO , R ‚à™ S , varrendo e intercalando os dois arquivos ordenados simultaneamente, e, sempre que a mesma tupla existir nas duas rela√ß√µes, apenas uma √© mantida no resultado intercalado. Para a opera√ß√£o INTERSEC√á√ÉO , R ‚à© S ,  mantemos no resultado intercalado somente as tuplas que aparecem nas duas rela√ß√µes ordenadas . Da Figura 19.3(c) at√© a (e) h√° um esbo√ßo da implementa√ß√£o dessas opera√ß√µes pela  ordena√ß√£o  e  intercala√ß√£o.  Alguns  dos  detalhes n√£o est√£o inclu√≠dos nesses algoritmos.

O hashing tamb√©m  pode  ser  usado  para  implementar UNI√ÉO, INTERSEC√á√ÉO e DIFEREN√áA DE CONJUNTO. Primeiro, uma tabela √© varrida e depois particionada em uma tabela hash na mem√≥ria com buckets, e os registros na outra tabela s√£o ent√£o varridos um de cada vez e usados para investigar a parti√ß√£o apropriada. Por exemplo, para implementar R ‚à™ S , primeiro crie o hash (particione) dos registros de R ; depois, use o hash (investigue) dos registros de S , mas n√£o insira registros duplicados nos buckets. Para implementar R ‚à© S , primeiro particione os registros de R para o arquivo hash. Depois, enquanto realiza o hashing de cada registro de S , investigue para verificar se um registro id√™ntico de R existe no bucket e, se houver, acrescente o registro no arquivo de resultado. Para implementar R -S , primeiro crie o hash dos registros de R para os buckets do arquivo hash. Ao realizar o hashing de (investigar) cada registro de

14 DIFEREN√áA DE CONJUNTO √© chamada de EXCEPT em SQL.

S , se um registro id√™ntico for encontrado no bucket, remova esse registro do bucket.

Em SQL, existem duas varia√ß√µes dessas opera√ß√µes de conjunto. As opera√ß√µes UNION, INTERSECTION e EXCEPT (a  palavra-chave  SQL  para  a  opera√ß√£o SET  DIFFERENCE ) se  aplicam  a  conjuntos tradicionais,  onde  n√£o  existe  registro  duplicado  no resultado. As opera√ß√µes UNION ALL, INTERSECTION ALL e EXCEPT ALL se aplicam a multiconjuntos (ou bags),  e  as  duplicatas  s√£o  totalmente  consideradas. As varia√ß√µes dos algoritmos citados podem ser usadas  para  as  opera√ß√µes  de  multiconjunto  em  SQL. Deixamos estas como um exerc√≠cio para o leitor.

## 19.5 mplementando opera√ß√µes de I agrega√ß√£o e JUN√á√ÉO EXTERNA

## 19.5.1 mplementando opera√ß√µes I de agrega√ß√£o

Os operadores de agrega√ß√£o ( MIN, MAX, COUNT, AVERAGE, SUM ), quando aplicados a uma tabela inteira, podem ser calculados por uma varredura de tabela ou usando um √≠ndice apropriado, se houver. Por exemplo, considere a seguinte consulta SQL:

## SELECT MAX ( Salario ) FROM FUNCIONARIO ;

Se  houver  um  √≠ndice  de  B + -tree  (crescente)  em Salario para a rela√ß√£o FUNCIONARIO , ent√£o o otimizador pode decidir sobre o uso do √≠ndice Salario para procurar o maior valor de Salario no √≠ndice, seguindo o ponteiro mais √† direita em cada n√≥ √≠ndice da raiz at√© a folha mais √† direita. Esse n√≥ incluiria o maior valor de Salario como sua √∫ltima entrada. Na maioria dos casos, isso seria mais eficiente do que uma varredura  completa  da  tabela FUNCIONARIO, pois  nenhum registro real precisa ser recuperado. A fun√ß√£o MIN pode ser tratada de maneira semelhante, com a exce√ß√£o de que o ponteiro mais √† esquerda no √≠ndice √© seguido da raiz at√© a folha mais √† esquerda. Esse n√≥ incluiria o menor valor de Salario como sua primeira entrada.

O √≠ndice tamb√©m poderia ser usado para as fun√ß√µes de agrega√ß√£o AVERAGE e SUM , mas somente se for um √≠ndice denso - ou seja, se houver uma entrada de √≠ndice para cada registro no arquivo principal. Nesse caso, o c√°lculo associado seria aplicado aos valores no √≠ndice. Para um √≠ndice n√£o denso , o n√∫mero real de registros associados a cada valor de √≠ndice  deve  ser  utilizado  para  um  c√°lculo  correto.

Isso  pode  ser  feito  se  o n√∫mero de registros associados a cada valor no  √≠ndice  for  armazenado  em cada entrada de √≠ndice. Para a fun√ß√£o de agrega√ß√£o COUNT , o n√∫mero de valores tamb√©m pode ser calculado com base no √≠ndice de modo semelhante. Se uma fun√ß√£o COUNT ( * )  for  aplicada a uma rela√ß√£o inteira, o n√∫mero de registros atualmente em cada rela√ß√£o costuma ser armazenado no cat√°logo e, portanto, o resultado pode ser recuperado diretamente do cat√°logo.

Quando uma cl√°usula GROUP BY √©  usada  em uma  consulta,  o  operador  de  agrega√ß√£o  deve  ser aplicado separadamente a cada grupo de tuplas, conforme  particionado  pelo  atributo  de  agrupamento. Logo, a tabela precisa primeiro ser particionada em subconjuntos de tuplas, nos quais cada parti√ß√£o (grupo) tem o mesmo valor para os atributos de agrupamento. Nesse caso, o c√°lculo √© mais complexo. Considere a seguinte consulta:

SELECT Dnr , AVG ( Salario ) FROM FUNCIONARIO

GROUP BY Dnr ;

A t√©cnica comum para tais consultas √© primeiro usar a ordena√ß√£o ou o hashing nos atributos de agrupamento para particionar o arquivo nos grupos apropriados. Depois, o algoritmo calcula a fun√ß√£o de agrega√ß√£o para as tuplas em cada grupo, que t√™m o mesmo valor de atributo(s) de agrupamento. Na consulta de exemplo, o conjunto de tuplas de FUNCIONARIO para cada n√∫mero de departamento seria agrupado em uma parti√ß√£o e o sal√°rio m√©dio, calculado para cada grupo.

Observe  que,  se  houver  um √≠ndice  de  agrupamento (ver  Cap√≠tulo  18)  no(s)  atributo(s)  de  agrupamento,  ent√£o  os  registros j√°  est√£o  particionados (agrupados)  nos  subconjuntos  apropriados.  Nesse caso, s√≥ √© preciso aplicar o c√°lculo a cada grupo.

## 19.5.2 Implementando JUN√ß√£o EXTERNA

Na Se√ß√£o 6.4, a opera√ß√£o de jun√ß√£o externa foi discutida, com suas tr√™s varia√ß√µes: jun√ß√£o externa esquerda ( left outer join ), jun√ß√£o externa direita ( right outer  join )  e  jun√ß√£o  externa  completa  ( full  outer join ). Tamb√©m discutimos, no Cap√≠tulo 5, como essas opera√ß√µes podem ser especificadas em SQL. A seguir vemos um exemplo de uma opera√ß√£o de jun√ß√£o externa esquerda em SQL:

SELECT Unome  Pnome  Dnome , , FROM ( FUNCIONARIO LEFT  OUTER  JOIN DEPARTAMENTO ON Dnr = Dnumero );

O resultado dessa consulta √© uma tabela de nomes de funcion√°rio e seus departamentos associados. Ele  √©  semelhante  ao  resultado  de  uma  jun√ß√£o  nor- mal (interna), com a exce√ß√£o de que, se uma tupla de FUNCIONARIO (uma tupla na rela√ß√£o esquerda ) n√£o tiver  um  departamento  associado ,  o  nome  do  funcion√°rio ainda aparecer√° na tabela resultante, mas o nome do departamento seria NULL para tais tuplas no resultado da consulta.

A jun√ß√£o externa pode ser calculada modificando-se um dos algoritmos de jun√ß√£o, como a jun√ß√£o de loop aninhado ou a jun√ß√£o de √∫nico loop. Por exemplo, para calcular uma jun√ß√£o externa esquerda ,  usamos a rela√ß√£o esquerda como loop externo ou √∫nico loop, pois cada tupla na rela√ß√£o esquerda deve aparecer no resultado. Se houver tuplas correspondentes  na  outra  rela√ß√£o,  as  tuplas  juntadas s√£o produzidas e salvas no resultado. Contudo, se nenhuma  tupla  correspondente  for  encontrada,  a tupla ainda √© inclu√≠da no resultado, mas √© preenchida com valor(es) NULL .  Os algoritmos ordena√ß√£o-intercala√ß√£o e jun√ß√£o hash tamb√©m podem ser estendidos para calcular jun√ß√µes externas.

Teoricamente, a jun√ß√£o externa tamb√©m pode ser calculada ao executar uma combina√ß√£o de operadores da √°lgebra relacional. Por exemplo, a opera√ß√£o de jun√ß√£o externa √† esquerda, mostrada acima, √© equivalente √† seguinte sequ√™ncia de opera√ß√µes relacionais:

- 1. Calcule a JUN√á√ÉO (interna) das tabelas FUNCIONARIO   DEPARTAMENTO e .
- TEMP1 ‚Üê ùõë Unome   Pnome   Dnome , , ( FUNCIONARIO /triangleleft /triangleright Dnr = DnumeroDEPARTAMENTO )
- 2. Ache  as  tuplas  de FUNCIONARIO que  n√£o aparecem no resultado da JUN√á√ÉO (interna). TEMP2 ‚Üê ùõë Unome   Pnome , ( FUNCIONARIO ) -ùõë Unome, Pnome ( TEMP1 )
- 3. Preencha cada tupla em TEMP2 com um campo Dnome NULL . TEMP2 ‚Üê TEMP2 √ó NULL
- 4. Aplique a opera√ß√£o UNION a TEMP1 TEMP2 , para produzir o resultado JUN√á√ÉO EXTERNA A ESQUERDA .

RESULT ‚Üê TEMP1 ‚à™ TEMP2

O custo da jun√ß√£o externa, conforme calculado anteriormente, seria a soma dos custos das etapas associadas (jun√ß√£o interna, proje√ß√µes, diferen√ßa de conjunto  e  uni√£o).  Por√©m,  observe  que  a  etapa  3 pode ser feita enquanto a rela√ß√£o tempor√°ria est√° sendo constru√≠da na etapa 2; ou seja, podemos simplesmente preencher cada tupla resultante com um NULL . Al√©m disso, na etapa 4, sabemos que os dois operandos da uni√£o s√£o disjuntos (sem tuplas comuns), de modo que n√£o h√° necessidade de elimina√ß√£o de duplicatas.

## 19.6 Combinando opera√ß√µes com pipelining

Uma consulta especificada em SQL normalmente ser√° traduzida para uma express√£o da √°lgebra relacional que √© uma sequ√™ncia de opera√ß√µes relacionais . Se executarmos uma √∫nica opera√ß√£o de cada vez, temos de gerar arquivos tempor√°rios no disco para manter os  resultados  dessas  opera√ß√µes  tempor√°rias,  criando um overhead excessivo.  Gerar  e  armazenar  grandes arquivos  tempor√°rios  em  disco  √©  demorado  e  pode ser  desnecess√°rio  em  muitos  casos,  uma  vez  que  esses arquivos ser√£o imediatamente usados como entrada  para  a  pr√≥xima  opera√ß√£o.  Para  reduzir  o  n√∫mero de arquivos tempor√°rios, √© comum gerar um c√≥digo de execu√ß√£o de consulta que corresponde a algoritmos para combina√ß√µes de opera√ß√µes em uma consulta.

Por exemplo, em vez de ser implementada separadamente, uma JUN√á√ÉO pode ser combinada com duas opera√ß√µes SELE√á√ÉO nos arquivos de entrada e uma opera√ß√£o PROJE√á√ÉO final no arquivo resultante; tudo isso √© implementado por um algoritmo com dois arquivos de entrada e um √∫nico arquivo de sa√≠da. Em vez de criar quatro arquivos tempor√°rios, aplicamos o algoritmo diretamente e recebemos apenas um arquivo  de  resultado.  Na  Se√ß√£o  19.7.2,  discutimos como a otimiza√ß√£o  da  √°lgebra  relacional  heur√≠stica pode agrupar opera√ß√µes para execu√ß√£o. Isso √© chamado de pipelining ou processamento baseado em fluxo .

√â usual criar  o  c√≥digo  de  execu√ß√£o  de  consulta de maneira din√¢mica para implementar m√∫ltiplas opera√ß√µes. O c√≥digo gerado para produzir a consulta  combina  v√°rios  algoritmos  que  correspondem  a opera√ß√µes individuais. √Ä medida que s√£o produzidas tuplas de resultado de uma opera√ß√£o, elas s√£o fornecidas como entrada para opera√ß√µes subsequentes. Por exemplo, se uma opera√ß√£o de jun√ß√£o segue duas opera√ß√µes de sele√ß√£o em rela√ß√µes da base, as tuplas resultantes de cada sele√ß√£o s√£o fornecidas como entrada  para  o  algoritmo  de  jun√ß√£o  em  um fluxo ou pipeline √† medida que s√£o produzidas.

## 19.7 Usando a heur√≠stica na otimiza√ß√£o da consulta

Nesta  se√ß√£o,  discutimos  t√©cnicas  de  otimiza√ß√£o que  aplicam  regras  heur√≠sticas  para  modificar  a  representa√ß√£o interna de uma consulta - que normalmente est√° na forma de uma √°rvore de consulta ou uma estrutura de dados de grafo de consulta - para melhorar seu desempenho esperado. A varredura e o analisador de uma consulta SQL gera primeiro uma estrutura de dados que corresponde a uma representa√ß√£o  inicial  de  consulta ,  que  √©  ent√£o  otimizada  de acordo com regras heur√≠sticas. Isso leva a uma representa√ß√£o  de  consulta  otimizada ,  que  corresponde  √† estrat√©gia de execu√ß√£o da consulta. Depois disso, um plano de execu√ß√£o de consulta √© gerado para executar grupos de opera√ß√µes com base nos caminhos de acesso dispon√≠veis nos arquivos envolvidos na consulta.

Uma das principais regras  heur√≠sticas √©  aplicar opera√ß√µes SELE√á√ÉO e PROJE√á√ÉO antes de  aplicar a JUN√á√ÉO ou outras opera√ß√µes bin√°rias, pois o tamanho do arquivo resultante de uma opera√ß√£o bin√°ria - como JUN√á√ÉO - normalmente √© uma fun√ß√£o multiplicativa dos tamanhos dos arquivos de entrada. As opera√ß√µes SELE√á√ÉO e PROJE√á√ÉO reduzem o tamanho de um arquivo e, portanto, devem ser aplicadas antes de uma jun√ß√£o ou outra opera√ß√£o bin√°ria.

Na Se√ß√£o 19.7.1, reiteramos as nota√ß√µes de √°rvore de consulta e grafo de consulta j√° introduzidas no contexto da √°lgebra e c√°lculo relacional, nas se√ß√µes 6.3.5 e 6.6.5, respectivamente. Estas podem ser usadas como base para as estruturas de dados que servem para a representa√ß√£o interna das consultas. Uma √°rvore de consulta √© utilizada pra representar uma express√£o da √°lgebra relacional ou da √°lgebra relacional estendida, enquanto um grafo de consulta o √© para representar uma express√£o do c√°lculo relacional . Depois, na Se√ß√£o 19.7.2, mostramos como as regras de otimiza√ß√£o heur√≠sticas  s√£o  aplicadas  para  converter  uma  √°rvore  de consulta inicial em uma √°rvore de consulta equivalente , que representa uma express√£o da √°lgebra relacional diferente, a qual √© mais eficiente de ser executada, mas gera o mesmo resultado da √°rvore original. Tamb√©m discutimos a equival√™ncia de diversas express√µes da √°lgebra relacional. Finalmente, a Se√ß√£o 19.7.3 discute a gera√ß√£o de planos de execu√ß√£o de consulta.

## 19.7.1 Nota√ß√£o para √°rvores de consulta e grafos de consulta

Uma √°rvore de consulta √© uma estrutura de dados de √°rvore que corresponde a uma express√£o da √°lgebra relacional. Ela representa as rela√ß√µes de entrada da consulta como n√≥s folha da √°rvore, e representa as opera√ß√µes da √°lgebra relacional como n√≥s internos.  Uma  execu√ß√£o  da  √°rvore  de  consulta  consiste na execu√ß√£o de uma opera√ß√£o de n√≥ interno sempre que  seus  operandos  est√£o  dispon√≠veis  e  depois  na substitui√ß√£o desse n√≥ interno pela rela√ß√£o que resulta da execu√ß√£o da opera√ß√£o. A ordem de execu√ß√£o das opera√ß√µes come√ßa nos n√≥s folha ,  que  representa as rela√ß√µes do banco de dados de entrada para a consulta, e termina no n√≥ raiz , que representa a opera√ß√£o final da consulta. A execu√ß√£o termina quando a opera√ß√£o do n√≥ raiz √© executada e produz a rela√ß√£o de resultado para a consulta.

A Figura 19.4(a) mostra uma √°rvore de consulta (a mesma mostrada na Figura 6.9) para a consulta C2 dos cap√≠tulos 4 a 6: para cada projeto localizado em 'Mau√°', recupere o n√∫mero do projeto, o n√∫mero do departamento de controle, o sobrenome, o endere√ßo e a data de nascimento do gerente do departamento. Essa  consulta  √©  especificada  no  esquema  relacional EMPRESA da Figura 3.5 e corresponde √† seguinte express√£o da √°lgebra relacional:



Isso corresponde √† seguinte consulta SQL:

C2: SELECT

.Projnumero  P .Dnum  F.Unome P , , , F.Endereco  F.Data\_nasc ,

FROM

PROJETO AS , AS D  FUNCIONARIO , AS F

P  DEPARTAMENTO

WHERE

.Dnum P = D.Dnumero AND D. Cpf\_ger = F.Cpf AND P.Projlocal = 'Mau√°';

Na Figura 19.4(a), os n√≥s folha P, D e F representam as tr√™s rela√ß√µes PROJETO, DEPARTAMENTO e FUNCIONARIO , respectivamente, e os n√≥s da √°rvore interna representam as opera√ß√µes da √°lgebra relacional da express√£o. Quando essa √°rvore de consulta √© executada, o n√≥ marcado com (1) na Figura 19.4(a) deve iniciar a execu√ß√£o antes do n√≥ (2), porque algumas tuplas resultantes da opera√ß√£o (1) devem estar dispon√≠veis antes de podermos iniciar a execu√ß√£o da opera√ß√£o (2). De modo semelhante, o n√≥ (2) deve come√ßar a executar e produzir resultados antes que o n√≥ (3) possa iniciar a execu√ß√£o, e assim por diante.

Figura 19.4



- (b) P.Projnumero, P.Dnumero, F.Unome, F.Endereco, F.Data\_nasc ùõë

- (c) [P.Projnumero, P.Dnum]

Duas √°rvores de consulta para a consulta C2. (a) √Årvore de consulta correspondente √† express√£o da √°lgebra relacional para C2. (b) √Årvore de consulta inicial (can√¥nica) para a consulta SQL C2. (c) Grafo de consulta para C2.

Como  podemos  ver,  a  √°rvore  de  consulta  representa uma ordem de opera√ß√µes espec√≠fica para a execu√ß√£o de uma consulta. Uma estrutura de dados mais  neutra  para  a  representa√ß√£o  de  uma  consulta √© a nota√ß√£o do grafo de consulta .  A Figura 19.4(c) (a mesma mostrada na Figura 6.13) traz o grafo de consulta para a consulta C2. As rela√ß√µes na consulta s√£o representadas por n√≥s de rela√ß√£o , que s√£o exibidos como c√≠rculos isolados. Os valores de constantes, normalmente das condi√ß√µes de sele√ß√£o de consulta, s√£o representados por n√≥s de constante , que s√£o exibidos como c√≠rculos duplos ou ovais. As condi√ß√µes de sele√ß√£o e jun√ß√£o s√£o representadas pelas arestas do grafo, como mostra a Figura 19.4(c). Por fim, os atributos  a  serem  recuperados  de  cada  rela√ß√£o  s√£o exibidos entre colchetes, acima dela.

A representa√ß√£o do grafo de consulta n√£o indica uma ordem sobre quais opera√ß√µes realizar primeiro. Existe apenas um √∫nico grafo correspondente a cada consulta. 15 Embora  algumas  t√©cnicas  de  otimiza√ß√£o fossem baseadas em grafos de consulta, agora costuma-se aceitar que as √°rvores de consulta s√£o prefer√≠veis porque, na pr√°tica, o otimizador de consulta precisa mostrar a ordem das opera√ß√µes para a execu√ß√£o da consulta, o que n√£o √© poss√≠vel nos grafos de consulta.

## 19.7.2 otimiza√ß√£o heur√≠stica das √°rvores de consulta

Em geral, muitas express√µes diferentes da √°lgebra relacional - e, portanto, muitas √°rvores de consulta diferentes - podem ser equivalentes ;  ou seja, elas podem representar a mesma consulta . 16

milh√µes de tuplas com tamanho de registro de 300 bytes  cada.  Por√©m,  a  √°rvore  de  consulta  inicial  na Figura 19.4(b) est√° em uma forma padr√£o simples, que pode ser facilmente criada com base na consulta SQL. Ela nunca ser√° executada. O otimizador de consulta heur√≠stica transformar√° essa √°rvore de consulta inicial em uma √°rvore de consulta final equivalente, que √© eficiente para se executar.

O otimizador deve incluir regras para equival√™ncia entre express√µes da √°lgebra relacional que podem ser  aplicadas  para  transformar  a  √°rvore  inicial  na √°rvore de consulta otimizada final. Primeiro, discutimos informalmente como uma √°rvore de consulta √© transformada pelo uso de heur√≠sticas, e depois discutimos as regras de transforma√ß√£o gerais e mostramos como elas podem ser usadas em um otimizador heur√≠stico alg√©brico.

Exemplo de transforma√ß√£o de uma consulta. Considere  a  seguinte  consulta C no  banco  de  dados  da Figura 3.5: ache os sobrenomes dos funcion√°rios nascidos ap√≥s 1957 que trabalham em um projeto chamado 'Aquarius' . Essa consulta pode ser especificada em SQL da seguinte forma:

C: SELECT

Unome

FROM

FUNCIONARIO  TRABALHA\_EM , , PROJETO

WHERE

Projnome = 'Aquarius' AND Projnumero = Pnr AND FCpf = Cpf AND

Data\_nasc &gt; '31-12-1957';

O  analisador  de  consulta  normalmente  gerar√° uma √°rvore de consulta inicial padr√£o para corresponder a uma consulta SQL, sem realizar qualquer otimiza√ß√£o. Por exemplo, para uma consulta SELE√á√ÉO-PROJE√á√ÉO-JUN√á√ÉO , como C2, a √°rvore inicial aparece na Figura 19.4(b). O PRODUTO CARTESIANO das  rela√ß√µes  especificadas  na  cl√°usula FROM √© aplicado primeiro; depois, as condi√ß√µes de sele√ß√£o e jun√ß√£o  da  cl√°usula WHERE s√£o  aplicadas,  seguidas pela  proje√ß√£o  nos  atributos  da  cl√°usula SELE√á√ÉO . Essa √°rvore de consulta can√¥nica representa uma express√£o da √°lgebra relacional que √© muito ineficaz se executada diretamente ,  por causa das opera√ß√µes do PRODUTO CARTESIANO (X). Por exemplo, se as rela√ß√µes PROJETO, DEPARTAMENTO e FUNCIONARIO tivessem tamanhos de registro de 100, 50 e 150 bytes, e tivessem 100, 20 e 5.000 tuplas, respectivamente, o resultado do PRODUTO CARTESIANO conteria 10

A √°rvore de consulta inicial para C aparece na Figura  19.5(a).  A  execu√ß√£o  dessa  √°rvore  primeiro cria um arquivo muito grande contendo o PRODUTO CARTESIANO dos  arquivos FUNCIONARIO, TRABA-LHA\_EM e PROJETO inteiros. √â por isso que a √°rvore de consulta inicial nunca √© executada, mas sim, transformada em outra √°rvore equivalente, que √© eficiente  para  se  executar.  Essa  consulta em particular s√≥ precisa de um registro da rela√ß√£o PROJETO - para o projeto 'Aquarius' - e apenas os registros de FUNCIONARIO para aqueles cuja data de nascimento se d√° ap√≥s '31-12-1957'. A Figura 19.5(b) mostra uma √°rvore de consulta melhorada, que primeiro aplica as opera√ß√µes SELE√á√ÉO para reduzir o n√∫mero de tuplas que aparecem no PRODUTO CARTESIANO .

Outra melhoria √© alcan√ßada trocando as posi√ß√µes das rela√ß√µes FUNCIONARIO e PROJETO na √°rvore, como mostra a Figura 19.5(c). Isso usa a informa√ß√£o de que Projnumero √© um atributo de chave da rela√ß√£o PROJETO , e, portanto, a opera√ß√£o SELE√á√ÉO

15 Portanto, um grafo de consulta corresponde a uma express√£o do c√°lculo relacional , como mostramos na Se√ß√£o 6.6.5.

16 A mesma consulta tamb√©m pode ser declarada de v√°rias maneiras em uma linguagem de consulta de alto n√≠vel, como a SQL (ver cap√≠tulos 4 e 5).



( continua )

## Figura 19.5

(d)

ùõë

Unome

Fcpf=Cpf Etapas na convers√£o de uma √°rvore de consulta durante a otimiza√ß√£o heur√≠stica. (a) √Årvore de consulta inicial (can√¥nica) para a consulta SQL C. (b) Movendo as opera√ß√µes SELE√á√ÉO mais para baixo na √°rvore de consulta. (c) Aplicando a opera√ß√£o SELE√á√ÉO mais restritiva primeiro.

Projnumero=Pnr

ùõî

Data\_nasc&gt;'31-12-1957'

ùõî

Projnome ='Aquarius'

TRABALHA\_EM

FUNCIONARIO

Projnome ='Aquarius'

TRABALHA\_EM

PROJETO

Figura 19.5 (continua√ß√£o)



Etapas na convers√£o de uma √°rvore de consulta durante a otimiza√ß√£o heur√≠stica. (d) Substituindo PRODUTO CARTESIANO e SELE√á√ÉO por opera√ß√µes JUN√á√ÉO. (e) Movendo opera√ß√µes PROJE√á√ÉO mais para baixo na √°rvore de consulta.

na rela√ß√£o PROJETO recuperar√° um √∫nico registro. Podemos melhorar ainda mais a √°rvore de consulta ao substituir qualquer opera√ß√£o de PRODUTO CARTESIANO que seja acompanhada por uma condi√ß√£o de jun√ß√£o por uma opera√ß√£o JUN√á√ÉO , como mostra a Figura 19.5(d). Outra melhoria √© manter apenas os atributos necess√°rios pelas opera√ß√µes subsequentes nas rela√ß√µes intermedi√°rias, incluindo opera√ß√µes PROJE√á√ÉO ( ùõë )  o  mais  cedo  poss√≠vel  na  √°rvore  de consulta, como mostra a Figura 19.5(e). Isso reduz os  atributos  (colunas)  das  rela√ß√µes  intermedi√°rias, enquanto as opera√ß√µes SELE√á√ÉO reduzem o n√∫mero de tuplas (registros).

Conforme mostra o exemplo anterior, uma √°rvore de consulta pode ser transformada passo a passo em uma √°rvore de consulta equivalente que √© mais eficiente de se executar. Por√©m, temos de garantir que as etapas de transforma√ß√£o sempre levem a uma √°rvore de consulta equivalente. Para fazer isso, o otimizador de consulta precisa saber quais regras de transforma√ß√£o preservam essa equival√™ncia . Discutiremos algumas dessas regras de transforma√ß√£o a seguir.

Regras de transforma√ß√£o gerais para opera√ß√µes da  √°lgebra  relacional. Existem  muitas  regras  para transformar opera√ß√µes da √°lgebra relacional em equivalentes.  Para  fins  de  otimiza√ß√£o  de  consulta,  estamos interessados no significado das opera√ß√µes e das rela√ß√µes resultantes. Logo, se duas rela√ß√µes tiverem o mesmo conjunto de atributos em uma ordem diferente ,  mas ambas representarem a mesma informa√ß√£o, consideramos que as rela√ß√µes s√£o equivalentes.  Na Se√ß√£o 3.1.2, demos uma defini√ß√£o alternativa da rela√ß√£o que torna a ordem dos atributos n√£o importante; usaremos essa defini√ß√£o aqui. Vamos expressar algumas regras de transforma√ß√£o que s√£o √∫teis na otimiza√ß√£o da consulta, sem prov√°-las:

- 1. Cascata de ùõî . Uma condi√ß√£o de sele√ß√£o conjuntiva pode ser desmembrada em uma cascata (ou seja, uma sequ√™ncia) de opera√ß√µes ùõî individuais:

<!-- formula-not-decoded -->

- 2. Comutatividade de ùõî . A opera√ß√£o ùõî √© comutativa:

<!-- formula-not-decoded -->

- 3. Cascata de ùõë . Em uma cascata (sequ√™ncia) de opera√ß√µes ùõë , todas podem ser ignoradas, menos a √∫ltima:

<!-- formula-not-decoded -->

- 4. Comuta√ß√£o de ùõî com ùõë . Se a condi√ß√£o de sele√ß√£o c envolve apenas os atributos A 1 , ..., A n na  lista  de  proje√ß√£o,  as  duas  opera√ß√µes  podem ser comutadas:

<!-- formula-not-decoded -->

- 5. Comutatividade de /triangleleft /triangleright (e √ó ). A opera√ß√£o de jun√ß√£o √© comutativa, assim como a opera√ß√£o √ó :

<!-- formula-not-decoded -->

Observe que, embora a ordem dos atributos possa n√£o ser a mesma nas rela√ß√µes resultantes  das  duas jun√ß√µes (ou dois produtos cartesianos), o significado √©  o mesmo porque a ordem dos atributos n√£o √© importante na defini√ß√£o alternativa da rela√ß√£o.

- 6. Comuta√ß√£o de ùõî com /triangleleft /triangleright (ou √ó ). Se todos os atributos na condi√ß√£o de sele√ß√£o c envolvem apenas os atributos de uma das rela√ß√µes sendo juntadas - digamos, R -, as duas opera√ß√µes podem ser comutadas da seguinte forma:

<!-- formula-not-decoded -->

Como alternativa, se a condi√ß√£o de sele√ß√£o c puder ser escrita como ( c 1 AND c 2 ), onde a condi√ß√£o c 1 envolve apenas os atributos de R e a condi√ß√£o c 2 envolve apenas os atributos de S , as opera√ß√µes s√£o comutadas da seguinte forma:

<!-- formula-not-decoded -->

As  mesmas  regras  se  aplicam  se  o /triangleleft /triangleright for substitu√≠do por uma opera√ß√£o √ó .

- 7. Comuta√ß√£o de ùõë com /triangleleft /triangleright (ou √ó ). Suponha que a lista de proje√ß√£o seja L = { A 1 , ..., A n , B 1 , ..., B m }, onde A 1 , ..., A n s√£o os atributos de R e B 1 , ..., B m s√£o atributos de S . Se a condi√ß√£o de jun√ß√£o   enc volver apenas atributos em L , as duas opera√ß√µes podem ser comutadas da seguinte forma:

<!-- formula-not-decoded -->

Se a condi√ß√£o de jun√ß√£o c contiver atributos adicionais n√£o em L , estes devem ser acrescentados √† lista de proje√ß√£o, e uma opera√ß√£o ùõë final √© necess√°ria. Por exemplo, se os atributos A n + 1 , ..., A n + k de R e B m + 1 , ..., B m + p de S estiverem envolvidos na condi√ß√£o de jun√ß√£o c , mas n√£o estiverem na lista de proje√ß√£o L , as opera√ß√µes s√£o comutadas da seguinte forma:

<!-- formula-not-decoded -->

Para √ó , n√£o existe condi√ß√£o c , de modo que a primeira regra de transforma√ß√£o sempre se aplica substituindo /triangleleft /triangleright c por √ó .

- 8. Comutatividade das opera√ß√µes de conjunto. As opera√ß√µes de conjunto ‚à™ e ‚à© s√£o comutativas, mas -n√£o √©.
- 9. Associatividade de /triangleleft /triangleright , √ó ‚à™ , e ‚à© . Essas quatro opera√ß√µes  s√£o  associativas  individualmente; ou seja, se ùõâ indicar qualquer uma dessas quatro opera√ß√µes (por toda a express√£o), temos: ( R ùõâ S ) ùõâ T ‚â° R ùõâ ( S ùõâ T )
- 10. Comuta√ß√£o de ùõî com opera√ß√µes de conjunto. A opera√ß√£o ùõî comuta com ‚à™ ‚à© , e -. Se ùõâ indicar qualquer uma dessas tr√™s opera√ß√µes (por toda a express√£o), temos:

<!-- formula-not-decoded -->

- 11. A opera√ß√£o ùõë comuta com ‚à™ .

<!-- formula-not-decoded -->

- 12. Convertendo uma sequ√™ncia ( ùõî , √ó ) em /triangleleft /triangleright . Se a condi√ß√£o c de um ùõî que segue um √ó corresponde a uma condi√ß√£o de jun√ß√£o, converta a sequ√™ncia ( ùõî , √ó ) em um /triangleleft /triangleright , da seguinte forma:

<!-- formula-not-decoded -->

Existem  outras  transforma√ß√µes  poss√≠veis.  Por exemplo, uma condi√ß√£o de sele√ß√£o ou jun√ß√£o   pode c ser convertida para uma condi√ß√£o equivalente usando as seguintes regras padr√£o da √°lgebra booleana (leis de DeMorgan):

NOT ( c 1 AND c 2 ) ‚â° ( NOT c 1 ) OR NOT ( c 2 )

<!-- formula-not-decoded -->

Transforma√ß√µes adicionais discutidas nos cap√≠tulos 4, 5 e 6 n√£o s√£o repetidas aqui. Discutimos em seguida como as transforma√ß√µes podem ser usadas na otimiza√ß√£o heur√≠stica.

Esbo√ßo de um algoritmo de otimiza√ß√£o alg√©brica heur√≠stica. Agora,  podemos  esbo√ßar  as  etapas  de um algoritmo que utiliza algumas das regras acima para transformar uma √°rvore de consulta inicial em uma √°rvore final que seja mais eficiente de executar (na maioria dos casos). O algoritmo levar√° a transforma√ß√µes semelhantes √†quelas discutidas em nosso exemplo da Figura 19.5. As etapas do algoritmo s√£o as seguintes:

- 1. Usando a Regra 1, quebre quaisquer opera√ß√µes SELE√á√ÉO com  condi√ß√µes  conjuntivas em uma cascata de opera√ß√µes SELE√á√ÉO . Isso permite um maior grau de liberdade na movi-

- menta√ß√£o para baixo de opera√ß√µes SELE√á√ÉO por diferentes ramos da √°rvore.
- 2. Usando as regras 2, 4, 6 e 10 referentes √† comutatividade de SELE√á√ÉO com outras opera√ß√µes, mova cada opera√ß√£o SELE√á√ÉO o mais para baixo poss√≠vel na √°rvore de consulta que for  permitido  pelos  atributos  envolvidos  na condi√ß√£o  de  sele√ß√£o.  Se  a  condi√ß√£o  envolver atributos de apenas uma tabela , o que significa que ela representa uma condi√ß√£o de sele√ß√£o , a opera√ß√£o √© movida at√© o n√≥ folha que representa essa tabela. Se a condi√ß√£o envolver atributos de duas tabelas , o que significa que ela representa  uma condi√ß√£o de jun√ß√£o ,  a  condi√ß√£o  √© movida para um local mais abaixo na √°rvore, ap√≥s as duas tabelas serem combinadas.
- 3. Usando as regras 5 e 9 referentes √† comutatividade e associatividade de opera√ß√µes bin√°rias, reorganize os n√≥s folha da √°rvore usando os crit√©rios a seguir. Primeiro, posicione as rela√ß√µes do n√≥ folha com as opera√ß√µes SELE√á√ÉO mais restritivas, de modo que sejam executadas primeiro na representa√ß√£o da √°rvore de consulta. A defini√ß√£o da SELE√á√ÉO mais restritiva pode significar aquelas que produzem uma rela√ß√£o com menos tuplas ou com o menor tamanho absoluto. 17  Outra possibilidade √©  definir  a SELE√á√ÉO mais  restritiva  como aquela com a menor seletividade; isso √© mais pr√°tico,  pois  as  estimativas  de  seletividades normalmente  est√£o  dispon√≠veis  no  cat√°logo do SGBD. Em segundo lugar, garanta que a ordena√ß√£o dos n√≥s folha n√£o cause opera√ß√µes de PRODUTO CARTESIANO ; por exemplo, se as duas rela√ß√µes com a SELE√á√ÉO mais restritiva n√£o tiverem uma condi√ß√£o de jun√ß√£o direta  entre  elas,  pode  ser  desej√°vel  mudar a ordem dos n√≥s folha para evitar produtos cartesianos. 18
- 4. Usando  a  Regra  12,  combine  uma  opera√ß√£o PRODUTO  CARTESIANO com  uma  opera√ß√£o SELE√á√ÉO subsequente  na  √°rvore  para  uma opera√ß√£o JUN√á√ÉO ,  se  a  condi√ß√£o representar uma condi√ß√£o de jun√ß√£o.
- 5. Usando as regras 3, 4, 7 e 11 referentes √† cascata de PROJE√á√ÉO e a comuta√ß√£o de PROJE√á√ÉO com outras opera√ß√µes, desmembre e mova as listas de atributos de proje√ß√£o para baixo na √°rvore ao m√°ximo poss√≠vel, crian-
- do novas opera√ß√µes PROJE√á√ÉO , conforme a necessidade.  Somente  os  atributos  necess√°rios no resultado da consulta e nas opera√ß√µes subsequentes na √°rvore de consulta devem ser mantidas ap√≥s cada opera√ß√£o PROJE√á√ÉO .
- 6. Identifique sub√°rvores que representam grupos de opera√ß√µes que podem ser executados por um √∫nico algoritmo.

Em nosso exemplo, a Figura 19.5(b) mostra a √°rvore da Figura 19.5(a) ap√≥s aplicar as etapas 1 e 2 do algoritmo; a Figura 19.5(c) mostra a √°rvore ap√≥s a etapa 3; a Figura 19.5(d), ap√≥s a etapa 4; e a Figura 19.5(e), ap√≥s a etapa 5. Na etapa 6, podemos agrupar as opera√ß√µes na sub√°rvore cuja raiz √© a opera√ß√£o ùõë FCpfi em um √∫nico algoritmo. Tamb√©m podemos agrupar as opera√ß√µes restantes em outra sub√°rvore, na qual as tuplas resultantes do primeiro algoritmo substituem a sub√°rvore cuja raiz √© a opera√ß√£o ùõë FCpf , pois o primeiro agrupamento significa que essa sub√°rvore √© executada primeiro.

Resumo  da  heur√≠stica  para  otimiza√ß√£o  alg√©brica. A heur√≠stica principal √© aplicar primeiro as opera√ß√µes que reduzem o tamanho dos resultados intermedi√°rios. Isso inclui a realiza√ß√£o o mais cedo poss√≠vel de opera√ß√µes SELE√á√ÉO para reduzir o n√∫mero de tuplas e opera√ß√µes PROJE√á√ÉO para reduzir o n√∫mero de atributos - ao mover as opera√ß√µes SELE√á√ÉO e PROJE√á√ÉO o mais para baixo na √°rvore poss√≠vel. Al√©m disso, as opera√ß√µes SELE√á√ÉO e JUN√á√ÉO que s√£o mais restritivas - ou seja, que resultam em rela√ß√µes com menos tuplas ou com o menor tamanho absoluto - devem ser executadas antes de outras opera√ß√µes semelhantes. A √∫ltima regra √© realizada por meio da reordena√ß√£o dos n√≥s folha da √°rvore entre eles mesmos, enquanto evita produtos cartesianos, e do ajuste do restante da √°rvore adequadamente.

## 19.7.3 Convertendo √°rvores de consulta em planos de execu√ß√£o de consulta

Um plano de execu√ß√£o para uma express√£o da √°lgebra relacional representada como uma √°rvore de consulta inclui informa√ß√µes sobre os m√©todos de acesso dispon√≠veis para cada rela√ß√£o, bem como os algoritmos a serem usados na computa√ß√£o dos operadores relacionais representados na √°rvore. Como um exemplo simples, considere a consulta C1 do  Cap√≠tulo 4, cuja express√£o da √°lgebra relacional correspondente √©

<!-- formula-not-decoded -->

17 Qualquer defini√ß√£o pode ser usada, pois essas regras s√£o heur√≠sticas.

18 Observe que um PRODUTO CARTESIANO √© aceit√°vel em alguns casos - por exemplo, se cada rela√ß√£o s√≥ tiver uma √∫nica tupla, pois cada uma teve uma condi√ß√£o de sele√ß√£o anterior em um campo chave.

A  √°rvore  de  consulta  √©  mostrada  na  Figura 19.6. Para converter isso em um plano de execu√ß√£o, o otimizador poderia escolher uma busca de √≠ndice para a opera√ß√£o SELE√á√ÉO em DEPARTAMENTO (supondo que exista uma), um algoritmo de jun√ß√£o de √∫nico loop que percorra os registros no resultado  da  opera√ß√£o SELE√á√ÉO em DEPARTAMENTO para a opera√ß√£o de jun√ß√£o (supondo que exista um √≠ndice  no  atributo Dnr de FUNCIONARIO), e  uma varredura do resultado de JUN√á√ÉO para a entrada do operador PROJE√á√ÉO .  Al√©m  disso,  a  t√©cnica para executar a consulta pode especificar uma avalia√ß√£o materializada ou canalizada, embora em geral uma avalia√ß√£o canalizada seja preferida sempre que vi√°vel.

Com  a avalia√ß√£o  materializada , o  resultado de  uma  opera√ß√£o  √©  armazenado  como  uma  rela√ß√£o tempor√°ria (ou seja, o resultado √© fisicamente materializado ).  Por exemplo, a opera√ß√£o JUN√á√ÉO pode ser calculada e o resultado inteiro, armazenado como uma rela√ß√£o tempor√°ria, que √© ent√£o lida como entrada pelo algoritmo que calcula a opera√ß√£o PROJE√á√ÉO ,  que  produziria a tabela de resultado da consulta. Por sua vez, com a avalia√ß√£o em pipeline , √† medida que as tuplas resultantes de uma opera√ß√£o  s√£o  produzidas,  elas  s√£o  encaminhadas diretamente  √†  pr√≥xima  opera√ß√£o  na  sequ√™ncia  de consulta. Por exemplo, √† medida que as tuplas selecionadas de DEPARTAMENTO s√£o produzidas pela opera√ß√£o SELE√á√ÉO , elas s√£o colocadas em um buffer; o algoritmo da opera√ß√£o JUN√á√ÉO consumiria ent√£o as tuplas do buffer, e as tuplas que resultam da opera√ß√£o JUN√á√ÉO s√£o pipeline para o algoritmo da opera√ß√£o de proje√ß√£o. A vantagem da pipeline √© a economia de custo por n√£o ter de gravar os resultados imediatos em disco e n√£o ter de l√™-los de volta para a pr√≥xima opera√ß√£o.



DEPARTAMENTO

Figura 19.6

Uma √°rvore de consulta para a consulta C1.

## 19.8 Usando seletividade e estimativas de custo na otimiza√ß√£o da consulta

Um otimizador de consulta n√£o depende unicamente de regras  heur√≠sticas;  ele  tamb√©m  estima e compara os custos da execu√ß√£o de uma consulta utilizando diferentes estrat√©gias  de  execu√ß√£o  e  algoritmos, e depois escolhe a estrat√©gia com a estimativa de custo mais baixa . Para que essa t√©cnica funcione, estimativas  de  custo precisas  s√£o  exigidas, de modo que diferentes estrat√©gias possam ser comparadas justa e realisticamente. Al√©m disso, o otimizador precisa limitar o n√∫mero de estrat√©gias de execu√ß√£o a serem consideradas; caso contr√°rio, muito tempo ser√° gasto ao fazer estimativas de custo para as muitas estrat√©gias de execu√ß√£o poss√≠veis. Logo, essa t√©cnica √© mais adequada para consultas compiladas , nas quais a otimiza√ß√£o √© feita na hora da compila√ß√£o e o c√≥digo da estrat√©gia de execu√ß√£o  resultante  √©  armazenado  e  executado  diretamente  em  tempo  de  execu√ß√£o.  Para consultas  interpretadas , nas quais o processo inteiro mostrado na Figura 19.1 ocorre em tempo de execu√ß√£o, uma otimiza√ß√£o  em  escala  total  pode  atrasar  o  tempo de resposta. Uma otimiza√ß√£o mais elaborada √© indicada  para  consultas  compiladas,  enquanto  uma otimiza√ß√£o parcial, menos demorada, funciona melhor para consultas interpretadas.

Essa t√©cnica geralmente √© denominada otimiza√ß√£o de consulta baseada em custo. 19 Ela usa t√©cnicas de otimiza√ß√£o tradicionais que pesquisam o espa√ßo da solu√ß√£o para um problema em busca de uma solu√ß√£o que minimize uma fun√ß√£o de objetivo (custo). As fun√ß√µes de custo usadas na otimiza√ß√£o de consulta s√£o estimativas e n√£o fun√ß√µes de custo exatas, de modo que a otimiza√ß√£o pode selecionar uma estrat√©gia de execu√ß√£o de consulta que n√£o √© a  ideal  (melhor  absoluta).  Na  Se√ß√£o  19.8.1,  discutimos os componentes do custo de execu√ß√£o da consulta.  Na  Se√ß√£o  19.8.2,  discutimos  o  tipo  de informa√ß√£o necess√°ria em fun√ß√µes de custo. Essa informa√ß√£o √© mantida no cat√°logo do SGBD. Na Se√ß√£o 19.8.3, damos exemplos de fun√ß√µes de custo para a opera√ß√£o SELE√á√ÉO , e, na Se√ß√£o 19.8.4, discutimos  as  fun√ß√µes  de  custo  para  opera√ß√µes JUN√á√ÉO de duas vias. A Se√ß√£o 19.8.5 aborda as jun√ß√µes em m√∫ltiplas vias, e a Se√ß√£o 19.8.6 fornece um exemplo.

19 Essa t√©cnica foi usada inicialmente no otimizador para o SYSTEM R em um SGBD experimental desenvolvido na IBM (Selinger et al., 1979).

## 19.8.1 Componentes de custo para execu√ß√£o da consulta

O custo da execu√ß√£o de uma consulta inclui os seguintes componentes:

- 1. Custo de acesso ao armazenamento secund√°rio. Esse √© o custo de transferir (ler e gravar) blocos  de  dados  entre  o  armazenamento  de disco secund√°rio e os buffers da mem√≥ria principal. Isso tamb√©m √© conhecido como custo de E/S (entrada/sa√≠da) de disco . O custo de procurar registros em um arquivo de disco depende do tipo de estruturas de acesso nesse arquivo, como  ordena√ß√£o,  hashing  e  √≠ndices  prim√°rio ou secund√°rio. Al√©m disso, fatores como se os blocos de arquivo est√£o alocados consecutivamente no mesmo cilindro de disco ou espalhados pelo disco afetam o custo de acesso.
- 2. Custo de armazenamento em disco. Esse √© o custo  de  armazenar  no  disco  quaisquer  arquivos intermedi√°rios que sejam gerados por uma estrat√©gia de execu√ß√£o para a consulta.
- 3. Custo de computa√ß√£o. Esse √© o custo de realizar opera√ß√µes na mem√≥ria em registros dentro dos buffers de dados durante a execu√ß√£o da consulta. Essas opera√ß√µes incluem procurar e ordenar registros, mesclar registros para uma opera√ß√£o de jun√ß√£o ou ordena√ß√£o, e realizar c√°lculos em valores de campo. Isso tamb√©m √© conhecido como custo de CPU (unidade central de processamento) .
- 4. Custo de uso da mem√≥ria. Esse √© o custo que diz respeito ao n√∫mero de buffers da mem√≥ria principal necess√°rios durante a execu√ß√£o da consulta.
- 5. Custo de comunica√ß√£o. Esse √© o custo de envio da consulta e seus resultados do local do banco de dados at√© o local ou terminal onde a consulta foi originada. Nos bancos de dados distribu√≠dos (ver Cap√≠tulo 25), isso tamb√©m incluiria o custo de transfer√™ncia de tabelas e resultados entre v√°rios computadores durante a avalia√ß√£o da consulta.

na consulta pode ser armazenada completamente na mem√≥ria, a √™nfase √© na minimiza√ß√£o do custo de computa√ß√£o. Em bancos de dados distribu√≠dos, nos quais muitos  locais  est√£o  envolvidos  (ver  Cap√≠tulo  25),  o custo da comunica√ß√£o tamb√©m precisa ser minimizado. √â dif√≠cil incluir todos os componentes de custo em uma fun√ß√£o de custo (ponderada), devido √† dificuldade de atribuir pesos adequados aos componentes de custo. √â por isso que algumas fun√ß√µes de custo consideram apenas um √∫nico fator - acesso de disco. Na pr√≥xima se√ß√£o, vamos tratar de algumas informa√ß√µes necess√°rias para formular fun√ß√µes de custo.

## 19.8.2 nforma√ß√£o de cat√°logo usada nas I fun√ß√µes de custo

Para  estimar  os  custos  de  diversas  estrat√©gias  de execu√ß√£o, temos de registrar qualquer informa√ß√£o necess√°ria para as fun√ß√µes de custo. Essa informa√ß√£o pode ser armazenada no cat√°logo do SGBD, onde √© acessada pelo otimizador de consulta. Primeiro, temos de saber o tamanho de cada arquivo. Para um arquivo cujos registros s√£o do mesmo tipo, o n√∫mero de registros (tuplas) ( r ) , o tamanho do registro (m√©dio) ( R ) e o n√∫mero de blocos de arquivo ( b ) (ou estimativas pr√≥ximas deles) s√£o necess√°rios. O fator de bloco ( bfr ) para o arquivo tamb√©m pode ser necess√°rio. Tamb√©m devemos registrar a organiza√ß√£o de arquivo prim√°ria para cada arquivo. Os registros da organiza√ß√£o de arquivo prim√°ria podem ser desordenados , ordenados por um atributo com ou sem um √≠ndice prim√°rio ou de agrupamento, ou hashed (hashing  est√°tico  ou  um  dos  m√©todos  de hashing din√¢mico) em um atributo chave. A informa√ß√£o tamb√©m √© mantida em todos os √≠ndices prim√°rios, secund√°rios ou de agrupamento e seus atributos de indexa√ß√£o. O n√∫mero de n√≠veis ( x ) de cada √≠ndice multin√≠vel (prim√°rio, secund√°rio ou de agrupamento) √© necess√°rio para fun√ß√µes de custo que estimam o n√∫mero de acessos de bloco que ocorrem durante a execu√ß√£o da consulta. Em algumas fun√ß√µes de custo, o n√∫mero de blocos de √≠ndice de primeiro n√≠vel ( b I 1 ) √© necess√°rio.

Para bancos de dados grandes, a √™nfase principal costuma estar na minimiza√ß√£o do custo de acesso para armazenamento secund√°rio. Fun√ß√µes de custo simples ignoram outros fatores e comparam diferentes estrat√©gias de execu√ß√£o de consulta em rela√ß√£o ao n√∫mero de transfer√™ncias de bloco entre buffers do disco e da mem√≥ria principal. Para bancos de dados menores, nos quais  a  maioria  dos  dados  nos  arquivos  envolvidos

Outro par√¢metro importante √© o n√∫mero de valores distintos ( d ) de um atributo e sua seletividade ( sl ) , que √© a fra√ß√£o de registros que satisfazem uma condi√ß√£o de igualdade no atributo. Isso permite a estimativa da cardinalidade de sele√ß√£o ( s = sl * r ) de um atributo, que √© o n√∫mero m√©dio de registros que satisfar√£o uma condi√ß√£o de sele√ß√£o de igualdade nesse atributo. Para um atributo chave , d = r , sl = 1/ r e s = 1. Para um atributo n√£o chave , ao fazer a suposi√ß√£o de que os d valores distintos s√£o distribu√≠  dos uniformemente entre os registros, estimamos sl = (1/ d ) e, portanto, s = ( r d / ). 20

20 Otimizadores mais precisos armazenam histogramas da distribui√ß√£o dos registros nos valores de dados para um atributo.

Informa√ß√µes como o n√∫mero de n√≠veis de √≠ndice s√£o f√°ceis de se manter porque n√£o mudam com muita frequ√™ncia. Por√©m, outras informa√ß√µes podem mudar frequentemente; por exemplo, o n√∫mero de registros r em  um  arquivo  muda  toda  vez  que  um registro √© inserido ou exclu√≠do. O otimizador de consulta precisar√° de valores bem pr√≥ximos, mas n√£o necessariamente atualizados at√© o √∫ltimo minuto desses par√¢metros para uso na estimativa do custo de diversas estrat√©gias de execu√ß√£o.

Para um atributo n√£o chave com d valores distintos, √© comum acontecer de os registros n√£o serem distribu√≠dos uniformemente entre esses valores. Por exemplo, suponha que uma empresa tenha cinco departamentos numerados de 1 a 5, e 200 funcion√°rios que est√£o distribu√≠dos entre os departamentos da seguinte forma: (1, 5), (2, 25), (3, 70), (4, 40), (5, 60). Nesses casos, o otimizador pode armazenar um histograma que reflete a distribui√ß√£o dos registros de funcion√°rios em diferentes departamentos em uma tabela com os dois atributos ( Dnr, Seletividade ), que teriam os seguintes valores para nosso  exemplo:  (1,  0,025),  (2,  0,125),  (3,  0,35),  (4, 0,2), (5, 0,3). Os valores de seletividade armazenados no histograma tamb√©m podem ser estimativas se a tabela de funcion√°rios mudar com frequ√™ncia.

Nas pr√≥ximas duas se√ß√µes, examinamos como alguns desses par√¢metros s√£o usados em fun√ß√µes de custo para um otimizador de consulta baseado em custo.

## 19.8.3 Exemplos de fun√ß√µes de custo para SELE√ß√£o

Agora, damos as fun√ß√µes de custo para os algoritmos de sele√ß√£o S1 a S8 discutidos na Se√ß√£o 19.3.1 em rela√ß√£o ao n√∫mero de transfer√™ncias de bloco entre a mem√≥ria e o disco. O algoritmo S9 envolve uma interse√ß√£o  de  ponteiros  de  registro  ap√≥s  eles  terem sido recuperados por algum outro meio, como o algoritmo S6, e, portanto, a fun√ß√£o de custo ser√° baseada no custo para S6. Essas fun√ß√µes de custo s√£o estimativas que ignoram o tempo de computa√ß√£o, o custo de armazenamento e outros fatores. O custo para o m√©todo Si √© indicado como C i S acessos de bloco.

- ¬Ñ S1 - T√©cnica de pesquisa linear (for√ßa bruta). Pesquisamos todos os blocos do arquivo para recuperar todos os registros que satisfazem a condi√ß√£o de sele√ß√£o; logo, C S1 a = b . Para uma condi√ß√£o de igualdade em um atributo chave , somente  metade  dos  blocos  de  arquivo  s√£o pesquisados na  m√©dia antes  de  encontrar  o registro,  de  modo  que  uma  estimativa  aproximada para C S1 b = ( b /2) se o registro for encontrado; se nenhum registro for encontrado satisfazendo a condi√ß√£o, C S1 b = b .
- ¬Ñ S2 - Pesquisa bin√°ria. Essa pesquisa acessa aproximadamente C S2 = log 2 b + Ô£Æ ( s bfr / )  - 1 Ô£π blocos de arquivo. Isso reduz para log 2 b se a condi√ß√£o de igualdade estiver em um atributo exclusivo (chave), pois s = 1 nesse caso.
- ¬Ñ S3a - Usando um √≠ndice de chave prim√°ria para  recuperar  um  √∫nico  registro. Para  um √≠ndice prim√°rio, recupere um bloco de disco em cada n√≠vel  de  √≠ndice,  mais  um  bloco  de disco do arquivo de dados. Logo, o custo √© um bloco de disco a mais que o n√∫mero de n√≠veis de √≠ndice: C S3 a = x + 1.
- ¬Ñ S3b  -  Usando  uma  chave  hash  para  recuperar um √∫nico registro. Para o hashing, somente um bloco de disco precisa ser acessado na maioria dos casos. A fun√ß√£o de custo √© aproximadamente C S3 b = 1 para o hashing est√°tico ou o hashing linear, e √© dois acessos de bloco de disco para o hashing extens√≠vel (ver Se√ß√£o 17.8).
- ¬Ñ S4 - Usando um √≠ndice de ordena√ß√£o para recuperar  m√∫ltiplos  registros. Se  a  condi√ß√£o de compara√ß√£o for &gt; &gt;= &lt; , , ou &lt;= em um campo  chave  com  um  √≠ndice  de  ordena√ß√£o, aproximadamente metade dos registros do arquivo satisfar√£o a condi√ß√£o. Isso produz uma fun√ß√£o de custo de C S4 = x + ( b /2).  Essa  √© uma estimativa muito aproximada e, embora possa estar correta na m√©dia, pode ser muito imprecisa em casos individuais. Uma estimativa mais precisa √© poss√≠vel se a distribui√ß√£o de registros for armazenada em um histograma.
- ¬Ñ S5 -Usando  um  √≠ndice  de  agrupamento para recuperar m√∫ltiplos registros. Um bloco de disco √© acessado em cada n√≠vel de √≠ndice, que oferece o endere√ßo do primeiro bloco de disco do arquivo no cluster. Dada uma condi√ß√£o de igualdade no atributo de indexa√ß√£o, s registros satisfar√£o a condi√ß√£o, onde s √©  a cardinalidade de sele√ß√£o do atributo de indexa√ß√£o. Isso significa que  ( / Ô£Æ s bfr )  blocos de ar-Ô£π quivo estar√£o no cluster de blocos de arquivo que mant√™m todos os registros selecionados, gerando C S5 = x + Ô£Æ ( s bfr / ) . Ô£π
- ¬Ñ S6 - Usando um √≠ndice secund√°rio (B -tree). + Para um √≠ndice secund√°rio em um atributo chave (exclusivo), o custo √© x + 1 acessos de bloco de disco. Para um √≠ndice secund√°rio em um atributo n√£o chave (n√£o exclusivo),   registros s satisfar√£o uma condi√ß√£o de igualdade, onde   √© s a cardinalidade de sele√ß√£o do atributo de indexa√ß√£o. Por√©m, como o √≠ndice √© n√£o de agrupamento, cada um dos registros pode residir em

- 3. Otimiza√ß√£o global da consulta. A otimiza√ß√£o  consiste  em  selecionar  uma  estrat√©gia com base em uma lista de candidatas que est√°  mais  pr√≥xima  do  ideal.  Uma  lista  de consultas  candidatas  pode  ser  obtida  ao permutar  a  ordena√ß√£o  das  opera√ß√µes  em uma consulta de fragmento gerada pelo est√°gio anterior. O tempo √© a unidade preferida para medir o custo. O custo total √© uma combina√ß√£o  ponderada  de  custos  como  o de CPU, os de E/S e aqueles de comunica√ß√£o.  Como  os  BDDs  s√£o  conectados  por uma rede, em geral os custos de comunica√ß√£o pela rede s√£o os mais significativos. Isso √© especialmente verdadeiro quando os sites  s√£o  conectados por uma rede remota ( WAN - Wide Area Network).
- 4. Otimiza√ß√£o de consulta local. Esse est√°gio √© comum a todos os sites no BDD. As t√©cnicas s√£o semelhantes √†quelas usadas nos sistemas centralizados.

Os tr√™s primeiros est√°gios citados s√£o realizados em um site de controle central, enquanto o √∫ltimo est√°gio √© realizado localmente.

## 25.5.2 Custos de transfer√™ncia de dados do processamento de consulta distribu√≠do

No Cap√≠tulo 19, discutimos as quest√µes envolvidas no processamento e na otimiza√ß√£o de uma consulta em um SGBD centralizado. Em um sistema distribu√≠do, v√°rios fatores adicionais complicam ainda mais o processamento da consulta. O primeiro √© o custo de transferir dados pela rede. Isso pode incluir arquivos  intermedi√°rios  que  s√£o  transferidos  para outros sites para que haja mais processamento, bem como os arquivos de resultado finais que podem ter de ser transferidos para o site em que o resultado da consulta  √©  necess√°rio.  Embora  esses  custos  possam n√£o ser muito altos se os sites estiverem conectados por uma rede local de alto desempenho, eles se tornam bastante significativos em outros tipos de redes. Assim, os algoritmos de otimiza√ß√£o de consulta do SGBDD consideram o objetivo de reduzir a quantidade de transfer√™ncia de dados como um crit√©rio de otimiza√ß√£o na escolha de uma estrat√©gia de execu√ß√£o de consulta distribu√≠da.

Ilustramos  isso  com  duas  consultas  simples  de exemplo. Suponha que as rela√ß√µes FUNCIONARIO e DEPARTAMENTO na Figura 3.5 sejam distribu√≠das em dois sites, como mostra a Figura 25.10. Vamos supor neste exemplo que nenhuma rela√ß√£o seja fragmenta- da.  De  acordo  com  a  Figura  25.10,  o  tamanho  da rela√ß√£o FUNCIONARIO √© 100   10.000 = 10 6  bytes, e * o tamanho da rela√ß√£o DEPARTAMENTO √© 35   100 = * 3.500 bytes. Considere a consulta C: para cada funcion√°rio, recupere o nome do funcion√°rio e o nome do departamento para o qual o funcion√°rio trabalha . Isso pode ser indicado da seguinte forma na √°lgebra relacional:

<!-- formula-not-decoded -->

- O resultado dessa consulta incluir√°  10.000  registros, supondo que cada funcion√°rio esteja relacionado a um departamento. Suponha que cada registro no resultado da consulta tenha 40 bytes de extens√£o . A consulta √© submetida a um site distinto 3, que √© chamado site de resultado , pois o resultado da consulta √© necess√°rio l√°. Nem a rela√ß√£o FUNCIONARIO nem DEPARTAMENTO residem no site 3. Existem tr√™s estrat√©gias  simples  para  executar  essa  consulta  distribu√≠da:
- 1. Transferir  tanto FUNCIONARIO quanto DEPARTAMENTO para o site de resultado e realizar a jun√ß√£o no site 3. Nesse caso, um total de 1.000.000 + 3.500 = 1.003.500 bytes devem ser transferidos.
- 2. Transferir a rela√ß√£o FUNCIONARIO para o site 2, executar a jun√ß√£o no site 2 e enviar o resultado para o site 3. O tamanho do resultado da consulta √© 40   10.000 = 400.000 bytes, de * modo que 400.000 + 1.000.000 = 1.400.000 devem ser transferidos.
- 3. Transferir a rela√ß√£o DEPARTAMENTO para o site 1, executar a jun√ß√£o no site 1 e enviar o resultado ao site 3. Nesse caso, 400.000 + 3.500 = 403.500 bytes devem ser transferidos.

Se a redu√ß√£o na quantidade de transfer√™ncia de dados √© nosso crit√©rio de otimiza√ß√£o, devemos escolher a estrat√©gia 3. Agora, considere outra consulta C' : para cada departamento, recupere o nome do departamento e o nome do gerente do departamento. Isso pode ser indicado da seguinte forma na √°lgebra relacional:

<!-- formula-not-decoded -->

Novamente, suponha que a consulta seja submetida no site 3. As mesmas tr√™s estrat√©gias para execu√ß√£o da consulta C se aplicam a C' , exceto que o resultado de C' inclui  apenas 100 registros, imaginando que cada depend√™ncia tenha um gerente:

## Site 1:

## FUNCIONARIO



## Site 2:

## DEPARTAMENTO

Figura 25.10



| Dnome                                    | Dnumero                                  | Cpf_gerente   | Data_inicio_ger          |
|------------------------------------------|------------------------------------------|---------------|--------------------------|
| 100 registros cada registro tem 35 bytes | 100 registros cada registro tem 35 bytes |               |                          |
| Campo Dnumero tem 4 bytes                | Campo Dnumero tem 4 bytes                |               | Campo Dnome tem 10 bytes |

Exemplo para ilustrar o volume dos dados transferidos.

- 1. Transferir  tanto FUNCIONARIO quanto DEPARTAMENTO para o site de resultado e realizar a jun√ß√£o no site 3. Nesse caso, um total de 1.000.000 + 3.500 = 1.003.500 bytes devem ser transferidos.
- 2. Transferir a rela√ß√£o FUNCIONARIO para o site 2, executar a jun√ß√£o no site 2 e enviar o resultado para o site 3. O tamanho do resultado da consulta √© 40 * 100 = 4.000 bytes, de modo que 4.000 + 1.000.000 = 1.004.000 bytes devem ser transferidos.
- 3. Transferir a rela√ß√£o DEPARTAMENTO para o site 1, executar a jun√ß√£o no site 1 e enviar o resultado ao site 3. Nesse caso, 4.000 + 3.500 = 7.500 bytes devem ser transferidos.

De novo, escolher√≠amos a estrat√©gia 3 - dessa vez,  por  uma  margem muito grande em rela√ß√£o √†s estrat√©gias 1 e 2. As tr√™s estrat√©gias anteriores s√£o as mais √≥bvias para o caso em que o site de resultado (site 3) √© diferente de todos os sites que cont√™m arquivos envolvidos na consulta (sites 1 e 2). Por√©m, suponha que o site de resultado seja o site 2; dessa forma, temos duas estrat√©gias simples:

- 1. Transferir  a  rela√ß√£o FUNCIONARIO para  o site 2, executar a consulta e apresentar o re-
- sultado ao usu√°rio no site 2. Aqui, o mesmo n√∫mero  de  bytes  -  1.000.000  -  deve  ser transferido tanto para C quanto para C' .
- 2. Transferir a rela√ß√£o DEPARTAMENTO para o site 1, executar a consulta no site 1 e enviar o resultado de volta para o site 2. Nesse caso, 400.000 + 3.500 = 403.500 bytes devem ser transferidos para C e 4.000 + 3.500 = 7.500 bytes para C' .

Uma estrat√©gia mais complexa, que √†s vezes funciona melhor do que essas mais simples, utiliza uma opera√ß√£o chamada semijun√ß√£o . A seguir, apresentamos essa opera√ß√£o e discutimos a execu√ß√£o distribu√≠da usando semijun√ß√µes.

## 25.5.3 Processamento de consulta distribu√≠do usando semijun√ß√£o

A ideia por tr√°s do processamento de consulta distribu√≠do  usando  uma opera√ß√£o  de  semijun√ß√£o √© reduzir o n√∫mero de tuplas em uma rela√ß√£o antes de transferi-la para outro site. Intuitivamente, a ideia √© enviar a jun√ß√£o de uma rela√ß√£o R para o site onde a outra rela√ß√£o S est√°  localizada;  √©  ent√£o  realizada  a jun√ß√£o dessa coluna com S . Depois disso, os atributos de jun√ß√£o, junto com os atributos exigidos no resultado, s√£o projetados para fora e enviados de volta

ao site original e juntados com R . Logo, somente a coluna de jun√ß√£o de R √© transferida em uma dire√ß√£o, e um subconjunto de S sem tuplas ou atributos estranhos √© transferido na outra dire√ß√£o. Se apenas uma pequena fra√ß√£o das tuplas em S participar da jun√ß√£o, esta pode ser uma solu√ß√£o eficiente para minimizar a transfer√™ncia de dados.

Para ilustrar isso, considere a seguinte estrat√©gia para executar C ou C' :

- 1. Projetar  os  atributos  de  jun√ß√£o  de DEPARTAMEN -TO no site 2 e transferi-los para o site 1. Para C, transferimos   = F œÄ Dnumero ( DEPARTAMENTO ),  cujo tamanho √© 4   100 = 400 bytes, enquanto, para * C ', transferimos F ' = œÄ Cpf\_ger ( DEPARTAMENTO ), cujo tamanho √© 9   100 = 900 bytes. *
- 2. Jun√ß√£o do arquivo transferido com a rela√ß√£o FUNCIONARIO no site 1 e transferir os atributos exigidos do arquivo resultante no site 2. Para C, transferimos R = œÄ Dnr, Pnome, Unome ( F /triangleleft /triangleright Dnumero=Dnr FUNCIONARIO ), cujo tamanho √© 34   10.000 = 340.000 bytes, enquanto, para * C ', transferimos R ' = œÄ Cpf\_ger, Pnome, Unome ( F ' /triangleleft /triangleright Cpf\_ger=Cpf FUNCIONARIO ), cujo tamanho √© 39 * 100 = 3.900 bytes.
- 3. Executar  a  consulta  de  jun√ß√£o  do  arquivo transferido R ou R '  com DEPARTAMENTO e apresentar o resultado ao usu√°rio no site 2.

Ao utilizar essa estrat√©gia, transferimos 340.400 bytes  para C e  4.800  bytes  para C' .  Limitamos  os atributos de FUNCIONARIO e tuplas transmitidas ao site 2 na etapa 2 para apenas aqueles que realmente ser√£o  usados  na  jun√ß√£o com  uma  tupla DEPARTA -MENTO na etapa 3. Para a consulta C, isso significou incluir  todas  as  tuplas  de FUNCIONARIO ,  de  modo que pouca melhoria foi alcan√ßada. Contudo, para C' , apenas 100 das 10.000 tuplas de FUNCIONARIO foram necess√°rias.

A opera√ß√£o de semijun√ß√£o foi criada para formalizar essa estrat√©gia. Uma opera√ß√£o de semijun√ß√£o R /triangleleft &lt; A B = S , onde A e B s√£o atributos compat√≠veis em dom√≠nio de R e S , respectivamente, produz o mesmo resultado que a express√£o da √°lgebra relacional œÄ R ( R /triangleleft /triangleright A B = S ).  Em  um  ambiente distribu√≠do onde R e S residem em diferentes sites, a semijun√ß√£o costuma ser implementada primeiro ao transferir F = œÄ B ( S ) ao site onde R reside e, depois, ao juntar F com R , levando assim √† estrat√©gia discutida aqui.

Observe que a opera√ß√£o de semijun√ß√£o n√£o √© comutativa; ou seja,

<!-- formula-not-decoded -->

## 25.5.4 Decomposi√ß√£o de consulta e atualiza√ß√£o

Em um SGBDD sem transpar√™ncia de distribui√ß√£o , o usu√°rio elabora uma consulta diretamente em rela√ß√£o  a  fragmentos  espec√≠ficos.  Por  exemplo,  considere  outra  consulta C: recupere  os  nomes  e  horas por  semana para cada funcion√°rio que trabalha em algum projeto controlado pelo departamento 5 ,  que √© especificado no banco de dados distribu√≠do onde as rela√ß√µes  nos  sites  2  e  3  aparecem  na  Figura  25.8,  e aquelas no site 1 aparecem na Figura 3.6, como em nosso exemplo anterior. Um usu√°rio que submete tal consulta precisa especificar se ela referencia as rela√ß√µes PROJ\_DEP\_5 e TRABALHA\_EM\_DEP\_5 no site 2 (Figura 25.8) ou as rela√ß√µes PROJETO e TRABALHA\_EM no site 1 (Figura 3.6). O usu√°rio tamb√©m deve manter a consist√™ncia dos itens de dados replicados ao atualizar um SGBDD sem transpar√™ncia de replica√ß√£o .

Al√©m  disso,  um  SGBDD  que  oferece  suporte  √† transpar√™ncia completa de distribui√ß√£o, fragmenta√ß√£o e replica√ß√£o permite que o usu√°rio especifique uma solicita√ß√£o  de  consulta  ou  atualiza√ß√£o  no  esquema  da Figura 3.5 como se o SGBD fosse centralizado. Para as atualiza√ß√µes, o SGBDD √© respons√°vel por manter a consist√™ncia entre itens replicados usando um dos algoritmos de controle de concorr√™ncia distribu√≠dos a serem discutidos na Se√ß√£o 25.7. Para consultas, um m√≥dulo de decomposi√ß√£o de consulta precisa desmembrar ou decompor uma consulta em subconsultas que possam ser executadas nos sites individuais. Ademais, deve ser gerada uma estrat√©gia para combinar os resultados das subconsultas, a fim de formar o resultado da consulta. Sempre que o SGBDD determina que um item referenciado na consulta √© replicado, ele deve escolher ou materializar uma r√©plica em particular durante a execu√ß√£o da consulta.

Para  determinar  quais  r√©plicas  incluem  os  itens de  dados  referenciados  em  uma  consulta,  o  SGBDD refere-se  √†  informa√ß√£o  de  fragmenta√ß√£o,  replica√ß√£o  e distribui√ß√£o armazenada no cat√°logo do SGBDD. Para a fragmenta√ß√£o vertical, a lista de atributos para cada fragmento √© mantida no cat√°logo. Para a fragmenta√ß√£o  horizontal,  uma  condi√ß√£o,  √†s  vezes  chamada  de guarda ,  √©  mantida  para  cada  fragmento. Esta √© basicamente uma condi√ß√£o de sele√ß√£o que especifica quais tuplas existem no fragmento; ela √© chamada de guarda porque apenas tuplas que satisfazem essa condi√ß√£o t√™m permiss√£o para serem armazenadas no fragmento. Para fragmentos mistos, tanto a lista de atributos quanto a condi√ß√£o de guarda s√£o mantidas no cat√°logo.

Em nosso exemplo anterior, as condi√ß√µes de guarda para os fragmentos no site 1 (Figura 3.6) s√£o TRUE (todas as tuplas) e as listas de atributos s√£o

* (todos os atributos). Para os fragmentos mostrados na Figura 25.8, temos as condi√ß√µes de guarda e as listas de atributos mostradas na Figura 25.11. Quando o SGBDD decomp√µe uma solicita√ß√£o de atualiza√ß√£o, ele pode determinar quais fragmentos devem ser atualizados ao examinar suas condi√ß√µes de guarda.  Por  exemplo,  uma  solicita√ß√£o  do  usu√°rio  para inserir  uma  nova  tupla  de FUNCIONARIO &lt;'Alex', 'B', 'Coleman', '34567123911', '22-ABR-1964', 'Rua  Sabar√°s,  3306,  S√£o  Paulo,  SP',  M,  33.000, '98765432168', 4&gt; seria  decomposta  pelo  SGBDD em duas solicita√ß√µes  de  inser√ß√£o:  a  primeira  insere a tupla anterior no fragmento FUNCIONARIO no site 1, e a segunda insere a tupla projetada &lt;'Alex', 'B', 'Coleman', '34567123911', 33.000, '98765432168', 4&gt; no fragmento FUNC\_DEP\_4 do site 3.

Para a decomposi√ß√£o da consulta, o SGBDD pode determinar  quais  fragmentos  podem  conter  as  tuplas exigidas ao comparar a condi√ß√£o de consulta com as condi√ß√µes de guarda. Por exemplo, considere a consulta C: recupere os nomes e horas por semana para cada funcion√°rio que trabalha em algum projeto controlado pelo departamento 5. Isso pode ser especificado em SQL no esquema da Figura 3.5 da seguinte forma:

## (a) FUNC\_DEP\_5

```
lista atributo: Pnome, Minicial, Unome, Cpf, Salario, Cpf_supervisor, Dnr condi√ß√£o guarda: Dnr=5 DEP_5 lista atributo: * (todos os atributos Dnome, Dnumero, Cpf_gerente, Data_inicio_ger) condi√ß√£o guarda: Dnumero=5 LOCAL_DEP_5 lista atributo: * (todos os atributos Dnumero, Localizacao) condi√ß√£o guarda: Dnumero=5 PROJ_DEP_5 lista atributo: * (todos os atributos Projnome, Projnumero, Projlocal, Dnum) condi√ß√£o guarda: Dnum=5 TRABALHA_EM_DEP_5 lista atributo: * (todos os atributos Fcpf, Pnr, Horas) condi√ß√£o guarda: Fcpf IN ( œÄ Cpf (FUNC_DEP_5)) OR Pnr IN ( œÄ Projnumero (PROJ_DEP_5)) (b) FUNC_DEP_4 lista atributo: Pnome, Minicial, Unome, Cpf, Salario, Cpf_supervisor, Dnr condi√ß√£o guarda: Dnum=4 DEP_4 lista atributo: * (todos os atributos Dnome, Dnumero, Cpf_gerente, Data_inicio_ger) condi√ß√£o guarda: Dnumero=4 LOCAL_DEP_4 lista atributo: * (todos os atributos Dnumero, Localizacao) condi√ß√£o guarda:: Dnumero=4 PROJ_DEP_4 lista atributo: * (todos os atributos Projnome, Projnumero, Projlocal, Dnum) condi√ß√£o guarda: Dnum=4 TRABALHA_EM5 lista atributo: * (todos os atributos Fcpf, Pnr, Horas) condi√ß√£o guarda: Fcpf IN ( œÄ Cpf (FUNC_DEP_4)) OR Pnr IN ( œÄ Projnumero (PROJ_DEP_4))
```

Figura 25.11

Condi√ß√µes de guarda e listas de atributos para fragmentos. (a) Fragmentos do site 2. (b) Fragmentos do site 3.

C:  SELECT Pnome, Unome, Horas FROM FUNCIONARIO, PROJETO, TRABALHA\_EM WHERE Dnum=5 AND Projnumero=Pnr AND Fcpf=Cpf;

Suponha que a consulta seja submetida no site 2, que √© onde o resultado da consulta ser√° necess√°rio. O SGBDD pode determinar, pela condi√ß√£o de guarda em PROJ\_DEP\_5 e TRABALHA\_EM\_DEP\_5 , que todas as tuplas que satisfazem as condi√ß√µes ( Dnum = 5 AND Projnumero = Pnr )  residem no site 2. Logo, ele pode decompor a consulta nas seguintes subconsultas da √°lgebra relacional:

<!-- formula-not-decoded -->

Essa decomposi√ß√£o pode ser utilizada para executar a consulta usando uma estrat√©gia de semijun√ß√£o. O SGBDD sabe, pelas condi√ß√µes de guarda, que PROJ\_DEP\_5 cont√©m exatamente as tuplas que satisfazem ( Dnum = 5) e que TRABALHA\_EM\_DEP\_5 cont√©m todas  as  tuplas  a  serem  juntadas  com PROJ\_DEP\_5; logo, a subconsulta T 1 pode ser executada no site 2, e a coluna projetada Fcpf pode ser enviada ao site 1. A subconsulta T 2 pode ent√£o ser executada no site 1, e o resultado pode ser enviado de volta ao site 2, onde o resultado da consulta final √© calculado e apresentado ao usu√°rio. Uma estrat√©gia alternativa seria enviar a pr√≥pria consulta C ao site 1, que inclui todas as tuplas do banco de dados, onde seria executada localmente e da qual o resultado seria enviado de volta ao site 2. O otimizador de consulta estimaria os custos das duas estrat√©gias e escolheria aquela com a estimativa de custo mais baixa.

## 25.6 Vis√£o geral do gerenciamento de transa√ß√£o em bancos de dados distribu√≠dos

Os m√≥dulos de software de gerenciamento de transa√ß√£o global e local, junto com o gerenciador de controle de concorr√™ncia e recupera√ß√£o de um SGBDD, coletivamente  garantem  as  propriedades  ACID  das transa√ß√µes (ver Cap√≠tulo 21). Discutimos sobre o gerenciamento distribu√≠do  de  transa√ß√µes  nesta  se√ß√£o  e exploramos o controle de concorr√™ncia na Se√ß√£o 25.7.

Como podemos ver na Figura 25.5, um componente  adicional,  chamado gerenciador  de  transa√ß√£o global ,  √©  introduzido  para  dar  suporte  a  transa√ß√µes distribu√≠das.  O  site  em  que  a  transa√ß√£o  foi  originada pode assumir temporariamente o papel de gerenciador  de  transa√ß√£o  global  e  coordenar  a  execu√ß√£o das opera√ß√µes de banco de dados com gerenciadores de transa√ß√£o por m√∫ltiplos sites. Os gerenciadores de transa√ß√£o  exportam  suas  funcionalidades  como  uma interface para os programas de aplica√ß√£o. As opera√ß√µes exportadas por essa interface s√£o semelhantes √†quelas cobertas na Se√ß√£o 21.2.1, a saber, BEGIN\_TRANSAC -TION, READ ou WRITE, END\_TRANSACTION, COMMIT\_ TRANSACTION e ROLLBACK (ou ABORT) . O gerenciador  armazena  informa√ß√µes  cont√°beis  relacionadas  a cada transa√ß√£o, como um identificador exclusivo, site de origem, nome, e assim por diante. Para opera√ß√µes READ , ele retorna uma c√≥pia local se for v√°lida e estiver  dispon√≠vel.  Para  opera√ß√µes WRITE ,  ele  garante que  as  atualiza√ß√µes  sejam  vis√≠veis  em  todos  os  sites que cont√©m c√≥pias (r√©plicas) do item de dados. Para opera√ß√µes ABORT , o gerenciador garante que nenhum efeito da transa√ß√£o seja refletido em qualquer site do banco de dados distribu√≠do. Para opera√ß√µes COMMIT , ele garante que os efeitos de uma grava√ß√£o sejam registrados persistentemente em todos os bancos de dados que cont√©m c√≥pias do item de dados. O t√©rmino at√¥mico ( COMMIT/ABORT ) de transa√ß√µes distribu√≠das normalmente √© implementado usando o protocolo de confirma√ß√£o em duas fases. Oferecemos mais detalhes desse protocolo na pr√≥xima se√ß√£o.

O gerenciador de transa√ß√£o passa ao controlador de concorr√™ncia a opera√ß√£o do banco de dados e informa√ß√µes associadas. O controlador √© respons√°vel pela aquisi√ß√£o e libera√ß√£o dos bloqueios associados. Se a transa√ß√£o exigir acesso a um recurso bloqueado, ela √© adiada at√© que o bloqueio seja adquirido. Quando  o  bloqueio  √©  adquirido,  a  opera√ß√£o  √©  enviada ao  processador  em  tempo  de  execu√ß√£o,  que  trata da  execu√ß√£o  real  da  opera√ß√£o  do  banco  de  dados. Quando  a  opera√ß√£o  √©  conclu√≠da,  os  bloqueios  s√£o liberados e o gerenciador de transa√ß√£o √© atualizado com o resultado da opera√ß√£o. Discutimos m√©todos de  concorr√™ncia  distribu√≠dos  comumente  utilizados na Se√ß√£o 25.7.

## 25.6.1 Protocolo de confirma√ß√£o em duas fases

Na Se√ß√£o 23.6, descrevemos o protocolo de confirma√ß√£o em duas fases ( 2PC) ,  que  exige  um gerenciador de recupera√ß√£o global ,  ou coordenador ,  para manter as informa√ß√µes necess√°rias para recupera√ß√£o, al√©m dos gerenciadores de recupera√ß√£o locais e as informa√ß√µes que eles mant√™m (log, tabelas). O protocolo de confirma√ß√£o em duas fases tem certas desvantagens que levaram ao desenvolvimento do protocolo de confirma√ß√£o em tr√™s fases, que discutiremos a seguir.

## 25.6.2 Protocolo de confirma√ß√£o em tr√™s fases

A maior desvantagem do 2PC √© que ele √© um protocolo de bloqueio. Uma falha do coordenador bloqueia  todos  os  sites  participantes,  fazendo  que esperem  at√©  que  o  coordenador  se  recupere.  Isso pode causar diminui√ß√£o do desempenho, especialmente se os participantes estiverem mantendo bloqueios para recursos compartilhados. Outro cen√°rio  problem√°tico  √©  quando  tanto  o  coordenador quanto um participante que foi confirmado falham juntos. No protocolo de confirma√ß√£o em duas fases, um participante n√£o tem como garantir que todos os participantes  receberam  a  mensagem  de  confirma√ß√£o na segunda fase. Logo, quando uma decis√£o de confirmar foi tomada pelo coordenador na primeira fase,  os  participantes  confirmar√£o  suas  transa√ß√µes na segunda fase, independentemente do recebimento de uma mensagem de confirma√ß√£o global por outros participantes. Assim, na situa√ß√£o em que tanto o coordenador quanto um participante confirmado falham juntos, o resultado da transa√ß√£o torna-se incerto ou n√£o determin√≠stico. Como a transa√ß√£o j√° foi confirmada por um participante, ela n√£o pode ser abortada  na  recupera√ß√£o  pelo  coordenador.  Al√©m disso, a transa√ß√£o n√£o pode ser confirmada otimisticamente na recupera√ß√£o, pois o voto original do coordenador pode ter sido para abortar.

A  ideia  principal  √©  limitar  o  tempo  de  espera para os participantes que confirmaram e est√£o esperando por uma confirma√ß√£o ou aborto global do  coordenado.  Quando  um  participante  recebe uma mensagem de pr√©-confirma√ß√£o, ele sabe que o restante dos participantes votou para confirmar. Se uma mensagem de pr√©-confirma√ß√£o n√£o tiver sido recebida, ent√£o o participante abortar√° e liberar√° todos os bloqueios.

## 25.6.3 Suporte do sistema operacional para o gerenciamento de transa√ß√µes

A seguir est√£o os principais benef√≠cios do gerenciamento de transa√ß√£o apoiado pelo sistema operacional (SO):

Esses problemas s√£o solucionados pelo protocolo de confirma√ß√£o em tr√™s fases (3PC), que basicamente divide a segunda fase de confirma√ß√£o em duas  subfases,  chamadas preparar-para-confirmar e confirmar .  A  fase  preparar-para-confirmar √© utilizada para comunicar o resultado da fase de voto a todos os participantes. Se todos os participantes votarem sim, ent√£o o coordenador os instrui a entrar  no  estado preparar-para-confirmar. A subfase confirmar √© id√™ntica √† sua correspondente em duas fases. Agora, se o coordenador falhar durante essa subfase,  outro  participante  pode  ver  a  transa√ß√£o inteira  at√©  o  t√©rmino.  Ele  pode  simplesmente  perguntar a um participante que falhou se ele recebeu uma mensagem de preparar-para-confirmar. Se n√£o tiver  recebido,  ent√£o  ele  assume  seguramente  que deve abortar. Assim, o estado do protocolo pode ser recuperado independentemente de qual participante falhou. Al√©m disso, ao limitar o tempo exigido para uma transa√ß√£o confirmar ou abortar a um tempo-limite m√°ximo, o protocolo garante que uma transa√ß√£o tentando confirmar por 3PC libera os bloqueios sobre o tempo-limite.

- ¬Ñ Em geral, os SGBDs usam os pr√≥prios sem√°foros 9 para garantir o acesso mutuamente exclusivo  aos  recursos  compartilhados.  Como esses sem√°foros s√£o implementados no espa√ßo do usu√°rio no n√≠vel do software de aplica√ß√£o do SGBD, o SO n√£o tem conhecimento a respeito deles. Logo, se o SO desativar um processo  do  SGBD  mantendo  um  bloqueio, outros processos do SGBD que esperam esse recurso  de  bloqueio  s√£o  enfileirados.  Essa situa√ß√£o  pode  causar  uma  s√©ria  degrada√ß√£o no desempenho. O conhecimento em n√≠vel de SO dos sem√°foros pode ajudar a eliminar tais situa√ß√µes.
- ¬Ñ O  suporte  especializado  do  hardware  para bloqueio pode ser explorado para reduzir os custos  associados.  Isso  pode  ser  de  grande import√¢ncia, visto que o bloqueio √© uma das opera√ß√µes mais comuns do SGBD.
- ¬Ñ Fornecer  um  conjunto  de  opera√ß√µes  comuns de suporte √† transa√ß√£o por meio do kernel  permite  que  os  desenvolvedores  de aplica√ß√£o  focalizem  a  inclus√£o  de  novos recursos a seus produtos, em vez de reimplementarem a funcionalidade comum para cada opera√ß√£o. Por exemplo, se diferentes SGBDDs  tiverem  de  coexistir  na  mesma m√°quina e eles escolherem o protocolo de confirma√ß√£o  em  duas  fases,  ent√£o  √©  mais ben√©fico com esse protocolo ser implementado como parte do kernel, de modo que os desenvolvedores de SGBDD possam focalizar mais na inclus√£o de novos recursos para seus produtos.

9 Sem√°foros s√£o estruturas de dados usadas para o acesso sincronizado e exclusivo a recursos compartilhados, para impedir condi√ß√µes de disputa em um sistema de computa√ß√£o paralelo.

## 25.7 Vis√£o geral do controle de concorr√™ncia e recupera√ß√£o em bancos de dados distribu√≠dos

Para fins de controle de concorr√™ncia e recupera√ß√£o, diversos problemas que n√£o s√£o encontrados em um ambiente de SGBD centralizado surgem em um ambiente de SGBD distribu√≠do. Entre eles est√£o os seguintes:

- ¬Ñ Lidar com m√∫ltiplas c√≥pias dos itens de dados. O m√©todo de controle de concorr√™ncia √© respons√°vel por manter a consist√™ncia entre essas c√≥pias. O m√©todo de recupera√ß√£o √© respons√°vel por tornar uma c√≥pia coerente com outras c√≥pias se o site em que a c√≥pia √© armazenada falhar e se recuperar mais tarde.
- ¬Ñ Falha  de  sites  individuais. O  SGBDD  deve continuar  a  operar  com  seus  sites  em  execu√ß√£o, se poss√≠vel, quando um ou mais sites individuais falharem. Quando um site se recupera, seu banco de dados local precisa ser atualizado com o restante dos sites antes que se junte novamente ao sistema.
- ¬Ñ Falha dos links  de  comunica√ß√£o. O  sistema precisa ser capaz de lidar com a falha de um ou  mais  dos  links  de  comunica√ß√£o  que  conectam os sites. Um caso extremo desse problema √© que pode haver particionamento da rede . Isso divide os sites em duas ou mais parti√ß√µes, onde os sites dentro de cada parti√ß√£o s√≥ podem ser comunicar entre si e n√£o com sites em outras parti√ß√µes.
- ¬Ñ Confirma√ß√£o distribu√≠da. Pode haver problemas  com  a  confirma√ß√£o  de  uma  transa√ß√£o que  est√°  acessando  bancos  de  dados  armazenados em v√°rios sites se alguns destes falharem  durante  o  processo  de  confirma√ß√£o. O protocolo  de  confirma√ß√£o  em  duas  fases (ver Se√ß√£o 23.6) costuma ser usado para lidar com esse problema.
- ¬Ñ Deadlock  distribu√≠do. Pode  haver  deadlock entre  v√°rios  sites,  de  modo  que  as  t√©cnicas para lidar com os deadlocks precisam ser estendidas para levar isso em considera√ß√£o.

As t√©cnicas distribu√≠das de controle de concorr√™ncia e recupera√ß√£o precisam lidar com esses e outros  problemas.  Nas  subse√ß√µes  a  seguir,  revisamos algumas das t√©cnicas que foram sugeridas para lidar com a recupera√ß√£o e o controle de concorr√™ncia nos SGBDDs.

## 25.7.1 Controle de concorr√™ncia distribu√≠do baseado em uma c√≥pia distinguida de um item de dados

Para lidar com itens de dados replicados em um banco  de  dados  distribu√≠do,  diversos  m√©todos  de controle de concorr√™ncia foram propostos, estendendo as t√©cnicas de controle de concorr√™ncia para bancos de dados centralizados. Discutimos essas t√©cnicas no contexto da extens√£o do bloqueio centralizado. Extens√µes semelhantes se aplicam a outras t√©cnicas de controle de concorr√™ncia. A ideia √© designar uma c√≥pia em particular de cada item de dados como uma c√≥pia distinguida . Os bloqueios para esse item de dados s√£o associados √† c√≥pia distinguida , e todas as solicita√ß√µes de bloqueio e desbloqueio s√£o enviadas ao site que cont√©m essa c√≥pia.

Diversos m√©todos s√£o baseados nessa ideia, mas eles diferem em seu m√©todo de escolha das c√≥pias distinguidas. Na t√©cnica de site prim√°rio ,  todas as c√≥pias distinguidas s√£o mantidas no mesmo site. Uma modifica√ß√£o dessa t√©cnica √© o site prim√°rio com um site de backup .  Outra t√©cnica √© o m√©todo da c√≥pia prim√°ria , em que as c√≥pias distinguidas dos diversos itens de dados podem ser armazenadas em diferentes sites. Um site que inclui uma c√≥pia distinguida de um item de dados basicamente atua como o site coordenador para controle de concorr√™ncia sobre esse item. Discutimos essas t√©cnicas a seguir.

T√©cnica de site prim√°rio. Nesse m√©todo, um √∫nico site prim√°rio √© designado para ser o site coordenador para todos os itens do banco de dados. Logo, todos os bloqueios s√£o mantidos nesse site, e todas as solicita√ß√µes para bloquear ou desbloquear s√£o enviadas para l√°. Esse m√©todo, portanto, √© uma extens√£o da t√©cnica de bloqueio centralizada. Por exemplo, se todas as transa√ß√µes seguirem o protocolo de bloqueio em duas fases, a serializa√ß√£o est√° garantida. A vantagem dessa t√©cnica √© que ela √© uma extens√£o simples da t√©cnica centralizada e, portanto, n√£o √© demasiadamente complexa. No entanto, ela tem certas desvantagens inerentes. Uma delas √© que todas as solicita√ß√µes de bloqueio s√£o enviadas para um √∫nico site, possivelmente  sobrecarregando-o  e  causando  um gargalo no sistema. Uma segunda desvantagem √© que uma falha do site principal paralisa o sistema, pois toda a informa√ß√£o de bloqueio √© mantida nesse site. Isso pode limitar a confiabilidade e a disponibilidade do sistema.

Embora todos os bloqueios sejam acessados no site  prim√°rio,  os  pr√≥prios  itens  podem  ser  acessados em qualquer site em que residem. Por exemplo, quando uma transa√ß√£o obt√©m um Read\_lock em um

item de dados do site prim√°rio, ela pode acessar qualquer c√≥pia desse item de dados. Por√©m, quando uma transa√ß√£o obt√©m um Write\_lock e atualiza um item de dados, o SGBDD √© respons√°vel por atualizar todas as c√≥pias do item de dados antes de liberar o bloqueio.

Site prim√°rio com site de backup. Essa t√©cnica enfrenta a segunda desvantagem do m√©todo do site prim√°rio ao designar um segundo site para ser um site de backup . Toda a informa√ß√£o de bloqueio √© mantida nos sites  prim√°rio  e  de  backup.  No  caso  de  uma falha no site prim√°rio, o site de backup assume como site prim√°rio, e um novo site de backup √© escolhido. Isso simplifica o processo de recupera√ß√£o de falhas do site prim√°rio, pois o site de backup assume e o processamento pode retomar ap√≥s um novo site de backup ser escolhido e a informa√ß√£o de status de bloqueio ser copiada para esse site. Contudo, isso atrasa o processo de aquisi√ß√£o de bloqueios, pois todas as solicita√ß√µes de bloqueio e concess√µes de bloqueios devem ser registrados nos sites prim√°rio e de backup antes que uma resposta seja enviada √† transa√ß√£o solicitante. O problema dos sites prim√°rio e de backup tornarem-se sobrecarregados com solicita√ß√µes e atrasos deixando o sistema inalterado.

T√©cnica de c√≥pia prim√°ria. Esse m√©todo tenta distribuir a carga da coordena√ß√£o de bloqueio entre v√°rios sites,  tendo  as  c√≥pias  distinguidas  de  diferentes  itens de dados armazenadas em diferentes sites . A falha de um site afeta quaisquer transa√ß√µes que est√£o acessando bloqueios em itens cujas c√≥pias prim√°rias residem nesse site, mas outras transa√ß√µes n√£o s√£o afetadas. Esse m√©todo tamb√©m pode usar sites de backup para melhorar a confiabilidade e a disponibilidade.

Escolhendo  um  novo  site  coordenador  em  caso de falha. Sempre que um site coordenador falha em qualquer  uma  das  t√©cnicas  anteriores,  os  sites  que ainda  est√£o  funcionando  devem  escolher  um  novo coordenador.  No  caso  da  t√©cnica  de  site  prim√°rio sem site de backup, todas as transa√ß√µes em execu√ß√£o precisam ser abortadas e reiniciadas em um processo de recupera√ß√£o tedioso. Parte do processo de recupera√ß√£o envolve a escolha de um novo site prim√°rio e a cria√ß√£o de um processo gerenciador de bloqueio e um registro de toda a informa√ß√£o de bloqueio nesse site. Para m√©todos que usam sites de backup, o processamento de transa√ß√£o √© suspenso enquanto o site de backup √© designado como o site principal e um novo site de backup √© escolhido e recebe c√≥pias de toda a informa√ß√£o de bloqueio do novo site prim√°rio.

Se  um  site  de  backup X est√°  para  se  tornar  o novo site prim√°rio, X pode escolher o novo site de backup dentre os sites em execu√ß√£o no sistema. Po- r√©m, se n√£o existisse um site de backup, ou se os sites prim√°rio e de backup estiverem parados, um processo denominado elei√ß√£o pode ser utilizado para escolher o novo site coordenador. Nesse processo, qualquer site Y, que tenta se comunicar com o site coordenador repetidamente e falha ao fazer isso, pode assumir que o coordenador est√° parado e iniciar o processo de elei√ß√£o ao enviar uma mensagem a todos os sites em funcionamento, propondo que Y se torne o novo coor  denador. Assim que Y recebe uma maioria dos votos sim, Y pode declarar que √© o novo coordenador. O algoritmo de elei√ß√£o em si √© muito complexo, mas essa √© a ideia principal por tr√°s do m√©todo de elei√ß√£o. O algoritmo tamb√©m resolve qualquer tentativa por dois ou mais sites de se tornarem o coordenador ao mesmo tempo. As refer√™ncias na bibliografia selecionada, ao final deste cap√≠tulo, discutem o processo com detalhes.

## 25.7.2 Controle de concorr√™ncia distribu√≠do baseado em vota√ß√£o

Todos os m√©todos de controle de concorr√™ncia para itens replicados, discutidos anteriormente, utilizam a ideia de uma c√≥pia distinguida que mant√©m os bloqueios para esse item. No m√©todo de vota√ß√£o , n√£o existe c√≥pia distinguida; em vez disso, uma solicita√ß√£o de bloqueio √© enviada a todos os sites, que inclui uma c√≥pia do item de dados. Cada c√≥pia mant√©m o pr√≥prio bloqueio e pode conceder ou negar a solicita√ß√£o  por  ele.  Se  uma  transa√ß√£o  que  solicita um bloqueio receber esse bloqueio por uma maioria das  c√≥pias,  ela  mant√©m  o  bloqueio  e  informa a todas as c√≥pias de que ela o teve concedido. Se uma transa√ß√£o n√£o receber uma maioria dos votos concedendo-lhe um bloqueio dentro de certo per√≠odo , ela cancela sua solicita√ß√£o e informa a todos os sites sobre o cancelamento.

O m√©todo de vota√ß√£o √© considerado um m√©todo de controle de concorr√™ncia verdadeiramente distribu√≠do, pois a responsabilidade por uma decis√£o reside em todos os sites envolvidos. Estudos de simula√ß√£o mostraram que a vota√ß√£o tem tr√°fego de mensagens mais alto entre os sites do que os m√©todos de c√≥pia distinguida. Se o algoritmo levar em conta poss√≠veis falhas do site durante o processo de vota√ß√£o, ele se torna extremamente complexo.

## 25.7.3 Recupera√ß√£o distribu√≠da

O processo de recupera√ß√£o em bancos de dados distribu√≠dos  √©  bastante  complicado.  Aqui,  damos apenas  uma  r√°pida  ideia  de  algumas  das  quest√µes. Em alguns casos, √© muito dif√≠cil at√© mesmo determinar se um site est√° parado sem trocar diversas men-

sagens com outros sites. Por exemplo, suponha que o site X envie uma mensagem ao site Y e espere uma resposta de Y , mas n√£o a receba. Existem v√°rias explica√ß√µes poss√≠veis:

- ¬Ñ A mensagem n√£o foi entregue a Y por  uma falha de comunica√ß√£o.
- ¬Ñ O site Y est√° parado e n√£o conseguiu responder.
- ¬Ñ O site Y est√° rodando e enviou uma resposta, mas esta n√£o foi entregue.

Sem informa√ß√µes adicionais ou o envio de mensagens adicionais, √© dif√≠cil determinar o que realmente aconteceu.

Outro problema com a recupera√ß√£o distribu√≠da √© a confirma√ß√£o distribu√≠da. Quando uma transa√ß√£o est√° atualizando dados em v√°rios sites, ela n√£o pode ser confirmada at√© que tenha certeza de que o efeito da transa√ß√£o em cada site n√£o poder√° ser perdido. Isso significa que cada site precisa ter registrado os efeitos locais das transa√ß√µes permanentemente no log do site local em disco. O protocolo de confirma√ß√£o em duas fases normalmente √© usado para garantir a exatid√£o da confirma√ß√£o distribu√≠da (ver Se√ß√£o 23.6).

## 25.8 Gerenciamento de cat√°logo distribu√≠do

O gerenciamento de cat√°logo eficiente nos bancos  de  dados  distribu√≠dos  √©  cr√≠tico  para  garantir  o desempenho  satisfat√≥rio  relacionado  √†  autonomia do site, gerenciamento de vis√£o e distribui√ß√£o e replica√ß√£o de dados. Os cat√°logos s√£o por si s√≥s bancos de dados que cont√©m metadados sobre o sistema de banco de dados distribu√≠do.

Tr√™s sistemas de gerenciamento populares para cat√°logos  distribu√≠dos  s√£o  cat√°logos centralizados , cat√°logos totalmente replicados e cat√°logos particionados .  A  escolha  do  esquema  depende  do  pr√≥prio banco de dados e tamb√©m dos padr√µes de acesso das aplica√ß√µes aos dados b√°sicos.

Cat√°logos centralizados. Nesse esquema, o cat√°logo inteiro √© armazenado em um √∫nico site. Devido √† sua natureza central, ele √© f√°cil de implementar. No entanto,  as  vantagens  da  confiabilidade,  disponibilidade,  autonomia e distribui√ß√£o do processamento da carga s√£o afetadas de maneira adversa. Para opera√ß√µes de leitura de sites n√£o centrais, os dados de cat√°logo  solicitados  s√£o  bloqueados  no  site  central e,  depois,  enviados  ao  site  solicitante.  Ao  terminar a  opera√ß√£o  de  leitura,  uma  confirma√ß√£o  √©  enviada ao site  central,  que,  por  sua  vez,  desbloqueia  esses dados. Todas as opera√ß√µes de atualiza√ß√£o devem ser processadas por meio do site central. Isso pode rapidamente se tornar um gargalo de desempenho para aplica√ß√µes com uso intensivo de grava√ß√£o.

Cat√°logos totalmente replicados. Nesse esquema, c√≥pias id√™nticas do cat√°logo completo est√£o presentes em cada site. Esse esquema facilita leituras mais r√°pidas ao permitir que sejam respondidas localmente. Por√©m, todas as atualiza√ß√µes devem ser transmitidas  a  todos  os  sites.  As  atualiza√ß√µes  s√£o  tratadas como transa√ß√µes e um esquema de confirma√ß√£o em duas fases √© empregado para garantir a consist√™ncia do cat√°logo. Assim como no esquema centralizado, as aplica√ß√µes com uso intensivo da grava√ß√£o podem causar maior tr√°fego de rede devido ao broadcast associado √†s grava√ß√µes.

Cat√°logos  parcialmente  replicados. Os  esquemas centralizados  e  totalmente  replicados  restringem  a autonomia do site, pois precisam garantir uma vis√£o global coerente do cat√°logo. Sob o esquema parcialmente replicado,  cada  site  mant√©m  informa√ß√µes  de cat√°logo completas sobre os dados armazenados localmente nesse site. Cada site tamb√©m tem permiss√£o para  colocar  em  cache  as  entradas  recuperadas  de sites remotos. Por√©m, n√£o h√° garantias de que essas c√≥pias  em  cache  ser√£o  as  mais  recentes  e  atualizadas. O sistema rastreia entradas de cat√°logo para sites onde o objeto foi criado e para sites que cont√™m c√≥pias desse objeto. Quaisquer mudan√ßas nas c√≥pias s√£o  propagadas  imediatamente  para  o  site  original (de nascimento). Recuperar c√≥pias atualizadas para que substituam dados antigos pode ser adiado at√© que haja um acesso a esses dados. Em geral, os fragmentos de rela√ß√µes entre os sites devem ser exclusivamente acess√≠veis. Al√©m disso, para garantir a transpar√™ncia na distribui√ß√£o de dados, os usu√°rios devem ter permiss√£o para criar sin√¥nimos para objetos remotos e utiliz√°-los para refer√™ncias subsequentes.

## 25.9 end√™ncias atuais em bancos T de dados distribu√≠dos

As  tend√™ncias  atuais  em  gerenciamento  de  dados distribu√≠dos giram em torno da Internet, em que petabytes  de  dados  podem  ser  gerenciados  de  uma forma escal√°vel, din√¢mica e confi√°vel. Duas √°reas importantes nessa dire√ß√£o s√£o a computa√ß√£o de nuvem e os bancos de dados peer-to-peer.

## 25.9.1 Computa√ß√£o de nuvem

A computa√ß√£o de nuvem √© o paradigma de oferecer  infraestrutura  de  computa√ß√£o,  plataformas  e software  como  servi√ßos  pela  Internet.  Isso  fornece

vantagens econ√¥micas significativas ao limitar os investimentos de capital iniciais para a infraestrutura de computa√ß√£o e tamb√©m o custo total de propriedade. Isso tem introduzido um novo desafio de gerenciar petabytes de dados de uma forma escal√°vel. Os sistemas de banco de dados tradicionais para gerenciar dados da empresa provaram ser inadequados no tratamento desse desafio, o que resultou em uma revis√£o de arquitetura importante. O relat√≥rio Claremont, 10  realizado por um grupo de pesquisadores de banco de dados s√™nior, prev√™ que a pesquisa futura em computa√ß√£o de nuvem resultar√° no surgimento de novas arquiteturas de gerenciamento de dados e na intera√ß√£o de dados estruturados e n√£o estruturados, bem como outros desenvolvimentos.

Custos de desempenho associados a falhas parciais e sincronismo global foram gargalos de desempenho importantes das solu√ß√µes de banco de dados tradicionais. A ideia-chave √© que a natureza do valor de hash dos conjuntos de dados b√°sicos usados por essas organiza√ß√µes servem naturalmente para o particionamento. Por exemplo, consultas de pesquisa basicamente envolvem um processo recursivo de mapeamento  de  palavras-chave  para  um  conjunto de  documentos  relacionados,  que  podem  se  beneficiar  de  tal  particionamento.  Al√©m  disso,  as  parti√ß√µes  podem  ser  tratadas  de  maneira  independente, eliminando assim a necessidade de uma confirma√ß√£o coordenada. Outro problema com os SGBDDs tradicionais √© a falta de suporte para particionamento din√¢  mico eficiente de dados, o que limitou a escalabilidade e a utiliza√ß√£o de recursos. Sistemas tradicionais tratavam metadados do sistema e dados de aplica√ß√£o da mesma forma, com os dados do sistema exigindo garantias  estritas  de  consist√™ncia  e  disponibilidade. Mas os dados da aplica√ß√£o t√™m requisitos vari√°veis nessas caracter√≠sticas, dependendo de sua natureza. Por exemplo, enquanto um mecanismo de pesquisa pode permitir garantias de consist√™ncia mais fracas, um editor de textos on-line, como o Google Documentos,  que  permite  usu√°rios  concorrentes,  possui requisitos de consist√™ncia estritos.

desempenho.  A  sem√¢ntica  de  objeto  √∫nico  dessas implementa√ß√µes permite uma toler√¢ncia mais alta √† n√£o volatilidade de certas se√ß√µes de dados. O acesso aos dados costuma se dar por um √∫nico objeto em um padr√£o at√¥mico. Logo, o suporte da transa√ß√£o para tais dados n√£o √© t√£o rigoroso quanto para os bancos  de  dados  tradicionais. 11   H√°  um  conjunto variado de servi√ßos de nuvem dispon√≠veis hoje, incluindo servi√ßos de aplica√ß√£o (salesforce.com), servi√ßos  de  armazenamento (Amazon Simple Storage Service,  ou  Amazon  S3),  servi√ßos  de  computa√ß√£o (Google  App  Engine,  Amazon  Elastic  Compute Cloud - Amazon EC2) e servi√ßos de dados (Amazon SimpleDB, Microsoft SQL Server Data Services, Google's Datastore). Cada vez mais aplica√ß√µes centralizadas nos dados devem aproveitar os servi√ßos de dados na nuvem. Embora os servi√ßos de nuvem mais atuais sejam para uso intensivo de an√°lise de dados, espera-se que a l√≥gica de neg√≥cios por fim seja  migrada  para  a  nuvem.  O  principal  desafio nessa  migra√ß√£o  seria  garantir  as  vantagens  de  escalabilidade para a sem√¢ntica de objetos m√∫ltiplos, inerente √† l√≥gica de neg√≥cios. Para um tratamento detalhado da computa√ß√£o de nuvem, consulte a bibliografia selecionada no final deste cap√≠tulo.

## 25.9.2 Sistemas de banco de dados peer-to-peer

Os metadados de um sistema de banco de dados distribu√≠do  devem  ser  desacoplados  de  seus  dados reais a fim de garantir a escalabilidade. Esse desacoplamento pode ser usado para desenvolver solu√ß√µes inovadoras para gerenciar os dados reais, explorando  sua  adequa√ß√£o  inerente  ao  particionamento  e usando solu√ß√µes de banco de dados tradicionais para gerenciar  metadados  cr√≠ticos  do  sistema.  Como  os metadados s√£o apenas uma fra√ß√£o do conjunto de dados total, eles n√£o se tornam um gargalo para o

Um  sistema  de  banco  de  dados  peer-to-peer (SBDP) visa integrar as vantagens da computa√ß√£o P2P (peer-to-peer), como escalabilidade, resili√™ncia a  ataque  e  auto-organiza√ß√£o,  com  os  recursos  do gerenciamento  de  dados  descentralizado.  Os  n√≥s s√£o aut√¥nomos e vinculados apenas a um pequeno n√∫mero de pares individualmente. √â permitido que um n√≥ se comporte puramente como uma cole√ß√£o de arquivos sem oferecer um conjunto completo de funcionalidades  do  SGBD  tradicional.  Embora  o SBDF e SBDM exijam a exist√™ncia de mapeamentos entre esquemas federados locais e globais, os SBDPs tentam evitar um esquema global ao oferecer mapeamentos entre pares de fontes de informa√ß√£o. No SBDP, cada par potencialmente modela de maneira sem√¢ntica dados relacionados de uma forma diferente dos outros pares, e, portanto, a tarefa de construir um esquema mediado central pode ser muito desafiadora. Os SBDPs visam descentralizar o compartilhamento de dados. Cada par tem um esquema associado a seus dados armazenados espec√≠ficos do dom√≠nio. O SBDP constr√≥i um caminho sem√¢ntico 12 de mapeamentos entre os esquemas de pares. Usando esse caminho, um par ao qual uma consulta foi submetida pode obter informa√ß√µes de qualquer par

10 'The Claremont Report on Database Research' est√° dispon√≠vel em: &lt;http://db.cs.berkeley.edu/claremont/claremontreport08.pdf&gt;.

11 Os leitores podem se referir ao trabalho feito por Das et al. (2008) para obterem mais detalhes.

12 Um caminho sem√¢ntico descreve o relacionamento de n√≠vel mais alto entre dois dom√≠nios que s√£o diferentes, mas n√£o relacionados.

relevante conectado por esse caminho. Em sistemas multibanco  de  dados,  um  processador  de  consulta global √© utilizado, enquanto em um sistema P2P uma consulta √© enviada de um para outro at√© que ela seja processada completamente. Uma consulta submetida a um n√≥ pode ser encaminhada para outros com base no  gr√°fico  de  mapeamento  dos  caminhos  sem√¢nticos.  Edutella  e  Piazza  s√£o  exemplos  de  SBDPs.  Os detalhes desses sistemas podem ser encontrados nas fontes mencionadas na bibliografia selecionada deste cap√≠tulo.

## 25.10 Bancos de dados distribu√≠dos em Oracle 13

O Oracle oferece suporte para arquiteturas homog√™neas, heterog√™neas e cliente-servidor de bancos de  dados  distribu√≠dos.  Em  uma  arquitetura  homog√™nea, um m√≠nimo de dois bancos de dados Oracle reside em pelo menos uma m√°quina. Embora a localiza√ß√£o e a plataforma dos bancos de dados sejam transparentes  para  aplica√ß√µes  clientes,  elas  precisariam distinguir entre objetos locais e remotos semanticamente.  Ao  utilizar  sin√¥nimos,  essa  necessidade pode ser contornada onde os usu√°rios podem acessar os objetos remotos com a mesma sintaxe dos objetos locais. Diferentes vers√µes de SGBDs podem ser usadas, embora deva ser observado que o Oracle oferece compatibilidade  anterior,  mas  n√£o  compatibilidade posterior entre suas vers√µes. Por exemplo, √© poss√≠vel que  algumas  das  extens√µes  em  SQL  que  foram  incorporadas no Oracle11i n√£o sejam entendidas pelo Oracle 9.

Em  uma  arquitetura  heterog√™nea,  pelo  menos um dos bancos de dados na rede √© um sistema n√£o Oracle. O banco de dados Oracle local para a aplica√ß√£o esconde a heterogeneidade b√°sica e oferece a vis√£o de um √∫nico banco de dados Oracle local, b√°sico. A conectividade √© tratada pelo uso de um protocolo compat√≠vel com ODBC ou OLE-DB ou pelos componentes agentes Heterogeneous Services e Transparent Gateway do Oracle. Uma discuss√£o sobre os tais agentes est√° fora do escopo deste livro, e o leitor √© aconselhado a consultar a documenta√ß√£o on-line do Oracle.

solicita√ß√£o, processamento e apresenta√ß√£o dos dados gerenciados pelo servidor. A parte do servidor roda o Oracle e trata das fun√ß√µes relacionadas ao acesso compartilhado concorrente. Ela aceita as instru√ß√µes SQL e PL/SQL originadas das aplica√ß√µes cliente, as processa e envia os resultados de volta a ele. As aplica√ß√µes cliente-servidor do Oracle oferecem transpar√™ncia  de  local,  tornando  o  local  dos  dados  transparente aos usu√°rios; v√°rios recursos, como vis√µes, sin√¥nimos e procedimentos, contribuem para isso. A nomea√ß√£o global √© obtida pelo uso de &lt;NOME\_TABE -LA@NOME\_BD&gt; para se referir √†s tabelas de forma exclusiva.

O Oracle utiliza um protocolo de confirma√ß√£o em duas fases para lidar com transa√ß√µes distribu√≠das concorrentes.  A  instru√ß√£o COMMIT dispara  o  mecanismo de confirma√ß√£o em duas fases. O processo de segundo plano RECO ( recoverer - recuperador) resolve o resultado daquelas transa√ß√µes distribu√≠das em que a confirma√ß√£o foi interrompida. O RECO de cada servidor Oracle local confirma ou reverte automaticamente quaisquer transa√ß√µes distribu√≠das em d√∫vida consistentemente em todos os n√≥s envolvidos. Para falhas a longo prazo, o Oracle permite que cada DBA local confirme ou reverta manualmente quaisquer  transa√ß√µes  em  d√∫vida  e  libere  os  recursos.  A consist√™ncia global pode ser mantida ao restaurar o banco de dados em cada site a um ponto fixo predeterminado no passado.

A arquitetura de banco de dados distribu√≠do do Oracle aparece na Figura 25.12. Um n√≥ em um sistema de banco de dados distribu√≠do pode atuar como um cliente, como um servidor ou ambos, dependendo da situa√ß√£o. A Figura mostra dois sites onde os bancos de dados chamados SEDE e VENDAS s√£o mantidos.  Por  exemplo,  na  aplica√ß√£o  mostrada  que  √© executada na SEDE, para um comando SQL emitido ao encontro dos dados locais (por exemplo, DELETE FROM DEP ... ),  o  computador SEDE atua como um servidor, enquanto para um comando ao encontro dos dados remotos (por exemplo, INSERT INTO FUNC@VENDAS ),  o  computador  SEDE  atua  como um cliente.

Na  arquitetura  cliente-servidor,  o  sistema  de banco de dados Oracle √© dividido em duas partes: um front-end  como  a  parte  do  cliente  e  um  back-end como a parte do servidor. A parte do cliente √© a aplica√ß√£o de banco de dados de front-end que interage com o usu√°rio. O cliente n√£o tem responsabilidade de acesso aos dados e simplesmente trata da

A comunica√ß√£o nesse ambiente heterog√™neo distribu√≠do √© facilitada pelos Oracle Net Services, que admitem os protocolos de rede padr√£o e APIs. Sob a implementa√ß√£o cliente-servidor do Oracle dos bancos de dados distribu√≠dos, o Net Services √© respons√°vel por estabelecer e gerenciar conex√µes entre uma aplica√ß√£o cliente e o servidor de banco de dados. Ele est√° presente em cada n√≥ na rede que roda uma aplica√ß√£o cliente Oracle, servidor de banco de dados ou

13 A discuss√£o √© baseada na documenta√ß√£o dispon√≠vel em: &lt;http://docs.oracle.com&gt;.

Figura 25.12



Sistema de banco de dados distribu√≠do do Oracle.

Fonte: Oracle (2008). Copyright ¬© Oracle Corporation 2008. Todos os direitos reservados.

ambos. E tamb√©m empacota comandos SQL em um dos muitos protocolos de comunica√ß√£o para facilitar a comunica√ß√£o cliente-a-servidor, e depois empacota os resultados de volta de maneira semelhante para o cliente. O suporte oferecido pelo Net Services √† heterogeneidade  refere-se  apenas  √†s  especifica√ß√µes  de plataforma, e n√£o ao software de banco de dados. O suporte para SGBDs diferentes do Oracle √© feito por meio dos Heterogeneous Services e Transparent Gateway do Oracle. Cada banco de dados tem um nome global √∫nico, fornecido por um arranjo hier√°rquico de nomes de dom√≠nio de rede que √© prefixado ao nome do banco de dados, para torn√°-lo √∫nico.

O Oracle admite links de banco de dados que definem um caminho de comunica√ß√£o unidirecional de um banco de dados Oracle para outro. Por exemplo,

CREATE DATABASE LINK vendas.br.americas;

estabelece uma conex√£o com o banco de dados vendas da Figura 25.12 sob o dom√≠nio de rede br que vem abaixo do dom√≠nio americas. Usando links, um usu√°rio  pode  acessar  um  objeto  remoto  em  outro banco de dados sujeito aos direitos de propriedade sem  a  necessidade  de  ser  um  usu√°rio  no  banco  de dados remoto.

Os dados em um SBDD Oracle podem ser replicados usando snapshots (instant√¢neos) ou tabelas mestras replicadas. A replica√ß√£o √© fornecida nos seguintes n√≠veis:

- ¬Ñ Replica√ß√£o  b√°sica. R√©plicas  de  tabelas  s√£o gerenciadas  para  acesso  somente  de  leitura. Para atualiza√ß√µes, os dados devem ser acessados em um √∫nico site prim√°rio.
- ¬Ñ Replica√ß√£o avan√ßada (sim√©trica). Isso  estende al√©m da replica√ß√£o b√°sica, permitindo que as aplica√ß√µes atualizem r√©plicas de tabela por

meio de um SBDD replicado. Os dados podem ser lidos e atualizados em qualquer site. Isso requer um software adicional, chamado advanced replication option do Oracle .  Um snapshot gera  uma  c√≥pia  de  uma  parte  da tabela  por  meio  de  uma  consulta,  chamada consulta de defini√ß√£o de snapshot . Uma defini√ß√£o de snapshot simples se parece com esta:

## CREATE SNAPSHOT PEDIDOS\_VENDA AS

SELECT * FROM PEDIDOS\_VENDA@sede. br.americas;

O Oracle agrupa snapshots em grupos de atualiza√ß√£o (ou refresh). Ao especificar um intervalo de atua  liza√ß√£o, o snapshot √© atualizado autom√°tica e periodicamente  nesse  intervalo,  por  at√©  dez Snapshot Refresh Processes (SNPs ). Se a consulta de defini√ß√£o de um snapshot tiver uma fun√ß√£o distinta ou de agrega√ß√£o, uma cl√°usula GROUP BY ou CONNECT BY , ou opera√ß√µes de jun√ß√£o ou conjunto, o snapshot √© chamado de snapshot complexo e exige processamento adicional. O Oracle (at√© a vers√£o 7.3) tamb√©m tem suporte para snapshots ROWID , que s√£o baseados em identificadores de linha f√≠sicos das linhas na tabela mestra.

Bancos de dados heterog√™neos no Oracle. Em um SBDD heterog√™neo, pelo menos um banco de dados √© um sistema n√£o Oracle. O Oracle Open Gateways oferece acesso a um banco de dados n√£o Oracle com base em um servidor Oracle, que usa um link de banco de dados para acessar dados ou executar procedimentos remotos no sistema n√£o Oracle. O recurso Open Gateways inclui o seguinte:

- ¬Ñ Transa√ß√µes  distribu√≠das. Sob  o  mecanismo  de confirma√ß√£o em duas fases, as transa√ß√µes podem se espalhar por sistemas Oracle e n√£o Oracle.
- ¬Ñ Acesso transparente √† SQL. Instru√ß√µes  SQL emitidas por uma aplica√ß√£o s√£o transformadas  transparentemente  em  instru√ß√µes  SQL entendidas pelo sistema n√£o Oracle.
- ¬Ñ SQL pass-through e procedimentos armazenados. Uma  aplica√ß√£o  pode  acessar  diretamente um sistema n√£o Oracle usando a vers√£o da SQL desse sistema. Os procedimentos armazenados  em  um  sistema  baseado  em SQL n√£o Oracle s√£o tratados como se fossem procedimentos remotos PL/SQL.
- ¬Ñ Otimiza√ß√£o  de  consulta  global. Informa√ß√£o de cardinalidade, √≠ndices e outros no sistema n√£o Oracle s√£o considerados pelo otimizador de consulta do servidor Oracle para realizar a otimiza√ß√£o de consulta global.
- ¬Ñ Acesso  procedimental. Os  sistemas  procedimentais,  como  sistemas  de  mensagens  ou enfileiramento,  s√£o  acessados  pelo  servidor Oracle  usando  chamadas  de  procedimento remoto PL/SQL.

Al√©m destes, refer√™ncias ao dicion√°rio de dados s√£o traduzidas para fazer que o dicion√°rio de dados n√£o Oracle pare√ßa ser parte  do  dicion√°rio do servidor Oracle. Tradu√ß√µes de conjunto de caracteres s√£o feitas entre conjuntos de caracteres do idioma  nacional  para  conectar  bancos  de  dados multi-idiomas.

Do ponto de vista da seguran√ßa, a Oracle recomenda que, se uma consulta for originada no site A e acessar os sites B, C e D, ent√£o a auditoria dos links dever√° ser feita apenas no banco de dados no site A. Isso porque os bancos de dados remotos n√£o podem distinguir se uma solicita√ß√£o de conex√£o bem-sucedida e as instru√ß√µes SQL seguintes est√£o vindo de outro servidor ou de um cliente conectado localmente.

## 25.10.1 Servi√ßos de diret√≥rio

Um conceito bastante relacionado aos sistemas empresariais distribu√≠dos √© o de diret√≥rios on-line. Os diret√≥rios on-line s√£o basicamente uma organiza√ß√£o estruturada  de  metadados  necess√°rios  para  as  fun√ß√µes  de  gerenciamento.  Eles  podem  representar  informa√ß√µes sobre diversas fontes, variando de credenciais de seguran√ßa, recursos de rede compartilhados a cat√°logo de banco de dados. O Lightweight Directory Access Protocol (LDAP) √© um protocolo-padr√£o do setor para servi√ßos de diret√≥rio. Ele permite o uso de uma Directory Information Tree (DIT) por v√°rios servidores LDAP, que, por sua vez, pode retornar refer√™ncias a outros servidores como resultado de uma consulta de diret√≥rio. Os diret√≥rios on-line e LDAP s√£o particularmente importantes em bancos de dados distribu√≠dos, onde o acesso de metadados relacionados √†s transpar√™ncias discutidas na Se√ß√£o 25.1 deve ser escal√°vel, seguro e altamente dispon√≠vel.

O Oracle aceita o LDAP Version 3 e diret√≥rios on-line por meio do Oracle Internet Directory, um servi√ßo de diret√≥rio de uso geral para acesso r√°pido e gerenciamento centralizado de metadados pertencentes a recursos de rede e usu√°rios distribu√≠dos. Ele √© executado como uma aplica√ß√£o em um banco de dados  Oracle  e  se  comunica  com  o  banco  de  dados por meio do Oracle Net Services. Ele tamb√©m fornece autentica√ß√£o do usu√°rio baseada em senha, an√¥nima e baseada em certificado, usando SSL Version 3.

A Figura 25.13 ilustra a arquitetura do Oracle Internet Directory. Os componentes principais s√£o:



## Figura 25.13

Vis√£o geral do Oracle Internet Directory.

Fonte: Oracle (2005). Copyright ¬© Oracle Corporation 2005. Todos os direitos reservados.

- ¬Ñ Servidor de diret√≥rio Oracle. Trata das solicita√ß√µes e atualiza√ß√µes do cliente para informa√ß√µes pertencentes a pessoas e recursos.
- ¬Ñ Servidor de replica√ß√£o de diret√≥rio Oracle. Armazena uma c√≥pia dos dados LDAP dos servidores de diret√≥rio Oracle como um backup.
- ¬Ñ Administrador de diret√≥rio. Admite  interfaces baseadas em GUI e baseadas na linha de comandos para administra√ß√£o de diret√≥rio.

## Resumo

Neste  cap√≠tulo,  fornecemos  uma  introdu√ß√£o  aos bancos de dados distribu√≠dos. Esse √© um assunto muito  amplo,  e  discutimos  apenas  algumas  das  t√©cnicas b√°sicas usadas com  bancos  de dados distribu√≠dos. Primeiro, abordamos os motivos para distribui√ß√£o e  as  vantagens  em  potencial  dos  bancos  de  dados  distribu√≠dos  em  rela√ß√£o  aos  sistemas  centralizados.  Depois,  o  conceito  de  transpar√™ncia  de  distribui√ß√£o  e  os conceitos  relacionados  de  transpar√™ncia  de  fragmenta√ß√£o  e  transpar√™ncia  de  replica√ß√£o  foram  definidos. Categorizamos os SGBDDs com crit√©rios como o grau de homogeneidade dos m√≥dulos de software e o grau de autonomia local. Distinguimos arquiteturas de sistemas paralela e distribu√≠da e, depois, apresentamos a arquitetura gen√©rica dos bancos de dados distribu√≠dos de um ponto de vista de arquitetura de componente e tamb√©m esquem√°tico.  As  quest√µes  de  gerenciamento  de  banco de dados federado foram ent√£o discutidas com alguns detalhes, focalizando as necessidades de suporte a v√°rios tipos de autonomias e tratando da heterogeneidade sem√¢ntica. Tamb√©m revisamos os conceitos da arquitetura  cliente-servidor  e  os  relacionamos  aos  bancos  de dados  distribu√≠  dos.  Discutimos  as  quest√µes  de  projeto relacionadas √† fragmenta√ß√£o de dados, replica√ß√£o e distribui√ß√£o, e distinguimos entre fragmentos horizontais e verticais das rela√ß√µes. O uso da replica√ß√£o de dados para melhorar a confiabilidade e disponibilidade do sistema foi discutido em seguida. Ilustramos algumas das t√©cnicas empregadas no processamento de consulta distribu√≠do e discutimos o custo da comunica√ß√£o entre os sites, que √© considerado um fator importante na otimiza√ß√£o de consulta distribu√≠da. As diferentes t√©cnicas para executar jun√ß√µes foram comparadas e, depois, apresentamos a t√©cnica de semijun√ß√£o para juntar rela√ß√µes que residem em diferentes sites. Em seguida, discutimos o gerenciamento de transa√ß√£o, incluindo diferentes protocolos de confirma√ß√£o  e  suporte  do  sistema  operacional  para  o gerenciamento de transa√ß√£o. Discutimos rapidamente as

t√©cnicas de controle de concorr√™ncia e recupera√ß√£o usadas nos SGBDDs, e ent√£o revisamos alguns dos problemas adicionais que devem ser tratados em um ambiente distribu√≠do e que n√£o aparecem em um ambiente centralizado. Revisamos o gerenciamento de cat√°logo nos bancos de dados distribu√≠dos e resumimos suas vantagens e desvantagens relativas. Depois, apresentamos a Computa√ß√£o em Nuvem e os Sistemas de Banco de Dados Peer-to-Peer como novas √°reas de foco em BDDs, em resposta √† necessidade de gerenciar petabytes de informa√ß√µes acess√≠veis pela Internet hoje em dia.

Descrevemos  algumas  das  facilidades  no  Or  acle para dar suporte a bancos de dados distribu√≠dos. Tamb√©m discutimos  sobre  diret√≥rios  on-line  e  o  protocolo LDAP de maneira resumida.

## Perguntas de revis√£o

| 25.1.   | Quais s√£o os principais motivos e vantagens em potencial dos bancos de dados distribu√≠dos?                                                                                                                                                                            |
|---------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 25.2.   | Que fun√ß√µes adicionais um SGBDD tem sobre um SGBD centralizado?                                                                                                                                                                                                       |
| 25.3.   | Discuta o significado dos seguintes termos: grau de homogeneidade de um SGBDD , grau de autonomia local de um SGBDD , SGBD fe- derado , transpar√™ncia de distribui√ß√£o , trans- par√™ncia de fragmenta√ß√£o , transpar√™ncia de replica√ß√£o , sistema multibanco de dados . |
| 25.4.   | Discuta a arquitetura de um SGBDD. Dentro do contexto de um SGBD centralizado, explique re- sumidamente os novos componentes introduzi- dos pela distribui√ß√£o de dados.                                                                                               |
| 25.5.   | Quais s√£o os principais m√≥dulos de software de um SGBDD? Discuta as principais fun√ß√µes de cada um desses m√≥dulos no contexto da arquite- tura cliente-servidor.                                                                                                       |
| 25.6.   | Compare as arquiteturas cliente-servidor de duas e tr√™s camadas.                                                                                                                                                                                                      |
| 25.7.   | O que √© um fragmento de uma rela√ß√£o? Quais s√£o os principais tipos de fragmentos? Por que a fragmenta√ß√£o √© um conceito √∫til no projeto de banco de dados distribu√≠do?                                                                                                 |
| 25.8.   | Por que a replica√ß√£o de dados √© √∫til nos SGBDDs? Que unidades de dados t√≠picas s√£o replicadas?                                                                                                                                                                        |
| 25.9.   | O que significa aloca√ß√£o de dados no projeto de banco de dados distribu√≠do? Que unidades de dados t√≠picas s√£o distribu√≠das pelos sites?                                                                                                                               |
| 25.10.  | Como um particionamento horizontal de uma rela√ß√£o √© especificado? Como uma rela√ß√£o pode ser reunida com base em um particionamento horizontal completo?                                                                                                               |
| 25.11.  | Como um particionamento vertical de uma rela- √ß√£o √© especificado? Como uma rela√ß√£o pode ser reunida novamente com base em um particiona- mento vertical completo?                                                                                                     |

| 25.12.   | Discuta o problema de nomea√ß√£o nos bancos de dados distribu√≠dos.                                                                                                                                                                            |
|----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 25.13.   | Quais s√£o os diferentes est√°gios de processamen- to de uma consulta em um SGBDD?                                                                                                                                                            |
| 25.14.   | Discuta as diferentes t√©cnicas para executar uma equijun√ß√£o de dois arquivos localizados em sites diferentes. Que fatores principais afetam o custo da transfer√™ncia de dados?                                                              |
| 25.15.   | Discuta o m√©todo de semijun√ß√£o para executar uma equijun√ß√£o de dois arquivos localizados em sites diferentes. Sob que condi√ß√µes uma estrat√©- gia de equijun√ß√£o √© eficiente?                                                                 |
| 25.16.   | Discuta os fatores que afetam a decomposi√ß√£o da consulta. Como as condi√ß√µes de guarda e as listas de atributos dos fragmentos s√£o usadas du- rante o processo de decomposi√ß√£o da consulta?                                                  |
| 25.17.   | Como a decomposi√ß√£o de uma solicita√ß√£o de atualiza√ß√£o √© diferente da decomposi√ß√£o de uma consulta? Como as condi√ß√µes de guarda e as listas de atributos dos fragmentos s√£o usadas durante a decomposi√ß√£o de uma solicita√ß√£o de atualiza√ß√£o? |
| 25.18.   | Liste o suporte oferecido pelos sistemas operacio- nais para um SGBDD e tamb√©m seus benef√≠cios.                                                                                                                                             |
| 25.19.   | Discuta os fatores que n√£o aparecem nos sistemas centralizados que afetam o controle de concor- r√™ncia e a recupera√ß√£o nos sistemas distribu√≠dos.                                                                                           |
| 25.20.   | Discuta o protocolo de confirma√ß√£o em duas fases usado para gerenciamento de transa√ß√£o em um SGBDD. Liste suas limita√ß√µes e explique como eles s√£o contornados usando o protocolo de confirma√ß√£o em tr√™s fases.                             |
| 25.21.   | Compare o m√©todo de site prim√°rio com o m√©- todo de c√≥pia prim√°ria para o controle de con- corr√™ncia distribu√≠do. Como o uso de sites de backup afeta cada um deles?                                                                        |
| 25.22.   | Quando a vota√ß√£o e as elei√ß√µes s√£o usadas em bancos de dados distribu√≠dos?                                                                                                                                                                  |
| 25.23.   | Discuta o gerenciamento de cat√°logo nos bancos de dados distribu√≠dos.                                                                                                                                                                       |
| 25.24.   | Quais s√£o os principais desafios enfrentados por um SGBDD tradicional no contexto das aplica- √ß√µes da Internet de hoje? Como a computa√ß√£o em nuvem tenta resolv√™-los?                                                                       |
| 25.25.   | Discuta em poucas palavras o suporte oferecido pelo Oracle para arquiteturas de banco de dados distribu√≠do homog√™neas, heterog√™neas e basea- das em cliente-servidor.                                                                       |
| 25.26.   | Discuta resumidamente os diret√≥rios on-line, seu gerenciamento e seu papel nos bancos de dados                                                                                                                                              |

## Exerc√≠cios

- 25.27. Considere a distribui√ß√£o de dados do banco de dados EMPRESA , em que os fragmentos nos sites 2 e 3 s√£o conforme aparecem na Figura 25.9 e  os  fragmentos no site 1 s√£o conforme aparecem na Figura 3.6. Para cada uma das consultas a seguir, mostre pelo menos duas estrat√©gias de decomposi√ß√£o e execu√ß√£o da consulta. Sob que condi√ß√µes cada uma de suas estrat√©gias funcionaria bem?
- a. Para  cada  funcion√°rio  no  departamento  5, recupere o nome do funcion√°rio e os nomes dos dependentes do funcion√°rio.
- b. Imprima os nomes de todos os funcion√°rios que trabalham no departamento 5, mas que trabalham em algum projeto n√£o controlado pelo departamento 5.

25.28. Considere as seguintes rela√ß√µes:

LIVROS(Num\_livro, Autor\_principal, Assunto, Esto -que\_total, preco)

LIVRARIA(Num\_livraria,  Cidade,  Estado,  Cep,  Va -lor\_estoque\_total)

ESTOQUE(Num\_livraria, Num\_livro, Qtd)

Estoque\_total √©  o  n√∫mero total de livros em estoque e Valor\_estoque\_total √© o valor de estoque total para a loja em reais.

- a. D√™ um exemplo de dois predicados simples que  seriam  significativos  para  a  rela√ß√£o LIVRARIA para particionamento horizontal.
- b. Como um particionamento horizontal  derivado de ESTOQUE seria baseado no particionamento de LIVRARIA?
- c. Mostre predicados pelos quais LIVROS pode ser particionado horizontalmente por t√≥pico.
- d. Mostre como o ESTOQUE pode ser particionado  ainda  mais  pelas  parti√ß√µes  em  (b)  ao acrescentar os predicados em (c).

25.29.

Considere um banco de dados distribu√≠do para uma cadeia de livrarias chamada Livros Nacionais com tr√™s sites chamados LESTE , CENTRO e OESTE. Os  esquemas  de  rela√ß√£o  s√£o  dados no Exerc√≠cio 25.28. Considere que LIVROS s√£o fragmentados por quantias de preco em:

B 1 : LIVRO1 :

preco at√© R$20,00

B 2 : LIVRO 2 :

preco de R$20,01 at√© R$50,00

B 3 : LIVRO 3 : preco de R$50,01 at√© R$100,00

- B 4 : LIVRO 4 : preco de R$100,01 em diante

De modo semelhante, LIVRARIAS s√£o  divididas por c√≥digos de CEP (Cep) em:

S 1 : LESTE: Cep at√© 35.000

S 2 : CENTRO: Cep 35.001 at√© 70.000

S : OESTE: Cep 70.001 at√© 99.999

3

Suponha que ESTOQUE seja um fragmento derivado baseado apenas em LIVRARIA.

a. Considere a consulta:

SELECT   Num\_livro, Estoque\_Total

FROM       Livros

WHERE   preco &gt; 15 AND preco &lt; 55;

Suponha que os fragmentos de LIVRARIA sejam n√£o replicados e atribu√≠dos com base na regi√£o. Suponha ainda que LIVROS sejam alocados como:

LESTE:

B  B 1 , 4

CENTRO: B  B 1 , 2

OESTE:

B  B 1 , 2 , B 3 , B 4

Supondo  que  a  consulta  fosse  submetida  em LESTE, que subconsultas remotas ela gera? (Escreva em SQL.)

- b. Se o pre√ßo de Num\_livro = 1234 for atualizado de R$45,00 para R$55,00 no site CENTRO, que atualiza√ß√µes isso gera? Escreva em portugu√™s e, depois, em SQL.
- c. D√™ um exemplo de consulta emitida em OES -TE que  gerar√°  uma  subconsulta  para CENTRO.
- d. Escreva  uma  consulta  envolvendo  sele√ß√£o  e proje√ß√£o  nas  rela√ß√µes  acima  e  mostre  duas √°rvores de consulta poss√≠veis que indicam diferentes formas de execu√ß√£o.
- 25.30. Considere que voc√™ foi solicitado a propor uma arquitetura de banco de dados em uma grande organiza√ß√£o  (General  Motors,  por  exemplo) para consolidar todos os dados, incluindo bancos de dados legados (de modelos hier√°rquicos e de rede, que ser√£o explicados nos ap√™ndices D e E dispon√≠veis no site de apoio do livro; nenhum conhecimento espec√≠fico desses modelos √© necess√°rio),  bem como bancos de dados relacionais, que s√£o distribu√≠dos geograficamente, de modo que as aplica√ß√µes globais possam ser admitidas. Suponha que a alternativa um √© manter todos os bancos de dados como est√£o, enquanto a alternativa dois √© primeiro convert√™-los para relacionais e depois dar suporte √†s aplica√ß√µes por um banco de dados integrado distribu√≠do.

- a. Desenhe  dois  diagramas  esquem√°ticos  para ambas  as  alternativas,  mostrando  as  liga√ß√µes entre os esquemas apropriados. Para a alternativa um, escolha a t√©cnica de oferecer esquemas de exporta√ß√£o para cada banco de dados e construir esquemas unificados para cada aplica√ß√£o.
- b. Liste as etapas pelas quais voc√™ teria de passar sob cada alternativa da situa√ß√£o presente at√© que as aplica√ß√µes globais sejam vi√°veis.
- c. Compare estas com:
- i. considera√ß√µes em tempo de projeto.
- ii. considera√ß√µes em tempo de execu√ß√£o.

## Bibliografia selecionada

Os livros-texto de Ceri e Pelagatti (1984a) e Ozsu e Valduriez (1999) s√£o dedicados a bancos de dados distribu√≠dos. Peterson e Davie (2008), Tannenbaum (2003) e Stallings (2007) abordam as comunica√ß√µes de dados e redes de computadores. Comer (2008) discute as redes e a internet. Ozsu et al. (1994) t√™m uma cole√ß√£o de artigos sobre gerenciamento de objeto distribu√≠do.

A maior parte da pesquisa sobre projeto de banco de dados distribu√≠do, processamento de consulta e otimiza√ß√£o  ocorreu  nos  anos  1980  e  1990;  aqui,  revisamos rapidamente as refer√™ncias importantes. O projeto de banco de dados distribu√≠do  foi  focalizado  em  mat√©ria  de fragmenta√ß√£o  horizontal  e  vertical,  aloca√ß√£o  e  replica√ß√£o. Ceri et al. (1982) definiram o conceito de fragmentos horizontais minterm. Ceri et al. (1983) desenvolveram um modelo de otimiza√ß√£o baseado em programa√ß√£o de inteiros para a fragmenta√ß√£o e aloca√ß√£o horizontal. Navathe  et  al.  (1984)  desenvolveram  algoritmos  para fragmenta√ß√£o vertical com base na afinidade de atributos e mostraram uma s√©rie de contextos para aloca√ß√£o de fragmento vertical. Wilson e Navathe (1986) apresentam um modelo anal√≠tico para aloca√ß√£o ideal  de  fragmentos. Elmasri et al. (1987) discutem a fragmenta√ß√£o para o modelo ECR; Karlapalem et al. (1996) discutem quest√µes para projeto distribu√≠do de bancos de dados de objeto. Navathe et al. (1996) discutem a fragmenta√ß√£o mista ao combinar a fragmenta√ß√£o horizontal e vertical; Karlapalem  et  al.  (1996)  apresentam  um  modelo  para reprojeto de bancos de dados distribu√≠dos.

O  processamento  de  consulta  distribu√≠do,  otimiza√ß√£o e decomposi√ß√£o s√£o discutidos em Hevner e Yao (1979), Kerschberg et al. (1982), Apers et al. (1983), Ceri e Pelagatti (1984) e Bodorick et al. (1992). Bernstein e Goodman (1981) discutem a teoria por tr√°s do processamento de semijun√ß√£o. Wong (1983) discute o uso de relacionamentos na fragmenta√ß√£o da rela√ß√£o. Os esquemas de controle de concorr√™ncia e recupera√ß√£o s√£o discutidos em Bernstein e Goodman (1981a). Kumar e Hsu (1998) compilam alguns artigos relacionados √† recupera√ß√£o nos bancos de dados distribu√≠dos. As elei√ß√µes nos sistemas distribu√≠dos  s√£o  discutidas  em  Garcia-Molina  (1982).

Lamport (1978) discute os problemas com a gera√ß√£o de timestamps exclusivas em um sistema distribu√≠do. Rahimi  e  Haug  (2007)  discutem  um  modo  mais  flex√≠vel  de construir metadados cr√≠ticos de consulta para bancos de dados P2P. Ouzzani e Bouguettaya (2004) esbo√ßam problemas fundamentais no processamento de consulta distribu√≠do por fontes de dados baseadas na Web.

Uma t√©cnica de controle de concorr√™ncia para dados replicados, que √© baseada na vota√ß√£o, √© apresentada por Thomas (1979). Gifford (1979) prop√µe o uso da vota√ß√£o ponderada, e Paris (1986) descreve um m√©todo chamado vota√ß√£o com testemunhas . Jajodia e Mutchler (1990) discutem a vota√ß√£o din√¢mica. Uma t√©cnica chamada de c√≥pia  dispon√≠vel √©  proposta  por  Bernstein  e  Goodman (1984), e uma que usa a ideia de um grupo √© apresentada em ElAbbadi e Toueg (1988). Outro trabalho que discute os dados replicados inclui Gladney (1989), Agrawal e ElAbbadi  (1990),  ElAbbadi  e  Toueg  (1989),  Kumar e  Segev  (1993),  Mukkamala  (1989)  e  Wolfson  e  Milo (1991). Bassiouni (1988) discute os protocolos otimistas para controle de concorr√™ncia de BDD. Garcia-Molina (1983) e Kumar e Stonebraker (1987) discutem t√©cnicas que usam a sem√¢ntica das transa√ß√µes. As t√©cnicas de controle de concorr√™ncia distribu√≠do baseadas em bloqueio e  c√≥pias  distinguidas  s√£o  apresentadas  por  Menasce  et al.  (1980)  e  Minoura  e  Wiederhold  (1982).  Obermark (1982) apresenta algoritmos para a detec√ß√£o de impasse  distribu√≠da.  Em  trabalho  mais  recente,  Vadivelu  et al.  (2008)  prop√µem  o  uso  do  mecanismo  de  backup  e seguran√ßa multin√≠vel  para  desenvolver  algoritmos  para melhorar a concorr√™ncia. Madria et al. (2007) prop√µem um mecanismo baseado em um esquema de bloqueio em duas fases multivers√£o e timestamp para resolver quest√µes  de  concorr√™ncia  espec√≠ficas  aos  sistemas  de  banco de  dados  m√≥veis.  Boukerche  e  Tuck  (2001)  prop√µem uma t√©cnica que permite que transa√ß√µes estejam fora de ordem at√© certo ponto. Eles tentam facilitar a carga no desenvolvedor da aplica√ß√£o ao explorar o ambiente de rede e produzir um schedule equivalente a um schedule serial ordenado temporalmente. Han et al. (2004) prop√µem um modelo de rede Petri estendido sem impasse e serializ√°vel para bancos de dados de tempo real distribu√≠dos, baseados na Web.

Um estudo de t√©cnicas de recupera√ß√£o nos sistemas distribu√≠dos √© dado por Kohler (1981). Reed (1983) discute  a√ß√µes  at√¥micas  em  dados  distribu√≠dos.  Bhargava (1987)  apresenta  uma  compila√ß√£o  editada  de  v√°rias abordagens e t√©cnicas para concorr√™ncia e confiabilidade nos sistemas distribu√≠dos.

Os sistemas de banco de dados federados foram definidos  inicialmente  em  McLeod  e  Heimbigner  (1985). T√©cnicas para integra√ß√£o de esquema nos bancos de dados federados s√£o apresentadas em Elmasri et al. (1986), Batini et al. (1987), Hayne e Ram (1990) e Motro (1987).

Elmagarmid  e  Helal  (1988)  e  Gamal-Eldin  et  al. (1988) discutem o problema de atualiza√ß√£o em SBDDs heterog√™neos. As quest√µes de banco de dados distribu√≠do heterog√™neo s√£o discutidas em Hsiao e Kamel (1989).

Sheth e Larson (1990) apresentam um estudo abrangente sobre o gerenciamento de banco de dados federado.

Desde o final da d√©cada de 1980, os sistemas multibanco de dados e a interoperabilidade se tornaram t√≥picos importantes. As t√©cnicas para lidar com incompatibilidades sem√¢nticas entre m√∫ltiplos bancos de dados s√£o examinadas em DeMichiel (1989), Siegel e Madnick (1991), Krishnamurthy et al. (1991) e Wang e Madnick (1989). Castano et al. (1998) apresentam um excelente estudo de t√©cnicas para an√°lise de esquemas. Pitoura et al. (1995) discutem a orienta√ß√£o a objeto nos sistemas multibanco de dados. Xiao et al. (2003) prop√µem um modelo baseado em XML para um modelo de dados comum para sistemas multibanco de dados e apresentam uma nova t√©cnica para mapeamento de esquema, com base nesse modelo. Lakshmanan et al. (2001) prop√µem estender a SQL para interoperabilidade, e descrevem a arquitetura e os algoritmos para conseguir o mesmo.

- O  processamento de transa√ß√£o em multibancos  de  dados  √©  discutido  em  Mehrotra  et  al.  (1992), Georgakopoulos et al. (1991), Elmagarmid et al. (1990) e  Brietbart  et  al.  (1990),  entre  outros.  Elmagarmid (1992) discute o processamento de transa√ß√£o para aplica√ß√µes  avan√ßadas,  incluindo  aplica√ß√µes  de  engenharia discutidas em Heiler et al. (1992).

Os sistemas de fluxo de trabalho, que est√£o se tornando populares  para  gerenciar  informa√ß√µes  em  organiza√ß√µes  complexas,  usam  transa√ß√µes  multin√≠vel  e  aninhadas junto com bancos de dados distribu√≠dos. Weikum (1991) discute o gerenciamento de transa√ß√£o multin√≠vel. Alonso et al. (1997) discutem as limita√ß√µes dos sistemas atuais de fluxo de trabalho. Lopes et al. (2009) prop√µem que os usu√°rios definam e executem os pr√≥prios fluxos de trabalho usando um navegador Web no lado do cliente. Eles  tentam  aproveitar  as  tend√™ncias  da  Web  2.0  para simplificar  o  trabalho  do  usu√°rio  para  gerenciamento de  fluxo  de  trabalho.  Jung  e  Yeom  (2008)  exploram  o fluxo de trabalho de dados para desenvolver um sistema de  gerenciamento  de  transa√ß√£o  melhorado,  que  oferece acesso simult√¢neo e transparente aos armazenamentos heterog√™neos que constituem o HVEM DataGrid. Deelman e Chervanak (2008) listam os desafios nos fluxos de trabalho cient√≠ficos com uso intenso de dados. Especificamente, eles examinam o gerenciamento automatizado de dados, t√©cnicas de mapeamento eficientes e quest√µes de feedback do usu√°rio no mapeamento de fluxo de trabalho. Eles tamb√©m argumentam em favor do reuso de dados como um meio eficiente para gerenciar dados e apresentar os desafios a esse respeito.

Diversos  SGBDs  distribu√≠dos  experimentais  t√™m sido implementados. Estes incluem INGRES distribu√≠do, por Epstein et al. (1978), DDTS, por Devor e Weeldreyer (1980), SDD-1, por Rothnie et al. (1980), System R , por * Lindsay et al. (1984), SIRIUS-DELTA, por Ferrier e Stangret (1982), e MULTIBASE, por Smith et al. (1981). O sistema OMNIBASE, por Rusinkiewicz et al. (1988), e o Federated Information Base, desenvolvido com o modelo de dados Candide, por Navathe et al. (1994), s√£o exemplos  de  SGBDDs  federados.  Pitoura  et  al.  (1995) apresentam  um  estudo  comparativo  dos  prot√≥tipos  de sistemas de bancos de dados federados. A maioria dos vendedores  de  SGBD  comercial  possui  produtos  que usam a abordagem cliente-servidor  e  oferecem  vers√µes distribu√≠das de seus sistemas. Algumas quest√µes de sistema referentes a arquiteturas SGBD cliente-servidor s√£o discutidas em Carey et al. (1991), DeWitt et al. (1990) e Wang e Rowe (1991). Khoshafian et al. (1992) discutem quest√µes de projeto para SGBDs relacionais no ambiente cliente-servidor.  As  quest√µes  de  gerenciamento  cliente-servidor s√£o discutidas em muitos livros, como Zantinge e Adriaans (1996). Di Stefano (2005) discute quest√µes de distribui√ß√£o de dados espec√≠ficas √† computa√ß√£o de grade. Uma parte importante dessa discuss√£o tamb√©m pode se aplicar √† computa√ß√£o de nuvem.



Modelos, sistemas e aplica√ß√µes de bancos de dados avan√ßados



## Modelos de dados avan√ßados para aplica√ß√µes avan√ßadas

√Ä medida que o uso de sistemas de banco de dados crescia, os usu√°rios exigiam funcionalidade adicional desses pacotes de software, com a finalidade de facilitar a implementa√ß√£o de aplica√ß√µes do usu√°  rio mais avan√ßadas e mais complexas. Os bancos de dados orientados a objeto e os sistemas objeto-relacional oferecem recursos que permitem que os usu√°rios estendam seus sistemas ao especificar outros tipos de dados abstratos para cada aplica√ß√£o. No entanto, √© muito √∫til identificar certos recursos comuns para algumas dessas aplica√ß√µes avan√ßadas e criar modelos que possam represent√°-las. Al√©m disso, estruturas de armazenamento especializadas e m√©todos de indexa√ß√£o podem ser implementados para melhorar o desempenho desses recursos comuns. Depois, os recursos podem ser implementados como tipos de dados abstratos ou bibliotecas de classes e adquiridos separadamente do pacote de software de SGBD b√°sico. Os termos data blade ,  no Informix, e cartridge ,  no Oracle, t√™m sido usados para se referirem a esses subm√≥dulos opcionais que podem ser inclu√≠dos em um pacote  de  SGBD.  Os  usu√°rios  podem  utilizar  esses recursos  diretamente  se  eles  forem  adequados  para suas aplica√ß√µes, sem precisarem reinventar, reimplementar e reprogramar tais recursos comuns.

Este  cap√≠tulo  apresenta  os  conceitos  de  banco de dados para alguns dos recursos comuns que s√£o exigidos por aplica√ß√µes avan√ßadas e que est√£o sendo  muito  utilizados.  Abordaremos  as regras  ativas que s√£o usadas nas aplica√ß√µes de bancos de dados ativos, conceitos temporais que s√£o empregados em aplica√ß√µes de bancos de dados temporais e, resumidamente, algumas das quest√µes que envolvem bancos de dados espaciais e bancos de dados multim√≠dia . Tamb√©m discutiremos os bancos de dados dedutivos . √â importante observar que cada um desses assuntos

√© muito amplo, e damos apenas uma r√°pida introdu√ß√£o a cada um. De fato, cada uma dessas √°reas pode servir como assunto isolado de um livro inteiro.

Na Se√ß√£o 26.1, apresentamos o t√≥pico de bancos de dados ativos, que oferecem funcionalidade adicional para especificar regras ativas . Essas regras podem ser  disparadas  automaticamente  por  eventos  que ocorrem, como atualiza√ß√µes ao banco de dados ou certos momentos sendo alcan√ßados, e podem iniciar certas  a√ß√µes  que  foram  especificadas  na  declara√ß√£o da regra para que ocorram se certas condi√ß√µes forem atendidas. Muitos pacotes comerciais incluem parte da funcionalidade fornecida pelos bancos de dados ativos  na  forma  de triggers .  Triggers  agora  fazem parte da SQL-99 e de padr√µes mais recentes.

Na  Se√ß√£o  26.2,  apresentamos  os  conceitos  de bancos de dados temporais , que permitem que o sistema de banco de dados armazene um hist√≥rico de mudan√ßas  e  que  os  usu√°rios  consultem  os  estados atual e passado do banco de dados. Alguns modelos de banco de dados temporais tamb√©m permitem que os  usu√°rios  armazenem  informa√ß√µes  esperadas  no futuro, como schedules planejados. √â importante observar que muitas aplica√ß√µes de banco de dados s√£o temporais, mas elas normalmente s√£o implementadas sem que haja muito suporte temporal do pacote de SGBD - ou seja, os conceitos temporais s√£o implementados nos programas de aplica√ß√£o que acessam o banco de dados.

A Se√ß√£o 26.3 oferece uma breve vis√£o geral dos conceitos de banco de dados espacial . Discutimos os tipos de dados espaciais, diferentes tipos de an√°lises espaciais, opera√ß√µes sobre dados espaciais, tipos de consultas  espaciais,  indexa√ß√£o  de  dados  espaciais, minera√ß√£o de dados espaciais e aplica√ß√µes de bancos de dados espaciais.

A Se√ß√£o 26.4 √© dedicada a conceitos de banco de dados de multim√≠dia. Os bancos de dados de multim√≠dia oferecem recursos que permitem que os usu√°rios armazenem e consultem diferentes tipos de informa√ß√µes de multim√≠dia, que incluem imagens (como figuras e desenhos), clipes de v√≠deo (como filmes, curtas-metragens e v√≠deos caseiros), clipes de √°udio (como m√∫sicas, mensagens telef√¥nicas e discursos) e documentos (como livros e artigos). Discutimos a an√°lise autom√°tica de imagens, o reconhecimento de objeto em imagens e a marca√ß√£o sem√¢ntica de imagens.

Na Se√ß√£o 26.5, discutimos sobre bancos de dados dedutivos, 1  uma √°rea que est√° na interse√ß√£o de bancos  de  dados,  l√≥gica  e  intelig√™ncia  artificial  ou bases de conhecimento. Um sistema de banco de dados dedutivo inclui capacidades para definir regras (dedutivas) , que podem deduzir informa√ß√µes adicionais dos fatos que est√£o armazenados em um banco de dados. Como parte da base te√≥rica para alguns sistemas  de  banco  de  dados  dedutivos  √©  a  l√≥gica matem√°tica,  essas  regras  costumam  ser  chamadas de bancos de dados l√≥gicos .  Outros  tipos  de  sistemas, conhecidos como sistemas de banco de dados especialistas ou sistemas baseados em conhecimento , tamb√©m incorporam capacidades de racioc√≠nio e dedu√ß√£o. Eles utilizam t√©cnicas que foram desenvolvidas no campo da intelig√™ncia artificial, incluindo redes sem√¢nticas, frames, sistemas de produ√ß√£o ou regras para capturar conhecimento espec√≠fico do dom√≠nio. No final do cap√≠tulo h√° um resumo.

Os leitores podem examinar cuidadosamente os t√≥picos em que possuem interesse particular, pois as se√ß√µes deste cap√≠tulo s√£o praticamente independentes uma da outra.

## 26.1 Conceitos de banco de dados ativo e triggers

As regras que especificam a√ß√µes que s√£o disparadas automaticamente por certos eventos t√™m sido consideradas melhorias importantes para os sistemas de banco de dados h√° muito tempo. De fato, o conceito de triggers - uma t√©cnica para especificar certos tipos de regras ativas - j√° existia nas primeiras vers√µes da especifica√ß√£o SQL para bancos de dados relacionais, e as triggers agora fazem parte do padr√£o SQL-99 e outros mais recentes. Os SGBDs relacionais  comerciais  -  como  Oracle,  DB2  e  Microsoft SQL Server - possuem diversas vers√µes de triggers √† disposi√ß√£o. Contudo, desde que os primeiros modelos  de  triggers  foram  propostos,  muita  pesquisa tem sido feita sobre como deve ser um modelo geral para bancos de dados ativos. Na Se√ß√£o 26.1.1, apresentaremos os conceitos gerais que foram propostos para especificar regras para bancos de dados ativos. Usaremos  a  sintaxe  do  SGBD  relacional  comercial do Oracle para ilustrar esses conceitos com exemplos espec√≠ficos, pois as triggers do Oracle s√£o pr√≥ximas ao modo como as regras s√£o especificadas no padr√£o SQL. A Se√ß√£o 26.1.2 discutir√° algumas quest√µes gerais de projeto e implementa√ß√£o para os bancos de dados ativos. Mostramos exemplos de como os bancos  de  dados  ativos  s√£o  implementados  no  SGBD experimental STARBURST na Se√ß√£o 26.1.3, pois o STARBURST prov√™ muitos dos conceitos de bancos de dados ativos generalizados em sua estrutura. A Se√ß√£o 26.1.4 discute as aplica√ß√µes poss√≠veis dos bancos de dados ativos. Finalmente, a Se√ß√£o 26.1.5 descreve como as triggers s√£o declaradas no padr√£o SQL-99.

## 26.1.1 Modelo generalizado para bancos de dados ativos e triggers no Oracle

- O modelo que tem sido usado para especificar regras  de  banco  de  dados  ativo  √©  conhecido  como modelo Evento-Condi√ß√£o-A√ß√£o  (ECA) .  Uma  regra no modelo ECA tem tr√™s componentes:
- 1. O(s) evento(s) que dispara(m) a regra: esses eventos normalmente s√£o opera√ß√µes de atualiza√ß√£o do banco de dados que s√£o aplicadas explicitamente ao banco de dados. No entanto, no modelo geral, eles tamb√©m poderiam ser  eventos  temporais 2   ou  outros  tipos  de eventos externos.
- 2. A condi√ß√£o que determina se a a√ß√£o da regra deve ser executada: quando o evento que dispara a a√ß√£o tiver ocorrido, uma condi√ß√£o opcional pode ser avaliada. Se nenhuma condi√ß√£o for especificada, a a√ß√£o ser√° executada quando ocorrer o evento.  Se  uma  condi√ß√£o for  especificada,  ela  √©  primeiro  avaliada  e, somente se  for  avaliada  como verdadeira ,  a a√ß√£o da regra ser√° executada.
- 3. A a√ß√£o a ser tomada: a a√ß√£o normalmente √© uma sequ√™ncia de comandos SQL, mas tamb√©m poderia ser uma transa√ß√£o do banco de dados ou um programa externo que ser√° executado automaticamente.

Vamos considerar alguns exemplos para ilustrar esses conceitos. Os exemplos s√£o baseados em uma varia√ß√£o  muito  simplificada  da  aplica√ß√£o  de  banco

1 A Se√ß√£o 26.5 √© um resumo dos bancos de dados dedutivos.

2 Um exemplo seria um evento temporal especificado como uma hora qualquer, como: dispare esta regra todo dia √†s 17h30.

de dados EMPRESA da Figura 3.5 e que aparece na Figura 26.1, com cada funcion√°rio tendo um nome ( Nome ),  n√∫mero de cadastro de pessoa f√≠sica ( Cpf ), sal√°rio  ( Salario ),  departamento  ao  qual  eles  est√£o atual  mente  designados ( Dnr ,  uma chave estrangeira para DEPARTAMENTO ) e um supervisor direto ( Cpf\_ supervisor , uma  chave  estrangeira  recursiva  para FUNCIONARIO ). Para  este  exemplo,  vamos  supor que NULL seja permitido para Dnr , indicando que um funcion√°rio pode n√£o estar temporariamente designado a nenhum departamento. Cada departamento tem um nome ( Dnome ), n√∫mero ( Dnr ), o sal√°rio total de  todos  os  funcion√°rios  designados  para  o  departamento ( Sal\_total ) e um gerente ( Cpf\_gerente , que √© uma chave estrangeira para FUNCIONARIO ).

Observe que o atributo Sal\_total √©, na realidade, um atributo derivado, cujo valor deve ser a soma dos sal√°rios de todos os funcion√°rios que est√£o atribu√≠dos ao departamento em particular. A manuten√ß√£o do valor correto desse atributo derivado pode ser feita por uma regra ativa. Primeiro, temos de determinar os eventos que podem causar uma mudan√ßa no valor de Sal\_total , que s√£o os seguintes:

- 1. Inserir (uma ou mais) tuplas de novos funcion√°rios.
- 2. Alterar o sal√°rio de (um ou mais) funcion√°rios existentes.
- 3. Alterar  a  designa√ß√£o  dos  funcion√°rios  existentes de um departamento para outro.
- 4. Excluir (uma ou mais) tuplas de funcion√°rios.

No caso do evento 1, s√≥ precisamos recalcular Sal\_total se  o  novo  funcion√°rio  for  imediatamente atribu√≠do  a  um  departamento  -  ou  seja,  se  o  valor do atributo Dnr para a nova tupla de funcion√°rio n√£o for NULL (supondo que NULL seja permitido para Dnr ). Logo, esta seria a condi√ß√£o a ser verificada. Uma condi√ß√£o semelhante poderia ser verificada

## FUNCIONARIO

Figura 26.1

| Nome         | Cpf          | Salario      | Dnr          | Cpf_supervisor   |
|--------------|--------------|--------------|--------------|------------------|
| DEPARTAMENTO | DEPARTAMENTO | DEPARTAMENTO | DEPARTAMENTO | DEPARTAMENTO     |
| Dnome        | Dnr          | Sal_total    |              | Cpf_gerente      |

Um banco de dados EMPRESA simplificado usado para os exemplos de regra ativa.

para o evento 2 (e 4) para determinar se o funcion√°rio cujo sal√°rio √© alterado (ou que est√° sendo exclu√≠do) est√° atualmente atribu√≠do a um departamento. Para o evento 3, sempre executaremos uma a√ß√£o para manter o valor de Sal\_total corretamente, de modo que nenhuma condi√ß√£o seja necess√°ria (a a√ß√£o sempre √© executada).

A a√ß√£o para os eventos 1, 2 e 4 √© atualizar automaticamente o valor de Sal\_total para  o  departamento do funcion√°rio, a fim de refletir o sal√°rio do funcion√°rio rec√©m-inserido, atualizado ou exclu√≠do. No caso do evento 3, uma a√ß√£o dupla √© necess√°ria: uma √© atualizar o Sal\_total do antigo departamento do  funcion√°rio  e  a  outra  √©  atualizar  o Sal\_total do novo departamento do funcion√°rio.

As quatro regras ativas (ou triggers) R1 , R2 , R3 e R4 - correspondentes √† situa√ß√£o acima - podem ser especificadas na nota√ß√£o do SGBD Oracle, como mostra a Figura 26.2(a). Vamos considerar a regra R1 para ilustrar a sintaxe da cria√ß√£o de triggers em Oracle.

A instru√ß√£o CREATE TRIGGER especifica o nome de uma trigger (ou regra ativa) -Sal\_total1 para R1. A cl√°usula AFTER especifica que a regra ser√° disparada depois que ocorrerem os eventos que disparam a regra. Os eventos de disparo - uma inser√ß√£o de um novo funcion√°rio, neste exemplo - s√£o especificados ap√≥s a palavra-chave AFTER . 3

A cl√°usula ON determina a rela√ß√£o em que a regra √© especificada FUNCIONARIO para R1. As palavras-chave opcionais FOR EACH ROW especificam que a regra ser√° disparada uma vez para cada linha que √© afetada pelo evento de disparo. 4

A cl√°usula opcional WHEN √©  utilizada  para  especificar quaisquer condi√ß√µes que precisam ser verificadas ap√≥s a regra ser disparada, mas antes que a a√ß√£o seja executada. Por fim, as a√ß√µes a serem tomadas s√£o especificadas como um bloco PL/SQL, que normalmente cont√©m um ou mais comandos SQL ou chamadas para executar procedimentos externos.

As quatro triggers (regras ativas) R1, R2, R3 e R4 ilustram uma s√©rie de recursos das regras ativas. Primeiro, os eventos b√°sicos que podem ser especificados para disparar as regras s√£o os comandos de atualiza√ß√£o da SQL padr√£o: INSERT DELETE , e UPDATE . Eles s√£o especificados pelas palavras-chave INSERT , DELETE e UPDATE na nota√ß√£o Oracle. No caso de UPDATE , podem-se especificar os atributos a serem atualizados - por exemplo, ao escrever UPDATE OF Salario, Dnr. Segundo, o projetista da regra precisa ter um modo de se referir √†s tuplas que foram inseridas,

3 Conforme veremos, tamb√©m √© poss√≠vel especificar BEFORE em vez de AFTER, que indica que a regra √© disparada antes que o evento de disparo seja executado .

4 Novamente, veremos que uma alternativa √© disparar a regra apenas uma vez , mesmo que v√°rias linhas (tuplas) sejam afetadas pelo evento de disparo.

(a)

## R1: CREATE TRIGGER Sal\_total1

AFTER INSERT ON FUNCIONARIO

FOR EACH ROW

WHEN ( NEW .Dnr IS NOT NULL )

UPDATE DEPARTAMENTO

SET Sal\_total = Sal\_total + NEW .Salario

WHERE Dnr = NEW .Dnr;

## R2: CREATE TRIGGER Sal\_total2

AFTER UPDATE OF

Salario ON FUNCIONARIO

FOR EACH ROW

WHEN ( NEW .Dnr IS NOT NULL )

UPDATE DEPARTAMENTO

SET Sal\_total = Sal\_total + NEW .Salario - OLD .Salario

WHERE Dnr = NEW .Dnr;

## R3: CREATE TRIGGER Sal\_total3

AFTER UPDATE OF Dnr ON FUNCIONARIO

FOR EACH ROW

BEGIN

UPDATE DEPARTAMENTO

SET Sal\_total = Sal\_total + NEW .Salario

WHERE Dnr = NEW .Dnr;

UPDATE DEPARTAMENTO

SET Sal\_total = Sal\_total - OLD .Salario

WHERE Dnr = OLD .Dnr;

END ;

R4:

CREATE TRIGGER

Sal\_total4

AFTER DELETE ON FUNCIONARIO

FOR EACH ROW

WHEN  OLD

( .Dnr IS NOT NULL )

UPDATE DEPARTAMENTO

SET Sal\_total = Sal\_total - OLD .Salario

WHERE Dnr = OLD .Dnr;

## (b) R5: CREATE TRIGGER Informar\_supervisor1

BEFORE INSERT OR UPDATE OF Salario, Cpf\_supervisor

ON FUNCIONARIO

FOR EACH ROW

WHEN  NEW (

.Salario &gt; ( SELECT Salario FROM FUNCIONARIO

WHERE Cpf = NEW .Cpf\_supervisor ) )

informar\_supervisor ( NEW .Cpf\_supervisor, NEW .Cpf );

## Figura  26.2

exclu√≠das ou modificadas pelo evento de disparo. As palavras-chave NEW e OLD s√£o empregadas na nota√ß√£o Oracle; NEW √© utilizada para se referir a uma tupla rec√©m-inserida ou rec√©m-atualizada, enquanto OLD √© usada para se referir a uma tupla exclu√≠da ou a uma tupla antes que ela seja atualizada.

Assim, a regra R1 √© disparada ap√≥s uma opera√ß√£o INSERT ser  aplicada  √†  rela√ß√£o FUNCIONARIO . Em R1, a condi√ß√£o ( NEW. Dnr IS NOT NULL ) √© verificada, e, se for avaliada como verdadeira, significando que a tupla de funcion√°rio rec√©m-inserida est√° relacionada a um departamento, ent√£o a a√ß√£o √© executada. A a√ß√£o atualiza a(s) tupla(s) de DEPARTAMENTO relacionada(s) ao funcion√°rio rec√©m-inserido, acrescentando seu sal√°rio ( NEW .Salario ) ao atributo Sal\_ total de seu departamento relacionado.

A regra R2 √© semelhante a R1, mas √© disparada por uma opera√ß√£o UPDATE que atualiza o SALARIO de um funcion√°rio, em vez de por um INSERT. A regra R3 √© disparada por uma atualiza√ß√£o no atributo Dnr de FUNCIONARIO, o  que  significa  alterar  a  designa√ß√£o  de  um  funcion√°rio  de  um  departamento para outro. N√£o existe condi√ß√£o a verificar em R3, de modo que a a√ß√£o √© executada sempre que o evento de disparo ocorre. A a√ß√£o atualiza tanto o departamento antigo quanto o novo dos funcion√°rios redesignados, somando seu sal√°rio a Sal\_total de seu novo departamento  e  subtraindo  seu  sal√°rio  do Sal\_total de seu antigo departamento. Observe que isso deve funcionar mesmo que o valor de Dnr seja NULL, pois nesse  caso  nenhum  departamento  ser√°  selecionado para a a√ß√£o da regra. 5

√â  importante  notar  o  efeito  da  cl√°usula FOR EACH ROW , que significa que a regra √© disparada separadamente para cada tupla . Isso √© conhecido como uma trigger de n√≠vel de linha . Se essa cl√°usula fosse omitida, a trigger seria conhecida como uma trigger em n√≠vel de comando , e seria disparada uma vez para cada comando de disparo. Para ver a diferen√ßa, considere a seguinte opera√ß√£o de atualiza√ß√£o, que gera um aumento de 10 por cento para todos os funcion√°rios designados para o departamento 5. Essa opera√ß√£o seria um evento que dispara a regra R2:

UPDATE SET WHERE

FUNCIONARIO

Salario = 1,1 *  Salario

Dnr = 5;

Como o comando acima poderia atualizar v√°rios registros, uma regra que usa a sem√¢ntica em n√≠vel de linha, como R2 na Figura 26.2, seria disparada uma vez para cada linha , enquanto uma regra que utiliza a sem√¢ntica em n√≠vel de comando √© disparada apenas uma vez . O sistema Oracle permite que o usu√°rio escolha qual dessas op√ß√µes deve ser usada para cada regra.  A  inclus√£o  da  cl√°usula  opcional FOR  EACH ROW cria uma trigger em n√≠vel de linha, e omiti-la cria uma trigger em n√≠vel de comando. Observe que as palavras-chave NEW e OLD s√≥ podem ser utilizadas com triggers em n√≠vel de linha.

Como um segundo  exemplo,  suponha  que  queiramos verificar sempre se o sal√°rio de um funcion√°rio √© maior que o sal√°rio de seu supervisor direto. V√°rios eventos podem disparar essa regra: inserir um novo funcion√°rio, alterar o sal√°rio de um funcion√°rio ou alterar o supervisor de um funcion√°rio. Suponha que a a√ß√£o a tomar seja chamar um procedimento externo informar\_ supervisor, 6 que notificar√° o supervisor. A regra poderia, ent√£o, ser escrita como em R5 (ver Figura 26.2(b)).

A Figura 26.3 mostra a sintaxe para especificar algumas das principais op√ß√µes dispon√≠veis nas triggers Oracle. Na Se√ß√£o 26.1.5, descreveremos a sintaxe para as triggers no padr√£o SQL-99.

## 26.1.2 Quest√µes de projeto e implementa√ß√£o para bancos de dados ativos

A se√ß√£o anterior forneceu uma vis√£o geral de alguns dos principais conceitos para especificar regras ativas.  Nesta  se√ß√£o,  discutimos  algumas  quest√µes adicionais  referentes  √†  forma  como  as  regras  s√£o projetadas  e  implementadas.  A  primeira  quest√£o est√° relacionada √† ativa√ß√£o, desativa√ß√£o e agrupamento de regras. Al√©m de criar regras, um sistema de banco de dados ativo deve permitir que os usu√°rios ativem , desativem e removam regras ao referir-se a seus nomes de regra. Uma regra desativada n√£o ser√° disparada pelo evento de disparo. Esse recurso permite  que  os  usu√°rios  seletivamente  desativem regras por certos per√≠odos quando elas n√£o forem necess√°rias. O comando de ativa√ß√£o tornar√° a regra ativa novamente. O comando de remo√ß√£o exclui a regra do sistema. Outra op√ß√£o √© agrupar as regras em conjuntos de regras nomeados, de modo que o conjunto inteiro de regras possa ser ativado, desativado ou removido. Tamb√©m √© √∫til ter um comando que possa disparar uma regra ou conjunto de regras por meio de um comando PROCESS RULES expl√≠cito, emitido pelo usu√°rio.

5 R1, R2 e R4 tamb√©m podem ser escritas sem uma condi√ß√£o. Por√©m, pode ser mais eficiente execut√°-las com a condi√ß√£o, pois a a√ß√£o n√£o √© chamada a menos que seja exigida.

6 Considerando que um procedimento externo apropriado tenha sido declarado. Esse √© um recurso que est√° dispon√≠vel na SQL-99 e em padr√µes posteriores.

```
<trigger> ::= CREATE TRIGGER <nome trigger> ( AFTER I BEFORE ) <evento trigger> ON <nome tabela> [ FOR EACH ROW ] [ WHEN <condi√ß√£o> ] <a√ß√µes da trigger > ; <evento triggering > ::= <evento trigger>  { OR <evento trigger>  } < evento trigger > ::= INSERT I DELETE I UPDATE [ OF <nome coluna>  {, <nome coluna>  } ] < acao trigger > ::= <bloco PL/SQL>
```

Figura 26.3

Um resumo de sintaxe para especificar triggers no sistema Oracle (apenas op√ß√µes principais).

A segunda quest√£o diz respeito a se a a√ß√£o disparada deve ser executada antes , depois , no lugar de ou juntamente com o evento de disparo. Uma trigger before executa a trigger antes de executar o evento que a causou. Ela pode ser usada em aplica√ß√µes como a verifica√ß√£o de viola√ß√µes de restri√ß√£o. Uma trigger after executa a trigger depois de executar o evento, e pode ser usada em aplica√ß√µes como a manuten√ß√£o de  dados  derivados  e  monitoramento  de  eventos  e condi√ß√µes espec√≠ficas. Uma trigger instead of executa a trigger em vez de executar o evento, e pode ser utilizada em aplica√ß√µes como executar atualiza√ß√µes correspondentes em rela√ß√µes da base em resposta a um evento que √© uma atualiza√ß√£o de uma vis√£o.

Uma quest√£o relacionada √© se a a√ß√£o que est√° sendo executada deve ser considerada uma transa√ß√£o separada ou se deve fazer parte da mesma transa√ß√£o que disparou a regra. Tentaremos categorizar as diversas op√ß√µes. √â importante observar que nem todas as op√ß√µes podem estar dispon√≠veis para determinado sistema de banco de dados ativo. De fato, a maioria dos sistemas comerciais √© limitada a uma ou duas das op√ß√µes que discutiremos em seguida.

Vamos  supor  que  o  evento  de  disparo  ocorra como  parte  da  execu√ß√£o  de  uma  transa√ß√£o.  Devemos considerar primeiro as diversas op√ß√µes de como o evento de disparo est√° relacionado √† avalia√ß√£o da condi√ß√£o da regra. A avalia√ß√£o de condi√ß√£o da regra tamb√©m  √©  conhecida  como considera√ß√£o  da  regra , pois  a  a√ß√£o  deve  ser  executada  somente  depois  de considerar se a condi√ß√£o √© avaliada como verdadeira ou falsa. Existem tr√™s possibilidades principais para a considera√ß√£o da regra:

- ¬Ñ ¬Ñ Avaliar  a  condi√ß√£o antes de  executar  o evento de disparo.
- ¬Ñ ¬Ñ Avaliar  a  condi√ß√£o depois de  executar  o evento de disparo.
- ¬Ñ ¬Ñ Avaliar a condi√ß√£o em vez de executar o evento de disparo.
- 2. Considera√ß√£o adiada. A condi√ß√£o √© avaliada ao final da transa√ß√£o que incluiu o evento de disparo.  Nesse  caso,  pode  haver  muitas  regras disparadas esperando para ter suas condi√ß√µes avaliadas.
- 3. Considera√ß√£o  separada. A  condi√ß√£o  √©  avaliada como uma transa√ß√£o separada, gerada com base na transa√ß√£o de disparo.

O pr√≥ximo conjunto de op√ß√µes refere-se ao relacionamento entre a avalia√ß√£o da condi√ß√£o de regra e a execu√ß√£o da a√ß√£o da regra. Aqui, novamente, tr√™s op√ß√µes s√£o poss√≠veis: execu√ß√£o imediata , adiada ou separada . A maioria dos sistemas ativos utiliza a primeira op√ß√£o. Ou seja, assim que a condi√ß√£o √© avaliada, se ela retornar verdadeira, a a√ß√£o √© executada imediatamente.

- 1. Considera√ß√£o imediata. A condi√ß√£o √© avaliada como parte da mesma transa√ß√£o que o evento de disparo, e √© avaliada imediatamente .  Esse caso pode ser categorizado ainda em tr√™s op√ß√µes:
- O sistema Oracle (ver Se√ß√£o 26.1.1) utiliza o modelo de considera√ß√£o imediata , mas permite que o usu√°rio especifique para cada regra se a op√ß√£o before ou after deve ser usada com a avalia√ß√£o de condi√ß√£o imediata. Ele tamb√©m usa o modelo de execu√ß√£o  imediata .  O  sistema  STARBURST  (ver Se√ß√£o 26.1.3) tem a op√ß√£o de considera√ß√£o adiada ,  significando  que  todas  as  regras  disparadas por  uma  transa√ß√£o  esperam  at√©  que  a  transa√ß√£o de disparo alcance seu fim e emita seu comando COMMIT WORK antes  que  as  condi√ß√µes  da  regra sejam avaliadas. 7

7 O STARBURST tamb√©m permite que o usu√°rio inicie a considera√ß√£o da regra explicitamente por meio do comando PROCESS RULES.

Outra quest√£o referente a regras de banco de dados ativo √© a distin√ß√£o entre regras em n√≠vel de linha e regras em n√≠vel de comando . Como as instru√ß√µes de atualiza√ß√£o SQL (que atuam como eventos de disparo) podem especificar um conjunto de tuplas, √© preciso distinguir se a regra deve ser considerada uma vez para o comando inteiro ou se deve ser considerada separadamente para cada linha (ou  seja,  tupla)  afetada pelo comando. O padr√£o SQL-99 (ver Se√ß√£o 26.1.5) e o sistema Oracle (ver Se√ß√£o 26.1.1) permitem que o usu√°rio escolha qual das op√ß√µes deve ser usada para cada regra, enquanto o STARBURST utiliza apenas a sem√¢ntica em n√≠vel de comando. Daremos exemplos de como as triggers em n√≠vel de comando podem ser especificadas na Se√ß√£o 26.1.3.

Uma das dificuldades que podem ter limitado o uso generalizado de regras ativas, apesar de seu potencial para simplificar o desenvolvimento de banco de dados e software, √© que n√£o existem t√©cnicas de f√°cil utiliza√ß√£o para projetar, escrever e verificar regras. Por exemplo, √© muito dif√≠cil verificar se um conjunto de regras √© consistente ,  significando que duas ou mais regras no conjunto n√£o contradizem uma √† outra.  √â  dif√≠cil  garantir  o t√©rmino de  um  conjunto de  regras  sob  todas  as  circunst√¢ncias.  Para  ilustrar o problema do t√©rmino resumidamente, considere as regras da Figura 26.4. Aqui, a regra R1 √© disparada por um evento INSERT na TABLE1 e sua a√ß√£o inclui um evento de atualiza√ß√£o em Attribute1 de TABLE2. Por√©m, o evento de disparo da regra R2 √© um evento UPDATE em Attribute1 de TABLE2, e  sua a√ß√£o inclui um evento INSERT na TABLE1. Neste exemplo, √© f√°cil ver que essas duas regras podem disparar uma √† outra indefinidamente, levando ao n√£o t√©rmino. Contudo, se dezenas de regras forem escritas, √© muito dif√≠cil determinar se o t√©rmino √© garantido ou n√£o.

R1:  CREATE TRIGGER T1 AFTER INSERT ON TABLE1 FOR EACH ROW

UPDATE TABLE2

SET Attribute1 = ... ;

R2:  CREATE TRIGGER T2

AFTER UPDATE OF Attribute1 ON TABLE2 FOR EACH ROW

INSERT INTO TABLE1 VALUES ( ... );

Figura 26.4

Um exemplo para ilustrar o problema de t√©rmino para regras ativas.

Se as regras ativas tiverem de alcan√ßar seu potencial, √© necess√°rio desenvolver ferramentas para o projeto, depura√ß√£o e monitoramento de regras ativas que possam ajudar os usu√°rios a projetarem e depurarem suas regras.

## 26.1.3 Exemplos de regras ativas em n√≠vel de comando no STARBURST

Agora, oferecemos alguns exemplos para ilustrar como as regras podem ser especificadas no SGBD experimental STARBURST. Isso nos permitir√° demonstrar como as regras em n√≠vel de comando podem ser escritas, pois estes s√£o os √∫nicos tipos de regras permitidas no STARBURST.

As tr√™s regras ativas R1S, R2S e R3S da Figura 26.5 correspondem √†s tr√™s primeiras regras da Figura 26.2, mas elas usam a nota√ß√£o do STARBURST e a sem√¢ntica em n√≠vel de comando. Podemos explicar a estrutura da regra com a regra R1S. O comando CREATE RULE especifica  um  nome  de  regra  -Sal\_total1 para R1S. A cl√°usula ON especifica a rela√ß√£o na qual a regra √© especificada FUNCIONARIO para R1S. A  cl√°usula WHEN √©  usada  para  especificar os eventos que disparam a regra. 8  A cl√°usula IF opcional √©  utilizada  para  especificar  quaisquer condi√ß√µes que precisam ser verificadas. Finalmente, usa-se a cl√°usula THEN para especificar as a√ß√µes a serem tomadas, que normalmente s√£o um ou mais comandos SQL.

No STARBURST, os eventos b√°sicos que podem ser especificados para disparar as regras s√£o os comandos de atualiza√ß√£o SQL padr√£o: INSERT, DELETE e UPDATE. Estes s√£o especificados pelas palavras-chave INSERTED DELETED , e UPDATED na nota√ß√£o do STARBURST. Segundo, o projetista de regra precisa ter um modo de referenciar as tuplas que foram modificadas. As palavras-chave INSERTED , DELETED , NEW-UPDATED e OLD-UPDATED s√£o  empregadas na nota√ß√£o do STARBURST para se referirem a quatro tabelas de transi√ß√£o (rela√ß√µes) que incluem as tuplas rec√©m-inseridas, as tuplas exclu√≠das, as tuplas atualizadas antes que fossem atualizadas e as tuplas atualizadas depois que foram atualizadas, respectivamente. Obviamente, dependendo dos eventos de disparo, somente algumas dessas tabelas de transi√ß√£o podem estar dispon√≠veis. O escritor da regra pode se referir a  essas  tabelas  ao  escrever  as  partes  de  condi√ß√£o  e a√ß√£o dela. As tabelas de transi√ß√£o cont√™m tuplas do mesmo tipo que aquelas na rela√ß√£o especificada na cl√°usula ON da regra - para R1S, R2S e R3S, esta √© a rela√ß√£o FUNCIONARIO .

8 Observe que a palavra-chave WHEN especifica eventos no STARBURST, mas serve para especificar a regra condi√ß√£o em SQL e triggers Oracle.

## R1S: CREATE RULE Sal\_total1 ON FUNCIONARIO

WHEN  INSERTED

IF

EXISTS

( SELECT * FROM INSERTED WHERE Dnr IS NOT NULL )

THEN  UPDATE

DEPARTAMENTO AS D

SET

D.Sal\_total = D.Sal\_total +

( SELECT SUM (I.Salario) FROM INSERTED AS  WHERE I D.Dnr = I.Dnr )

WHERE

D.Dnr IN ( SELECT Dnr FROM INSERTED

);

## R2S: CREATE RULE Sal\_total2 ON FUNCIONARIO

WHEN  UPDATED

( Salario )

IF

EXISTS

( SELECT * FROM NEW-UPDATED WHERE Dnr IS NOT NULL )

OR EXISTS

( SELECT * FROM OLD-UPDATED WHERE Dnr IS NOT NULL )

THEN  UPDATE

DEPARTAMENTO AS D

SET

D.Sal\_total = D.Sal\_total +

( SELECT SUM (N.Salario) FROM NEW-UPDATED AS N

WHERE D.Dnr = N.Dnr ) -

( SELECT SUM (O.Salario) FROM OLD-UPDATED AS O

WHERE D.Dnr = O.Dnr )

WHERE

D.Dnr IN ( SELECT Dnr )

FROM NEW-UPDATED  OR );

D.Dnr IN ( SELECT Dnr FROM OLD-UPDATED

R3S: CREATE RULE Sal\_total3 ON FUNCIONARIO

WHEN  UPDATED

( Dnr )

THEN  UPDATE

DEPARTAMENTO AS D

SET

D.Sal\_total = D.Sal\_total +

( SELECT SUM (N.Salario) FROM NEW-UPDATED AS N WHERE D.Dnr = N.Dnr )

WHERE

D.Dnr IN ( SELECT Dnr FROM NEW-UPDATED );

UPDATE

DEPARTAMENTO AS D

SET

D.Sal\_total = D.Sal\_total -

( SELECT SUM (O.Salario) FROM OLD-UPDATED AS O

WHERE

D.Dnr = O.Dnr )

WHERE

D.Dnr IN ( SELECT Dnr FROM OLD-UPDATED );

Figura 26.5

Regras ativas usando sem√¢ntica em n√≠vel de comando na nota√ß√£o do STARBURST.

Na sem√¢ntica em n√≠vel de comando, o projetista da regra s√≥ pode se referir √†s tabelas de transi√ß√£o como um todo, e a regra √© disparada apenas uma vez, de modo que as regras precisam ser escritas de forma diferente daquela para a sem√¢ntica em n√≠vel de linha. Como v√°rias tuplas de funcion√°rios podem ser inseridas em um √∫nico comando de inser√ß√£o, temos de verificar se pelo menos uma das tuplas de funcion√°rio rec√©m-inseridas est√° relacionada a um departamento. Em R1S , a condi√ß√£o

√© verificada e, se for avaliada como verdadeira, ent√£o a  a√ß√£o  √©  executada.  A  a√ß√£o  atualiza  em  um  √∫nico comando as tuplas de DEPARTAMENTO relacionadas aos funcion√°rios rec√©m-inseridos ao acrescentar seus sal√°rios ao atributo Sal\_total de  cada departamento relacionado. Como mais de um funcion√°rio rec√©m-inserido  pode  pertencer  ao  mesmo  departamento, usamos  a  fun√ß√£o  de  agrega√ß√£o SUM para  garantir que todos os seus sal√°rios sejam atualizados.

EXISTS ( SELECT * FROM INSERTED WHERE Dnr IS NOT NULL )

A regra R2S √© semelhante √† R1S, mas √© disparada por uma opera√ß√£o UPDATE que atualiza o sal√°rio  de  um  ou  mais  funcion√°rios,  em  vez  de  um

INSERT. A regra R3S √© disparada por uma atualiza√ß√£o no atributo Dnr de FUNCIONARIO, que significa alterar a designa√ß√£o de um ou mais funcion√°rios de um departamento para outro. N√£o existe condi√ß√£o em R3S, de  modo que a a√ß√£o √© executada sempre que  o  evento  de  disparo  ocorre. 9 A  a√ß√£o  atualiza tanto  o(s)  departamento(s)  antigo(s)  quanto  o(s) departamento(s)  novo(s)  dos  funcion√°rios redesignados,  somando  seu  sal√°rio  a Sal\_total de  cada departamento novo e  subtraindo-o  de Sal\_total de cada departamento antigo .

Em nosso exemplo, √© mais complexo escrever as regras em n√≠vel de comando do que em n√≠vel de linha, como  pode  ser  ilustrado  ao  se  comparar  as  figuras 26.2 e 26.5. No entanto, essa n√£o √© uma regra geral, e outros tipos de regras ativas podem ser mais f√°ceis de especificar quando se usa a nota√ß√£o em n√≠vel de comando do que quando se usa a nota√ß√£o em n√≠vel de linha.

O  modelo  de  execu√ß√£o  para  regras  ativas  no STARBURST  usa  a considera√ß√£o  adiada .  Ou  seja, todas as regras que s√£o disparadas em uma transa√ß√£o s√£o colocadas em um conjunto - chamado conjunto de conflito - que n√£o √© considerado para avalia√ß√£o de condi√ß√µes e execu√ß√£o at√© que a transa√ß√£o termine (emitindo seu comando COMMIT WORK ). O STARBURST tamb√©m permite que o usu√°rio inicie explicitamente  a  considera√ß√£o  da  regra  no  meio  de uma transa√ß√£o por meio de um comando PROCESS RULES expl√≠cito.  Como  v√°rias  regras  precisam  ser avaliadas,  √©  necess√°rio  especificar  uma  ordem  entre as  regras.  A  sintaxe  para  a  declara√ß√£o  da  regra  no STARBURST permite a especifica√ß√£o da ordena√ß√£o entre as regras para instruir o sistema sobre a ordem em que um conjunto de regras deve ser considerado. 10 Al√©m disso, as tabelas de transi√ß√£o INSERTED, DE -LETED, NEW-UPDATED e OLD-UPDATED - cont√™m o efeito de entrela√ßamento (net effect) de todas as opera√ß√µes na transa√ß√£o que afetaram cada tabela, pois m√∫ltiplas opera√ß√µes podem ter sido aplicadas a cada tabela durante a transa√ß√£o.

## 26.1.4 Aplica√ß√µes em potencial para bancos de dados ativos

Agora,  discutimos  rapidamente  algumas  das aplica√ß√µes em potencial das regras ativas. Obviamente, uma aplica√ß√£o importante √© permitir a notifica√ß√£o de certas condi√ß√µes que ocorrem. Por exemplo, um banco de dados ativo pode ser usado para monitorar, digamos, a temperatura de uma fornalha industrial.

A aplica√ß√£o pode inserir periodicamente no banco de dados os registros de leitura de temperatura diretamente dos sensores de temperatura, e regras ativas podem ser escritas, que s√£o ativadas sempre que um registro de temperatura for inserido, com uma condi√ß√£o que verifica se a temperatura excede o n√≠vel de perigo, e resulta na a√ß√£o para disparar um alarme.

As regras ativas tamb√©m podem ser usadas para impor restri√ß√µes de integridade ao especificar os tipos de eventos que podem fazer que as restri√ß√µes sejam violadas e, depois, avaliar condi√ß√µes apropriadas que verificam se as restri√ß√µes s√£o realmente violadas pelo evento ou n√£o. Logo, as restri√ß√µes de aplica√ß√£o complexas, normalmente conhecidas como regras de neg√≥cios , podem ser impostas dessa forma. Por exemplo, na aplica√ß√£o de banco de dados UNIVERSIDADE , uma regra pode monitorar a m√©dia dos alunos sempre que uma nova nota for inserida, e pode alertar o conselho se a m√©dia de um aluno ficar abaixo de certo patamar. Outra regra pode verificar se os pr√©-requisitos do curso s√£o satisfeitos antes de permitir que um aluno se matricule em uma disciplina; e assim por diante.

Outras aplica√ß√µes incluem a manuten√ß√£o autom√°tica de dados derivados , como os exemplos das regras de R1 a R4 que mant√™m o atributo derivado Sal\_total sempre que tuplas de funcion√°rio individual s√£o alteradas. Uma aplica√ß√£o semelhante √© usar regras ativas para  manter  a  consist√™ncia  de vis√µes  materializadas (ver Se√ß√£o 5.3) sempre que as rela√ß√µes da base s√£o modificadas. Como alternativa, uma opera√ß√£o de atualiza√ß√£o especificada em uma vis√£o pode ser um evento de disparo, que pode ser convertido para atualiza√ß√µes nas rela√ß√µes de base ao usar uma trigger instead of . Essas aplica√ß√µes tamb√©m s√£o relevantes para as novas tecnologias de data warehousing (ver Cap√≠tulo 29). Uma aplica√ß√£o relacionada mant√©m que tabelas replicadas s√£o consistentes ao especificar regras que modificam as r√©plicas sempre que a tabela mestra √© modificada.

## 26.1.5 Triggers na SQL-99

As triggers na SQL-99 e padr√µes posteriores s√£o muito semelhantes aos exemplos que discutimos na Se√ß√£o 26.1.1, com algumas pequenas diferen√ßas sint√°ticas. Os eventos b√°sicos que podem ser especificados para disparar as regras s√£o os comandos de atualiza√ß√£o SQL padr√£o: INSERT , DELETE e UPDATE . No caso de UPDATE , podem-se especificar os atributos a serem atualizados. Tanto as triggers em n√≠vel de linha quando em n√≠vel de comando s√£o permitidas, indica-

9 Assim como nos exemplos do Oracle, as regras R1S e R2S podem ser escritas sem uma condi√ß√£o. Por√©m, pode ser mais eficiente execut√°-las com a condi√ß√£o, j√° que a a√ß√£o n√£o √© chamada a menos que seja exigida.

10 Se nenhuma ordem for especificada entre um par de regras, a ordem default do sistema √© baseada na coloca√ß√£o da regra declarada primeiro, antes da outra regra.

T1: CREATE TRIGGER Sal\_total1

AFTER UPDATE OF Salario ON FUNCIONARIO

REFERENCING OLD ROW AS O, NEW ROW AS N

FOR EACH ROW

WHEN ( N.Dnr IS NOT NULL )

UPDATE DEPARTAMENTO

SET Sal\_total = Sal\_total + N.salario - O.salario

WHERE Dnr = N.Dnr;

T2: CREATE TRIGGER Sal\_total2

AFTER UPDATE OF

Salario ON FUNCIONARIO

REFERENCING OLD TABLE AS O, NEW TABLE AS N

FOR EACH STATEMENT

WHEN  EXISTS ( SELECT * FROM N WHERE N.Dnr IS NOT NULL )

OR )

EXISTS ( SELECT * FROM O WHERE O.Dnr IS NOT NULL

UPDATE DEPARTAMENTO AS D

SET D.Sal\_total = D.Sal\_total

+ ( SELECT SUM (N.Salario) FROM N WHERE D.Dnr=N.Dnr )

- ( SELECT SUM (O.Salario) FROM O WHERE D.Dnr=O.Dnr )

WHERE Dnr IN ( ( SELECT Dnr FROM N ) UNION ( SELECT Dnr FROM O ) );

Figura 26.6

Trigger T1 ilustrando a sintaxe para definir triggers na SQL-99.

das na trigger pelas cl√°usulas FOR EACH ROW e FOR EACH STATEMENT ,  respectivamente. Uma diferen√ßa sint√°tica  √©  que  a  trigger  pode  especificar  nomes  de vari√°vel de tupla em particular para as tuplas antiga e nova em vez de usar as palavras-chave NEW e OLD , como mostra a Figura 26.1. A trigger T1 da Figura 26.6 mostra como a trigger em n√≠vel de linha R2 da Figura 26.1(a) pode ser especificada na SQL-99. Dentro da cl√°usula REFERENCING , nomeamos vari√°veis de tupla (apelidos) O e N para nos referirmos √† tupla OLD (antes  da  modifica√ß√£o) e √† tupla NEW (ap√≥s a modifica√ß√£o), respectivamente. A trigger T2 da  Figura  26.6  mostra  como  a  trigger  em  n√≠vel  de comando R2S da Figura 26.5 pode ser especificada na SQL-99. Para uma trigger em n√≠vel de comando, a  cl√°usula REFERENCING √©  usada  para  se  referir  √† tabela de todas as tuplas novas (rec√©m-inseridas ou rec√©m-atualizadas) como N , enquanto a tabela de todas as tuplas antigas (tuplas exclu√≠das ou tuplas antes que sejam atualizadas) √© referenciada como O .

## 26.2 Conceitos de banco de dados temporal

Bancos  de  dados  temporais,  no  sentido  mais amplo,  abrangem  todas  as  aplica√ß√µes  de  banco  de dados que exigem algum aspecto de tempo quando organizam suas informa√ß√µes. Logo, elas oferecem um bom exemplo para ilustrar a necessidade de desenvolver um conjunto de conceitos de unifica√ß√£o para os desenvolvedores de aplica√ß√£o usarem. Aplica√ß√µes de banco de dados temporal t√™m sido desenvolvidas desde os primeiros dias do uso do banco de dados. Por√©m, na cria√ß√£o dessas aplica√ß√µes, fica principalmente a cargo dos projetistas e desenvolvedores de aplica√ß√£o descobrir, projetar, programar e implementar  os  conceitos  temporais  de  que  eles  necessitam. Existem muitos exemplos de aplica√ß√µes em que algum aspecto de tempo √© necess√°rio para manter as informa√ß√µes em um banco de dados. Entre eles est√£o a √°rea de sa√∫de ,  em  que  hist√≥ricos  de  paciente precisam ser mantidos; seguro , em que hist√≥ricos de acicles e sinistros s√£o necess√°rios, bem como informa√ß√µes sobre as datas em que as ap√≥lices de seguro est√£o em vigor; sistemas de reserva em geral (hotel, companhia a√©rea, aluguel de carro etc.), em que informa√ß√µes  sobre  datas  e  hor√°rios  das  reservas  s√£o necess√°rias; bancos de dados cient√≠ficos ,  em que os dados coletados de experimentos incluem o hor√°rio em que cada dado √© medido; e assim por diante. At√© mesmo os dois exemplos usados neste livro podem ser facilmente expandidos para aplica√ß√µes temporais. No banco de dados EMPRESA , podemos querer manter hist√≥ricos de SALARIO, CARGO e PROJETO sobre

cada funcion√°rio. No banco de dados UNIVERSIDA -DE ,  a  hora  j√°  est√°  inclu√≠da  em SEMESTRE e ANO de cada TURMA de uma DISCIPLINA, o hist√≥rico de notas de um ALUNO e as informa√ß√µes sobre concess√µes de pesquisa. De fato, √© correto concluir que a maioria das aplica√ß√µes de banco de dados possui alguma informa√ß√£o temporal. Por√©m, os usu√°rios normalmente tentam simplificar ou ignorar os aspectos temporais por causa da complexidade que eles acrescentam √†s suas aplica√ß√µes.

Nesta se√ß√£o, apresentaremos alguns dos conceitos que foram desenvolvidos para lidar com a complexidade das aplica√ß√µes de bancos de dados temporais. A Se√ß√£o 26.2.1 cont√©m uma vis√£o geral de como o tempo √© representado nos bancos de dados, os diferentes tipos de informa√ß√µes temporais e algumas das diferentes dimens√µes do tempo que podem ser necess√°rias.  A  Se√ß√£o 26.2.2 discute como o tempo pode ser incorporado nos bancos de dados relacionais. A Se√ß√£o 26.2.3 oferece algumas op√ß√µes adicionais para representar o tempo, que s√£o poss√≠veis nos modelos de banco de dados que permitem objetos estruturados complexos, como bancos de dados de objeto. A Se√ß√£o  26.2.4  introduz  opera√ß√µes  para  consulta  de bancos de dados temporais e oferece uma breve vis√£o geral da linguagem TSQL2, que estende a SQL com conceitos temporais. A Se√ß√£o 26.2.5 focaliza os dados de s√©rie temporal, que √© um tipo de dado temporal muito importante na pr√°tica.

## 26.2.1 Representa√ß√£o de tempo, calend√°rios e dimens√µes de tempo

Como  n√£o  existe  um  in√≠cio  ou  fim  conhecido para o tempo, √© preciso que haja um ponto de refer√™ncia  para  medir  pontos  espec√≠ficos  no  tempo. Diversos calend√°rios s√£o usados por v√°rias culturas (como  o  gregoriano  -  ocidental,  chin√™s,  isl√¢mico, hindu, judeu, c√≥ptico etc.), com diferentes pontos de refer√™ncia. Um calend√°rio organiza o tempo em diferentes unidades por conveni√™ncia. A maioria dos calend√°rios agrupa 60 segundos em um minuto, 60 minutos em uma hora, 24 horas em um dia (com base no tempo f√≠sico da rota√ß√£o da terra em rela√ß√£o a seu eixo) e sete dias em uma semana. Outros agrupamentos de dias em meses e de meses em anos seguem o fen√¥meno natural solar ou lunar, e geralmente s√£o irregulares. No calend√°rio gregoriano, que √© usado na maioria dos pa√≠ses ocidentais, os dias s√£o agrupados em meses, que t√™m 28, 29, 30 ou 31 dias, e 12 meses s√£o agrupados em um ano. F√≥rmulas complexas s√£o utilizadas para mapear as diferentes unidades de tempo entre si.

Em SQL2, os tipos de dados temporais (ver Cap√≠tulo 4) incluem DATE (especificando dia, m√™s e ano como  DD-MM-AAAA), TIME (especificando  hora, minuto e  segundo  como  HH:MM:SS), TIMESTAMP (especificando  uma  combina√ß√£o  de  data/hora,  com op√ß√µes para incluir divis√µes de subsegundo, se forem necess√°rias), INTERVAL (uma dura√ß√£o de tempo relativa, como dez dias ou 250 minutos) e PERIOD (uma dura√ß√£o de tempo ancorada com um ponto de partida fixo, como o per√≠odo de dez dias desde 1 de janeiro de 2009 at√© 10 de janeiro de 2009, inclusive). 11

Para  bancos  de  dados  temporais,  o  tempo  √© considerado uma sequ√™ncia ordenada de pontos em alguma granularidade que √© determinado pela aplica√ß√£o. Por exemplo, suponha que alguma aplica√ß√£o temporal nunca exija unidades de tempo que s√£o menores que um segundo. Ent√£o, cada ponto no tempo representa  um  segundo  usando  essa  granularidade. Na realidade, cada segundo √© uma (curta) dura√ß√£o de tempo , e n√£o um ponto, pois ele pode ser dividido ainda em milissegundos, microssegundos, e assim por diante. Os pesquisadores de banco de dados temporal  t√™m  usado  o  termo cr√¥non em vez de ponto para descrever essa granularidade m√≠nima para determinada  aplica√ß√£o.  A  principal  consequ√™ncia  da escolha de uma granularidade m√≠nima - digamos, um segundo - √© que os eventos que ocorrem no mesmo segundo ser√£o considerados eventos simult√¢neos , embora na realidade eles podem n√£o ser.

Informa√ß√£o de evento versus informa√ß√£o de dura√ß√£o  (ou  estado). Um banco de dados temporal ainda armazenar√° informa√ß√µes referentes a quando certos eventos ocorrem, ou quando certos fatos s√£o considerados verdadeiros. Existem v√°rios tipos de informa√ß√µes temporais. Eventos ou fatos pontuais em geral s√£o associados no banco de dados a um √∫nico  ponto  no  tempo em  alguma  granularidade.  Por exemplo, um evento de dep√≥sito banc√°rio pode ser associado ao r√≥tulo de tempo de quando o dep√≥sito foi feito, ou as vendas totais mensais de um produto  (fato)  podem  ser  associadas  a  determinado  m√™s (digamos,  fevereiro  de  2010).  Observe  que,  embora tais eventos ou fatos possam ter diferentes n√≠veis de granularidades, cada um ainda √© associado a um √∫nico valor de tempo no banco de dados. Esse tipo de informa√ß√£o costuma ser representado como dado de  s√©rie  temporal ,  conforme  discutiremos  na  Se√ß√£o 26.2.5. Eventos ou fatos de dura√ß√£o , por sua vez, s√£o

11 Infelizmente, a terminologia n√£o tem sido usada de forma consistente. Por exemplo, o termo interval normalmente √© usado para indicar uma dura√ß√£o ancorada. Para consist√™ncia, usaremos a terminologia da SQL.

associados a um per√≠odo espec√≠fico no banco de dados. 12 Por exemplo, um funcion√°rio pode ter trabalhado em uma empresa desde 15 de agosto de 2003 at√© 20 de novembro de 2008.

Um period √©  representado por seus pontos inicial  e  final [START-TIME, END-TIME]. Por  exemplo, o  per√≠odo  que  acabamos  de  indicar  √©  representado como [15-08-2003, 20-11-2008]. Esse per√≠odo normalmente √© interpretado para indicar o conjunto de todos os pontos de tempo desde a data inicial at√© a data  final,  inclusive,  na  granularidade  especificada. Logo, considerando a granularidade de dia, o per√≠odo [15-08-2003, 20-11-2008] representa o conjunto de todos os dias desde 15 de agosto de 2003 at√© 20 de novembro de 2008, inclusive. 13

Dimens√µes de tempo v√°lido e tempo de transa√ß√£o. Dado um evento ou fato em particular, associado a um ponto no tempo ou per√≠odo em particular no banco de dados, a associa√ß√£o pode ser interpretada para indicar coisas diferentes. A interpreta√ß√£o mais natural √© que o tempo associado √© a hora em que o evento ocorreu, ou o per√≠odo durante o qual o fato foi considerado como verdadeiro no mundo real. Se essa interpreta√ß√£o for usada, o tempo associado com frequ√™ncia √© conhecido como tempo v√°lido . Um banco de dados temporal que usa essa interpreta√ß√£o √© chamado de banco de dados de tempo v√°lido .

Contudo, uma interpreta√ß√£o diferente pode ser utilizada,  na  qual  o  tempo  associado  refere-se  ao tempo em que a informa√ß√£o foi realmente armazenada no banco de dados; ou seja, √© o valor do clock de tempo do sistema quando a informa√ß√£o √© v√°lida no sistema . 14 Nesse caso, o tempo associado √© chamado de tempo de transa√ß√£o . Um banco de dados temporal que usa essa interpreta√ß√£o √© chamado de banco de dados de tempo de transa√ß√£o .

Outras interpreta√ß√µes tamb√©m podem ser intencionadas, mas estas s√£o consideradas as mais comuns e conhecidas como dimens√µes de tempo . Em algumas aplica√ß√µes, somente uma das dimens√µes √© necess√°ria e, em outros casos, as duas dimens√µes de tempo s√£o necess√°rias,  quando  o  banco  de  dados  temporal  √© chamado de banco de dados bitemporal .  Se  outras interpreta√ß√µes  forem  intencionadas  para  o  tempo, o usu√°rio pode definir a sem√¢ntica e programar as aplica√ß√µes devidamente, e ele √© chamado de tempo definido pelo usu√°rio .

A pr√≥xima se√ß√£o mostra como esses conceitos podem ser incorporados aos bancos de dados relacionais,  e  a  Se√ß√£o  26.2.3  aborda  uma  t√©cnica  para incorporar os conceitos temporais em bancos de dados de objeto.

## 26.2.2 ncorporando o tempo nos I bancos de dados relacionais com versionamento de tupla

Rela√ß√µes  de  tempo  v√°lidas. Vamos  agora  ver como diferentes tipos de bancos de dados temporais podem ser representados no modelo relacional. Primeiro, suponha que queiramos incluir o hist√≥rico das mudan√ßas conforme ocorrem no mundo real. Considere novamente o banco de dados da Figura 26.1, e vamos supor que, para essa aplica√ß√£o, a granularidade seja em n√≠vel de dia. Ent√£o, poder√≠amos converter as  duas  rela√ß√µes FUNCIONARIO e DEPARTAMENTO para rela√ß√µes de tempo v√°lidas ao acrescentar os atributos Tiv (Tempo Inicial V√°lido) e Tft (Tempo Final de Transa√ß√£o), cujo tipo de dado √© DATE, a  fim  de oferecer detalhamento de dia. Isso √© mostrado na Figura 26.7(a), em que as rela√ß√µes foram renomeadas para FUNC\_TV e DEP\_TV, respectivamente.

Considere  como  a  rela√ß√£o FUNC\_TV difere  da rela√ß√£o n√£o temporal FUNCIONARIO (Figura 26.1). 15 Em FUNC\_TV, cada  tupla V representa  uma vers√£o da informa√ß√£o de um funcion√°rio que √© v√°lida (no mundo real) apenas durante o per√≠odo [V.Tiv, V.Tfv], enquanto  em FUNCIONARIO cada  tupla  representa apenas o estado ou a vers√£o atual de cada funcion√°rio. Em FUNC\_TV, a vers√£o atual de cada funcion√°rio normalmente tem um valor especial, now , como seu  tempo  final  v√°lido.  Esse  valor  especial, now ,  √© uma vari√°vel temporal que implicitamente representa a hora atual √† medida que o tempo prossegue. A rela√ß√£o n√£o temporal FUNCIONARIO s√≥  incluiria  as tuplas da rela√ß√£o FUNC\_TV cujo Tfv √© now .

A Figura 26.8 mostra algumas vers√µes de tupla nas  rela√ß√µes  de  tempo  v√°lido FUNC\_TV e DEP\_TV. Existem duas vers√µes de Silva, tr√™s vers√µes de Wong, uma vers√£o de Braga e uma vers√£o de Lima. Agora, podemos ver como uma rela√ß√£o de tempo v√°lida deve se  comportar quando as informa√ß√µes s√£o trocadas. Sempre que um ou mais atributos de um funcion√°rio s√£o atualizados , em vez de simplesmente sobrescreve-

12 Isso √© o mesmo que uma dura√ß√£o ancorada . Tamb√©m tem sido constantemente chamado de intervalo de tempo , mas, para evitar confus√£o, usaremos period para sermos coerentes com a terminologia da SQL.

13 A representa√ß√£o [15-08-2003, 20-11-2008] √© chamada de representa√ß√£o de intervalo fechado . Tamb√©m √© poss√≠vel usar um intervalo aberto , indicado como [15-08-2003, 21-11-2008], em que o conjunto de pontos n√£o inclui o ponto final. Embora essa √∫ltima representa√ß√£o √†s vezes seja mais conveniente, usaremos os intervalos fechados, exceto quando indicado de outra forma.

14 A explica√ß√£o √© mais complicada, conforme veremos na Se√ß√£o 26.2.3.

15 Uma rela√ß√£o n√£o temporal tamb√©m √© chamada de rela√ß√£o de snapshot , pois mostra apenas o snapshot atual ou estadoatual do banco de dados.

(a) FUNC\_TV



| Nome                                                       | Cpf   | Salario   | Dnr         | Cpf_supervisor   | Tiv   |
|------------------------------------------------------------|-------|-----------|-------------|------------------|-------|
| DEP_TV                                                     |       |           |             |                  |       |
| Dnome Dnr Sal_total Cpf_gerente Tiv Tfv                    |       |           |             |                  |       |
| (b) FUNC_TT                                                |       |           |             |                  |       |
| Nome Cpf Salario Dnr Cpf_supervisor Tiv Tfv Tit Tft DEP_BT |       |           |             |                  |       |
| Dnome                                                      | Dnr   | Sal_total | Cpf_gerente | Tiv              | Tfv   |

## Figura 26.7

Diferentes tipos de bancos de dados relacionais temporais. (a) Esquema de banco de dados de tempo v√°lido. (b) Esquema de banco de dados de tempo de transa√ß√£o. (c) Esquema de banco de dados bitemporal.

FUNC\_TV

| Nome   |         Cpf |   Salario |   Dnr |   Cpf_supervisor | Tiv        | Tfv        |
|--------|-------------|-----------|-------|------------------|------------|------------|
| Silva  | 12345678966 |        25 |     5 |      33344555587 | 15-06-2002 | 31-05-2003 |
| Silva  | 12345678966 |        30 |     5 |      33344555587 | 01-06-2003 | Now        |
| Wong   | 33344555587 |        25 |     4 |      99988777767 | 20-08-1999 | 31-01-2001 |
| Wong   | 33344555587 |        30 |     5 |      99988777767 | 01-02-2001 | 31-03-2002 |
| Wong   | 33344555587 |        40 |     5 |      88866555576 | 01-04-2002 | Now        |
| Braga  | 22244777711 |        28 |     4 |      99988777767 | 01-05-2001 | 10-08-2002 |
| Lima   | 66688444476 |        38 |     5 |      33344555587 | 01-08-2003 | Now        |

‚Ä¶

DEP\_TV

| Dnome    |   Dnr |   Cpf_gerente | Tiv        | Tfv        |
|----------|-------|---------------|------------|------------|
| Pesquisa |     5 |   88866555576 | 20-09-2001 | 31-03-2002 |
| Pesquisa |     5 |   33344555587 | 01-04-2002 | Now        |

....

Figura 26.8

Algumas vers√µes de tupla nas rela√ß√µes de tempo v√°lidas FUNC\_TV e DEP\_TV.

rem os valores antigos, como aconteceria em uma rela√ß√£o n√£o temporal, o sistema deve criar outra vers√£o e fechar a vers√£o atual ao alterar seu Tfv para o tempo final. Logo, quando o usu√°rio emitiu o comando para atualizar o sal√°rio de Silva a partir de 1 de junho de 2003 para R$30.000, a segunda vers√£o de Silva foi criada (ver Figura 26.8). No momento dessa atualiza√ß√£o, a primeira vers√£o de Silva era a vers√£o atual, com now como seu Tfv, mas ap√≥s a atualiza√ß√£o now foi alterado para 31 de maio de 2003 (um a menos

que 1 de junho de 2003, com granularidade de dia), para indicar que a vers√£o tornou-se uma vers√£o fechada ou hist√≥rica e que a nova (segunda) vers√£o de Silva agora √© a atual.

√â importante observar que, em uma rela√ß√£o de tempo v√°lida, o usu√°rio geralmente precisa oferecer o tempo v√°lido de uma atualiza√ß√£o. Por exemplo, a atua  liza√ß√£o de sal√°rio de Silva pode ter sido inserida no banco de dados em 15 de maio de 2003, √†s 8:52:12, digamos, embora a mudan√ßa de sal√°rio no mundo real tenha sido efetivada em 1 de junho de 2003. Isso √© chamado de atualiza√ß√£o proativa , pois √© aplicada ao banco de dados antes que se torne efetiva no mundo real. Se a atualiza√ß√£o for aplicada ao banco de dados ap√≥s ter se tornado efetiva no mundo real,  ela  √©  chamada de atualiza√ß√£o retroativa .  Uma atualiza√ß√£o que √© aplicada ao mesmo tempo em que se torna efetiva √© chamada de atualiza√ß√£o simult√¢nea.

A a√ß√£o que corresponde a excluir um funcion√°rio  em  um banco de dados n√£o temporal em geral seria aplicada a um banco de dados de tempo v√°lido ao fechar a vers√£o atual do funcion√°rio sendo exclu√≠do. Por exemplo, se Silva deixar a empresa a partir de 19 de janeiro de 2004, ent√£o isso seria aplicado ao alterar o Tfv da vers√£o atual de Silva de now para 19-01-2004. Na Figura 26.8, n√£o existe uma vers√£o atual  para  Braga,  pois  presume-se  que  ele  saiu  da empresa em 10-08-2002, e foi exclu√≠do logicamente . Mas, como o banco de dados √© temporal, a informa√ß√£o antiga sobre Braga ainda est√° l√°.

A  opera√ß√£o  para inserir um  novo  funcion√°rio corresponderia  a criar  a  primeira  vers√£o  de  tupla para esse funcion√°rio e torn√°-la a vers√£o ativa, com o Tiv sendo o tempo de efetiva√ß√£o (mundo real) em que o funcion√°rio come√ßa a trabalhar. Na Figura 26.7, a tupla em Lima ilustra isso, pois a primeira vers√£o ainda n√£o foi atualizada.

ser mantida nas rela√ß√µes de tempo v√°lidas. Observe que, se o valor da chave prim√°ria n√£o temporal puder mudar com o tempo, √© importante ter um atributo de chave substituta √∫nico, cujo valor nunca muda para cada entidade do mundo real, a fim de relacionar todas as vers√µes da mesma entidade do mundo real.

Rela√ß√µes  de  tempo  v√°lidas  basicamente  acompanham o hist√≥rico das mudan√ßas √† medida que se tornam efetivas no mundo real .  Assim,  se  todas  as mudan√ßas do mundo real s√£o aplicadas, o banco de dados mant√©m um hist√≥rico dos estados do mundo real que s√£o representados. No entanto, como atualiza√ß√µes,  inser√ß√µes  e  exclus√µes  podem  ser  aplicadas de maneira retroativa ou proativa, n√£o h√° registro do estado do banco de dados real em qualquer ponto no tempo. Se os estados reais do banco de dados forem importantes para uma aplica√ß√£o, ent√£o √© preciso usar rela√ß√µes de tempo de transa√ß√£o .

Rela√ß√µes de tempo de transa√ß√£o. Em um banco de  dados  de  tempo  de  transa√ß√£o,  sempre  que  uma mudan√ßa √© aplicada ao banco de dados, o r√≥tulo de tempo real da transa√ß√£o que aplicou a mudan√ßa (inser√ß√£o,  exclus√£o  ou  atualiza√ß√£o)  √©  registrado.  Esse banco  de  dados  √©  mais  √∫til  quando  as  mudan√ßas s√£o  aplicadas simultaneamente na  maioria  dos  casos - por exemplo, em transa√ß√µes de negocia√ß√µes de a√ß√µes em tempo real ou banc√°rias. Se convertermos o banco de dados n√£o temporal da Figura 26.1 em um banco de dados de tempo de transa√ß√£o, ent√£o as duas rela√ß√µes FUNCIONARIO e DEPARTAMENTO s√£o convertidas para rela√ß√µes de tempo de transa√ß√£o ao acrescentar os atributos Tit (Tempo Inicial de Transa√ß√£o) e Tft (Tempo Final de Transa√ß√£o), cujo tipo de dados normalmente √© TIMESTAMP. Isso aparece na Figura 26.7(b), onde as rela√ß√µes foram renomeadas como FUNC\_TT e DEP\_TT , respectivamente.

Observe que, em uma rela√ß√£o de tempo v√°lida, a chave n√£o temporal , como Cpf em FUNCIONARIO , n√£o √© mais √∫nica em cada tupla (vers√£o). A nova chave da rela√ß√£o para FUNC\_TV √© uma combina√ß√£o da chave n√£o temporal e o atributo de hora de in√≠cio v√°lido Tiv , 16 de  modo  que  usamos  ( Cpf , Tiv )  como chave prim√°ria. Isso porque, em qualquer ponto no tempo, deve haver no m√°ximo uma vers√£o v√°lida de cada entidade. Logo, a restri√ß√£o de que duas vers√µes de tupla quaisquer representando a mesma entidade devem ter per√≠odos v√°lidos sem intersec√ß√£o que deve

Em FUNC\_TT , cada  tupla V representa  uma vers√£o das informa√ß√µes de um funcion√°rio, que foi criada no tempo real V .Tit e (logicamente) removida no tempo real V .Tft (porque a informa√ß√£o n√£o estava mais correta). Em FUNC\_TT, a vers√£o atual de cada funcion√°rio costuma ter um valor especial, uc ( Until Changed - at√© ser alterada), como seu tempo final de transa√ß√£o, que indica que a tupla representa informa√ß√µes corretas at√© que seja alterada por alguma outra transa√ß√£o. 17  Um banco de dados de tempo de transa√ß√£o  tamb√©m  √©  chamado  de banco  de  dados de  rollback , 18 pois  um  usu√°rio  pode  reverter  logi-

16 Uma combina√ß√£o da chave n√£o temporal e do atributo de tempo final v√°lido Tfv tamb√©m poderia ser usada.

17 A vari√°vel uc nas rela√ß√µes de tempo de transa√ß√£o corresponde √† vari√°vel now nas rela√ß√µes de tempo v√°lidas. Contudo, a sem√¢ntica √© ligeiramente diferente.

18 Aqui, o termo rollback n√£o tem o mesmo significado que rollback de transa√ß√£o (ver Cap√≠tulo 23) durante a recupera√ß√£o, onde as atualiza√ß√µes de transa√ß√£o s√£o desfeitas fisicamente . Em vez disso, aqui as atualiza√ß√µes podem ser desfeitas logicamente , permitindo que o usu√°rio examine o banco de dados conforme ele apareceu em um ponto anterior no tempo.

camente para o estado real do banco de dados em qualquer ponto do passado no tempo T ao recuperar todas as vers√µes de tupla V cujo per√≠odo de transa√ß√£o [ V .Tit, V .Tft ] inclui o ponto no tempo T .

Rela√ß√µes bitemporais. Algumas aplica√ß√µes exigem tanto o tempo v√°lido quanto o tempo de transa√ß√£o, levando a rela√ß√µes bitemporais . Em nosso exemplo, a Figura 26.7(c) mostra como as rela√ß√µes n√£o temporais FUNCIONARIO e DEPARTAMENTO na Figura 26.1 apareceriam como rela√ß√µes bitemporais FUNC\_BT e DEP\_BT, respectivamente. A Figura 26.9 mostra algumas tuplas nessas rela√ß√µes. Nas tabelas, as tuplas cujo  tempo  final  de  transa√ß√£o Tft √© uc s√£o  aquelas que  representam  informa√ß√µes  atualmente  v√°lidas, enquanto  as  tuplas  cujo Tft √©  um  r√≥tulo  de  tempo absoluto s√£o tuplas que eram v√°lidas at√© (imediatamente antes de) esse r√≥tulo de tempo. Logo, as tuplas com uc da  Figura  26.9  correspondem  √†s  tuplas  de tempo v√°lidas da Figura 26.7. O atributo de tempo de in√≠cio de transa√ß√£o Tit em cada tupla √© o r√≥tulo de tempo de transa√ß√£o que criou essa tupla.

Agora, considere como uma opera√ß√£o de atualiza√ß√£o seria implementada em uma rela√ß√£o bitemporal. Nesse modelo de bancos de dados bitemporais, 19 nenhum atributo √© fisicamente alterado em qualquer tupla, exceto pelo atributo de tempo final de transa√ß√£o Tft com um valor de uc . 20 Para ilustrar como as tuplas s√£o criadas, considere a rela√ß√£o FUNC\_BT . A vers√£o atual V de um funcion√°rio tem uc em seu atributo Tft e now em seu atributo Tfv . Se algum atributo digamos, Salario - for atualizado, ent√£o a transa√ß√£o T que realiza a atualiza√ß√£o dever√° ter dois par√¢metros: um novo valor de Salario e  o tempo v√°lido TV quando o novo sal√°rio torna-se efetivo (no mundo real). Suponha que TVseja o ponto no tempo antes de TV na granularidade de tempo v√°lido indicado e que a transa√ß√£o T tenha um r√≥tulo de tempo RT ( T ). Ent√£o, as mudan√ßas f√≠sicas a seguir seriam aplicadas √† tabela FUNC\_BT :

- 1. Fa√ßa uma c√≥pia V 2 da vers√£o atual V ; defina V 2 . Tfv para TV-, V 2 .Tit para TS ( T ), V 2 .Tft para uc , e insira V 2 em FUNC\_BT; V 2 √© uma c√≥pia

FUNC\_BT

| Nome   |         Cpf |   Salario |   Dnr |   Cpf_supervisor | Tiv        | Tfv        | Tit                  | Tft                  |
|--------|-------------|-----------|-------|------------------|------------|------------|----------------------|----------------------|
| Silva  | 12345678966 |        25 |     5 |      33344555587 | 15-06-2002 | Now        | 08-06-2002, 13:05:58 | 04-06-2003, 08:56:12 |
| Silva  | 12345678966 |        25 |     5 |      33344555587 | 15-06-2002 | 31-05-2003 | 04-06-2003, 08:56:12 | uc                   |
| Silva  | 12345678966 |        30 |     5 |      33344555587 | 01-06-2003 | Now        | 04-06-2003, 08:56:12 | uc                   |
| Wong   | 33344555587 |        25 |     4 |      99988777767 | 20-08-1999 | Now        | 20-08-1999, 11:18:23 | 07-01-2001, 14:33:02 |
| Wong   | 33344555587 |        25 |     4 |      99988777767 | 20-08-1999 | 31-01-2001 | 07-01-2001, 14:33:02 | uc                   |
| Wong   | 33344555587 |        30 |     5 |      99988777767 | 01-02-2001 | Now        | 07-01-2001, 14:33:02 | 28-03-2002, 09:23:57 |
| Wong   | 33344555587 |        30 |     5 |      99988777767 | 01-02-2001 | 31-03-2002 | 28-03-2002, 09:23:57 | uc                   |
| Wong   | 33344555587 |        40 |     5 |      88866777767 | 01-04-2002 | Now        | 28-03-2002, 09:23:57 | uc                   |
| Braga  | 22244777711 |        28 |     4 |      99988777767 | 01-05-2001 | Now        | 27-04-2001, 16:22:05 | 12-08-2002, 10:11:07 |
| Braga  | 22244777711 |        28 |     4 |      99988777767 | 01-05-2001 | 10-08-2002 | 12-08-2002, 10:11:07 | uc                   |
| Lima   | 66688444476 |        38 |     5 |      33344555587 | 01-08-2003 | Now        | 28-07-2003, 09:25:37 | uc                   |

...

## DEP\_BT

| Dnome    |   Dnr |   Cpf_gerente | Tiv        | Tfv        | Tit                  | Tft                  |
|----------|-------|---------------|------------|------------|----------------------|----------------------|
| Pesquisa |     5 |   88866555576 | 20-09-2001 | Now        | 15-09-2001, 14:52:12 | 28-03-2001, 09:23:57 |
| Pesquisa |     5 |   88866555576 | 20-09-2001 | 31-03-1997 | 28-03-2002, 09:23:57 | uc                   |
| Pesquisa |     5 |   33344555587 | 01-04-2002 | Now        | 28-03-2002, 09:23:57 | uc                   |

## Figura 26.9

Algumas vers√µes de tupla nas rela√ß√µes bitemporais FUNC\_BT e DEP\_BT .

19 Muitos t√™m sido modelos de banco de dados temporais propostos. Descrevemos modelos espec√≠ficos aqui como exemplos para ilustrar os conceitos.

20 Alguns modelos bitemporais permitem que o atributo Tfv seja alterado tamb√©m, mas as interpreta√ß√µes das tuplas s√£o diferentes nesses modelos.

da vers√£o atual e anterior V depois de ser fechada no tempo v√°lido VT-.

- 2. Fa√ßa uma c√≥pia V 3 da vers√£o atual V ; defina V 3 .Tiv como TV, V 3 .Tft como now , V 3 .Salario como o novo valor  do  sal√°rio, V 3 .Tit como RT ( T ), V 3 .Tft como uc e insira V 3 em FUNC\_ BT ; V 3 representa a nova vers√£o atual.
- 3. Defina V .Tft como RT ( T ), pois a vers√£o atual n√£o  est√°  mais  representando  a  informa√ß√£o correta.

Como uma ilustra√ß√£o, considere as tr√™s primeiras tuplas V 1 , V 2 e V 3 em FUNC\_BT da Figura 26.9. Antes da atualiza√ß√£o do sal√°rio de Silva de 25.000 para  30.000,  somente V 1 estava  em FUNC\_BT e essa era a vers√£o atual e seu Tft era uc . Depois, uma transa√ß√£o T cujo r√≥tulo de tempo RT ( T )  √©  '04-062003,08:56:12' atualiza o sal√°rio para 30.000 com o  tempo v√°lido efetivo de '01-06-2003'. A tupla V 2 √© criada, que √© uma c√≥pia de V 1 , exceto que seu Tfv √© definido como '31-05-2003', um dia a menos que o novo tempo v√°lido, e seu Tit √© o r√≥tulo de tempo de transa√ß√£o em atualiza√ß√£o. A tupla V 3 tamb√©m √© criada,  que  tem  o  novo  sal√°rio,  seu Tiv √©  definido como '01-06-2003' e seu Tit tamb√©m √© o r√≥tulo de tempo de transa√ß√£o em atualiza√ß√£o. Por fim, o Tft de V 1 √©  definido como o r√≥tulo de tempo da transa√ß√£o em atualiza√ß√£o, '04-06-2003, 08:56:12'. Observe que esta √© uma atualiza√ß√£o retroativa , pois a transa√ß√£o de atualiza√ß√£o rodou em 4 de junho de 2003, mas a mudan√ßa de sal√°rio √© efetivada em 1 de junho de 2003.

De modo semelhante, quando o sal√°rio e o departamento  de  Wong  s√£o  atualizados  (ao  mesmo tempo) para 30.000 e 5, o r√≥tulo de tempo da transa√ß√£o de atualiza√ß√£o √© '07-01-2001, 14:33:02' e o tempo v√°lido efetivo  para  a  atualiza√ß√£o  √©  '01-022001'. Logo, esta √© uma atualiza√ß√£o proativa , pois a transa√ß√£o rodou em 7 de janeiro de 2001, mas a data de efetiva√ß√£o foi 1 de fevereiro de 2001. Neste caso, a tupla V 4 √© logicamente substitu√≠da por V 5 e V 6 .

Em seguida, vamos ilustrar como uma opera√ß√£o de exclus√£o seria implementada em uma rela√ß√£o bitemporal ao considerar as tuplas V 9 e V 10 na rela√ß√£o FUNC\_BT da Figura 26.9. Aqui, o funcion√°rio Braga saiu da empresa efetivamente em 10 de agosto de 2002, e a exclus√£o l√≥gica √© executada por uma transa√ß√£o T com RT ( T ) =  12-08-2002,10:11:07. Antes disso, V 9 era a vers√£o atual de Braga, e seu Tft era uc . A exclus√£o l√≥gica √© implementada ao definir V 9 .Tft como 12-08-2002, 10:11:07 para invalid√°-la, e ao criar a vers√£o final V 10 para Braga, com seu Tfv =  10-08-2002  (ver  Figura  26.9).  Finalmente,  uma opera√ß√£o de inser√ß√£o √© implementada ao criar a primeira vers√£o , conforme ilustrada por V 11 na tabela FUNC\_BT .

Considera√ß√µes de implementa√ß√£o. Existem diversas  op√ß√µes  para  armazenar  as  tuplas  em  uma rela√ß√£o temporal. Uma √© armazenar todas as tuplas na mesma tabela, como mostram as figuras 26.8 e 26.9. Outra op√ß√£o √© criar duas tabelas: uma para a  informa√ß√£o atualmente v√°lida e a outra para o restante das tuplas. Por exemplo, na rela√ß√£o bitemporal FUNC\_BT ,  as  tuplas  com uc para  seu Tft e now para seu Tfv estariam em uma rela√ß√£o, a tabela atual ,  pois  elas  s√£o  aquelas atualmente v√°lidas (ou  seja,  representam  o  snapshot  atual),  e  todas as  outras  tuplas  estariam  em  outra  rela√ß√£o.  Isso permite  que  o  administrador  de  banco  de  dados tenha  diferentes  caminhos  de  acesso,  como  √≠ndices para cada rela√ß√£o, e mantenha o tamanho da tabela atual razo√°vel. Outra possibilidade √© criar uma terceira tabela para as tuplas corrigidas cujo Tet n√£o √© uc .

Outra op√ß√£o dispon√≠vel √© particionar verticalmente os atributos da rela√ß√£o temporal em rela√ß√µes separadas, de modo que, se uma rela√ß√£o tem muitos atributos, uma vers√£o de tupla inteira √© criada sempre que qualquer um dos atributos for atualizado. Se os atributos forem atualizados assincronamente, cada  nova  vers√£o  pode  diferir  apenas  em  um  dos atributos, repetindo assim, de maneira desnecess√°ria,  os  outros  valores  de  atributo.  Se  uma  rela√ß√£o separada for criada para conter apenas os atributos que sempre mudam sincronamente , com a chave  prim√°ria  replicada  em  cada  rela√ß√£o,  diz-se  que o banco de dados est√° em forma normal temporal . Contudo, para combinar a informa√ß√£o, uma varia√ß√£o de jun√ß√£o conhecida como jun√ß√£o de interse√ß√£o temporal seria necess√°ria, que geralmente √© dispendiosa de se implementar.

√â importante observar que os bancos de dados bitemporais permitem um registro completo das mudan√ßas. At√© mesmo um registro de corre√ß√µes √© poss√≠vel. Por exemplo, √© poss√≠vel que duas vers√µes de tupla do mesmo funcion√°rio possam ter o mesmo tempo v√°lido, mas diferentes valores de atributo, desde que seus  tempos  de  transa√ß√£o  sejam  disjuntos.  Nesse caso, a tupla com o tempo de transa√ß√£o mais recente √© uma corre√ß√£o da outra vers√£o de tupla. At√© mesmo tempos v√°lidos incorretamente inseridos podem ser corrigidos dessa maneira. O estado incorreto do banco de dados ainda estar√° dispon√≠vel como um estado de banco de dados anterior para fins de consulta. Um banco de dados que mant√©m tal registro completo de mudan√ßas e corre√ß√µes √†s vezes √© chamado de banco de dados apenas de inser√ß√£o .

## 26.2.3 ncorporando o tempo nos bancos I de dados orientados a objeto com o versionamento de atributo

A se√ß√£o anterior discutiu a t√©cnica de versionamento  de  tupla para  implementa√ß√£o  de  bancos  de dados temporais. Nessa t√©cnica, sempre que um valor de atributo √© mudado, uma nova vers√£o de tupla inteira √© criada, embora todos os outros valores de atributo sejam id√™nticos √† vers√£o de tupla anterior. Uma t√©cnica alternativa pode ser usada nos sistemas de banco de dados que d√£o suporte a objetos estruturados complexos , como bancos de dados de objeto (ver Cap√≠tulo 11) ou sistemas objeto-relacional. Essa t√©cnica √© chamada de versionamento de atributo .

No versionamento de atributo, um √∫nico objeto complexo √© utilizado para armazenar todas as mudan√ßas temporais do objeto. Cada atributo que muda com o tempo √© chamado de atributo vari√°vel com o tempo , e ele tem seus valores versionados com o tempo pela inclus√£o de per√≠odos temporais ao atributo. Os per√≠odos temporais podem representar tempo v√°lido, tempo de transa√ß√£o ou bitemporal, dependendo dos requisitos da aplica√ß√£o. Os atributos que n√£o mudam com o tempo s√£o chamados de n√£o vari√°veis com o tempo , e n√£o s√£o associados a per√≠odos temporais. Para ilustrar isso, considere o exemplo da Figura 26.10, que √© uma representa√ß√£o de tempo v√°lido versionada por atributo de FUNCIONARIO que usa a nota√ß√£o da linguagem de defini√ß√£o de objeto (ODL) para bancos de dados de objeto (ver Cap√≠tulo 11). Aqui, assumimos que nome e n√∫mero de CPF s√£o atributos n√£o vari√°veis com o tempo, enquanto sal√°rio, departamento e supervisor s√£o atributos vari√°veis com o tempo (eles podem mudar com o tempo). Cada atributo vari√°vel com o tempo √© representado como uma lista de tuplas &lt;Tempo\_inicial\_valido, Tempo\_final\_valido, Valor&gt;, ordenada por tempo inicial v√°lido.

Para bancos de dados bitemporais, cada vers√£o de atributo teria uma tupla com cinco componentes:

&lt;Tempo\_inicial\_valido, Tempo\_final\_valido, Tempo\_inicial\_trans, Tempo\_final\_trans, Valor&gt;

A expectativa de vida do objeto tamb√©m incluiria dimens√µes de tempo v√°lidas e de transa√ß√£o. Portanto, as capacidades completas dos bancos de dados bitemporais podem estar dispon√≠veis com o versionamento de atributo. Mecanismos semelhantes aos discutidos anteriormente para atualiza√ß√£o de vers√µes de tupla podem ser aplicados √† atualiza√ß√£o de vers√µes de atributo.

## 26.2.4 Constru√ß√µes de consulta temporal e a linguagem TSQL2

At√© aqui, discutimos como os modelos de dados podem  ser  estendidos  com  constru√ß√µes  temporais. Agora, oferecemos uma breve vis√£o geral de como as opera√ß√µes de consulta precisam ser estendidas para a consulta temporal. Vamos discutir rapidamente a linguagem TSQL2, que estende a SQL para a consulta de tempo v√°lido, tempo de transa√ß√£o e bancos de dados relacionais bitemporais.

Em bancos de dados relacionais n√£o temporais, as condi√ß√µes de sele√ß√£o t√≠picas envolvem condi√ß√µes de atributo, e tuplas que satisfazem essas condi√ß√µes s√£o selecionadas com base no conjunto de tuplas atuais . Seguindo isso, os atributos de interesse √† consulta s√£o especificados por uma opera√ß√£o de proje√ß√£o (ver Cap√≠tulo 6). Por exemplo, na consulta para recuperar os nomes de todos os funcion√°rios que trabalham no departamento 5 cujo sal√°rio √© maior que 30.000, a condi√ß√£o de sele√ß√£o seria a seguinte:

((Salario &gt; 30.000) AND (Dnr = 5))

Sempre que um atributo √© mudado nesse modelo, a vers√£o do atributo atual √© fechada e uma nova vers√£o de atributo √© apenas anexada √† lista. Isso permite que os atributos mudem assincronamente. O valor atual para cada atributo tem now para seu Tempo\_fi-nal\_valido. Ao usar o versionamento de atributo, √© √∫til incluir  um atributo temporal de expectativa de vida associado ao objeto inteiro cujo valor √© um ou mais per√≠odos v√°lidos, que indicam o tempo v√°lido de exist√™ncia para o objeto inteiro. A exclus√£o l√≥gica do objeto √© implementada ao fechar a expectativa de vida. A restri√ß√£o de que qualquer per√≠odo de um atributo em um objeto deve ser um subconjunto de sua expectativa de vida precisa ser imposta.

O atributo projetado seria Nome. Em um banco de dados temporal, as condi√ß√µes podem envolver o tempo al√©m dos atributos. Uma condi√ß√£o de tempo pura envolve  apenas  tempo  -  por  exemplo,  para selecionar todas as vers√µes de tupla de funcion√°rio que eram v√°lidas em certo ponto no tempo T ou que eram v√°lidas durante certo  per√≠odo [ T 1 , T 2 ].  Nesse caso, o per√≠odo especificado √© comparado com o per√≠odo v√°lido de cada vers√£o de tupla [ T .Tiv, T .Tfv ], e  somente as tuplas que satisfazem a condi√ß√£o s√£o selecionadas. Nessas opera√ß√µes, um per√≠odo √© considerado equivalente ao conjunto de pontos de tempo de T 1 a T 2 inclusive,  de  modo que as opera√ß√µes de compara√ß√£o do conjunto-padr√£o podem ser usadas. Opera√ß√µes adicionais, como se um per√≠odo termina antes de outro come√ßar, tamb√©m s√£o necess√°rias. 21

21 Um conjunto completo de opera√ß√µes, conhecido como √°lgebra de Allen (Allen, 1983), tem sido definido para a compara√ß√£o de per√≠odos de tempo.

class SALARIO\_TEMPORAL

{ attribute

Date

Tempo\_inicial\_valido;

attribute

Date

Tempo\_final\_valido;

attribute

float

Salario;

};

class DEP\_TEMPORAL

{ attribute

Date

Tempo\_inicial\_valido;

attribute

Date

Tempo\_final\_valido;

attribute

DEPARTAMENTO\_TV

Dept;

};

class SUPERVISOR\_TEMPORAL

{ attribute

Date

Tempo\_inicial\_valido;

attribute

Date

Tempo\_final\_valido;

attribute

FUNCIONARIO\_TV

Supervisor;

};

class EXPECTATIVA\_TEMPORAL

{ attribute

Date

Tempo\_inicial\_valido;

attribute

Date

Tempo\_final\_valido;

};

## class FUNCIONARIO\_TV

( extent FUNCIONARIO )

{ attribute

list&lt;EXPECT\_VIDA\_TEMPORAL&gt;  expectvida;

attribute

string

Nome;

attribute

string

Cpf;

attribute

list&lt;SALARIO\_TEMPORAL&gt;

Historico\_sal;

attribute

list&lt;DEP\_TEMPORAL&gt;

Historico\_dep;

attribute

list&lt;SUPERVISOR\_TEMPORAL&gt; Historico\_supervisor;

};

## Figura 26.10

Esquema ODL poss√≠vel para uma classe de objeto FUNCIONARIO\_VT de tempo v√°lido temporal usando versionamento de atributo.

## Algumas das opera√ß√µes mais comuns usadas nas consultas s√£o as seguintes:

[ T .Tiv, T .Tfv] INCLUDES [ T 1 , T 2 ]

Equivalente a T 1 ‚â• T .Tiv AND T 2 ‚â§ T .Tfv

[ T .Tiv, T .Tfv] INCLUDED\_IN [ T 1 , T 2 ]

Equivalente a T 1 ‚â§ T .Tiv AND T 2 ‚â• T .Tfv

[ T .Tiv, T .Tfv] OVERLAPS [ T 1 , T 2 ]

Equivalente a ( T 1 ‚â§ T .Tfv AND T 2 ‚â• T .Tiv) 22

[ T .Tiv, T .Tfv] BEFORE [ T 1 , T 2 ]

Equivalente a T 1 ‚â• T .Tfv

[ T .Tiv, T .Tfv] AFTER [ T 1 , T 2 ]

Equivalente a T 2 ‚â§ T .Tiv

[ T .Tiv, T .Tfv] MEETS\_BEFORE [ T 1 , T 2 ]

Equivalente a T 1 = T .Tfv + 1 23

[ T .Tiv, T .Tfv] MEETS\_AFTER [ T 1 , T 2 ]

Equivalente a T 2 + 1 = T .Tiv

22 Esta opera√ß√£o retorna verdadeira se a interse√ß√£o dos dois per√≠odos n√£o for vazia; ela tamb√©m tem sido chamada de INTERSECTS\_WITH .

23 Aqui, 1 refere-se a um ponto no tempo na granularidade especificada. As opera√ß√µes MEETS basicamente especificam se um per√≠odo come√ßa imediatamente ap√≥s outro per√≠odo terminar.

Al√©m disso, s√£o necess√°rias opera√ß√µes para manipular  per√≠odos  de  tempo,  como  para  calcular  a uni√£o ou intersec√ß√£o de dois per√≠odos de tempo. Os resultados dessas opera√ß√µes podem n√£o ser per√≠odos, mas sim elementos temporais - uma cole√ß√£o de um ou mais per√≠odos disjuntos , de modo que dois per√≠odos de tempo em um elemento temporal n√£o sejam diretamente adjacentes. Ou seja, para dois per√≠odos quaisquer [ T 1 , T 2 ] e [ T 3 , T 4 ] em um elemento temporal, as tr√™s condi√ß√µes a seguir devem ser mantidas:

- ¬Ñ Interse√ß√£o de [ T 1 , T 2 ], [ T 3 , T 4 ], √© vazia.
- ¬Ñ T 3 n√£o √© o ponto no tempo ap√≥s T 2 na granularidade indicada.
- ¬Ñ T 1 n√£o √© o ponto no tempo ap√≥s T 4 na granularidade indicada.

Essas √∫ltimas condi√ß√µes s√£o necess√°rias para garantir representa√ß√µes √∫nicas dos elementos temporais. Se dois per√≠odos [ T 1 , T 2 ] e [ T 3 , T 4 ] s√£o adjacentes, eles s√£o combinados em um √∫nico per√≠odo [ T 1 , T 4 ]. Isso √© chamado de aglutina√ß√£o de per√≠odos. A aglutina√ß√£o tamb√©m combina a interse√ß√£o de per√≠odos.

Para ilustrar como as condi√ß√µes de tempo puras podem  ser  usadas,  suponha  que  um  usu√°rio  queira selecionar todas as vers√µes de funcion√°rio que foram v√°lidas em qualquer ponto durante 2002. A condi√ß√£o de  sele√ß√£o  apropriada  aplicada  √†  rela√ß√£o  na  Figura 26.8 seria

[ T. Tiv, T. Tfv] OVERLAPS [01-01-2002, 31-12-2002]

Normalmente,  a  maioria  das  sele√ß√µes  temporais  √©  aplicada  √†  dimens√£o  de  tempo  v√°lida.  Para um banco de dados bitemporal, em geral se aplicam as  condi√ß√µes  √†s  tuplas  atualmente  corretas  com uc como seus tempos finais de transa√ß√£o. Contudo, se a consulta precisa ser aplicada a um estado de banco de dados anterior, uma cl√°usula AS\_OF T √© anexada √† consulta, o que significa que a consulta √© aplicada √†s tuplas de tempo v√°lidas que estavam corretas no banco de dados no tempo T .

Al√©m das condi√ß√µes de tempo puras, outras sele√ß√µes envolvem condi√ß√µes de atributo e tempo . Por exemplo, suponha que queiramos recuperar todas as vers√µes de tupla T de FUNC\_TV para funcion√°rios que trabalharam  no  departamento  5  em  qualquer  momento durante 2002. Nesse caso, a condi√ß√£o √©

[ T. Tiv, T. Tfv] OVERLAPS [01-01-2002, 31-122002] AND ( T. Dnr = 5)

Finalmente, damos uma breve vis√£o geral da linguagem de consulta TSQL2, que estende a SQL com constru√ß√µes para bancos de dados temporais. A ideia principal por tr√°s da TSQL2 √© permitir que os usu√°rios especifiquem se uma rela√ß√£o √© n√£o temporal (ou seja, uma  rela√ß√£o  SQL  padr√£o)  ou  temporal.  O  comando CREATE TABLE √© estendido com uma cl√°usula opcional AS para permitir que os usu√°rios declarem diferentes op√ß√µes temporais. As seguintes op√ß√µes est√£o dispon√≠veis:

- ¬Ñ &lt; AS VALID STATE &lt;GRANULARITY&gt; (rela√ß√£o de tempo v√°lida com per√≠odo v√°lido.)
- ¬Ñ &lt; AS VALID EVENT &lt;GRANULARITY&gt; (rela√ß√£o de tempo v√°lida com ponto no tempo v√°lido.)
- ¬Ñ &lt; AS TRANSACTION (rela√ß√£o de tempo de transa√ß√£o com per√≠odo de transa√ß√£o.)
- ¬Ñ &lt; AS VALID STATE &lt;GRANULARITY&gt; AND TRANS  ACTION (rela√ß√£o bitemporal, per√≠odo de tempo v√°lido.)
- ¬Ñ &lt; AS  VALID  EVENT  &lt;GRANULARITY&gt;  AND TRANSACTION (rela√ß√£o bitemporal, ponto de tempo v√°lido.)

As  palavras-chave STATE e EVENT s√£o  usadas para especificar se um per√≠odo ou ponto no tempo est√° associado √† dimens√£o de tempo v√°lida. Em TSQL2, em vez de um usu√°rio realmente ver como as tabelas temporais  s√£o  implementadas  (conforme  discutimos nas se√ß√µes anteriores), a linguagem TSQL2 acrescenta  constru√ß√µes  da  linguagem  de  consulta  para  especificar diversos tipos de sele√ß√µes temporais, proje√ß√µes temporais, agrega√ß√µes temporais, transforma√ß√£o entre granularidades e muitos outros conceitos. O livro de Snodgrass et al. (1995) descreve a linguagem.

## 26.2.5 Dados de s√©rie temporais

Os  dados  de  s√©rie  temporais  s√£o  usados  com muita frequ√™ncia em aplica√ß√µes financeiras, de vendas e economia. Eles envolvem valores de dados que s√£o registrados de acordo com uma sequ√™ncia predefinida de pontos no tempo. Portanto, eles s√£o um tipo especial de dados de evento v√°lidos , em que os pontos no tempo do evento s√£o predeterminados de acordo com um calend√°rio fixo. Considere o exemplo do pre√ßo de fechamento di√°rio das a√ß√µes de determinada empresa na Bolsa de Valores de Nova York. A granularidade aqui √© o dia, mas os dias em que a bolsa de valores est√° aberta s√£o conhecidos (dias de semana n√£o feriados). Logo, tem sido comum especificar um procedimento computacional que calcula o calend√°rio em particular associado √† s√©rie de tempo. Consultas t√≠picas sobre s√©ries de tempo envolvem agrega√ß√£o temporal em intervalos de granularidade maior - por exemplo, encontrar o pre√ßo de fechamento de a√ß√£o semanal m√©dio ou m√°ximo, ou o pre√ßo de fechamento de a√ß√£o m√°ximo e m√≠nimo mensal com base na informa√ß√£o di√°ria .

Como outro exemplo, considere as vendas di√°rias em d√≥lar em cada loja de uma cadeia de super-

mercados pertencente  √†  determinada  empresa.  Novamente,  as  agrega√ß√µes  temporais  t√≠picas  estariam recuperando as vendas semanal, mensal ou anual da informa√ß√£o de vendas di√°rias  (usando  a  fun√ß√£o  de agrega√ß√£o de soma), ou comparando algumas vendas mensais da loja com as vendas mensais anteriores, e assim por diante.

Devido √† natureza especializada dos dados de s√©rie de tempo e a falta de suporte para isso nos SGBDs mais antigos, tem sido comum usar sistemas de gerenciamento de s√©rie de tempo especializados em vez de SGBDs de uso geral para gerenciar tais informa√ß√µes.  Nesses  sistemas,  tem  sido  comum  armazenar valores de s√©rie de tempo em ordem sequencial em um arquivo e aplicar procedimentos de s√©rie de tempo  especializados  para  analisar  as  informa√ß√µes.  O problema com essa t√©cnica √©  que  o  poder  total  da consulta de alto n√≠vel em linguagens como SQL n√£o estar√° dispon√≠vel em tais sistemas.

Mais recentemente, alguns pacotes de SGBD comerciais est√£o oferecendo extens√µes de s√©rie de tempo, como o cartridge de tempo da Oracle e a data blade de dados de s√©rie de tempo do Informix Universal Server. Al√©m disso, a linguagem TSQL2 oferece algum suporte para a s√©rie de tempo na forma de tabelas de evento.

## 26.3 Conceitos de banco de dados espacial 24

## 26.3.1 ntrodu√ß√£o aos bancos de I dados espaciais

Os  bancos  de  dados  espaciais  incorporam  a funcionalidade que oferece suporte para bancos de dados que registram  objetos  em  um  espa√ßo  multidimensional. Por exemplo, bancos de dados cartogr√°ficos  que  armazenam mapas incluem descri√ß√µes espaciais bidimensionais de seus objetos - de pa√≠ses e estados at√© rios, cidades, estradas, mares, e assim por diante. Os sistemas que gerenciam dados geogr√°ficos  e  aplica√ß√µes  relacionadas  s√£o  conhecidos como sistemas  de  informa√ß√µes  geogr√°ficas ( GIS -Geographical  Information  Systems ),  e  s√£o  usados em √°reas  como  aplica√ß√µes  ambientais,  sistemas  de transporte, sistemas de resposta √† emerg√™ncia e gerenciamento  de  batalha.  Outros  bancos  de  dados, como os meteorol√≥gicos para informa√ß√µes de clima, s√£o  tridimensionais,  pois  as  temperaturas  e  outras informa√ß√µes  meteorol√≥gicas  est√£o  relacionadas  a pontos espaciais tridimensionais. Em geral, um banco de dados espacial armazena objetos que possuem caracter√≠sticas espaciais que os descrevem e que possuem relacionamentos espaciais entre eles. Os relacionamentos  espaciais  entre  os  objetos  s√£o  importantes,  e  eles  costumam  ser  necess√°rios  quando  se consulta  o  banco  de  dados.  Embora  um  banco  de dados espacial em geral possa se referir a um espa√ßo n -dimensional  para  qualquer n ,  limitaremos  nossa discuss√£o a duas dimens√µes como uma ilustra√ß√£o.

Um banco de dados espacial √© otimizado para armazenar  e  consultar  dados  relacionados  a  objetos no espa√ßo, incluindo pontos, linhas e pol√≠gonos. Imagens de sat√©lite s√£o um exemplo proeminente de dados espaciais. As consultas impostas nesses dados espaciais, onde os predicados para sele√ß√£o lidam com par√¢metros espaciais, s√£o chamados consultas espaciais . Por exemplo, 'Quais s√£o os nomes de todas as livrarias  que  est√£o  dentro  de  cinco  quil√¥metros  do pr√©dio  da  Faculdade  de  Computa√ß√£o  na  Georgia Tech?'  √©  uma  consulta  espacial.  Enquanto  os  bancos  de  dados  t√≠picos  processam  dados  num√©ricos  e de  caractere,  uma  funcionalidade  adicional  precisa ser acrescentada aos bancos de dados para que processem tipos de dados espaciais. Uma consulta como 'Liste todos os clientes localizados dentro de 20 quil√¥metros da sede da empresa' exigir√° o processamento de tipos de dados espaciais normalmente fora do escopo da √°lgebra relacional padr√£o, e pode envolver a consulta a um banco de dados geogr√°fico externo, que mapeia a sede da empresa e cada cliente em um mapa 2-D com base em seu endere√ßo. Efetivamente,  cada  cliente  estar√°  associado  a  uma  posi√ß√£o  de &lt;latitude, longitude&gt;. Um √≠ndice B + -tree tradicional, baseado  nos  ceps  dos  clientes,  ou  outros  atributos n√£o  espaciais,  n√£o  pode  ser  usado  para  processar essa  consulta,  visto  que  os  √≠ndices  tradicionais  n√£o s√£o capazes de ordenar dados de coordenadas multidimensionais. Portanto, existe uma necessidade especial para bancos de dados ajustados para tratar de dados e consultas espaciais.

A Tabela 26.1 mostra as opera√ß√µes anal√≠ticas comuns envolvidas no processamento de dados geogr√°ficos ou espaciais. 25 Opera√ß√µes de medi√ß√£o s√£o usadas para  medir  algumas  propriedades  globais  de  objetos isolados (como a √°rea, o tamanho relativo das partes de um objeto, compacta√ß√£o ou simetria) e a posi√ß√£o relativa de diferentes objetos em rela√ß√£o a dist√¢ncia e dire√ß√£o. Opera√ß√µes de an√°lise espacial , que normalmente usam t√©cnicas estat√≠sticas, s√£o utilizadas para desvendar relacionamentos espaciais dentro e entre camadas de dados mapeadas. Um exemplo seria criar um mapa - conhecido como mapa de previs√£o - que identifica os locais de prov√°veis clientes para produtos em particular com

24 Agradecemos a participa√ß√£o de Pranesh Parimala Ranganathan a esta se√ß√£o.

25 Lista de opera√ß√µes de an√°lise de GIS proposta em Albrecht (1996).

Tabela 26.1 Tipos comuns de an√°lise para dados espaciais.

| Tipo de an√°lise              | Tipo de opera√ß√µes e medidas                                                                       |
|------------------------------|---------------------------------------------------------------------------------------------------|
| Medidas                      | Dist√¢ncia, per√≠metro, forma, adjac√™ncia e dire√ß√£o                                                 |
| An√°lise estat√≠stica espacial | Padr√£o, autocorrela√ß√£o e √≠ndices de semelhan√ßa e topologia usando dados espaciais e n√£o espaciais |
| An√°lise de fluxo             | Conectividade e caminho mais curto                                                                |
| An√°lise de local             | An√°lise de pontos e linhas dentro de um pol√≠gono                                                  |
| An√°lise de terreno           | Inclina√ß√£o/aspecto, √°rea de capta√ß√£o, rede de dreno                                               |
| Pesquisa                     | Busca tem√°tica, busca por regi√£o                                                                  |

base nas informa√ß√µes de vendas hist√≥ricas e demogr√°ficas. Opera√ß√µes de an√°lise de fluxo ajudam a determinar o caminho mais curto entre dois pontos e tamb√©m a conectividade entre n√≥s ou regi√µes em um grafo. A an√°lise de local visa descobrir se o conjunto dado de pontos e linhas se encontra em determinado pol√≠gono (local). O processo envolve gerar um buffer em torno dos recursos  geogr√°ficos  existentes  e,  depois,  identificar  ou  selecionar recursos baseado em se eles est√£o dentro ou fora do limite do buffer. A an√°lise digital de terreno √© utilizada para montar modelos tridimensionais, nos quais a topografia de um local geogr√°fico pode ser representada com um modelo de dados x y z , , conhecido como Digital Terrain (ou Elevation) Model (DTM/DEM). As dimens√µes x e y de um DTM representam o plano horizontal e z representa alturas pontuais para as respectivas coordenadas x y , . Esses modelos podem ser usados para an√°lise de dados ambientais ou durante o desenho de projetos de engenharia que exijam informa√ß√µes de terreno. A busca espacial permite que um usu√°rio procure  objetos  em  determinada  regi√£o  espacial.  Por exemplo, a busca tem√°tica nos permite procurar objetos relacionados a determinado tema ou classe, como 'Encontre todas as fontes de √°gua dentro de 25 quil√¥metros de Atlanta', onde a classe √© √°gua .

## 26.3.2 Tipos de dados e modelos espaciais

Esta se√ß√£o descreve resumidamente os modelos e tipos de dados comuns para armazenamento de dados espaciais. Os dados espaciais v√™m em tr√™s formas b√°sicas. Essas formas se tornaram um padr√£o de fato devido a seu uso generalizado em sistemas comerciais.

- ¬Ñ Dados de mapa 26 incluem  diversos  recursos geogr√°ficos  ou  espaciais  de  objetos  em  um mapa, como a forma de um objeto e seu local no mapa. Os tr√™s tipos b√°sicos de recursos s√£o pontos, linhas e pol√≠gonos (ou √°reas). Pontos s√£o  usados  para  representar  caracter√≠sticas espaciais dos objetos cujos locais correspondem a uma √∫nica coordenada 2-D ( x , y ou longitude/latitude)  na  escala  de  uma  aplica√ß√£o em particular. Dependendo da escala, alguns exemplos de objetos de ponto poderiam ser pr√©dios, torres de celular ou ve√≠culos estacion√°rios. Ve√≠culos em movimento e outros objetos em movimento podem ser representados por uma sequ√™ncia de locais de ponto que mudam com o tempo. As linhas representam objetos que t√™m comprimento, como estradas e  rios,  cujas  caracter√≠sticas  espaciais  podem ser aproximadas por uma sequ√™ncia de linhas conectadas. Pol√≠gonos s√£o usados para representar caracter√≠sticas espaciais de objetos que t√™m um limite, como pa√≠ses, estados, lagos ou cidades.  Observe  que  alguns  objetos,  como pr√©dios ou cidades, podem ser representados como pontos ou pol√≠gonos,  dependendo  da escala do detalhe.

H√°  tamb√©m relacionamentos  topol√≥gicos entre objetos  espaciais.  Estes  normalmente  s√£o  usados  em predicados booleanos para selecionar objetos com base em seus relacionamentos espaciais. Por exemplo, se um limite de cidade for representado como um pol√≠gono e as rodovias forem representadas como multilinhas, uma condi√ß√£o como 'Encontrar todas as rodovias que passam por Campinas, S√£o Paulo' envolveria uma opera√ß√£o de interse√ß√£o , para determinar quais rodovias (linhas) cruzam o limite da cidade (pol√≠gono).

- ¬Ñ Dados de atributo s√£o  os  dados  descritivos que os sistemas de GIS associam a recursos de mapa .  Por exemplo, suponha que um mapa contenha  recursos  que  representam  munic√≠pios em um estado dos Estados Unidos (como Texas ou Oregon). Os atributos para cada recurso  de  munic√≠pio  (objeto)  poderia  incluir popula√ß√£o, maior cidade, √°rea em quil√¥metros  quadrados,  e  assim  por  diante.  Outros dados  de  atributo  poderiam  ser  inclu√≠dos para outros recursos no mapa, como estados, cidades, distritos, tratados de censo etc.
- ¬Ñ Dados de imagem incluem dados como imagens de sat√©lite e fotografias a√©reas, que s√£o tipicamente criadas por c√¢meras. Objetos de interesse, como pr√©dios e estradas, podem ser identificados  e  sobrepostos  nessas  imagens.

26 Esses tipos de dados geogr√°ficos s√£o baseados no guia da ESRI para o GIS. Dispon√≠vel em: &lt;www.gis.com/implementing\_gis/data/data\_types.html&gt;.

As imagens tamb√©m podem ser atributos de recursos de mapa. Podem-se acrescentar imagens a outros recursos de mapa, de modo que o clique no recurso exibiria a imagem. Imagens a√©reas e de sat√©lite s√£o exemplos t√≠picos de dados de rastreio.

Modelos  de  informa√ß√£o  espaciais √†s  vezes  s√£o agrupados em duas categorias gerais: campo e objeto . Uma aplica√ß√£o espacial (como sensoriamento remoto ou controle de tr√°fego de rodovia) √© moldada usando um modelo baseado em campo ou objeto, dependendo dos requisitos e da escolha tradicional do modelo para a aplica√ß√£o. Modelos de campo normalmente s√£o utilizados para modelar dados espaciais que s√£o cont√≠nuos em natureza, como eleva√ß√£o de terreno, dados de temperatura e caracter√≠sticas de varia√ß√£o de solo, enquanto modelos  de  objeto tradicionalmente  t√™m sido usados para aplica√ß√µes como redes de transporte, lotes de terra, pr√©dios e outros objetos que possuem atributos espaciais e n√£o espaciais.

## 26.3.3 Operadores espaciais

Operadores espaciais s√£o usados para capturar todas as propriedades geom√©tricas relevantes dos objetos embutidos no espa√ßo f√≠sico e as rela√ß√µes entre elas, bem como realizar an√°lise espacial. Os operadores s√£o classificados em tr√™s categorias gerais.

- ¬Ñ Operadores topol√≥gicos. Propriedades topol√≥gicas  s√£o  invari√°veis  quando  transforma√ß√µes topol√≥gicas s√£o aplicadas. Essas propriedades n√£o mudam ap√≥s transforma√ß√µes como rota√ß√£o, transla√ß√£o ou escala. Operadores topol√≥gicos s√£o hierarquicamente estruturados em diversos n√≠veis, sendo que o n√≠vel b√°sico oferece  aos  operadores  a  capacidade  de  verificar  rela√ß√µes  topol√≥gicas  detalhadas  entre regi√µes com um limite amplo, e os n√≠veis mais altos  oferecem  operadores  mais  abstratos, que permitem que os usu√°rios consultem dados espaciais incertos independentemente do modelo de dados geom√©tricos b√°sico. Alguns exemplos  incluem  aberto  (regi√£o),  fechado (regi√£o) e interno (ponto, loop).
- ¬Ñ Operadores  projetivos. Operadores  projetivos,  como corpo  convexo ,  s√£o  usados  para expressar  predicados  sobre  a  concavidade/ convexidade  de  objetos,  bem  como  outras rela√ß√µes espaciais (por exemplo, estar dentro da concavidade de determinado objeto).
- ¬Ñ Operadores  m√©tricos. Operadores  m√©tricos oferecem  uma  descri√ß√£o  mais  espec√≠fica  da geometria  do  objeto.  Eles  s√£o  usados  para medir algumas propriedades globais de obje-

tos isolados (como a √°rea, o tamanho relativo das partes de um objeto, a compacta√ß√£o e a simetria) e para medir a posi√ß√£o relativa de diferentes  objetos  em  rela√ß√£o  a  dist√¢ncia  e dire√ß√£o.  Alguns  exemplos  incluem  tamanho (arco) e dist√¢ncia (ponto, ponto).

Operadores  espaciais din√¢micos. As opera√ß√µes realizadas  pelos  operadores  mencionados  s√£o  est√°ticas, no sentido de que os operandos n√£o s√£o afetados pela aplica√ß√£o da opera√ß√£o. Por exemplo, calcular o tamanho da curva n√£o tem efeito sobre a pr√≥pria curva. Opera√ß√µes din√¢micas alteram os objetos sobre os quais as opera√ß√µes atuam. As tr√™s opera√ß√µes din√¢micas fundamentais s√£o criar , destruir e atualizar .  Um exemplo representativo das opera√ß√µes din√¢micas seria atualizar um objeto espacial que pode ser subdividido em traduzir (deslocar posi√ß√£o), girar (mudar orienta√ß√£o), escalar para cima ou para baixo, refletir (produzir uma imagem de espelho) e cortar (deformar).

Consultas espaciais. As consultas espaciais s√£o solicita√ß√µes para dados espaciais que exigem o uso de opera√ß√µes espaciais. As categorias a seguir ilustram tr√™s tipos t√≠picos de consultas espaciais:

- ¬Ñ Consulta  de  intervalo  (range). Encontra  os objetos de determinado tipo que est√£o dentro  de  determinada  √°rea  espacial  ou  dentro de determinada dist√¢ncia de um local indicado. (Por exemplo, encontre todos os hospitais dentro  da  √°rea  da  cidade  metropolitana  de S√£o Paulo, ou encontre todas as ambul√¢ncias no raio de cinco quil√¥metros do local de um acidente.)
- ¬Ñ Consulta  do  vizinho  mais  pr√≥ximo. Encontra um objeto de determinado tipo que esteja mais pr√≥ximo de determinado local. (Por exemplo, encontre o carro da pol√≠cia que esteja mais pr√≥ximo do local do crime.)
- ¬Ñ Jun√ß√µes ou sobreposi√ß√µes espaciais. Normalmente, a jun√ß√£o dos objetos de dois tipos com base em alguma condi√ß√£o espacial, como os objetos que cruzam ou sobrep√µem espacialmente ou que est√£o dentro de certa dist√¢ncia um do outro. (Por exemplo, encontre todas as  cidades  localizadas  em  uma  rodovia  importante entre duas cidades ou encontre todas as casas que estejam a menos de dois quil√¥metros de um lago.)

## 26.3.4 Indexa√ß√£o de dados espaciais

Um √≠ndice espacial √© usado para organizar objetos em um conjunto de buckets (que correspondem a p√°ginas de mem√≥ria secund√°ria), de modo que os

objetos em determinada regi√£o espacial possam ser facilmente localizados. Cada bucket tem uma regi√£o de bucket, uma parte do espa√ßo que cont√©m todos os objetos  armazenados no bucket. As regi√µes do bucket normalmente s√£o ret√¢ngulos; para estruturas de dados pontuais, essas regi√µes s√£o disjuntas e dividem o espa√ßo de modo que cada ponto perten√ßa a exatamente um bucket. Existem basicamente duas maneiras de oferecer um √≠ndice espacial.

- 1. Estruturas de indexa√ß√£o especializadas, que permitem a busca eficiente  por  objetos  de  dados com base nas opera√ß√µes de busca espacial, s√£o inclu√≠das no sistema de banco de dados. Essas estruturas  de  indexa√ß√£o  desempenhariam  um papel semelhante ao que √© realizado pelos √≠ndices da B + -tree nos sistemas de banco de dados tradicionais. Alguns exemplos dessas estruturas de indexa√ß√£o s√£o arquivos de grade e R-trees . Tipos especiais de √≠ndices espaciais, conhecidos como √≠ndices de jun√ß√£o espacial , podem ser usados para agilizar opera√ß√µes de jun√ß√£o espacial.
- 2. Em vez de criar estruturas de indexa√ß√£o totalmente novas, os dados espaciais bidimensionais (2-D) s√£o convertidos em dados unidimensionais (1-D), de modo que t√©cnicas de indexa√ß√£o tradicionais  (B -tree)  podem  ser  usadas.  Os + algoritmos  para  converter  2-D  para  1-D  s√£o conhecidos como curvas de preenchimento de espa√ßo .  N√£o  discutiremos  esses  m√©todos  com detalhes (veja outras refer√™ncias na bibliografia selecionada no final deste cap√≠tulo).

A seguir, oferecemos uma vis√£o geral de algumas das t√©cnicas de indexa√ß√£o espacial.

Arquivos de grade. Apresentamos os arquivos de grade para indexa√ß√£o de dados em m√∫ltiplos atributos no Cap√≠tulo 18. Eles tamb√©m podem ser usados para indexa√ß√£o de dados espaciais bidimensionais e de dimens√£o n mais alta. O m√©todo de grade fixa divide um hiperespa√ßo n -dimensional em buckets de mesmo tamanho. A estrutura de dados que implementa a grade fixa √© um vetor n -dimensional. Os objetos cujos locais espaciais se encontram em uma c√©lula (total ou parcialmente) podem ser armazenados em uma estrutura din√¢mica para lidar com overflows. Essa estrutura √© √∫til para dados uniformemente distribu√≠dos, como imagens de sat√©lite. Por√©m, a estrutura de grade fixa √© r√≠gida, e seu diret√≥rio pode ser esparso e grande.

R-trees. A R-tree √©  uma √°rvore com altura balanceada, que √© uma extens√£o da B + -tree para k dimens√µes, onde k &gt; 1. Para duas dimens√µes (2-D), os objetos espaciais s√£o aproximados na R-tree por seu ret√¢ngulo delimitador m√≠nimo (MBR - Minimum Bounding Rectangle) , que √© o menor ret√¢ngulo, com lados paralelos ao eixo do sistema de coordenadas ( x e y ), que cont√©m o objeto. As R-trees s√£o caracterizadas pelas propriedades a seguir, que s√£o semelhantes √†s propriedades das B + -trees (ver Se√ß√£o 18.3), mas s√£o adaptadas para objetos  espaciais  2-D.  Como na Se√ß√£o 18.3, usamos M para indicar o n√∫mero m√°ximo de entradas que podem caber em um n√≥ da R-tree.

- 1. A estrutura de cada entrada de √≠ndice (ou registro de √≠ndice) em um n√≥ folha √© (I, identificador-objeto ), onde I √© o MBR para o objeto espacial cujo identificador √© identificador-objeto .
- 2. Cada n√≥, exceto o n√≥ raiz, deve estar cheio pelo menos at√© a metade. Assim, um n√≥ folha que n√£o √© a raiz deve conter m entradas (I, identificador-objeto ), onde M /2 &lt;= m &lt;= M . De modo semelhante, um n√≥ n√£o folha que n√£o √© a raiz deve conter m entradas (I, ponteiro-filho ), onde M /2 &lt;= m &lt;= M , e I √© o MBR que cont√©m a uni√£o de todos os ret√¢ngulos no n√≥ apontado pelo ponteiro-filho .
- 3. Todos os n√≥s folha est√£o no mesmo n√≠vel, e o n√≥ raiz deve ter pelo menos dois ponteiros, a menos que seja um n√≥ folha.
- 4. Todos os MBRs t√™m seus lados paralelos aos eixos do sistema de coordenada global.

Outras  estruturas  de  armazenamento  espaciais incluem quadtrees e suas varia√ß√µes. Quadtrees costumam dividir cada espa√ßo ou subespa√ßo em √°reas de mesmo tamanho, e prosseguem com as subdivis√µes de cada subespa√ßo para identificar  as  posi√ß√µes  de  v√°rios objetos.  Recentemente,  muitas  estruturas  de  acesso espaciais mais novas t√™m sido propostas, e essa √°rea continua sendo uma √°rea de pesquisa ativa.

√çndice de jun√ß√£o espacial. Um √≠ndice de jun√ß√£o espacial pr√©-calcula uma opera√ß√£o de jun√ß√£o espacial e armazena os ponteiros para o objeto relacionado em uma estrutura de √≠ndice. Os √≠ndices de jun√ß√£o melhoram o desempenho das consultas de jun√ß√£o recorrentes em tabelas que possuem baixas taxas de atualiza√ß√£o. As condi√ß√µes de jun√ß√£o espaciais s√£o usadas para responder a desafios como 'Crie uma lista de combina√ß√µes de rodovia e estrada que se cruzam'. A jun√ß√£o espacial √© usada para identificar e recuperar esses pares de objetos que satisfazem o relacionamento espacial cruzado . Como o  c√°lculo  dos  resultados  dos  relacionamentos espaciais geralmente √© demorado, o resultado pode ser calculado uma vez e armazenado em uma tabela que tem os pares de identificadores de objetos (ou ids de tupla) que satisfazem o relacionamento espacial, o qual basicamente √© o √≠ndice de jun√ß√£o.

Um √≠ndice de jun√ß√£o pode ser descrito por um gr√°fico bipartite G = (V1,V2,E), onde V1 cont√©m as

ids de tupla da rela√ß√£o R , e V2 cont√©m as ids de tupla da rela√ß√£o S . O conjunto de arestas cont√©m uma aresta (vr,vs) para vr em R e vs em S , se existir uma tupla correspondente a (vr,vs) no √≠ndice de jun√ß√£o. O grafo bipartite  modela  todas  as  tuplas  relacionadas  como v√©rtices conectados nos gr√°ficos. Os √≠ndices de jun√ß√£o espacial s√£o usados nas opera√ß√µes (ver Se√ß√£o 26.3.3) que envolvem o c√°lculo de relacionamentos entre objetos espaciais.

## 26.3.5 Minera√ß√£o de dados espaciais

Dados espaciais tendem a ser altamente correlacionados. Por exemplo, as pessoas com caracter√≠sticas, ocupa√ß√µes e bases semelhantes tendem a se agrupar nas mesmas vizinhan√ßas.

As tr√™s t√©cnicas principais de minera√ß√£o de dados  espaciais  s√£o  classifica√ß√£o  espacial,  associa√ß√£o espacial e agrupamento espacial.

- ¬Ñ Classifica√ß√£o espacial. O objetivo da classifica√ß√£o √© estimar o valor de um atributo de uma rela√ß√£o com base no valor dos outros atributos da rela√ß√£o. Um exemplo do problema de classifica√ß√£o  espacial  √©  determinar  os  locais dos ninhos em um p√¢ntano com base no valor de outros atributos  (por  exemplo,  durabilidade da  vegeta√ß√£o  e  profundidade  da  √°gua);  isso tamb√©m √© chamado de problema da previs√£o de local . De modo semelhante, onde esperar os principais pontos de atividade criminosa tamb√©m √© um problema de previs√£o de local.
- ¬Ñ Associa√ß√£o espacial. As regras de associa√ß√£o espacial s√£o definidas em mat√©ria de predicados espaciais, em vez de itens. Uma regra de associa√ß√£o espacial tem a forma P  ^ P  ^ ... ^ P 1 2 n ‚áí Q  ^ Q  ^ ... ^ Q 1 2 m , onde pelo menos um dos P  ou Q  √© um predii j cado espacial. Por exemplo, a regra is\_a( x ,  pa√≠s)  ^  touches( x ,  Mediterr√¢neo) ‚áí is\_a ( x , exportador-vinho) (ou seja, um pa√≠s que √© adjacente ao Mar Mediterr√¢neo normalmente √© um exportador de vinho) √© um exemplo de uma regra de associa-

√ß√£o, que ter√° certo suporte   e confian√ßa s c . 27

Regras de coloca√ß√£o espacial tentam generalizar as regras de associa√ß√£o para que apontem para conjuntos de dados de coleta que s√£o √≠ndices pelo espa√ßo. Existem v√°rias diferen√ßas cruciais entre associa√ß√µes espaciais e n√£o espaciais, incluindo:

- 1. A no√ß√£o de uma transa√ß√£o √© ausente em situa√ß√µes  espaciais,  pois  os  dados  s√£o  embutidos no  espa√ßo  cont√≠nuo.  O  particionamento  do espa√ßo em transa√ß√µes levaria a uma superestimativa ou uma subestimativa de medidas de interesse, por exemplo, suporte ou confian√ßa.
- 2. O tamanho dos conjuntos de itens nos bancos  de  dados  espaciais  √©  pequeno,  ou  seja, existem  muito  menos  itens  no  conjunto  de itens  em  uma  situa√ß√£o  espacial  do  que  em uma situa√ß√£o n√£o espacial.

Na maioria dos casos, os itens espaciais s√£o uma vers√£o discreta das vari√°veis cont√≠nuas. Por exemplo, no Brasil, as regi√µes de receita podem ser definidas como regi√µes onde a receita anual m√©dia est√° dentro de certos intervalos, como abaixo de R$40.000, de R$40.000 a R$100.000, e acima de R$100.000.

- ¬Ñ O agrupamento  (clustering)  espacial tenta agrupar objetos do banco de dados de modo que os objetos mais semelhantes estejam no mesmo cluster, e objetos em clusters diferentes sejam os mais divergentes poss√≠veis. Uma aplica√ß√£o do agrupamento espacial √© agrupar eventos s√≠smicos a fim de determinar falhas de terremoto. Um exemplo de algoritmo de agrupamento espacial √© o agrupamento baseado em densidade , que tenta encontrar clusters com base na densidade dos pontos de dados em uma regi√£o. Esses algoritmos tratam dos clusters como regi√µes densas de objetos no  espa√ßo  de  dados.  Duas  varia√ß√µes  desses algoritmos s√£o o agrupamento espacial baseado em densidade das aplica√ß√µes com ru√≠do (DBSCAN) 28   e  o  agrupamento  baseado  em densidade (DENCLUE). 29  DBSCAN √© um algoritmo de agrupamento baseado em densidade porque encontra uma s√©rie de clusters que  come√ßam  da  distribui√ß√£o  de  densidade estimada dos n√≥s correspondentes.

## 26.3.6 Aplica√ß√µes de dados espaciais

- O gerenciamento  de  dados  espaciais  √©  √∫til  em muitas disciplinas, incluindo geografia, sensores remotos,  planejamento  urbano  e  gerenciamento  de recurso natural. O gerenciamento de banco de dados espacial  est√°  desempenhando  um  papel  importante na  solu√ß√£o  de  problemas  cient√≠ficos  desafiadores, como mudan√ßas globais no clima e no genoma. Devido √† natureza espacial dos dados de genoma, o GIS

27 Os conceitos de suporte e confian√ßa para regras de associa√ß√£o ser√£o discutidos como parte da minera√ß√£o de dados, na Se√ß√£o 28.2.

28 DBSCAN foi proposto por Martin Ester, Hans-Peter Kriegel, J√∂rg Sander e Xiaowei Xu (1996) .

29 DENCLUE foi proposto por Hinnenberg e Gabriel (2007).

e sistemas de gerenciamento de banco de dados espacial t√™m um papel importante a desempenhar na √°rea de  bioinform√°tica.  Algumas  das  aplica√ß√µes  t√≠picas incluem  reconhecimento  de  padr√£o  (por  exemplo, para  verificar  se  a  topologia  de  determinado  gene no genoma √© encontrada em qualquer outro mapa de  caracter√≠stica  de  sequ√™ncia  no  banco  de  dados), desenvolvimento de navegador de genoma e mapas de visualiza√ß√£o. Outra √°rea de aplica√ß√£o importante da minera√ß√£o de dados espaciais √© a detec√ß√£o de outlier espacial. Um outlier espacial √© um objeto referenciado espacialmente cujos valores de atributo n√£o espaciais  s√£o  significativamente  diferentes  daqueles de  outros  objetos  referenciados  espacialmente  em sua  vizinhan√ßa  espacial.  Por  exemplo,  se  uma  vizinhan√ßa de casas mais antigas tiver apenas uma casa nova, essa casa seria um outlier com base no atributo n√£o espacial 'casa\_antiga'. A detec√ß√£o de outliers espaciais √© √∫til em muitas aplica√ß√µes de sistemas de informa√ß√µes geogr√°ficas e bancos de dados espaciais. Esses dom√≠nios de aplica√ß√£o incluem transporte, ecologia, seguran√ßa p√∫blica, sa√∫de p√∫blica, climatologia e servi√ßos baseados em local.

## 26.4 Conceitos de banco de dados multim√≠dia

Os bancos de dados multim√≠dia oferecem recursos que permitem que os usu√°rios armazenem e consultem diferentes tipos de informa√ß√µes de multim√≠dia, que incluem imagens (como fotos ou desenhos), clipes de v√≠deo (como filmes, notici√°rios ou v√≠deos caseiros), clipes de √°udio (como m√∫sicas, mensagens telef√¥nicas ou discursos) e documentos (como livros ou artigos). Os principais tipos de consultas de banco de dados necess√°rios envolvem localiza√ß√£o de fontes de multim√≠dia que cont√™m certos objetos de interesse. Por exemplo, algu√©m pode querer localizar todos os clipes de v√≠deo em um banco de dados de v√≠deo que incluam certa pessoa, digamos, Michael Jackson. Tamb√©m se pode querer recuperar clipes de v√≠deo com base em certas atividades inclu√≠das neles, como clipes de v√≠deo onde um gol no futebol √© avaliado por certo jogador ou time.

Esses  tipos  de  consultas  s√£o  conhecidos  como recupera√ß√£o baseada em conte√∫do ,  pois  a  fonte  de multim√≠dia est√° sendo recuperada se contiver certos objetos ou atividades. Logo, um banco de dados multim√≠dia precisa usar algum modelo para organizar e indexar  as  fontes  de  multim√≠dia  com  base  em  seus conte√∫dos. A identifica√ß√£o do conte√∫do das fontes de multim√≠dia √© uma tarefa dif√≠cil e demorada. Existem duas t√©cnicas principais. A primeira se baseia na an√°lise autom√°tica das fontes de multim√≠dia para identificar certas caracter√≠sticas matem√°ticas de seu conte√∫do.

Essa  abordagem usa diferentes  t√©cnicas,  dependendo do tipo de fonte de multim√≠dia (imagem, v√≠deo, √°udio ou texto). A segunda abordagem depende da identifica√ß√£o  manual dos  objetos  e  atividades  de  interesse em cada fonte de multim√≠dia e do uso dessa informa√ß√£o para indexar as fontes. Essa t√©cnica pode ser aplicada a todas as fontes de multim√≠dia, mas requer uma fase de pr√©-processamento manual em que uma pessoa precisa analisar cada fonte de multim√≠dia para identificar e catalogar os objetos e atividades que ela cont√©m, de modo que possam ser usados para indexar as fontes.

Na primeira parte desta se√ß√£o, discutiremos rapidamente algumas das caracter√≠sticas de cada tipo de  fonte  de  multim√≠dia  -  imagens,  v√≠deo,  √°udio  e texto/documentos. Depois, abordaremos t√©cnicas para  an√°lise  autom√°tica  de  imagens  seguidas  pelo problema  de  reconhecimento  de  objeto  nelas.  Terminamos esta se√ß√£o com alguns coment√°rios sobre an√°lise de fontes de √°udio.

Uma imagem costuma ser armazenada em forma bruta, como um conjunto de valores de pixel ou c√©lula, ou em forma compactada, para economizar espa√ßo. O descritor de forma da imagem descreve a forma geom√©trica da imagem bruta, que normalmente √© um ret√¢ngulo de c√©lulas de certa largura e altura. Logo, cada imagem pode ser representada por uma grade de c√©lulas de m por n .  Cada c√©lula cont√©m um valor de pixel que descreve seu conte√∫do. Nas imagens em preto e branco, os pixels podem ter um bit. Em imagens com escala de cinza ou coloridas, um pixel tem m√∫ltiplos bits. Como as imagens podem exigir grande quantidade de espa√ßo, elas normalmente s√£o armazenadas em forma compactada. Os padr√µes de compacta√ß√£o, como GIF, JPEG ou MPEG, utilizam diversas transforma√ß√µes matem√°ticas para reduzir o n√∫mero de c√©lulas armazenadas, mas ainda mant√™m as principais caracter√≠sticas da imagem. Transforma√ß√µes matem√°ticas aplic√°veis incluem Discrete Fourier Transform (DFT), Discrete Cosine Transform (DCT) e transforma√ß√µes de wavelet .

Para identificar objetos de interesse em uma imagem, esta normalmente √© dividida em segmentos homog√™neos que usam um predicado de homogeneidade . Por exemplo, em uma imagem colorida, c√©lulas adjacentes que possuem valores de pixel semelhantes s√£o agrupadas em um segmento. O predicado de homogeneidade define condi√ß√µes para agrupar essas c√©lulas automaticamente. A segmenta√ß√£o e compacta√ß√£o podem, ent√£o, identificar as principais caracter√≠sticas de uma imagem.

Uma consulta de banco de dados de imagem t√≠pica seria encontrar imagens no banco de dados que s√£o similares √† determinada imagem. A imagem dada poderia ser um segmento isolado que cont√©m, digamos,

um padr√£o de interesse, e a consulta deve localizar outras imagens que contenham esse mesmo padr√£o. Existem duas t√©cnicas principais para esse tipo de consulta. A primeira utiliza uma fun√ß√£o de dist√¢ncia para comparar a imagem dada com as imagens armazenadas e seus segmentos. Se o valor de dist√¢ncia retornado for pequeno, a probabilida  de de uma combina√ß√£o √© alta. Os √≠ndices podem ser criados para agrupar imagens armazenadas que s√£o pr√≥ximas na m√©trica da dist√¢ncia para limitar o espa√ßo de pesquisa. A segunda, chamada de t√©cnica da transforma√ß√£o , mede a semelhan√ßa da imagem tendo um pequeno n√∫mero de transforma√ß√µes que podem mudar as c√©lulas de uma imagem para combinar com a outra imagem. As transforma√ß√µes incluem rota√ß√µes, transla√ß√µes e escala. Embora a abordagem da transforma√ß√£o seja mais geral, ela tamb√©m √© mais demorada e dif√≠cil.

Uma fonte  de  v√≠deo em  geral  √©  representada como uma sequ√™ncia de quadros, onde cada quadro ainda √© uma imagem. Por√©m, em vez de identificar os objetos e atividades em cada quadro individual, o v√≠deo √© dividido em segmentos de v√≠deo , onde cada segmento compreende uma sequ√™ncia de quadros cont√≠guos que inclui os mesmos objetos/atividades. Cada segmento  √©  identificado  por  seus  quadros  inicial  e final. Os objetos e atividades identificados em cada segmento de v√≠deo podem ser usados para indexar os segmentos. Uma t√©cnica de indexa√ß√£o chamada √°rvores de segmento de quadro foi proposta para a indexa√ß√£o do v√≠deo. O √≠ndice inclui tanto objetos, como pessoas, casas e carros, quanto atividades, como uma pessoa realizando um discurso ou duas pessoas falando .  Os  v√≠deos  tamb√©m  costumam ser compactados usando padr√µes como MPEG.

Fontes de √°udio incluem mensagens gravadas armazenadas, como discursos, apresenta√ß√µes de sala de aula ou mesmo grava√ß√µes de vigil√¢ncia de mensagens ou conversas telef√¥nicas por imposi√ß√£o da lei. Aqui, transforma√ß√µes  discretas  podem  ser  usadas  para identificar as principais caracter√≠sticas da voz de uma pessoa a fim de ter indexa√ß√£o e recupera√ß√£o baseada em  semelhan√ßa.  Comentaremos  rapidamente  sobre sua an√°lise na Se√ß√£o 26.4.4.

Uma fonte  de  texto/documento √©  basicamente o texto completo de algum artigo, livro ou revista. Essas fontes normalmente s√£o indexadas ao identificar as palavras-chave que aparecem no texto e suas frequ√™ncias  relativas.  Contudo,  palavras  de  preenchimento ou palavras comuns, chamadas stopwords , s√£o eliminadas do processo. Como pode haver muitas palavras-chave ao se tentar indexar uma cole√ß√£o de documentos, t√™m sido desenvolvidas t√©cnicas para reduzir o n√∫mero de palavras-chave para as que s√£o mais relevantes √† cole√ß√£o. Uma t√©cnica de redu√ß√£o de dimensionalidade, chamada decomposi√ß√µes de valor singular (SVD), que √© baseada em transforma√ß√µes de matriz, pode ser utilizada para essa finalidade. Uma t√©cnica de indexa√ß√£o, chamada √°rvores de vetor telesc√≥pico (√°rvores  TV),  pode  ent√£o  ser  usada  para agrupar documentos semelhantes. O Cap√≠tulo 27 discutir√° o processamento de documentos em detalhes.

## 26.4.1 An√°lise autom√°tica de imagens

A an√°lise de fontes de multim√≠dia √© cr√≠tica para o  suporte  de  qualquer  tipo  de  consulta  ou  interface de pesquisa. Precisamos representar dados de fonte de multim√≠dia,  como  imagens,  em  rela√ß√£o  aos  recursos que nos permitiriam definir similaridade. O trabalho feito at√© aqui nessa √°rea usa recursos visuais de baixo n√≠vel, como cor, textura e forma, que est√£o diretamente relacionados aos aspectos perceptivos do conte√∫do da imagem. Esses recursos s√£o f√°ceis de extrair e representar, e √© conveniente projetar medidas de similaridade com base em suas propriedades estat√≠sticas.

A cor √©  um  dos  recursos  visuais  mais  usados  na recupera√ß√£o de imagens baseada em conte√∫do, pois n√£o depende do tamanho ou da orienta√ß√£o da imagem. A recupera√ß√£o baseada em semelhan√ßa de cor √© feita principalmente ao calcular um histograma de cor para cada imagem, que identifica  a  propor√ß√£o  de  pixels  dentro de uma imagem para os tr√™s canais de cor (vermelho, verde, azul RGB ).  Por√©m,  a  representa√ß√£o  RGB √© afetada pela orienta√ß√£o do objeto com rela√ß√£o √† ilumina√ß√£o e dire√ß√£o da c√¢mera. Portanto, as t√©cnicas atuais de recupera√ß√£o de imagens calculam histogramas de cores que usam representa√ß√µes invari√°veis concorrentes, como HSV (matiz, satura√ß√£o, valor). A HSV descreve cores como pontos em um cilindro cujo eixo central varia de preto, no fundo, at√© branco, no topo, com cores neutras entre elas. O √¢ngulo em torno do eixo corresponde √† matiz, a dist√¢ncia do eixo, √† satura√ß√£o e a dist√¢ncia ao longo do eixo, ao valor (brilho).

A textura refere-se aos padr√µes em uma imagem que apresentam as propriedades de homogeneidade que n√£o resultam da presen√ßa de um √∫nico valor de cor ou de intensidade. Alguns exemplos de classes de textura s√£o a bruta e a lustrosa. Alguns exemplos  de  texturas  que  podem  ser  identificadas incluem couro de bezerro prensado, esteira de palha, tela de algod√£o, e assim por diante. Assim como as figuras s√£o representadas por vetores de pixels (elementos  de  imagem),  as  texturas  s√£o  representadas por vetores  de  texels (elementos  de  textura).  Essas texturas s√£o ent√£o colocadas em uma s√©rie de conjuntos, dependendo de quantas texturas s√£o identificadas na imagem. Tais conjuntos n√£o apenas cont√™m a defini√ß√£o de textura, mas tamb√©m indicam onde a textura  est√°  localizada  na  imagem.  A  identifica√ß√£o

de textura √© feita principalmente ao model√°-la como uma  varia√ß√£o  bidimensional,  de  n√≠vel  de  cinza.  O brilho relativo dos pares de pixels √© calculado para estimar o grau de contraste, regularidade, rispidez e direcionalidade.

A forma refere-se √† forma de uma regi√£o em uma imagem.  Ela  geralmente  √©  determinada  ao  aplicar segmenta√ß√£o ou detec√ß√£o de borda a uma imagem. A segmenta√ß√£o √© uma t√©cnica baseada em regi√£o que usa uma regi√£o inteira (conjuntos de pixels), enquanto a detec√ß√£o de borda √© uma t√©cnica baseada em limites, que utiliza apenas as caracter√≠sticas de contorno externo das entidades. A representa√ß√£o da forma em geral precisa ser invari√°vel √† transla√ß√£o, rota√ß√£o e escala. Alguns m√©todos bem conhecidos para a representa√ß√£o de forma incluem descritores de Fourier e invari√°veis de movimento.

## 26.4.2 Reconhecimento de objeto em imagens

O reconhecimento de objeto √© a tarefa de identificar  objetos  do  mundo  real  em  uma  imagem  ou sequ√™ncia de v√≠deo. O sistema precisa ser capaz de identificar o objeto mesmo quando suas imagens variam em pontos de vista, tamanho, escala ou mesmo quando elas s√£o giradas ou passam por transla√ß√£o. Algumas t√©cnicas foram desenvolvidas para dividir a imagem original em regi√µes com base na similaridade dos pixels cont√≠guos. Assim, em determinada imagem que  mostra  um  tigre  na  selva,  uma  subimagem  do tigre pode ser detectada contra o fundo da selva, e, quando comparada com um conjunto de imagens em treinamento, ela pode ser marcada como um tigre.

A representa√ß√£o do objeto de multim√≠dia em um modelo de objeto √© extremamente importante. Uma t√©cnica  consiste  em  dividir  a  imagem  em  segmentos homog√™neos usando um predicado homog√™neo. Por exemplo, em uma imagem colorida, c√©lulas adjacentes que possuem valores de pixel semelhantes s√£o agrupadas em um segmento. O predicado de homogeneidade define condi√ß√µes para agrupar automaticamente essas c√©lulas. A segmenta√ß√£o e compacta√ß√£o, portanto, podem  identificar  as  principais  caracter√≠sticas  de  uma imagem. Outra t√©cnica encontra medi√ß√µes do objeto que  s√£o  invari√°veis  √†s  transforma√ß√µes.  √â  imposs√≠vel manter um banco de dados de exemplos de todas as diferentes transforma√ß√µes de uma imagem. Para lidar com isso, as t√©cnicas de reconhecimento de objeto encontram pontos (ou caracter√≠sticas) interessantes em uma imagem, que n√£o variam com as transforma√ß√µes.

Uma contribui√ß√£o importante para esse campo foi feita por Lowe, 30 que usou recursos invari√°veis na

30 Ver Lowe (2004), 'Distinctive Image Features from Scale-Invariant Keypoints'.

escala com base nas imagens para realizar um reconhecimento de objeto confi√°vel. Essa t√©cnica √© chamada de transforma√ß√£o de caracter√≠stica  invari√°vel em escala  SIFT ( ). Os recursos SIFT s√£o invari√°veis ao redimensionamento e rota√ß√£o da imagem, e parcialmente invari√°veis √† mudan√ßa na ilumina√ß√£o e ponto de vista da c√¢mera 3D. Eles s√£o bem localizados nos dom√≠nios espacial e de frequ√™ncia, reduzindo a probabilidade de interrup√ß√£o por oclus√£o, aglomera√ß√£o ou ru√≠do. Al√©m disso, as caracter√≠sticas s√£o altamente  distintivos,  o  que  permite  que  um  √∫nico  recurso seja corretamente combinado com alta probabilidade contra um grande banco de dados de caracter√≠sticas, oferecendo uma base para reconhecimento de objeto e cena.

Para combina√ß√£o e reconhecimento de imagem, os recursos do SIFT (tamb√©m conhecidos como caracter√≠sticas de ponto-chave ) s√£o primeiro extra√≠dos de um conjunto de imagens de refer√™ncia e armazenados em um banco de dados. O reconhecimento de objeto √© ent√£o realizado ao comparar cada caracter√≠stica da nova imagem com as caracter√≠sticas armazenadas no banco de dados e ao encontrar prov√°veis caracter√≠sticas correspondentes com base na dist√¢ncia euclideana de seus vetores de caracter√≠stica. Como as caracter√≠sticas de ponto-chave s√£o altamente distintas, uma √∫nica caracter√≠stica pode ser combinada corretamente  com boa probabilidade em um grande banco de dados de caracter√≠sticas.

Al√©m  do  SIFT,  existem  diversos  m√©todos  concorrentes dispon√≠veis para reconhecimento de objeto sob  aglomera√ß√£o  ou  oclus√£o  parcial.  Por  exemplo, o RIFT ,  uma generaliza√ß√£o invari√°vel √† rota√ß√£o do SIFT, identifica grupos de regi√µes afins locais (caracter√≠sticas de imagem com uma apar√™ncia caracter√≠stica e forma el√≠ptica) que permanecem aproximadamente afins por uma gama de vis√µes de um objeto, e por m√∫ltiplas inst√¢ncias da mesma classe de objeto.

## 26.4.3 Marca√ß√£o sem√¢ntica de imagens

A  no√ß√£o  de  marca√ß√£o  impl√≠cita  √©  importante para reconhecimento e compara√ß√£o de imagem. M√∫ltiplas tags podem se conectar a uma imagem ou uma subimagem: por exemplo, no caso que referenciamos acima, tags como 'tigre', 'selva', 'verde' e 'listras' podem ser associadas a essa imagem. A maioria das t√©cnicas de pesquisa de imagem recupera imagens com base  em  tags  fornecidas  pelo  usu√°rio,  que  normalmente n√£o s√£o muito precisas ou abrangentes. Para melhorar a qualidade da pesquisa, diversos sistemas recentes  visam  √†  gera√ß√£o  automatizada  dessas  tags de imagem. No caso de dados de multim√≠dia, a maio-

ria de sua sem√¢ntica est√° presente em seu conte√∫do. Esses sistemas utilizam t√©cnicas de processamento de imagem e modelagem estat√≠stica para analisar o conte√∫do da imagem e gerar tags de anota√ß√£o precisas, que podem ent√£o ser usadas para recuperar imagens por conte√∫do. Como diferentes esquemas de anota√ß√£o empregar√£o vocabul√°rios distintos para anotar imagens, a qualidade da recupera√ß√£o da imagem ser√° fraca. Para resolver esse problema, t√©cnicas de pesquisa recentes propuseram o uso de hierarquias de conceito,  taxonomias  ou  ontologias  usando OWL ( Web  Ontology  Language ),  em  que  termos  e  seus relacionamentos s√£o claramente definidos. Estes podem ser usados para deduzir conceitos de n√≠vel mais alto com base nas tags. Conceitos como 'c√©u' e 'grama' podem ser divididos ainda em 'c√©u claro' e 'c√©u nublado' ou 'grama seca' e 'grama verde' nessa taxonomia. Essas t√©cnicas costumam vir sob a marca√ß√£o sem√¢ntica e podem ser usadas em conjunto com as estrat√©gias citadas de an√°lise de recursos e identifica√ß√£o de objetos.

## 26.4.4 An√°lise de fontes de dados de √°udio

As fontes de √°udio s√£o em geral classificadas em dados de voz, m√∫sica e outros dados de √°udio. Cada uma delas √© significativamente diferente da outra, e, portanto, diversos tipos de dados de √°udio s√£o tratados de formas diferentes. Os dados de √°udio precisam ser digitalizados antes que possam ser processados e armazenados. A indexa√ß√£o e recupera√ß√£o de dados de √°udio √© comprovadamente a mais dif√≠cil entre todos os tipos de m√≠dia, pois, assim como o v√≠deo, ela √© cont√≠nua no tempo e n√£o tem caracter√≠sticas facilmente mensur√°veis, como o texto. A clareza das grava√ß√µes de som √© f√°cil de perceber humanamente, mas dif√≠cil de ser quantificada para aprendizado da m√°quina.  √â  interessante  que  os  dados  de  voz  com frequ√™ncia usam t√©cnicas de reconhecimento de voz para auxiliar o conte√∫do de √°udio real, e isso pode tornar a indexa√ß√£o desses dados muito mais f√°cil e precisa. Isso √†s vezes √© chamado de indexa√ß√£o baseada em texto de dados de √°udio . Os metadados de voz costumam depender do conte√∫do, na medida em que eles s√£o gerados do conte√∫do de √°udio, por exemplo, o comprimento da fala, o n√∫mero de pessoas falando, e assim por diante. Por√©m, alguns dos metadados poderiam ser independentes do conte√∫do real, como o comprimento da fala e o formato em que os dados s√£o armazenados. A indexa√ß√£o da m√∫sica, por sua vez, √© feita com base na an√°lise estat√≠stica do sinal de √°udio, tamb√©m conhecida como indexa√ß√£o baseada em conte√∫do. Tal tipo de indexa√ß√£o normalmente utiliza os principais recursos do som: intensidade, tom, timbre e ritmo. √â poss√≠vel comparar diferentes trechos de dados de √°udio e recuperar informa√ß√µes deles com base no c√°lculo de certas caracter√≠sticas, bem como a aplica√ß√£o de certas transforma√ß√µes.

## 26.5 ntrodu√ß√£o aos bancos de I dados dedutivos

## 26.5.1 Vis√£o geral dos bancos de dados dedutivos

Em um sistema de banco de dados dedutivo, √©  comum  especificarmos  regras  por  meio  de  uma linguagem  declarativa -  uma  linguagem  em  que especificamos o que conseguir em vez de como consegui-lo.  Um mecanismo  de  infer√™ncia (ou mecanismo de dedu√ß√£o ) dentro do sistema pode deduzir novos fatos do banco de dados ao interpretar essas regras. O modelo usado para bancos de dados dedutivos est√° bastante relacionado ao modelo de dados relacional, e particularmente ao formalismo do c√°lculo relacional do dom√≠nio (ver Se√ß√£o 6.6). Ele tamb√©m est√° relacionado ao campo da programa√ß√£o l√≥gica e  √†  linguagem Prolog .  O  trabalho com banco  de  dados  dedutivo  baseado  na  l√≥gica  tem usado Prolog como ponto de partida. Uma varia√ß√£o da Prolog, chamada Datalog ,  √©  utilizada para definir regras em forma de declara√ß√£o, junto com um conjunto de rela√ß√µes existentes, que por si s√≥s s√£o tratadas como literais na linguagem. Embora a estrutura da linguagem da Datalog seja semelhante √† da Prolog, sua sem√¢ntica operacional - ou seja, como um programa em Datalog √© executado - ainda √© diferente.

Um  banco  de  dados  dedutivo  usa  dois  tipos principais de especifica√ß√µes: fatos e regras. Fatos s√£o especificados de uma maneira semelhante ao modo como as rela√ß√µes s√£o especificadas, exceto que n√£o √©  necess√°rio  incluir  nomes  de  atributo.  Lembre-se de  que  uma  tupla  em  uma  rela√ß√£o  descreve  algum fato do mundo real, cujo significado √© parcialmente determinado pelos nomes de atributo. Em um banco de dados dedutivo, o significado de um valor de atributo  em  uma  tupla  √©  determinado  unicamente por sua posi√ß√£o na tupla. Regras s√£o semelhantes a vis√µes relacionais. Elas especificam rela√ß√µes virtuais que n√£o est√£o realmente armazenadas, mas podem ser  formadas com base nos fatos, ao aplicar mecanismos de infer√™ncia baseados nas especifica√ß√µes da regra.  A  principal  diferen√ßa  entre  regras  e  vis√µes  √© que as regras podem envolver recurs√£o e, portanto, gerar rela√ß√µes virtuais que n√£o podem ser definidas em rela√ß√£o a vis√µes relacionais b√°sicas.

A avalia√ß√£o de programas Prolog se baseia em uma  t√©cnica  chamada backward  chaining ,  que  envolve uma avalia√ß√£o top-down (de cima para baixo) dos  objetivos.  Em  bancos  de  dados  dedutivos  que usam Datalog, a aten√ß√£o deve ser dedicada ao tratamento  de  grande  volume  de  dados  armazenados em um banco de dados relacional. Logo, t√©cnicas de avalia√ß√£o  foram  criadas,  semelhantes  √†quelas  para uma avalia√ß√£o bottom-up (de baixo para cima). O Prolog sofre da limita√ß√£o de que a ordem da especifica√ß√£o dos fatos e regras √© significativa na avalia√ß√£o; al√©m do mais, a ordem de literais (definidas na Se√ß√£o 26.5.3) em uma regra √© significativa. As t√©cnicas de execu√ß√£o para programas Datalog tentam contornar esses problemas.

## 26.5.2 Nota√ß√£o Prolog/Datalog

tados como identificadores (ou nomes) que come√ßam com uma letra min√∫scula , enquanto nomes de vari√°veis sempre come√ßam com uma letra mai√∫scula.

Considere o exemplo mostrado na Figura 26.11, que √© baseado no banco de dados relacional da Figura 3.6, mas em uma forma bastante simplificada. Existem tr√™s nomes de predicado: supervisiona , superior e subordinado O predicado SUPERVISIONA √© definido por meio de um conjunto de fatos, cada um com dois argumentos: um nome de supervisor, seguido pelo nome de um supervisionado direto (subordinado) desse supervisor. Esses fatos correspondem aos dados reais armazenados no banco de dados, e podem ser considerados constituintes de um conjunto de tuplas em uma rela√ß√£o SUPERVISIONA com dois atributos, cujo esquema √©

SUPERVISIONA(Supervisor, Supervisionado)

A nota√ß√£o em Prolog/Datalog √© baseada em fornecer predicados com nomes exclusivos. Um predicado tem um significado impl√≠cito, que √© sugerido pelo nome do predicado, e um n√∫mero fixo de argumentos. Se os argumentos forem todos valores constantes, o predicado simplesmente indica que certo fato √©  verdadeiro.  Se,  caso  contr√°rio,  o  predicado  tiver vari√°veis como argumentos, ele √© considerado uma consulta ou parte de uma regra ou restri√ß√£o. Em nossa discuss√£o, adotamos a conven√ß√£o Prolog de que todos  os valores  constantes em  um  predicado  s√£o strings num√©ricas ou de caractere ; eles s√£o represen-

Assim, SUPERVISIONA( X Y , )  declara  o  fato  de que X supervisiona Y . Observe a omiss√£o dos nomes de atributo na nota√ß√£o Prolog. Os nomes de atributo s√≥ s√£o representados em virtude da posi√ß√£o de cada argumento em um predicado: o primeiro argumento representa o supervisor, e o segundo argumento representa um subordinado direto.

Os outros dois nomes de predicado s√£o definidos por regras. As principais contribui√ß√µes dos bancos de dados dedutivos s√£o a capacidade de especificar regras recursivas e oferecer um framework para deduzir novas informa√ß√µes com base nas regras espec√≠fi-



...

## Regras

SUPERIOR( X, Y ) :- SUPERVISIONA( X, Y ). SUPERIOR( X, Y ) :- SUPERVISIONA( X, Z ), SUPERIOR( Z, Y ). SUBORDINADO( X, Y ) :- SUPERIOR( Y, X ).

## Consultas

SUPERIOR(jorge, Y )? SUPERIOR(jorge, joice)?

cas. Uma regra tem a forma cabe√ßa :- corpo , onde :- √© lido como se e somente se . Uma regra normalmente tem um √∫nico predicado √† esquerda do s√≠mbolo :- chamado de cabe√ßa ou left-hand side (LHS) ou conclus√£o da regra - e um ou mais predicados √† direita do s√≠mbolo :- - chamado de corpo ou right-hand side (RHS) ou premissa(s) da  regra.  Um  predicado com  constantes  como  argumentos  √©  considerado base ; tamb√©m nos referimos a ele como um predicado instanciado .  Os argumentos dos predicados que aparecem em uma regra costumam incluir uma s√©rie de s√≠mbolos vari√°veis, embora os predicados tamb√©m possam  conter  constantes  como  argumentos.  Uma regra  especifica  que,  se  determinada  atribui√ß√£o  ou v√≠nculo dos valores constantes √†s vari√°veis no corpo (predicados RHS) tornar todos os  predicados  RHS verdadeiros ,  ela  tamb√©m torna a cabe√ßa (predicado LHS) verdadeira ao usar a mesma atribui√ß√£o de valores  constantes  √†s  vari√°veis.  Logo,  uma  regra  nos oferece um modo de gerar novos fatos que s√£o instancia√ß√µes da cabe√ßa da regra. Esses novos fatos s√£o baseados em fatos que j√° existem, correspondentes √†s instancia√ß√µes (ou v√≠nculos) de predicados no corpo da regra. Observe que, ao listar v√°rios predicados no corpo de uma regra, aplicamos implicitamente o operador l√≥gico AND a esses predicados. Assim, as v√≠rgulas  entre  os  predicados  RHS  podem  ser  lidas como significando and .

corpo da regra define uma s√©rie de premissas, de modo que,  se  todas  elas  s√£o  verdadeiras,  podemos  deduzir que a conclus√£o na cabe√ßa da regra tamb√©m √© verdadeira. Observe que, se tivermos duas (ou mais) regras com a mesma cabe√ßa (predicado LHS), isso √© equivalente a dizer que o predicado √© verdadeiro (ou seja, que pode ser instanciado) se um dos corpos for verdadeiro; logo, isso √© equivalente a uma opera√ß√£o OR l√≥gica . Por exemplo, se tivermos duas regras X :-Y e X :-Z , elas s√£o equivalentes a uma regra X :-Y OR Z . Por√©m, a √∫ltima forma n√£o √© usada nos sistemas dedutivos, pois n√£o est√° na forma padr√£o da regra, chamada cl√°usula Horn , como discutimos na Se√ß√£o 26.5.4.

Um sistema Prolog cont√©m uma s√©rie de predicados embutidos que o sistema pode interpretar diretamente. Estes costumam incluir o operador de compara√ß√£o de igualdade = ( X Y , ), que retorna verdadeiro se X e Y forem id√™nticos e tamb√©m pode ser escrito como X Y = ao utilizar a nota√ß√£o de infixo padr√£o. 31  Outros operadores  de  compara√ß√£o  para  n√∫meros,  como  &lt;, &lt;=, &gt; e &gt;=, podem ser tratados como predicados bin√°rios. As fun√ß√µes aritm√©ticas como +, -,   e / podem ser * usadas como argumentos em predicados Prolog. Por sua vez, Datalog (em sua forma b√°sica) n√£o permite fun√ß√µes como opera√ß√µes aritm√©ticas como argumentos; na realidade, essa √© uma das principais diferen√ßas entre Prolog e Datalog. Contudo, foram propostas extens√µes √† Datalog, que incluem fun√ß√µes.

Considere a defini√ß√£o do predicado SUPERIOR da  Figura  26.11,  cujo  primeiro  argumento  √©  um nome  de  funcion√°rio  e  cujo  segundo  argumento  √© um funcion√°rio  subordinado direto ou indireto do primeiro  funcion√°rio.  Com subordinado  indireto , queremos  dizer  o  subordinado  ou  algum  subordinado abaixo at√© qualquer n√∫mero de n√≠veis. Assim, SUPERIOR ( X Y , ) indica o fato de que X √© um superior de Y por meio de supervis√£o direta ou indireta. Podemos escrever duas regras que juntas especificam o significado do novo predicado. A primeira regra sob Regras na figura indica que, para cada valor de X e Y ,  se SUPERVISIONA ( X,Y )  -  o  corpo  da  regra  for verdadeiro, ent√£o SUPERIOR ( X,Y ) - a cabe√ßa da regra - tamb√©m √© verdadeiro, pois Y seria  um subordinado direto de X (um n√≠vel abaixo). Essa regra pode ser usada para gerar todos os relacionamentos diretos de superior/subordinado com base nos fatos que definem o predicado SUPERVISIONA . A segunda regra  recursiva  indica  que,  se SUPERVISIONA( X,Z ) e SUPERIOR ( Z,Y ) s√£o ambos verdadeiros,  ent√£o SUPERIOR ( X,Y )  tamb√©m  √©  verdadeiro.  Esse  √©  um exemplo de uma regra recursiva ,  onde um dos predicados do corpo da regra no RHS √© o mesmo que o predicado de cabe√ßa da regra no LHS. Em geral, o

Uma consulta normalmente envolve um s√≠mbolo de predicado com alguns argumentos vari√°veis, e seu significado (ou resposta ) √© deduzir todas as diferentes combina√ß√µes de constantes que, quando vinculadas (atribu√≠das) √†s vari√°veis, podem tornar o predicado verdadeiro. Por exemplo, a primeira consulta na Figura 26.11 solicita os nomes de todos os subordinados de jorge em qualquer n√≠vel. Um tipo diferente de consulta, que tem apenas s√≠mbolos constantes como argumentos, retorna um resultado verdadeiro ou falso, dependendo de os argumentos fornecidos poderem ser deduzidos dos fatos e regras. Por exemplo, a segunda consulta na Figura 26.11 retorna verdadeira, pois SUPERIOR (jorge, joice) pode ser deduzido.

## 26.5.3 Nota√ß√£o Datalog

Em  Datalog,  como  em  outras  linguagens  baseadas  na  l√≥gica,  um  programa  √©  criado  com  base em objetos b√°sicos, chamados f√≥rmulas at√¥micas . √â comum definir a sintaxe de linguagens baseadas em l√≥gica ao descrever a sintaxe de f√≥rmulas at√¥micas e identificar como elas podem ser combinadas para formar um programa. Em Datalog, as f√≥rmulas at√¥micas s√£o literais na forma p a ( 1 , a 2 , ... a n ), onde p √©

31 Um sistema Prolog normalmente tem uma s√©rie de predicados de igualdade diferentes, que possuem interpreta√ß√µes diversas.

o nome do predicado e n √© o n√∫mero de argumentos para o predicado p . Diferentes s√≠mbolos de predicado podem ter distintos n√∫meros de argumentos, e o n√∫mero de argumentos n do predicado p √†s vezes √© chamado de aridez ou grau de p . Os argumentos podem ser valores constantes ou nomes vari√°veis. Como j√° dissemos, usamos a conven√ß√£o de que valores constantes ou s√£o num√©ricos ou come√ßam com um caractere min√∫sculo , enquanto nomes de vari√°vel sempre come√ßam com um caractere mai√∫sculo .

Uma s√©rie de predicados embutidos est√° inclu√≠  da em Datalog, que tamb√©m pode ser usada para construir  f√≥rmulas  at√¥micas.  Os  predicados  embutidos s√£o de dois tipos principais: os predicados de compara√ß√£o bin√°ria &lt; ( less ), &lt;= ( less\_or\_equal ), &gt; ( greater ) e &gt;= ( greater\_or\_equal ) em dom√≠nios ordenados; e os predicados de compara√ß√£o = ( equal ) e /= ( not\_equal ) em dom√≠nios ordenados ou n√£o ordenados. Estes podem ser utilizados como predicados bin√°rios com a mesma sintaxe funcional de outros predicados - por exemplo, ao escrever less ( X ,3) - ou eles podem ser especificados ao usar a nota√ß√£o infixa comum X &lt;3. Observe  que,  como  os  dom√≠nios  desses  predicados s√£o potencialmente infinitos, eles devem ser usados com cuidado nas defini√ß√µes de regra. Por exemplo, o predicado greater ( X ,3), se usado isoladamente, gera um conjunto infinito de valores para X que satisfaz o predicado (todos os n√∫meros inteiros maiores que 3).

Um literal √© uma f√≥rmula at√¥mica, conforme definido anteriormente - chamado literal positivo -, ou uma f√≥rmula at√¥mica precedida por not . A √∫ltima √© uma f√≥rmula at√¥mica negada, chamada literal negativo . Os programas em Datalog podem ser considerados  um subconjunto das  f√≥rmulas  de  c√°lculo de  predicado,  que  s√£o  semelhantes  √†s  f√≥rmulas  do c√°lculo  relacional  de  dom√≠nio  (ver  Se√ß√£o  6.7).  Em Datalog, por√©m, essas f√≥rmulas s√£o primeiro convertidas no que √© conhecido como forma clausular antes que sejam expressas em Datalog, e somente f√≥rmulas dadas em uma forma clausular restrita, denominadas cl√°usulas de Horn , 32 podem ser usadas em Datalog.

## 26.5.4 Forma clausular e cl√°usulas de Horn

Lembre-se, da Se√ß√£o 6.6, que uma f√≥rmula no c√°lculo relacional √© uma condi√ß√£o que inclui predicados  chamados √°tomos (com  base  nos  nomes  de rela√ß√£o). Al√©m disso, uma f√≥rmula pode ter quantificadores - a saber, o quantificador universal (para todos) e o quantificador existencial (existe). Na forma clausular, uma f√≥rmula precisa ser transformada em outra com as seguintes caracter√≠sticas:

32 Devido ao nome do matem√°tico Alfred Horn.

- ¬Ñ Todas as vari√°veis na f√≥rmula s√£o quantificadas  universalmente.  Logo,  n√£o  √©  necess√°rio incluir os quantificadores universais (para todos) explicitamente; os quantificadores s√£o removidos,  e  todas  as  vari√°veis  na  f√≥rmula s√£o implicitamente quantificadas pelo quantificador universal.
- ¬Ñ Na forma clausular, a f√≥rmula √© composta de uma s√©rie de cl√°usulas, em que cada cl√°usula √© composta de uma s√©rie de literais conectadas apenas por conectivos l√≥gicos OR . Logo, cada cl√°usula √© uma disjun√ß√£o de literais.
- ¬Ñ As pr√≥prias cl√°usulas s√£o conectadas apenas por conectivos l√≥gicos AND , para formar uma f√≥rmula.  Assim,  a forma  clausular  de  uma f√≥rmula √© uma conjun√ß√£o de cl√°usulas.

Pode-se mostrar que qualquer f√≥rmula pode ser convertida  para  uma  forma  clausular .  Para  nossos prop√≥sitos,  estamos interessados principalmente na forma  das  cl√°usulas  individuais,  cada  qual  sendo uma disjun√ß√£o das literais. Lembre-se de que os literais podem ser literais positivos ou negativos. Considere a cl√°usula na forma:

<!-- formula-not-decoded -->

Esta cl√°usula tem n literais negativos e m literais positivos. Ela pode ser transformada na seguinte f√≥rmula l√≥gica equivalente:

<!-- formula-not-decoded -->

onde ‚áí √©  o  s√≠mbolo implica .  As f√≥rmulas (1) e (2) s√£o equivalentes, significando que seus valores verdade s√£o sempre os mesmos. Isso acontece porque, se todas as literais P i (  = 1, 2, ..., i n ) forem verdadeiros, a f√≥rmula (2) s√≥ √© verdadeira se pelo menos um dos Qi for verdadeiro, que √© o significado do s√≠mbolo ‚áí (implica). Para a f√≥rmula (1), se todos os literais P i (  = 1, 2, ..., i n ) forem verdadeiros, suas nega√ß√µes s√£o todas falsas; assim, neste caso, a f√≥rmula (1) s√≥ √© verdadeira se pelo menos um dos Qi for verdadeiro. Em Datalog,  as  regras  s√£o  expressas  como  uma  forma restrita  de  cl√°usulas,  chamadas cl√°usulas  de  Horn , em que uma cl√°usula pode conter no m√°ximo um literal positivo. Logo, uma cl√°usula de Horn pode ter a forma

<!-- formula-not-decoded -->

ou a forma

<!-- formula-not-decoded -->

A cl√°usula de Horn em (3) pode ser transformada na cl√°usula

<!-- formula-not-decoded -->

que √© escrita em Datalog como a seguinte regra:

<!-- formula-not-decoded -->

A cl√°usula de Horn em (4) pode ser transformada para

<!-- formula-not-decoded -->

que √© escrita em Datalog da seguinte forma:

<!-- formula-not-decoded -->

Uma regra Datalog ,  como em (6), √©, portanto, uma cl√°usula de Horn, e seu significado, baseado na f√≥rmula (5), √© que, se os predicados P 1 AND P 2 AND ... AND P n forem todos verdadeiros para um v√≠nculo em particular com seus argumentos vari√°veis, ent√£o Q tamb√©m √© verdadeiro e, portanto, pode ser deduzido. A express√£o Datalog (8) pode ser considerada uma restri√ß√£o  de  integridade,  onde  todos  os  predicados devem ser verdadeiros para satisfazer a consulta.

Em geral, uma consulta em Datalog consiste em dois componentes:

- ¬Ñ Um programa Datalog,  que  √©  um  conjunto finito de regras.
- ¬Ñ Uma literal P X ( 1 , X 2 , ..., X n ), onde cada X i √© uma vari√°vel ou uma constante.

Um sistema em Prolog ou Datalog tem um mecanismo de infer√™ncia interno que pode ser usado para processar e calcular os resultados de tais consultas. Os mecanismos de infer√™ncia em Prolog normalmente retornam um resultado para a consulta (ou seja, um conjunto de valores para as vari√°veis na consulta) de cada vez e devem ser solicitados a retornar resultados adicionais. Ao contr√°rio, Datalog retorna resultados um conjunto de cada vez.

## 26.5.5 nterpreta√ß√µes de regras I

Existem duas alternativas principais para interpretar  o  significado  te√≥rico  das  regras: te√≥rico  de prova e te√≥rico de modelo . Em sistemas pr√°ticos, o mecanismo de infer√™ncia em um sistema define a interpreta√ß√£o  exata,  que  pode  n√£o  coincidir  com  nenhuma das interpreta√ß√µes te√≥ricas. O mecanismo de infer√™ncia √© um procedimento computacional e, portanto, oferece uma interpreta√ß√£o computacional do significado das regras. Nesta se√ß√£o, primeiro discutimos as duas interpreta√ß√µes te√≥ricas. Depois, discutimos rapidamente os mecanismos de infer√™ncia como um modo de definir o significado das regras.

Na  interpreta√ß√£o te√≥rica  de  prova das  regras, consideramos os fatos e as regras afirma√ß√µes verdadeiras, ou axiomas . Axiomas de base n√£o possuem vari√°veis.  Os  fatos  s√£o  axiomas  de  base  que  s√£o dados  como  verdadeiros.  Regras  s√£o  chamadas  de axiomas dedutivos , pois podem ser usadas para deduzir novos fatos. Os axiomas dedutivos podem ser utilizados para construir provas que derivam novos fatos de fatos existentes. Por exemplo, a Figura 26.12 mostra como provar o fato SUPERIOR (jorge, andre) com base nas regras e fatos dados na Figura 26.11. A interpreta√ß√£o te√≥rica de prova nos d√° uma t√©cnica procedimental  e  computacional  para  calcular  uma resposta √† consulta Datalog. O processo de provar se certo fato (teorema) √© mantido √© conhecido como prova do teorema .

- O segundo tipo de interpreta√ß√£o √© chamado de interpreta√ß√£o te√≥rica de modelo . Aqui, dado um dom√≠nio finito ou infinito de valores constantes, 33  atribu√≠mos a um predicado cada combina√ß√£o poss√≠vel de valores como argumentos. Devemos, ent√£o, determinar se o predicado √© verdadeiro ou falso. Em geral, √© suficiente especificar as combina√ß√µes de argumentos que tornam o predicado verdadeiro e indicar que todas as outras combina√ß√µes tornam o predicado falso. Se for feito para cada predicado, isso √© chamado de
- 1.  SUPERIOR(X, Y ) :-  SUPERVISIONA(X, Y ).
- 2.  SUPERIOR(X, Y ) :-  SUPERVISIONA(X, Z ), SUPERIOR(Z, Y ).
- 3.  SUPERVISIONA(jennifer, andre).
- 4.  SUPERVISIONA(jorge, jennifer).
- 5.  SUPERIOR(jennifer, andre).
- 6.  SUPERIOR(jorge, andre).

Figura 26.12

Provando um novo fato.

33 O dom√≠nio escolhido mais comum √© finito e se chama Universo de Herbrand.

(regra 1) (regra 2)

(axioma de base, dado)

(axioma de base, dado)

(aplicar regra 1 sobre 3)

(aplicar regra 2 sobre 4 e 5)

uma interpreta√ß√£o do  conjunto  de  predicados.  Por exemplo, considere a interpreta√ß√£o mostrada na Figura 26.13 para os predicados SUPERVISIONA e SU -PERIOR. Essa interpreta√ß√£o atribui um valor verdade (verdadeiro ou falso) para cada combina√ß√£o poss√≠vel de valores de argumento (de um dom√≠nio finito) para os dois predicados.

Uma interpreta√ß√£o √© chamada de modelo para um conjunto espec√≠fico de regras se essas regras forem sempre  verdadeiras sob  essa  interpreta√ß√£o;  ou seja,  para  quaisquer  valores  atribu√≠dos  √†s  vari√°veis nas regras, a cabe√ßa das regras √© verdadeira quando substitu√≠mos os valores verdade atribu√≠dos aos predicados  no  corpo  da  regra  por  essa  interpreta√ß√£o. Logo, sempre que determinada substitui√ß√£o (v√≠nculo) para as vari√°veis nas regras √© aplicada, se todos os predicados no corpo de uma regra forem verdadeiros  sob  a  interpreta√ß√£o,  o  predicado  na  cabe√ßa  da regra tamb√©m precisa ser verdadeiro. A interpreta√ß√£o da  Figura  26.13  √©  um  modelo  para  as  duas  regras mostradas, pois nunca pode fazer que as regras sejam violadas. Observe que uma regra √© violada se determinado v√≠nculo de constantes para vari√°veis tornar todos os predicados no corpo da regra verdadeiros, mas tornar o predicado na cabe√ßa da regra falso. Por exemplo, se SUPERVISIONA( a , b )  e SUPERIOR( b , c ) forem ambos verdadeiros sob alguma interpreta√ß√£o, mas SUPERIOR ( a, c ) n√£o for verdadeiro, a interpreta√ß√£o n√£o pode ser um modelo para a regra recursiva:

## SUPERIOR(X, Y) :- SUPERVISIONA(X, Z), SUPERIOR(Z, Y)

Na t√©cnica te√≥rica de modelo, o significado das regras √© estabelecido ao oferecer um modelo para essas regras. Um modelo √© chamado de modelo m√≠nimo para um conjunto de regras se n√£o pudermos mudar nenhum fato de verdadeiro para falso e ainda obter um modelo para essas regras. Por exemplo, considere  a  interpreta√ß√£o  da  Figura  26.13,  e  suponha  que o  predicado SUPERVISIONA seja  definido  por  um conjunto de fatos conhecidos, enquanto o predicado SUPERIOR √© definido como uma interpreta√ß√£o (modelo) para as regras. Suponha que acrescentemos o predicado SUPERIOR(jorge,  roberto) aos  predicados verdadeiros. Este permanece um modelo para as regras mostradas, mas n√£o √© um modelo m√≠nimo, pois mudar o valor verdade de SUPERIOR(jorge, roberto) de verdadeiro para falso ainda nos oferece um modelo para as regras. O modelo mostrado na Figura 26.13 √© o modelo m√≠nimo para o conjunto de fatos que s√£o definidos pelo predicado SUPERVISIONA .

Em  geral,  o  modelo  m√≠nimo  que  corresponde a  determinado  conjunto  de  fatos  na  interpreta√ß√£o te√≥rica  de  modelo  deve  ser  o  mesmo  que  os  fatos

## Regras

SUPERIOR(  , X Y ) :-  SUPERVISIONA(  , X Y ).

SUPERIOR(  , X Y ) :-   SUPERVISIONA(  , X Z ), SUPERIOR(  , Z Y ).

## Interpreta√ß√£o

Fatos conhecidos: SUPERVISIONA(fernando, joao) √© verdadeiro . SUPERVISIONA(fernando, ronaldo) √© verdadeiro . SUPERVISIONA(fernando, joice) √© verdadeiro . SUPERVISIONA(jennifer, alice) √© verdadeiro . SUPERVISIONA(jennifer, andre) √© verdadeiro . SUPERVISIONA(jorge, fernando) √© verdadeiro . SUPERVISIONA(jorge, jennifer) √© verdadeiro .

SUPERVISIONA(  , X  Y ) √© falso para todas as outras combina√ß√µes poss√≠veis de (  , X Y )

## Fatos derivados:

SUPERIOR(fernando, joao) √© verdadeiro .

SUPERIOR(fernando, ronaldo) √© verdadeiro .

SUPERIOR(fernando, joice) √© verdadeiro .

SUPERIOR(jennifer, alice) √© verdadeiro .

SUPERIOR(jennifer, andre) √© verdadeiro .

SUPERIOR(jorge, fernando) √© verdadeiro .

SUPERIOR(jorge, jennifer) √© verdadeiro .

SUPERIOR(jorge, joao) √©

verdadeiro .

SUPERIOR(jorge, ronaldo) √©

verdadeiro .

SUPERIOR(jorge, joice) √© verdadeiro .

SUPERIOR(jorge, alice) √© verdadeiro .

SUPERIOR(jorge, andr√©) √©

verdadeiro .

SUPERIOR(  , X Y )   √© falso para todas as outras combina√ß√µes poss√≠veis de (  , X Y )

Figura  26.13

Uma interpreta√ß√£o que √© um modelo m√≠nimo.

gerados pela interpreta√ß√£o te√≥rica de prova para o mesmo conjunto original de axiomas de base e dedutivos. Por√©m, isso geralmente √© verdadeiro apenas para regras com uma estrutura simples. Quando permitimos a nega√ß√£o na especifica√ß√£o das regras, a correspond√™ncia entre as interpreta√ß√µes n√£o se mant√©m.

De fato, com a nega√ß√£o, diversos modelos m√≠nimos s√£o poss√≠veis para determinado conjunto de fatos.

Uma terceira t√©cnica para interpretar o significado das regras envolve a defini√ß√£o de um mecanismo de infer√™ncia que √© usado pelo sistema para deduzir fatos  das  regras.  Esse  mecanismo  de  infer√™ncia  definiria uma interpreta√ß√£o computacional para o significado das regras. A linguagem de programa√ß√£o l√≥gica Prolog utiliza seu mecanismo de interface para definir o significado das regras e fatos em um programa Prolog. Nem todos os programas Prolog correspondem √†s interpreta√ß√µes te√≥rica de prova ou te√≥rica de modelo; isso depende do tipo de regras no programa. Por√©m, para muitos programas Prolog simples, o mecanismo de infer√™ncia Prolog deduz os fatos que correspondem ou √† interpreta√ß√£o te√≥rica de prova ou a um modelo m√≠nimo sob a interpreta√ß√£o te√≥rica de modelo.

## 26.5.6 Programas Datalog e sua seguran√ßa

Existem dois m√©todos principais para definir os valores verdade de predicados em programas Datalog reais. Predicados definidos por fato (ou rela√ß√µes ) s√£o definidos ao listar todas as combina√ß√µes de valores (as tuplas) que tornam o predicado verdadeiro. Estas correspondem √†s rela√ß√µes de base cujo conjunto √© armazenado em um sistema de banco de dados. A Figura 26.14 mostra os predicados definidos por fato FUN -CIONARIO , MASCULINO , FEMININO , DEPARTAMEN -TO SUPERVISIONA , , PROJETO e TRABALHA\_EM , que correspondem √† parte do banco de dados relacional mostrado na Figura 3.6. Predicados definidos por regra (ou vis√µes ) s√£o definidos por serem a cabe√ßa (LHS) de uma ou mais regras Datalog; eles correspondem a rela√ß√µes virtuais cujo conte√∫do pode ser deduzido pelo mecanismo de infer√™ncia. A Figura 26.15 mostra uma s√©rie de predicados definidos por regra.

Um programa ou uma regra √© considerado seguro se gerar um conjunto finito de fatos. O problema te√≥rico geral de determinar se um conjunto de regras √© seguro √©  indecid√≠vel.  Contudo,  pode-se  determinar  a  seguran√ßa de formas restritas de regras. Por exemplo, as regras mostradas na Figura 26.16 s√£o seguras. Uma situa√ß√£o em que obtemos regras inseguras que podem gerar um n√∫mero infinito de fatos surge quando uma das vari√°veis na regra pode variar por um dom√≠nio infinito de valores, e essa vari√°vel n√£o √© limitada a variar por uma rela√ß√£o finita. Por exemplo, considere a regra a seguir:

ALTO\_SALARIO( Y ) :-Y &gt;60.000

Aqui, podemos obter um resultado infinito se Y variar por todos os inteiros poss√≠veis. Mas suponha que mudemos a regra da seguinte forma:

ALTO\_SALARIO( Y )  :-  FUNCIONARIO( X ),  Salario( X , Y ), Y &gt;60.000

Na segunda regra, o resultado n√£o √© infinito, pois os  valores  aos  quais Y pode  estar  vinculado  agora s√£o restringidos a valores que s√£o o sal√°rio de algum funcion√°rio no banco de dados - presumidamente, um conjunto de valores finito. Tamb√©m podemos reescrever a regra da seguinte forma:

ALTO\_SALARIO( Y )  :-Y &gt;60.000,  FUNCIONARIO( X ), Salario( X Y , )

Nesse caso, a regra ainda √© teoricamente segura. Por√©m, em Prolog ou em qualquer outro sistema que usa  um  mecanismo  de  infer√™ncia  top-down,  come√ßando na profundidade, a regra cria um loop infinito, visto que primeiro procuramos um valor para Y e, depois, verificamos se ele √© o sal√°rio de um funcion√°rio. O resultado √© a gera√ß√£o de um n√∫mero infinito de  valores Y ,  embora  estes,  ap√≥s  certo  ponto,  n√£o possam levar a um conjunto de predicados RHS verdadeiros. Uma defini√ß√£o da Datalog considera que as duas regras s√£o seguras, pois isso n√£o depende de um mecanismo de infer√™ncia em particular. Apesar disso, em geral √© aconselh√°vel escrever tal regra da forma mais segura, com os predicados que restringem poss√≠veis v√≠nculos das vari√°veis colocados em primeiro lugar. Como outro exemplo de uma regra insegura, considere a regra a seguir:

TEM\_ALGO( X Y , ) :- FUNCIONARIO( X )

Aqui,  um  n√∫mero  infinito  de  valores Y novamente pode ser gerado, pois a vari√°vel Y s√≥ aparece na cabe√ßa da regra e, portanto, n√£o √© limitada a um conjunto finito de valores. Para definir regras seguras mais  formalmente,  usamos  o  conceito  de  uma  vari√°vel limitada. Uma vari√°vel X √© limitada em uma regra  se  (1)  ela  aparecer  em  um  predicado  regular (n√£o embutido) no corpo da regra; (2) ela aparecer em um predicado na forma X c =  ou  = c X ou ( c 1&lt; &lt;= X e X&lt; c = 2 ) no corpo da regra, onde c , c 1 e c 2 s√£o valores constantes; ou (3) ela aparecer em um predicado na forma X Y = ou Y X = no corpo da regra, onde Y √© uma vari√°vel limitada. Uma regra √© considerada segura se todas as suas vari√°veis forem limitadas.

## 26.5.7 Uso de opera√ß√µes relacionais

√â f√°cil  especificar  muitas  opera√ß√µes  da  √°lgebra relacional na forma de regras Datalog que definem o resultado da aplica√ß√£o dessas opera√ß√µes em rela√ß√µes do banco de dados (predicados de fato). Isso significa que as consultas e vis√µes relacionais podem ser facilmente especificadas em Datalog. O poder adicio-

FUNCIONARIO(joao).

HOMEM(joao).

FUNCIONARIO(fernando).

HOMEM(fernando).

FUNCIONARIO(alice).

HOMEM(ronaldo).

FUNCIONARIO(jennifer).

HOMEM(andre).

FUNCIONARIO(ronaldo).

HOMEM(jorge).

FUNCIONARIO(joice).

FUNCIONARIO(andre).

MULHER(alice).

FUNCIONARIO(jorge).

MULHER(jennifer).

MULHER(joice).

SALARIO(joao, 30.000).

SALARIO(fernando, 40.000).

PROJETO(produtox).

SALARIO(alice, 25.000).

PROJETO(produtoy).

SALARIO(jennifer, 43.000).

PROJETO(produtoz).

SALARIO(ronaldo, 38.000).

PROJETO(informatizacao).

SALARIO(joice, 25.000).

PROJETO(reorganizacao).

SALARIO(andre, 25.000).

PROJETO(novosbeneficios).

SALARIO(jorge, 55.000).

TRABALHA\_EM(joao, produtox, 32). TRABALHA\_EM(joao, produtoy, 8). TRABALHA\_EM(ronaldo, produtoz, 40). TRABALHA\_EM(joice, produtox, 20). TRABALHA\_EM(joice, produtoy, 20). TRABALHA\_EM(fernando, produtoy, 10). TRABALHA\_EM(fernando, produtoz, 10). TRABALHA\_EM(fernando, informatizacao, 10). TRABALHA\_EM(fernando, reorganizacao, 10). TRABALHA\_EM(alice, novosbeneficios, 30). TRABALHA\_EM(alice, informatizacao, 10). TRABALHA\_EM(andre, informatizacao, 35). TRABALHA\_EM(andre, novosbeneficios, 5). TRABALHA\_EM(jennifer, novosbeneficios, 20). TRABALHA\_EM(jennifer, reorganizacao, 15). TRABALHA\_EM(jorge, reorganizacao, 10).

DEPARTAMENTO(joao, pesquisa).

DEPARTAMENTO(fernando, pesquisa).

DEPARTAMENTO(alice, administracao).

DEPARTAMENTO(jennifer, administracao).

DEPARTAMENTO(ronaldo, pesquisa).

DEPARTAMENTO(joice, pesquisa).

DEPARTAMENTO(andre, administracao).

DEPARTAMENTO(jorge, matriz).

SUPERVISIONA(fernando, joao). SUPERVISIONA(fernando, ronaldo). SUPERVISIONA(fernando, joice). SUPERVISIONA(jennifer, alice). SUPERVISIONA(jennifer, andre). SUPERVISIONA(jorge, fernando). SUPERVISIONA(jorge, jennifer).

SUPERIOR( X Y ,

) :- SUPERVISIONA( X Y , ).

SUPERIOR( X Y ,

) :- SUPERVISIONA( X Z , ), SUPERIOR( Z Y , ).

SUBORDINADO( , X Y

) :- SUPERIOR( Y X , ).

SUPERVISOR( X ) :- FUNCIONARIO( X ), SUPERVISIONA( X Y , ). FUNC\_ACIMA\_40K( ) :- FUNCIONARIO( X X ), SALARIO( X Y , ), Y &gt;= 40.000. SUPERVISOR\_ABAIXO\_40K( X ) :- SUPERVISOR( X ), NOT(OVER\_40\_K\_EMP( X )). FUNC\_PRINC\_PRODUTO( ) :- FUNCIONARIO(X), TRABALHA\_EM(X, produtox, X Y ), Y &gt;=20. PRESIDENTE( X ) :- FUNCIONARIO( X ), NOT(SUPERVISIONA( Y X , ) ).

Figura 26.15

Predicados definidos por regra.

REL\_ONE( A, B, C ).

REL\_TWO( D, E, F ).

REL\_THREE( G, H, I, J ).

SELECT\_ONE\_A\_EQ\_C( X, Y, Z ) :- REL\_ONE( C, Y, Z ). SELECT\_ONE\_B\_LESS\_5( X, Y, Z ) :- REL\_ONE( X, Y, Z ), Y &lt;5.

SELECT\_ONE\_A\_EQ\_C\_AND\_B\_LESS\_5( X, Y, Z ) :- REL\_ONE( C, Y, Z ), Y &lt;5.

SELECT\_ONE\_A\_EQ\_C\_OR\_B\_LESS\_5( X, Y, Z ) :- REL\_ONE( C, Y, Z ). SELECT\_ONE\_A\_EQ\_C\_OR\_B\_LESS\_5( X, Y, Z ) :- REL\_ONE( X, Y, Z ), Y &lt;5.

PROJECT\_THREE\_ON\_G\_H( W, X ) :- REL\_THREE( W, X, Y, Z ).

UNION\_ONE\_TWO( X, Y, Z ) :- REL\_ONE( X, Y, Z

UNION\_ONE\_TWO( X, Y, Z ) :- REL\_TWO( X, Y, Z

). ).

INTERSECT\_ONE\_TWO( X, Y, Z ) :- REL\_ONE( X, Y, Z ), :- REL\_TWO( X, Y, Z ).

DIFFERENCE\_TWO\_ONE( X, Y, Z ) :- REL\_TWO( X, Y, Z ) NOT(REL\_ONE( X, Y, Z ).

CART PROD\_ONE\_THREE( T, U, V, W, X, Y , Z ) :-REL\_ONE( T, U, V ), REL\_THREE( W, X, Y, Z ).

NATURAL\_JOIN\_ONE\_THREE\_C\_EQ\_G( U, V, W, X, Y, Z ) :-REL\_ONE( T, U, V ), REL\_THREE( W, X, Y, Z ).

Figura 26.16

Predicados para ilustrar opera√ß√µes relacionais.

Figura 26.17



Grafo de depend√™ncia de predicados para as figuras 26.15 e 26.16.

nal  que  o  Datalog  oferece  est√°  na  especifica√ß√£o  de consultas recursivas e vis√µes baseadas em consultas recursivas.  Nesta  se√ß√£o,  mostramos  como  algumas das opera√ß√µes relacionais padr√£o podem ser especificadas como regras Datalog. Nossos exemplos usar√£o as  rela√ß√µes  da  base  (predicados  definidos  por  fato) REL\_ONE, REL\_TWO e REL\_THREE, cujos esquemas s√£o exibidos na Figura 26.16. Em Datalog, n√£o precisamos  especificar  os  nomes  de  atributo  como  na Figura 26.16. Em vez disso, a aridez (grau) de cada predicado  √©  o  aspecto  importante.  Em  um  sistema pr√°tico, o dom√≠nio (tipo de dado) de cada atributo tamb√©m √© relevante para opera√ß√µes como UNI√ÉO IN , -TERSEC√á√ÉO e JUN√á√ÉO , e consideramos que os tipos de atributo s√£o compat√≠veis para as diversas opera√ß√µes, conforme discutimos no Cap√≠tulo 3.

A Figura 26.16 ilustra uma s√©rie de opera√ß√µes relacionais  b√°sicas.  Observe  que,  se  o  modelo  Datalog for baseado no modelo relacional e, portanto, pressupor que os predicados (rela√ß√µes de fato e resultados  de  consulta)  especificam  conjuntos  de  tuplas, as tuplas duplicadas no mesmo predicado s√£o automaticamente eliminadas.  Isso  pode  ou  n√£o  ser verdade, dependendo do mecanismo de infer√™ncia do Datalog. Contudo, esse definitivamente n√£o √© o caso em Prolog  ,  de  modo  que  qualquer  uma  das  regras da Figura 26.16 que envolva elimina√ß√£o de duplicatas n√£o est√° correta para a Prolog. Por exemplo, se quisermos especificar regras Prolog para a opera√ß√£o UNI√ÉO com elimina√ß√£o de duplicatas, temos de reescrev√™-las da seguinte forma:

UNION\_ONE\_TWO( , X Y Z , ) :- REL\_ONE( X Y Z , , ). UNION\_ONE\_TWO( , X Y Z , ) :- REL\_TWO( X Y Z , , ), NOT(REL\_ONE( X Y Z , , )).

Entretanto, as regras mostradas na Figura 26.16 devem funcionar para Datalog, se as duplicatas forem  automaticamente  eliminadas.  De  modo  semelhante, as regras para a opera√ß√£o PROJE√á√ÉO exibida na Figura 26.16 devem funcionar para Datalog nesse caso, mas n√£o est√£o corretas para Prolog, pois as duplicatas apareceriam nesse √∫ltimo caso.

## 26.5.8 Avalia√ß√£o de consultas Datalog n√£o recursivas

Para usar a Datalog como um sistema de banco de dados dedutivo, √© apropriado definir um mecanismo de infer√™ncia baseado nos conceitos de processamento de consulta a banco de dados relacional. A estrat√©gia inerente envolve uma avalia√ß√£o bottom-up, come√ßando  com  as  rela√ß√µes  da  base;  a  ordem  das opera√ß√µes √© mantida flex√≠vel e sujeita √† otimiza√ß√£o da consulta. Nesta se√ß√£o, discutimos um mecanismo de infer√™ncia baseado nas opera√ß√µes relacionais que podem ser aplicadas a consultas Datalog n√£o recursivas . Usamos as bases de fato e de regra das figuras 26.14 e 26.15 para ilustrar nossa discuss√£o.

Se uma consulta envolver apenas predicados definidos por fato, a infer√™ncia se torna a de procurar o resultado da consulta nos fatos. Por exemplo, uma consulta como

## DEPARTAMENTO( X , Pesquisa)?

√© uma sele√ß√£o de todos os nomes de funcion√°rio X que trabalham para o departamento Pesquisa . Na √°lgebra relacional, ela √© a consulta:

<!-- formula-not-decoded -->

que  pode  ser  respondida  ao  pesquisar  o  predicado definido  por  fato departamento ( X,Y ). A  consulta envolve  as  opera√ß√µes  relacionais SELE√á√ÉO e PRO -JE√á√ÉO em uma rela√ß√£o da base, e pode ser tratada pelas t√©cnicas de processamento e otimiza√ß√£o da consulta de banco de dados discutidas no Cap√≠tulo 19.

Quando uma consulta envolve predicados definidos por regra, o mecanismo de infer√™ncia precisa calcular o resultado com base nas defini√ß√µes de regra. Se uma consulta for n√£o recursiva e envolver um predicado p que aparece como cabe√ßa de uma regra p :-p 1 , p 2 , ... , p n , a estrat√©gia √© primeiro calcular as rela√ß√µes correspondentes a p 1 , p 2 , ... , p n e, depois, calcular a rela√ß√£o correspondente a p .  √â  √∫til  acompanhar a depend√™ncia entre os predicados de um banco de dados dedutivo em um grafo de depend√™ncia de predicados . A Figura 26.17 mostra o grafo para os predicados  de  fato  e  regra  mostrados  nas  figuras 26.14 e 26.15. O grafo de depend√™ncia cont√©m um n√≥ para cada predicado. Sempre que um predicado A √© especificado no corpo (RHS) de uma regra, e a cabe√ßa (LHS) dessa regra √© o predicado B , dizemos que B depende de A , e desenhamos uma aresta direcionada de A para B . Isso indica que, para calcular os fatos para o predicado B (a cabe√ßa da regra), temos de primeiro calcular os fatos para todos os predicados A no corpo da regra. Se o grafo de depend√™ncia n√£o tiver ciclos, chamamos  o  conjunto  de  regras  de n√£o  recursivo . Se houver pelo menos um ciclo, chamamos o conjunto de regras de recursivo . Na Figura 26.17, existe um predicado definido recursivamente - a saber, SUPE -RIOR - que tem uma aresta recursiva apontando de volta para si mesma. Al√©m disso, como o predicado subordinado depende de SUPERIOR, ele tamb√©m requer recurs√£o no c√°lculo de seu resultado.

Uma consulta que inclui apenas predicados n√£o recursivos √© chamada de consulta n√£o recursiva . Nesta se√ß√£o, discutimos apenas mecanismos de infer√™ncia para consultas n√£o recursivas. Na Figura 26.17, qualquer  consulta  que  n√£o  envolva  os  predicados SUBORDINADO ou SUPERIOR √©  n√£o  recursiva.  No grafo  de  depend√™ncia  de  predicado,  os  n√≥s  correspondentes a predicados definidos por fato n√£o t√™m quaisquer arestas chegando, pois todos os predicados definidos por fato t√™m seus fatos armazenados em uma rela√ß√£o do banco de dados. O conte√∫do de um predicado definido por fato pode ser calculado ao recuperar diretamente as tuplas na rela√ß√£o correspondente do banco de dados.

A fun√ß√£o principal de um mecanismo de infer√™ncia √© calcular os fatos que correspondem aos predicados de consulta. Isso pode ser realizado ao gerar uma express√£o relacional que envolva operadores relacionais como SELE√á√ÉO, PROJE√á√ÉO, JUN√á√ÉO, UNI√ÉO e DIFEREN√áA DE CONJUNTOS (com a devida provis√£o para lidar com quest√µes de seguran√ßa) que, quando executada, forne√ßa o resultado da consulta. A consulta pode ent√£o ser executada utilizando o processamento de consulta interno e opera√ß√µes de otimiza√ß√£o de um sistema de gerenciamento de banco de dados relacional.  Sempre  que  o  mecanismo  de  infer√™ncia precisa calcular o conjunto de fatos correspondente a um predicado definido por regra n√£o recursivo p , ele primeiro localiza todas as regras que t√™m p como sua  cabe√ßa.  A  ideia  √©  calcular  o  conjunto  de  fatos para cada regra desse tipo e, depois, aplicar a opera√ß√£o UNI√ÉO aos resultados, pois UNI√ÉO corresponde a uma opera√ß√£o OR l√≥gica. O grafo de depend√™ncia indica todos os predicados q dos quais cada p depende, e como assumimos que o predicado √© n√£o recursivo, sempre podemos determinar uma ordem parcial entre tais predicados q . Antes de calcular o conjunto de fatos para p , primeiro calculamos os conjuntos de fatos para todos os predicados q dos quais p depende, com base em sua ordem parcial. Por exemplo, se uma consulta envolve o predicado FUNC\_ACIMA\_40K, primeiro temos de calcular tanto SUPERVISOR quanto FUNC\_ACIMA\_40K. Como os dois √∫ltimos dependem apenas  dos  predicados  definidos  por  fato FUNCIO -NARIO, SALARIO e SUPERVISIONA, eles  podem  ser calculados diretamente das rela√ß√µes armazenadas no banco de dados.

Isso conclui nossa introdu√ß√£o aos bancos de dados dedutivos. Isso inclui uma discuss√£o sobre algoritmos para processamento de consulta recursiva. Inclu√≠mos uma extensa bibliografia do trabalho realizado sobre bancos de dados dedutivos, processamento de consulta recursiva, conjuntos m√°gicos, combina√ß√£o de bancos de dados relacionais com regras dedutivas e o GLUE-NAIL! System ao final deste cap√≠tulo.

## Resumo

Neste cap√≠tulo, apresentamos os conceitos de banco de dados para alguns dos recursos comuns que s√£o exigidos por aplica√ß√µes avan√ßadas: bancos de dados ativos, bancos de dados temporais, bancos de dados espaciais, bancos de dados de multim√≠dia e bancos de dados dedutivos. √â importante observar que cada um destes √© um assunto amplo e justifica um livro-texto completo.

Primeiro,  apresentamos  o  t√≥pico  de  bancos  de dados  ativos,  que  oferece  funcionalidade  adicional para especificar regras ativas. Apresentamos o modelo Event-Condition-Action  (ECA)  para  bancos  de  dados ativos. As regras podem ser disparadas automaticamente por eventos que ocorrem - como uma atualiza√ß√£o de banco de dados - e iniciar certas a√ß√µes que foram especificadas na declara√ß√£o de regra se certas condi√ß√µes forem verdadeiras. Muitos pacotes comerciais possuem parte da funcionalidade oferecida por bancos de dados ativos  na  forma  de  triggers.  Discutimos  as  diferentes op√ß√µes para especificar regras, como regras em n√≠vel de linha versus em n√≠vel de comando, before versus after e imediata versus adiada. Demos exemplos de triggers em n√≠vel de linha no sistema comercial Oracle e de regras em n√≠vel de comando no sistema experimental STARBURST. A sintaxe para triggers no padr√£o SQL-99 tamb√©m  foi  discutida.  Abordamos  rapidamente  algumas quest√µes de projeto e algumas aplica√ß√µes poss√≠veis para bancos de dados ativos.

Em seguida, apresentamos alguns dos conceitos de bancos de dados temporais, que permitem que o sistema  de  banco  de  dados  armazene  um  hist√≥rico das  mudan√ßas  e  permite  que  os  usu√°rios  consultem os estados atual e passado do banco de dados. Discutimos como o tempo √© representado e distinguido entre as dimens√µes de tempo v√°lido e tempo de transa√ß√£o. Abordamos como o tempo v√°lido, o tempo de transa√ß√£o e as rela√ß√µes bitemporais podem ser implementados usando versionamento de tupla no modelo relacional, com exemplos para ilustrar como as atualiza√ß√µes,  inser√ß√µes  e  exclus√µes  s√£o  implementadas. Tamb√©m mostramos como objetos complexos podem ser  usados  para  implementar  bancos  de  dados  temporais com versionamento de atributos. Examinamos algumas  das  opera√ß√µes  de  consulta  para  bancos  de dados relacionais temporais e demos uma r√°pida introdu√ß√£o √† linguagem TSQL2.

Depois, passamos para os bancos de dados espaciais. Estes oferecem conceitos para bancos de dados que registram objetos que possuem caracter√≠sticas espaciais. Discutimos os tipos de dados espaciais, tipos de operadores para processamento de dados espaciais, tipos de consultas espaciais  e  t√©cnicas  de  indexa√ß√£o  espacial,  incluindo  as populares R-trees. Na sequ√™ncia, falamos sobre algumas t√©cnicas de minera√ß√£o de dados espaciais e aplica√ß√µes dos dados espaciais.

Tratamos de alguns tipos b√°sicos de banco de dados multim√≠dia  e  suas  caracter√≠sticas  mais  importantes.  Os bancos de dados de multim√≠dia oferecem recursos que permitem aos usu√°rios armazenar e consultar diferentes tipos de informa√ß√µes de multim√≠dia, incluindo imagens (como figuras e desenhos), clipes de v√≠deo (como filmes, notici√°rios e v√≠deos caseiros), clipes de √°udio (como m√∫sicas,  mensagens telef√¥nicas e discursos) e documentos

(como livros e artigos). Oferecemos uma r√°pida vis√£o geral dos diversos tipos de fontes de m√≠dia e como as fontes de multim√≠dia podem ser indexadas. As imagens s√£o um tipo de dado extremamente comum entre os bancos de dados de hoje, e provavelmente ocupar√£o uma grande propor√ß√£o dos dados armazenados nos bancos de dados. Portanto,  oferecemos  um  tratamento  mais  detalhado das imagens: sua an√°lise autom√°tica, reconhecimento de objetos em imagens e sua marca√ß√£o sem√¢ntica - todos contribuindo para o desenvolvimento de sistemas melhores  para recuperar imagens por conte√∫do, o que ainda continua  sendo  um  problema  desafiador.  Tamb√©m  comentamos sobre a an√°lise de fontes de dados de √°udio.

Conclu√≠mos  o  cap√≠tulo  com  uma  introdu√ß√£o  aos bancos de dados dedutivos. Demos uma vis√£o geral da nota√ß√£o Prolog e Datalog. Discutimos a forma clausular das f√≥rmulas. Regras Datalog s√£o restritas a cl√°usulas de Horn, que cont√™m no m√°ximo um literal positivo. Abordamos  a  interpreta√ß√£o  te√≥rica  de  prova  e  te√≥rica  de modelo  das  regras.  Discutimos  rapidamente  as  regras da Datalog e sua seguran√ßa, e as maneiras de expressar opera√ß√µes relacionais usando regras Datalog. Finalmente, tratamos de um mecanismo de infer√™ncia baseado em opera√ß√µes relacionais, que pode ser usado para avaliar consultas Datalog n√£o recursivas com t√©cnicas de otimiza√ß√£o de consulta relacional. Embora a Datalog seja uma linguagem popular com muitas aplica√ß√µes, infelizmente, implementa√ß√µes de sistemas de banco de dados dedutivos, como LDL ou VALIDITY, n√£o se tornaram muito dispon√≠veis comercialmente.

## Perguntas de revis√£o

- 26.1. Quais s√£o as diferen√ßas entre as regras ativas em n√≠vel de linha e em n√≠vel de comando?
- 26.2. Quais  s√£o  as  diferen√ßas  entre  a considera√ß√£o imediata, adiada e separada das condi√ß√µes da regra ativa?
- 26.3. Quais s√£o as diferen√ßas entre a execu√ß√£o imediata, adiada e separada das a√ß√µes da regra ativa?
- 26.4. Discuta rapidamente os problemas de consist√™ncia e t√©rmino ao projetar um conjunto de regras ativas.
- 26.5. Discuta algumas aplica√ß√µes dos bancos de dados ativos.
- 26.6. Discuta como o tempo √© representado nos bancos de dados temporais e compare as diferentes dimens√µes de tempo.
- 26.7. Quais s√£o as diferen√ßas entre rela√ß√µes de tempo v√°lido, de tempo de transa√ß√£o e bitemporais?
- 26.8. Descreva como os comandos de inser√ß√£o, exclus√£o e atualiza√ß√£o devem ser implementados em uma rela√ß√£o de tempo v√°lido.
- 26.9. Descreva como os comandos de inser√ß√£o, exclus√£o e atualiza√ß√£o devem ser implementados em uma rela√ß√£o bitemporal.

- 26.10. Descreva como os comandos de inser√ß√£o, exclu- s√£o e atualiza√ß√£o devem ser implementados em uma rela√ß√£o de tempo de transa√ß√£o.

- 26.11. Quais s√£o as principais diferen√ßas entre versio- namento de tupla e versionamento de atributo?

- 26.12. Como os bancos de dados espaciais diferem dos bancos de dados regulares?

- 26.13. Quais s√£o os diferentes tipos de dados espaciais?

- 26.14. Cite os principais tipos de operadores espaciais e diferentes classes de consultas espaciais.

- 26.15. Quais s√£o as propriedades das R-trees que atuam como um √≠ndice para dados espaciais?

- 26.16. Descreva como um √≠ndice de jun√ß√£o espacial en- tre objetos espaciais pode ser constru√≠do.

- 26.17. Quais  s√£o  os  diferentes  tipos  de  minera√ß√£o  de dados espacial?

- 26.18. cia√ß√£o espacial.

Indique a forma geral de uma regra de associa- √ß√£o espacial. D√™ um exemplo de regra de asso-

- 26.19. Quais s√£o os diferentes tipos de fontes de multi- m√≠dia?

- 26.20. Como  as  fontes  de  multim√≠dia  s√£o  indexadas para recupera√ß√£o baseada em conte√∫do?

- 26.21. Que recursos importantes das imagens s√£o usa- dos para compar√°-las?

- 26.22. Quais s√£o as diferentes t√©cnicas para o reconhe- cimento de objetos em imagens?

26.23.

Como √© usada a marca√ß√£o sem√¢ntica das imagens?

- 26.24. √°udio?

Quais s√£o as dificuldades na an√°lise de fontes de

- 26.25. O que s√£o bancos de dados dedutivos?

26.26. Escreva exemplos de regras em Prolog para defi- nir que os cursos com n√∫mero acima de CC5000 s√£o  cursos  de  gradua√ß√£o  e  que  DBgrads  s√£o aqueles alunos formados que se matriculam nos cursos CC6400 e CC8803.

- 26.27. Defina a forma clausular das f√≥rmulas e as cl√°u- sulas de Horn.

- 26.28. √ß√£o te√≥rica de prova das regras?

O que √© prova do teorema e o que √© interpreta-

## VENDAS

Id\_S

Id\_V

Comissao

## VENDEDOR

- 26.29. O que √© interpreta√ß√£o te√≥rica de modelo e como ela difere da interpreta√ß√£o te√≥rica de prova?

- 26.30. O que s√£o predicados definidos por fato e predi- cados definidos por regra?

- 26.31.

O que √© uma regra segura?

26.32. D√™ exemplos de regras que podem definir opera- √ß√µes relacionais SELE√á√ÉO PROJE√á√ÉO JUN√á√ÉO , , e CONJUNTO .

- 26.33. Discuta o mecanismo de infer√™ncia baseado em opera√ß√µes relacionais que pode ser aplicado para

avaliar consultas Datalog n√£o recursivas.

## Exerc√≠cios

- 26.34. Considere o banco de dados EMPRESA descrito na Figura 3.6. Usando a sintaxe das triggers em Oracle, escreva regras ativas para fazer o seguinte:
- a. Sempre que as tarefas de projeto de um funcion√°rio mudarem, verifique se o total de horas gastas por semana nos projetos do funcion√°rio s√£o menores que 30 ou maiores que 40; nesse caso, notifique o supervisor direto do funcion√°rio.
- b. Sempre  que  um  funcion√°rio  for  exclu√≠do, exclua as tuplas de PROJETO e as tuplas de DEPENDENTE relacionadas a esse funcion√°rio, e se o funcion√°rio gerenciar um departamento ou supervisionar funcion√°rios, defina o Cpf\_gerente para esse departamento como NULL e  defina  o Cpf\_supervisor para  esses funcion√°rios como NULL.
- 26.35. Repita o Exerc√≠cio 26.34, mas use a sintaxe das regras ativas do STARBURST.

26.36. Considere o esquema relacional mostrado na Figura 26.18. Escreva regras ativas para manter o atributo Comissoes\_soma de PESSOAL\_VEN -DAS igual √† soma do atributo Commissao em VENDAS para cada vendedor. Suas regras tamb√©m dever√£o verificar se a Comissoes\_soma ultrapassa 100.000; nesse caso, chame um procedimento Notifica\_gerente (S\_id) .  Escreva regras em n√≠vel de comando na nota√ß√£o STARBURST e regras em n√≠vel de linha no Oracle.

- 26.37. Considere  o  esquema  EER UNIVERSIDADE da Figura 8.10. Escreva algumas regras (em portugu√™s) que poderiam ser implementadas por meio de regras ativas para impor algumas restri√ß√µes de integridade comuns, que voc√™ acredita serem relevantes a essa aplica√ß√£o.
- 26.38. Discuta quais das atualiza√ß√µes que criaram cada uma das tuplas mostradas na Figura 26.9 foram aplicadas retroativamente e quais foram aplicadas proativamente.
- 26.39. Mostre como as seguintes atualiza√ß√µes, se aplicadas  em  sequ√™ncia,  mudariam  o  conte√∫do  da rela√ß√£o  bitemporal FUNC\_BT na  Figura  26.9. Para cada atualiza√ß√£o, indique se ela √© uma atualiza√ß√£o retroativa ou proativa.
- a. Em 10-03-2004,17:30:00, o sal√°rio de Lima √©  atualizado  para  40.000,  efetivado  em  0103-2004.
- b. Em  30-07-2003,08:31:00,  o  sal√°rio  de  Silva  foi  corrigido  para  mostrar  que  deveria ter sido informado como 31.000 (em vez de 30.000, conforme aparece), efetivado em 0106-2003.
- c. Em 18-03-2004,08:31:00, o banco de dados foi  alterado  para  indicar  que  Lima  estava saindo da empresa (ou seja, exclu√≠do logicamente), com efetiva√ß√£o em 31-03-2004.
- d. Em 20-04-2004,14:07:33, o banco de dados foi  alterado  para  indicar  a  contrata√ß√£o  de um novo funcion√°rio chamado Jonas, com a tupla &lt;'Jonas', '33445566711', 1, NULL &gt;, efetivada em 20-04-2004.
- e. Em 28-04-2004,12:54:02, o banco de dados foi alterado para indicar que Wong estava saindo da empresa (ou seja, foi logicamente exclu√≠do), com data de efetiva√ß√£o 01-06-2004.
- f. Em 05-05-2004,13:07:33, o banco de dados foi alterado para indicar a recontrata√ß√£o de Braga, com o mesmo departamento e supervisor, mas com sal√°rio de 35.000, efetivado em 01-05-2004.
- 26.40. Mostre como as atualiza√ß√µes dadas no Exerc√≠cio 26.39, se aplicadas em sequ√™ncia, mudariam o conte√∫do da rela√ß√£o de tempo v√°lido FUNC\_TV da Figura 26.8.
- 26.41. Acrescente os seguintes fatos ao banco de dados de exemplo da Figura 26.11:

SUPERVISIONA(andre, roberto), SUPERVISIONA(fernando, gisele).

Primeiro,  modifique  a  √°rvore  de  supervis√£o  na Figura 26.11(b) para refletir essa mudan√ßa. Depois, construa um diagrama mostrando a avalia√ß√£o top-down  da  consulta SUPERIOR( jorge, Y )  usando  as regras 1 e 2 da Figura 26.12.

- 26.42. Considere  o  seguinte  conjunto  de  fatos  para  a rela√ß√£o PAI ( X Y , ), onde Y √© o pai de X :

PAI(a,  aa),  PAI(a,  ab),  PAI(aa, aaa), PAI(aa, aab), PAI(aaa, aaaa), PAI(aaa, aaab).

Considere as regras r 1 : ANCESTRAL( X Y , ) :- PAI( X Y , ) r 2 :  ANCESTRAL( X Y , )  :-  P AI( X Z , ),  ANCESTRAL( Z Y , )

que definem o ancestral Y de X , como acima.

- a. Mostre como solucionar a consulta Datalog ANCESTRAL (aa, X ).
- e mostre seu trabalho a cada etapa.
- b. Mostre a mesma consulta calculando apenas as  mudan√ßas  na  rela√ß√£o  ancestral  e  usando isso na regra 2 a cada vez.

[ Esta quest√£o √© derivada de Bancilhon e Ramakrishnan (1986). ]

- 26.43. Considere um banco de dados dedutivo com as

seguintes regras:

ANCESTRAL( X Y , ) :- PAI( X Y , )

ANCESTRAL( X Y , ) :- PAI( X Z , ),

ANCESTRAL( Z Y , )

Observe que PAI ( X , Y ) significa que Y √© o pai de X ; ANCESTRAL ( XY , )  significa  que Y √© o ancestral de X .

Considere a seguinte base de fatos:

PAI(Hamilton, Isaac), PAI(Isaac, Joao), PAI(Joao, Carlos).

- a. Construa uma interpreta√ß√£o te√≥rica de modelo das regras acima usando os fatos dados.
- b. Considere  que  um  banco  de  dados  cont√©m  as  rela√ß√µes  acima PAI ( X Y , ),  outra  rela√ß√£o IRMAO ( X Y , )  e  uma  terceira  rela√ß√£o DATANASC ( X B , ), onde B √© a data de nascimento da pessoa X .  Indique uma regra que calcule os primeiros primos da seguinte variedade: seus pais devem ser irm√£os.
- c. Mostre um programa Datalog completo, com literais baseadas em fato e baseadas em regra, que calcule a seguinte rela√ß√£o: lista de pares de primos, onde a primeira pessoa nasceu depois  de  1960  e  a  segunda,  depois  de  1970. Voc√™ pode usar greater-than como predicado embutido.  ( Nota: fatos  de  amostra  para  irm√£o, nascimento e pessoa tamb√©m precisam ser mostrados.)

26.44. Considere as seguintes regras:

```
ALCANCAVEL( X Y , ) :- VOO( X Y , ) ALCANCAVEL( X Y , ) :- VOO( X Z , ), ALCANCAVEL( Z Y , )
```

onde ALCANCAVEL ( X Y , ) significa que a cidade Y pode ser alcan√ßada da cidade X e VOO ( X Y , ) significa que existe um voo para a cidade Y da cidade X .

- a. Construa predicados de fato que descrevam o seguinte:
- i. Los Angeles, Nova York, Chicago, Atlanta,  Frankfurt,  Paris,  Cingapura,  Sydney s√£o cidades.
- ii. Os seguintes voos existem: LA para NY, NY para Atlanta, Atlanta para Frankfurt, Frankfurt  para  Atlanta,  Frankfurt  para Cingapura  e  Cingapura  para  Sydney. ( Nota :  nenhum  voo  na  dire√ß√£o  oposta pode ser assumido automaticamente.)
- b. Os  dados  apresentados  s√£o  c√≠clicos?  Se  forem, em que sentido?
- c. Construa uma interpreta√ß√£o te√≥rica de modelo (ou seja, uma interpreta√ß√£o semelhante √†quela mostrada na Figura 26.13) dos fatos e regras acima.
- d. Considere a consulta

ALCANCAVEL(Atlanta, Sydney)?

Como essa consulta ser√° executada? Liste a s√©rie de etapas por que ela passar√°.

- e. Considere os seguintes predicados definidos por regra:

DA\_VOLTA\_ALCANCAVEL( X Y , ) :-ALCANCAVEL( , X Y ), ALCANCAVEL( Y X , ) DURACAO( , X Y Z , )

Desenhe um grafo de depend√™ncia de predicado  para  os  predicados  acima.  ( Nota: DURACAO ( X Y Z , , ) significa que voc√™ pode fazer um voo de X para Y em Z horas.)

- f. Considere  a  consulta  a  seguir:  que  cidades podem ser alcan√ßadas em 12 horas saindo de Atlanta? Mostre como expressar isso em Datalog. Considere que haja predicados embutidos como greater( X Y , ). Isso pode ser convertido para um comando da √°lgebra relacional de uma forma direta? Por qu√™?
- g. Considere o predicado popula√ß√£o( X Y , ), onde Y √© a popula√ß√£o da cidade X . Considere a seguinte  consulta:  liste  todos  os  v√≠nculos  poss√≠veis do par de predicados ( X Y , ), onde Y √© uma cidade que pode ser alcan√ßada em dois

voos saindo da cidade X , que tem mais de 1 milh√£o de pessoas. Mostre essa consulta em Datalog. Desenhe uma √°rvore de consulta correspondente em termos alg√©bricos relacionais.

## Bibliografia selecionada

O livro de Zaniolo et al. (1997) consiste em v√°rias partes, cada uma descrevendo um conceito avan√ßado de banco de dados, como bancos de dados ativos, temporais e espaciais/texto/multim√≠dia. Widom e Ceri (1996) e Ceri e Fraternali (1997) focalizam os conceitos e sistemas de bancos de dados ativos. Snodgrass (1995) descreve a linguagem e o modelo de dados TSQL2. Khoshafian e Baker (1996), Faloutsos  (1996)  e Subrahmanian (1998) descrevem conceitos de banco de dados multim√≠dia. Tansel et al. (1993) √© uma cole√ß√£o de cap√≠tulos sobre bancos de dados temporais.

As regras do STARBURST s√£o descritas em Widom e Finkelstein (1990). Cada trabalho sobre bancos de dados ativos inclui o projeto HiPAC, discutido em Chakravarthy et al. (1989) e Chakravarthy (1990). Um gloss√°rio para bancos de dados temporais √© dado em Jensen et al. (1994). Snodgrass (1987) focaliza a TQuel, uma antiga linguagem de consulta temporal.

A  normaliza√ß√£o  temporal  √©  definida  em  Navathe e  Ahmed (1989).  Paton  (1999)  e  Paton  e  Diaz  (1999) analisam os bancos de dados ativos. Chakravarthy et al. (1994) descrevem o SENTINEL e sistemas ativos baseados em objeto. Lee et al. (1998) discutem o gerenciamento de s√©rie temporal.

O livro de Shekhar e Chawla (2003) consiste em todos os aspectos dos bancos de dados espaciais, incluindo modelos de dados espaciais, armazenamento e indexa√ß√£o espacial e minera√ß√£o de dados espacial. Scholl et al. (2001) √© outro livro-texto sobre gerenciamento de dados espaciais. Albrecht (1996) descreve com detalhes as diversas opera√ß√µes de an√°lise GIS. Clementini e Di Felice (1993) d√£o uma descri√ß√£o detalhada dos operadores espaciais. G√ºting (1994) descreve as estruturas de dados espaciais e as linguagens de consulta para sistemas de banco de dados espaciais. Guttman (1984) prop√¥s R-trees para a indexa√ß√£o de dados espaciais. Manolopoulos et al.  (2005) √© um livro sobre a teoria e aplica√ß√µes de R-trees. Papadias et al. (2003) discutem o processamento de consulta usando R-trees para redes espaciais. Ester et al. (2001) oferecem uma discuss√£o abrangente sobre os algoritmos e aplica√ß√µes da minera√ß√£o de dados espacial. Koperski e Han (1995) discutem a descoberta da regra de associa√ß√£o com base em bancos de dados geogr√°ficos. Brinkhoff et al. (1993) oferecem uma vis√£o geral abrangente  do  uso  de  R-trees  para  o  processamento  eficaz de jun√ß√µes espaciais. Rotem (1991) descreve √≠ndices de jun√ß√£o espacial de modo abrangente. Shekhar e Xiong (2008) √© uma compila√ß√£o de diversas fontes, que discute diferentes aspectos dos sistemas de gerenciamento de banco de dados espacial e GIS. Os algoritmos de agrupamento baseados em densidade DBSCAN e DENCLUE

s√£o propostos por Ester et al. (1996) e Hinnenberg e Gabriel (2007), respectivamente.

A modelagem de banco de dados de multim√≠dia tem uma vasta quantidade de literatura  -  √©  dif√≠cil  indicar todas as refer√™ncias importantes aqui. O sistema QBIC (Query By Image Content) da IBM, descrito em Niblack et al. (1998), foi uma das primeiras t√©cnicas abrangentes para consultar imagens com base no conte√∫do. Agora, ele est√° dispon√≠vel como parte do extensor de imagem de banco de dados DB2 da IBM. Zhao e Grosky (2002) discutem a recupera√ß√£o de imagens baseada em conte√∫do.  Carneiro  e  Vasconselos  (2005)  apresentam uma vis√£o centrada em banco de dados da anota√ß√£o e recupera√ß√£o  sem√¢nticas  de  imagens.  A  recupera√ß√£o  de subimagens baseada em conte√∫do √© discutida por Luo e Nascimento (2004). Tuceryan e Jain (1998) abordam diversos aspectos da an√°lise de textura. O reconhecimento de objetos usando SIFT √© discutido em Lowe (2004). Lazebnik et al. (2004) descrevem o uso de regi√µes afins locais para modelar objetos 3D (RIFT). Em outras t√©cnicas de reconhecimento de objetos, G-RIF √© descrito em Kim et al. (2006), Bay et al. (2006) discutem SURF, Ke e Sukthankar (2004) apresentam PCA-SIFT, e Mikolajczyk e  Schmid  (2005)  descrevem  GLOH.  Fan  et  al.  (2004) apresentam uma t√©cnica para a anota√ß√£o autom√°tica de imagem usando objetos  sens√≠veis  ao  conceito.  Fotouhi et al. (2007) foi o primeiro workshop internacional sobre as muitas faces da sem√¢ntica de multim√≠dia, que est√° continuando anualmente. Thuraisingham (2001) classifica os dados de √°udio em diferentes categorias e, ao tratar cada uma delas de maneira diferente, desenvolve o uso de metadados para √°udio. Prabhakaran (1996) tamb√©m discutiu como as t√©cnicas de processamento de voz podem acrescentar informa√ß√µes de metadados valiosas ao trecho de √°udio.

Os  primeiros  desenvolvimentos  da  t√©cnica  de  l√≥gica  e  banco  de  dados  s√£o  analisados  por  Gallaire  et al. (1984). Reiter (1984) oferece uma reconstru√ß√£o da teoria de banco de dados relacional, enquanto Levesque (1984) fornece uma discuss√£o do conhecimento incompleto  do  ponto  de  vista  da  l√≥gica.  Gallaire  e  Minker (1978) oferecem um livro antigo sobre esse assunto. Um tratamento detalhado da l√≥gica e bancos de dados aparece em Ullman (1989, volume 2) e existe um cap√≠tulo relacionado no volume 1 (1988). Ceri, Gottlob e Tanca (1990) apresentam um tratamento abrangente, por√©m conciso,  sobre  l√≥gica  e  bancos  de  dados.  Das  (1992) √©  um livro abrangente sobre bancos de dados dedutivos e programa√ß√£o l√≥gica. A hist√≥ria antiga da Datalog √© abordada em Maier e Warren (1988). Clocksin e Mellish (2003) √© uma excelente refer√™ncia sobre a linguagem Prolog.

Aho e Ullman (1979) oferecem um algoritmo antigo para lidar com consultas recursivas, usando o menor operador de ponto fixo. Bancilhon e Ramakrishnan (1986) d√£o  uma  descri√ß√£o  excelente  e  detalhada  das  t√©cnicas para o processamento de consulta recursiva, com exemplos detalhados das t√©cnicas naive e seminaive. Artigos de  estudo  excelentes  sobre  bancos  de  dados  dedutivos e processamento de consulta recursiva incluem Warren (1992) e Ramakrishnan e Ullman (1995). Uma descri√ß√£o completa da t√©cnica seminaive baseada na √°lgebra relacional √© dada em Bancilhon (1985). Outras t√©cnicas para  o  processamento  de  consulta  recursiva  incluem  a estrat√©gia  de  consulta/subconsulta  recursiva  de  Vieille (1986), que √© uma estrat√©gia interpretada top-down, e a estrat√©gia iterativa compilada top-down de Henschen-Naqvi (1984). Balbin e Ramamohanrao (1987) discutem uma extens√£o da t√©cnica diferencial seminaive para predicados m√∫ltiplos.

O  artigo  original  sobre  conjuntos  m√°gicos  √©  de Bancilhon et al. (1986). Beeri e Ramakrishnan (1987) o estendem. Mumick et al. (1990a) mostram a aplicabilidade dos conjuntos m√°gicos √†s consultas SQL aninhadas n√£o recursivas. Outras t√©cnicas para otimizar regras sem reescrev√™-las  aparecem  em  Vieille  (1986,  1987).  Kifer e Lozinskii (1986) prop√µem uma t√©cnica diferente. Bry (1990) discute como as t√©cnicas top-down e bottom-up podem ser reconciliadas. Whang e Navathe (1992) descrevem uma t√©cnica de forma normal disjuntiva estendida para lidar com a recurs√£o nas express√µes da √°lgebra relacional, para oferecer uma interface de sistema especialista em um SGBD relacional.

Chang (1981) descreve um antigo sistema para combinar regras dedutivas com bancos de dados relacionais. O prot√≥tipo de sistema LDL √© descrito em Chimenti et al. (1990). Krishnamurthy e Naqvi (1989) apresentam a no√ß√£o de escolha em LDL. Zaniolo (1988) discute as quest√µes de linguagem para o sistema LDL. Uma vis√£o geral da linguagem do CORAL √© fornecida em Ramakrishnan et al. (1992) e a implementa√ß√£o √© descrita em Ramakrishnan et al. (1993). Uma extens√£o para dar suporte a recursos orientados a objeto, chamada CORAL++, √© descrita em Srivastava et al. (1993). Ullman (1985) oferece a base para o sistema NAIL!, que √© descrito em Morris et al. (1987). Phipps et al. (1991) descrevem o sistema de banco de dados dedutivo GLUE-NAIL!

Zaniolo (1990) analisa a base te√≥rica e a import√¢ncia pr√°tica dos bancos de dados dedutivos. Nicolas (1997) oferece um hist√≥rico excelente dos desenvolvimentos levando  at√©  os  sistemas  Deductive  Object-Oriented  Database (DOOD). Falcone et al. (1997) analisam o panorama do DOOD. As refer√™ncias sobre o sistema VALIDITY incluem Friesen et al. (1995), Vieille (1998) e Dietrich et al. (1999).



## Introdu√ß√£o √† recupera√ß√£o de informa√ß√µes e busca na Web 1

A t√© aqui, discutimos t√©cnicas para modelagem, projeto, consulta, processamento de transa√ß√£o e gerenciamento de dados estruturados . Na Se√ß√£o 12.1,  discutimos  a  diferen√ßa  entre  dados  estruturados,  semiestruturados  e  desestruturados.  A recupera√ß√£o  de  informa√ß√µes  lida  principalmente com dados desestruturados , e as t√©cnicas para indexa√ß√£o, pesquisa e recupera√ß√£o de informa√ß√µes de  grandes  cole√ß√µes  de  documentos  desestruturados.  Neste  cap√≠tulo,  faremos  uma  introdu√ß√£o √†  recupera√ß√£o  de  informa√ß√µes.  Esse  √©  um  t√≥pico muito amplo, de  modo  que  focalizaremos  as  semelhan√ßas e diferen√ßas entre as tecnologias de recupera√ß√£o de informa√ß√£o e banco de dados, al√©m das t√©cnicas de indexa√ß√£o que formam a base de muitos sistemas de recupera√ß√£o de informa√ß√µes.

## 27.1 Conceitos de recupera√ß√£o de informa√ß√µes (RI)

Na  Se√ß√£o  27.1,  apresentamos  os  conceitos de  recupera√ß√£o de informa√ß√£o (RI) e discutimos como ela difere dos bancos de dados tradicionais. A Se√ß√£o 27.2 √© dedicada a uma discuss√£o dos modelos de recupera√ß√£o, que formam a base para a consulta RI. A Se√ß√£o 27.3 aborda diferentes tipos de consultas em sistemas RI. A Se√ß√£o 27.4 discute o pr√©-processamento de textos, e a Se√ß√£o 27.5 oferece uma vis√£o geral da indexa√ß√£o RI, que est√° no √¢mago de qualquer sistema RI. Na Se√ß√£o 27.6, descrevemos  as  diversas  m√©tricas  de  avalia√ß√£o para  desempenho  de  sistemas  RI.  A  Se√ß√£o  27.7 detalha  a  an√°lise  da  Web  e  seu  relacionamento com a recupera√ß√£o de informa√ß√µes, e a Se√ß√£o 27.8 apresenta resumidamente as tend√™ncias atuais em RI. No final do cap√≠tulo h√° um resumo. Para uma vis√£o geral limitada da RI, sugerimos que os alunos leiam as se√ß√µes 27.1 a 27.6.

Recupera√ß√£o  de  informa√ß√µes √©  o  processo  de recuperar documentos de uma cole√ß√£o em resposta a uma consulta (ou solicita√ß√£o de consulta) por um usu√°rio. Esta se√ß√£o oferece uma vis√£o geral dos conceitos de recupera√ß√£o de informa√ß√µes (RI). Na Se√ß√£o 27.1.1, apresentamos a recupera√ß√£o de informa√ß√µes em geral e, depois, discutimos os diferentes tipos e n√≠veis de pesquisa que a RI abrange. Na Se√ß√£o  27.1.2,  comparamos  a  RI  e  as  tecnologias  de banco de dados. A Se√ß√£o 27.1.3 oferece um breve hist√≥rico da RI. Depois, apresentamos os diferentes modos de intera√ß√£o do usu√°rio com sistemas de RI na Se√ß√£o 27.1.4. Na Se√ß√£o 27.1.5, descrevemos o processo de RI t√≠pico com um conjunto detalhado de tarefas e, depois, com um fluxo de processo simplificado,  e  terminamos  com  uma  breve  discuss√£o sobre as bibliotecas digitais e a Web.

## 27.1.1 ntrodu√ß√£o √† recupera√ß√£o de I informa√ß√µes

Primeiro, revemos a distin√ß√£o entre dados estruturados e desestruturados (ver Se√ß√£o 12.1) para entender como a recupera√ß√£o de informa√ß√µes difere do gerenciamento de dados estruturados. Considere uma rela√ß√£o (ou tabela) chamada CASAS com os atributos:

CASAS(Num\_lote, Endereco, Metragem\_qua-drada, Preco\_listado)

Este √© um exemplo de dados estruturados .  Podemos  comparar  essa  rela√ß√£o  com  documentos  de

1 Este cap√≠tulo tem como coautor Saurav Sahay, do Georgia Institute of Technology.

contrato de compra de casa, que s√£o exemplos de dados desestruturados .  Esses tipos de documentos podem variar de uma cidade para outra, e at√© mesmo de um munic√≠pio para outro, em determinado estado no Brasil. Normalmente, um documento de contrato em determinado estado ter√° uma lista-padr√£o de cl√°usulas descritas em par√°grafos dentro de se√ß√µes do documento, com algum texto predeterminado (fixo) e algumas √°reas vari√°veis cujo conte√∫do deve ser fornecido pelo comprador e vendedor espec√≠fico. Outras informa√ß√µes vari√°veis incluiriam taxa de juros para financiamento, valor de pagamento antecipado, datas de fechamento, e assim por diante. Os documentos possivelmente tamb√©m poderiam incluir algumas imagens  tiradas  durante  uma  inspe√ß√£o  da  casa.  O conte√∫do das informa√ß√µes em tais documentos pode ser considerado dados desestruturados que podem ser armazenados  em  diversos  arranjos  e  formatos  poss√≠veis.  Com informa√ß√£o  desestruturada ,  geralmente queremos dizer informa√ß√µes que n√£o t√™m um modelo formal bem definido e uma linguagem formal correspondente para a representa√ß√£o e argumento, mas que √© baseada no conhecimento da linguagem natural.

Com o advento da World Wide Web (ou Web, para  abreviar),  o  volume  de  informa√ß√µes  desestruturadas  armazenadas  em  mensagens  e  documentos que cont√™m informa√ß√µes textuais e de multim√≠dia explodiu. Esses documentos s√£o armazenados em uma s√©rie  de  formatos-padr√£o,  incluindo  HTML,  XML (ver Cap√≠tulo 12) e diversos padr√µes de formata√ß√£o de √°udio e v√≠deo. A recupera√ß√£o de informa√ß√µes lida com os problemas de armazenamento, indexa√ß√£o e recupera√ß√£o (busca) de tais informa√ß√µes para satisfazer as necessidades dos usu√°rios. Os problemas com que a RI lida s√£o aumentados pelo fato de o n√∫mero de p√°ginas Web e o n√∫mero de eventos de intera√ß√£o social j√° estar na casa dos bilh√µes, e crescer em um ritmo fenomenal. Todas as formas de dados desestruturados descritas est√£o sendo acrescentadas a taxas de milh√µes por dia, expandindo o espa√ßo pesquis√°vel na Web em taxas que crescem de maneira r√°pida.

tores, t√≥picos e palavras-chave. Em programas acad√™micos, o campo de RI h√° muito tem feito parte de programas de Ci√™ncia da Informa√ß√£o e Biblioteca. A informa√ß√£o no contexto da RI n√£o requer estruturas que a m√°quina possa entender, como nos sistemas de bancos de dados relacionais. Alguns exemplos desse tipo de informa√ß√£o s√£o textos escritos, resumos, documentos,  livros,  p√°ginas  Web,  e-mails,  mensagens instant√¢neas e cole√ß√µes de bibliotecas digitais. Portanto, toda a informa√ß√£o livremente representada (desestruturada) ou semiestruturada tamb√©m faz parte da disciplina de RI.

Apresentamos  a  modelagem  e  recupera√ß√£o  da XML no Cap√≠tulo 12 e discutimos tipos avan√ßados de  dados,  incluindo  dados  espaciais,  temporais  e multim√≠dia, no Cap√≠tulo 26. Vendedores de SGBDR est√£o oferecendo m√≥dulos para dar suporte a muitos desses  tipos  de  dados,  bem  como  dados  em  XML, nas vers√µes mais recentes de seus produtos, √†s vezes conhecidos como SGBDRs estendidos ,  ou sistemas de gerenciamento de banco de dados objeto-relacional (SGBDORs, ver Cap√≠tulo 11). O desafio de lidar com  dados  desestruturados  √©  em  grande  parte  um problema de recupera√ß√£o de informa√ß√µes, embora os pesquisadores de banco de dados estejam aplicando indexa√ß√£o de banco de dados e t√©cnicas de pesquisa a alguns desses problemas.

Historicamente,  a recupera√ß√£o  de  informa√ß√µes √© 'a disciplina que trata da estrutura, an√°lise, organiza√ß√£o, armazenamento, pesquisa e recupera√ß√£o de informa√ß√µes', conforme definida por Gerald Salton, um pioneiro em RI. 2  Podemos aperfei√ßoar a defini√ß√£o ligeiramente para dizer que ela se aplica ao contexto de documentos desestruturados para satisfazer as necessidades de informa√ß√£o de um usu√°rio. Esse campo j√° existia bem antes do campo de banco de dados, e tratava originalmente da recupera√ß√£o de informa√ß√µes catalogadas em bibliotecas baseadas em t√≠tulos, au-

Os sistemas RI v√£o al√©m dos sistemas de banco de dados, pois n√£o limitam o usu√°rio a uma linguagem de consulta espec√≠fica, nem esperam que ele conhe√ßa a estrutura (esquema) ou conte√∫do de um banco de dados em particular. Os sistemas de RI utilizam a  necessidade  de  informa√ß√£o  de  um  usu√°rio  como uma solicita√ß√£o de pesquisa em forma livre (√†s vezes chamada de consulta por pesquisa de palavra-chave , ou apenas consulta ) para interpreta√ß√£o pelo sistema. Embora o campo de RI historicamente tenha tratado da cataloga√ß√£o, processamento e acesso de texto na forma de documentos h√° d√©cadas, no mundo de hoje, o uso de mecanismos de busca da Web est√° se tornando o modo dominante de encontrar informa√ß√µes. Os problemas tradicionais da indexa√ß√£o de texto e da elabora√ß√£o de cole√ß√µes de documentos pesquis√°veis t√™m sido transformados ao tornar a pr√≥pria Web um reposit√≥rio de conhecimento humano facilmente acess√≠vel.

Um sistema de RI pode ser caracterizado em diferentes n√≠veis: por tipos de usu√°rios , tipos de dados e  tipos  de necessidade de informa√ß√£o ,  junto  com o tamanho  e  a  escala  do  reposit√≥rio  de  informa√ß√µes que ele trata. Diferentes sistemas de RI s√£o designados para lidar com problemas espec√≠ficos que exigem

2 Ver o livro de 1968 de Salton, intitulado Automatic Information Organization and Retrieval .

uma  combina√ß√£o  de  diversas  caracter√≠sticas.  Essas caracter√≠sticas  podem  ser  rapidamente  descritas  da seguinte forma:

Tipos de usu√°rios. O usu√°rio pode ser um usu√°rio especialista (por exemplo, um curador ou um bibliotec√°rio),  que  est√°  procurando  informa√ß√µes  espec√≠ficas que est√£o claras em sua mente e forma consultas relevantes  para  a  tarefa,  ou  um usu√°rio  leigo com uma necessidade de informa√ß√£o gen√©rica. Este √∫ltimo n√£o pode criar consultas altamente relevantes para pesquisa  (por  exemplo,  alunos  tentando  encontrar informa√ß√µes  sobre  um  novo  t√≥pico,  pesquisadores tentando assimilar  diferentes  pontos  de  vista  sobre uma quest√£o hist√≥rica, um cientista verificando uma declara√ß√£o de outro cientista ou uma pessoa tentando comprar roupas).

Tipos de dados. Sistemas  de  pesquisa  podem  ser ajustados a tipos de dados espec√≠ficos. Por exemplo, o problema de recuperar informa√ß√µes sobre um t√≥pico espec√≠fico pode ser tratado de modo mais eficiente por sistemas de pesquisa personalizados, que s√£o criados para coletar e recuperar apenas informa√ß√µes relacionadas a esse t√≥pico espec√≠fico. O reposit√≥rio de informa√ß√µes poderia ser organizado hierarquicamente com base em uma hierarquia de conceito ou t√≥pico.  Esses sistemas  de  RI  t√≥picos  espec√≠ficos  do dom√≠nio ou verticais n√£o s√£o t√£o grandes ou t√£o diversos como a World Wide Web gen√©rica, que cont√©m informa√ß√µes sobre todos os tipos de t√≥picos. Visto que essas cole√ß√µes espec√≠ficas do dom√≠nio existem e podem ter sido adquiridas por meio de um processo espec√≠fico, elas podem ser exploradas muito mais eficientemente por um sistema especializado.

Tipos de informa√ß√£o necess√°ria. No contexto de pesquisa na Web, as necessidades de informa√ß√£o dos usu√°rios  podem  ser  definidas  como  navegacional, informativa ou transacional. 3 Pesquisa navegacional refere-se a encontrar um peda√ßo de informa√ß√£o em particular  (como  o  Website  da  Georgia  Tech  University)  de  que  um  usu√°rio  precisa  rapidamente.  A finalidade  de pesquisa  informativa √©  encontrar  informa√ß√µes atuais sobre um t√≥pico (como atividades de pesquisa na faculdade de computa√ß√£o da Georgia Tech - essa √© a tarefa cl√°ssica do sistema de RI). O objetivo da pesquisa transacional √©  alcan√ßar  um site em que acontece mais intera√ß√£o (como juntar-se a uma rede social, compra de produtos, reservas on-line, acesso a bancos de dados, e assim por diante).

N√≠veis  de  escala. Nas  palavras  do  ganhador  do pr√™mio Nobel Herbert Simon,

3 Veja mais detalhes em Broder (2002).

4 De Simon (1971), 'Designing Organizations for an Information-Rich World'.

O que a informa√ß√£o consome √© bastante √≥bvio: ela consome a aten√ß√£o de seus destinat√°rios. Logo, uma rica fonte de informa√ß√µes cria uma pobreza de aten√ß√£o e uma necessidade de alocar essa aten√ß√£o de forma eficiente entre a superabund√¢ncia de fontes de informa√ß√µes que poderiam consumi-la. 4

Essa superabund√¢ncia de fontes de informa√ß√£o de fato cria uma alta rela√ß√£o sinal-ru√≠do em sistemas de RI. Especialmente na Web, onde bilh√µes de p√°ginas s√£o indexadas, as interfaces de RI s√£o montadas com algoritmos escal√°veis eficientes para pesquisa distribu√≠da, indexa√ß√£o, caching, intercala√ß√£o e toler√¢ncia a falhas. Mecanismos de pesquisa de RI podem ser limitados  em  n√≠vel  a  cole√ß√µes  de  documentos  mais espec√≠ficas. Sistemas  de  pesquisa  empresarial oferecem solu√ß√µes de RI para pesquisar diferentes entidades  na intranet de  uma  empresa,  que  consiste na rede de computadores dentro dessa empresa. As entidades pesquis√°veis incluem e-mails, documentos corporativos, manuais, gr√°ficos e apresenta√ß√µes, bem como relat√≥rios  relacionados  a  pessoas,  reuni√µes  e projetos. Eles ainda costumam lidar com centenas de milh√µes de entidades em grandes empresas globais. Em uma escala menor, existem sistemas de informa√ß√µes pessoais, como aqueles em desktops ou laptops, chamados mecanismos de pesquisa de desktop (por exemplo, Google Desktop), para recuperar arquivos, pastas  e  diferentes  tipos  de  entidades  armazenadas no computador. Existem sistemas peer-to-peer, como o BitTorrent, que permitem o compartilhamento de m√∫sica na forma de arquivos de √°udio, bem como mecanismos de pesquisa especializados para √°udio, como a pesquisa de √°udio do Lycos e do Yahoo!

## 27.1.2 Bancos de dados e sistemas de RI: uma compara√ß√£o

Na disciplina de ci√™ncia da computa√ß√£o, os bancos de dados e sistemas de RI s√£o campos intimamente  relacionados.  Os  bancos  de  dados  lidam  com  recupera√ß√£o de informa√ß√µes estruturadas por meio de linguagens formais bem definidas para representa√ß√£o e manipula√ß√£o com base nos modelos de dados criados de maneira te√≥rica. Algoritmos eficientes t√™m sido desenvolvidos para operadores que permitem a r√°pida execu√ß√£o de consultas complexas. A RI, por outro lado, lida com a pesquisa desestruturada com sem√¢ntica de consulta ou pesquisa possivelmente vaga e sem representa√ß√£o esquem√°tica l√≥gica bem definida. Algumas das principais diferen√ßas entre bancos de dados e sistemas de RI s√£o listadas na Tabela 27.1.

## Tabela 27.1

Uma compara√ß√£o dos bancos de dados e sistemas de RI.

## Bancos de dados

- ¬Ñ Dados estruturados
- ¬Ñ Controlados por esquema
- ¬Ñ Modelo relacional (ou de objeto, hier√°rquico e rede) √© predominante
- ¬Ñ Modelo de consulta estruturada
- ¬Ñ Opera√ß√µes ricas com metadados
- ¬Ñ Consulta retorna dados
- ¬Ñ Resultados s√£o baseados em combina√ß√£o exata (sempre correta)

Enquanto os bancos de dados t√™m esquemas fixos definidos em algum modelo de dados, como o relacional, um sistema de RI n√£o tem modelo de dados fixo; ele v√™ os dados ou documentos de acordo com algum esquema, como o modelo de espa√ßo de vetor, e  auxilia  no  processamento  de  consulta  (ver  Se√ß√£o 27.2). Os bancos de dados que usam o modelo relacional empregam a SQL para consultas e transa√ß√µes. As consultas s√£o mapeadas em opera√ß√µes da √°lgebra relacional e algoritmos de pesquisa (ver Cap√≠tulo 19) e retornam uma nova rela√ß√£o (tabela) como o resultado da consulta, oferecendo uma resposta exata √† consulta para o estado atual do banco de dados. Em sistemas RI, n√£o existe linguagem fixa para definir a estrutura  (esquema)  do  documento  ou  para  operar sobre um documento - as consultas tendem a ser um conjunto de termos de consulta (palavras-chave) ou uma frase na linguagem natural em forma livre. Um resultado de consulta RI √© uma lista de ids de documento, ou algumas partes de texto, ou objetos de multim√≠dia (imagens, v√≠deos, e assim por diante), ou uma lista de links para p√°ginas Web.

## Sistemas de RI

- ¬Ñ Dados desestruturados
- ¬Ñ Sem esquema fixo; v√°rios modelos de dados (por exemplo,
- modelo de espa√ßo de vetor)
- ¬Ñ Modelos de consulta em forma livre
- ¬Ñ Opera√ß√µes ricas com dados
- ¬Ñ Solicita√ß√£o de pesquisa retorna lista ou ponteiros para documentos
- ¬Ñ Resultados s√£o baseados na combina√ß√£o aproximada e medidas de efic√°cia (podem ser imprecisos e pontuados)

√© realizada para determinar a relev√¢ncia de cada documento ou partes de um documento √† solicita√ß√£o do usu√°rio.

## 27.1.3 Um breve hist√≥rico da RI

O resultado de uma consulta de banco de dados √© uma resposta exata; se n√£o forem encontrados registros (tuplas) correspondentes na rela√ß√£o, o resultado √© vazio (nulo). Al√©m disso, a resposta para uma solicita√ß√£o do usu√°rio em uma consulta RI representa a melhor tentativa do sistema RI de recuperar a informa√ß√£o mais relevante  para  essa  consulta.  Enquanto sistemas de banco de dados mant√™m uma grande quantidade de metadados e permitem seu uso na otimiza√ß√£o de consulta, as opera√ß√µes nos sistemas RI contam com os pr√≥prios valores de dados e suas frequ√™ncias de ocorr√™ncia. A an√°lise estat√≠stica complexa √†s vezes

A recupera√ß√£o de informa√ß√µes tem sido uma tarefa comum desde as antigas civiliza√ß√µes, que criaram maneiras de organizar, armazenar e catalogar documentos e registros. M√≠dias, como os rolos de papiro  e  as  mesas  de  pedra,  foram  usadas  para registrar  informa√ß√µes  documentadas  nos  tempos antigos. Esses esfor√ßos permitiram que o conhecimento fosse retido e transferido entre as gera√ß√µes. Com  o  surgimento  de  bibliotecas  p√∫blicas  e  da prensa  tipogr√°fica,  surgiram  m√©todos  em  grande escala para produzir, coletar, arquivar e distribuir documentos  e  livros.  Quando  surgiram  computadores  e  sistemas  de  armazenamento  autom√°tico, houve a necessidade de aplicar esses m√©todos a sistemas computadorizados. V√°rias t√©cnicas surgiram na d√©cada de 1950, como o trabalho inicial de H. P. Luhn, 5  que prop√¥s o uso de palavras e suas contagens de frequ√™ncia como unidades de indexa√ß√£o para documentos, e o uso de medidas de sobreposi√ß√£o de palavras entre consultas e documentos como crit√©rio  de  recupera√ß√£o.  Logo,  foi  observado  que armazenar grande quantidade de texto n√£o era dif√≠cil. A tarefa mais dura foi procurar e recuperar essa informa√ß√£o  seletivamente  para  usu√°rios  com  necessidades de informa√ß√£o espec√≠ficas. M√©todos que exploraram estat√≠sticas de distribui√ß√£o de palavras fizeram surgir a escolha de palavras-chave com base em suas propriedades de distribui√ß√£o 6   e  esquemas de peso baseados em palavra-chave.

5 Ver Luhn (1957) 'A Statistical Approach to Mechanized Encoding and Searching of Literary Information'.

6 Ver Salton, Yang e Yu (1975).

Os primeiros experimentos com sistemas de recupera√ß√£o de documentos, como o SMART 7  na d√©cada de 1960, adotaram a organiza√ß√£o de arquivo invertida com base em palavras-chave e seus pesos como  o  m√©todo  de  indexa√ß√£o  (ver  Se√ß√£o  27.5).  A organiza√ß√£o serial (ou sequencial) provou ser inadequada se as consultas solicitassem tempos de resposta r√°pidos, quase em tempo real. A organiza√ß√£o apropriada desses arquivos tornou-se uma √°rea de estudo importante; em resultado, apareceram esquemas de classifica√ß√£o e agrupamento de documentos. A escala de experimentos de recupera√ß√£o continuou sendo um desafio devido √† falta de disponibilidade de grandes cole√ß√µes de texto. Isso logo mudou com a World Wide Web. Al√©m disso, a Text Retrieval Conference (TREC)  foi  iniciada  pelo  NIST  (National  Institute of Standards and Technology - Instituto Nacional de Padr√µes e Tecnologia), em 1992, como uma parte do programa TIPSTER, 8  com o objetivo de oferecer uma plataforma para avaliar metodologias de recupera√ß√£o de informa√ß√µes e facilitar a transfer√™ncia de tecnologia para desenvolver produtos de RI.

Um mecanismo de busca √© uma aplica√ß√£o pr√°tica da recupera√ß√£o de informa√ß√µes para cole√ß√µes de documentos em grande escala. Com avan√ßos significativos em computadores e tecnologias de comunica√ß√µes, as pessoas hoje possuem acesso interativo a uma enorme quantidade de conte√∫do distribu√≠do gerado pelo usu√°rio na Web. Isso incentivou o r√°pido crescimento na tecnologia de mecanismo de busca, na qual tais mecanismos tentam descobrir diferentes tipos de conte√∫do de  tempo real  encontrados  na  Web.  A  parte  de  um mecanismo de busca respons√°vel por descobrir, analisar  e  indexar  esses  novos  documentos  √©  conhecida como crawler . Existem outros tipos de mecanismos de busca para dom√≠nios de conhecimento espec√≠ficos. Por exemplo, o banco de dados de pesquisa da literatura biom√©dica foi iniciado na d√©cada de 1970 e agora tem o apoio do mecanismo de busca PubMed, 9  que d√° acesso a mais de 20 milh√µes de resumos.

Embora tenha havido progresso cont√≠nuo para ajustar os resultados de busca √†s necessidades de um usu√°rio final, ainda resta o desafio de oferecer informa√ß√µes de alta qualidade, pertinentes  e  oportunas, que estejam alinhadas com precis√£o √†s necessidades de informa√ß√£o dos usu√°rios individuais.

## 27.1.4 Modos de intera√ß√£o em sistemas de RI

No in√≠cio da Se√ß√£o 27.1, definimos a recupera√ß√£o de informa√ß√µes como o processo de recuperar docu-

7 Para mais detalhes, consulte Buckley et al. (1993).

8 Para mais detalhes, consulte Harman (1992).

9 Consulte &lt;www.ncbi.nlm.nih.gov/pubmed/&gt;.

mentos de uma cole√ß√£o em resposta a uma consulta (ou  a  uma  solicita√ß√£o  de  consulta)  por  um  usu√°rio. Normalmente, a cole√ß√£o √© composta de documentos que  cont√™m  dados  desestruturados.  Outros  tipos  de documentos incluem imagens, grava√ß√µes de √°udio, trechos de v√≠deo e mapas. Os dados podem ser espalhados de modo n√£o uniforme nesses documentos, sem uma estrutura definitiva. Uma consulta √©  um conjunto de termos (tamb√©m chamados de palavras-chave ) usados pelo pesquisador para especificar uma necessidade de informa√ß√£o (por exemplo, os termos 'bancos de dados' e 'sistemas operacionais' podem ser considerados uma consulta para um banco de dados bibliogr√°fico de  ci√™ncia  da  computa√ß√£o).  Uma  solicita√ß√£o  informativa ou uma consulta de pesquisa tamb√©m podem ser uma frase ou uma pergunta em linguagem natural (por exemplo, 'Qual √© a moeda da China?' ou 'Encontre restaurantes italianos na cidade de S√£o Paulo.').

Existem dois modos principais de intera√ß√£o com sistemas  de  RI  -  recupera√ß√£o  e  navega√ß√£o  -  que, embora semelhantes em objetivo, s√£o realizados por meio de diferentes tarefas de intera√ß√£o. A recupera√ß√£o refere-se √† extra√ß√£o de informa√ß√µes relevantes de um reposit√≥rio de documentos por meio de uma consulta de RI, enquanto a navega√ß√£o significa a atividade de um usu√°rio que visita ou navega por documentos semelhantes ou relacionados com base na avalia√ß√£o de  relev√¢ncia  pelo  usu√°rio.  Durante  a  navega√ß√£o,  a necessidade de informa√ß√£o de um usu√°rio pode n√£o ser definida a priori e √© flex√≠vel. Considere o seguinte cen√°rio de navega√ß√£o: um usu√°rio especifica 'Recife' como  uma  palavra-chave.  O  sistema  de  recupera√ß√£o de  informa√ß√µes  recupera  links  para  documentos  de resultado  relevantes  que  cont√™m  diversos  aspectos de Recife para o usu√°rio. Ele se depara com o termo 'Georgia  Tech'  em  um  dos  documentos  retornados, utiliza alguma t√©cnica de acesso (como clicar na frase 'Georgia Tech' em um documento, que tem um link embutido) e visita documentos sobre Georgia Tech no mesmo Website ou em um site diferente (reposit√≥rio). L√°, o usu√°rio encontra uma entrada para 'Athletics' que o leva a informa√ß√µes sobre diversos programas atl√©ticos na Georgia Tech. Por fim, o usu√°rio termina sua pesquisa na programa√ß√£o do segundo semestre para a equipe de futebol Yellow Jackets, que ele descobre ser  de  grande  interesse.  Essa  atividade  do  usu√°rio  √© conhecida como navega√ß√£o (ou browsing ). Hiperlinks s√£o usados para interconectar p√°ginas Web e servem, principalmente, para navega√ß√£o. Textos de √¢ncora s√£o frases em documentos usadas para rotular hiperlinks, consideradas muito relevantes √† navega√ß√£o.

A busca na Web combina os dois aspectos - navega√ß√£o e recupera√ß√£o - e √© uma das principais aplica√ß√µes da recupera√ß√£o de informa√ß√µes hoje. P√°ginas Web s√£o semelhantes a documentos. Os mecanismos de busca na Web mant√™m um reposit√≥rio indexado de p√°ginas Web, normalmente usando a t√©cnica de indexa√ß√£o invertida (ver Se√ß√£o 27.5). Eles recuperam as p√°ginas Web mais relevantes para o usu√°rio em resposta √† solicita√ß√£o de pesquisa dele com uma poss√≠vel pontua√ß√£o em ordem decrescente de relev√¢ncia. A pontua√ß√£o de uma p√°gina Web em um conjunto recuperado √© a medida de sua relev√¢ncia √† consulta que gerou o conjunto de resultados.

## 27.1.5 Pipeline RI gen√©rica

Como j√° mencionamos, os documentos s√£o feitos  de  texto  em  linguagem  natural  desestruturada, composto  de  cadeias  de  caracteres  do  portugu√™s  e outras linguagens. Exemplos comuns de documentos incluem servi√ßos de not√≠cias (como AP ou Reuters), manuais e relat√≥rios corporativos, not√≠cias do governo, artigos de p√°gina Web, blogs, tweets, livros e artigos de jornal. Existem duas abordagens principais para RI: estat√≠stica e sem√¢ntica.

Em uma abordagem estat√≠stica ,  os  documentos s√£o analisados e desmembrados em trechos de texto (palavras, frases ou n -gramas, que s√£o todos subsequ√™ncias com comprimento de n caracteres  em um texto ou documento), e cada palavra ou frase √© contada, pesada e medida por sua relev√¢ncia ou import√¢ncia. Essas palavras e suas propriedades s√£o ent√£o comparadas com os termos de consulta em grau de combina√ß√£o em potencial,  para  produzir  uma  lista pontuada de documentos resultantes que cont√™m as palavras. As t√©cnicas estat√≠sticas s√£o classificadas ainda com base no m√©todo empregado. As tr√™s t√©cnicas principais s√£o a booleana, espa√ßo de vetor e probabil√≠stica (ver Se√ß√£o 27.2).

Abordagens sem√¢nticas para RI usam t√©cnicas de recupera√ß√£o baseadas em conhecimento, que contam bastante  com  os  n√≠veis  sint√°tico,  l√©xico,  sentencial, baseado em discurso e pragm√°tico do entendimento do conhecimento. Na pr√°tica, as t√©cnicas sem√¢nticas tamb√©m aplicam alguma forma de an√°lise estat√≠stica para melhorar o processo de recupera√ß√£o.

A  Figura  27.1  mostra  os  diversos  est√°gios  envolvidos  em  um  sistema  de  processamento  de  RI. As etapas mostradas √† esquerda na Figura 27.1 normalmente s√£o processos off-line, que preparam um conjunto de documentos para recupera√ß√£o eficiente; estes s√£o pr√©-processamento de documento, modelagem de documento e indexa√ß√£o. As etapas envolvidas na forma√ß√£o da consulta, processamento da consulta, mecanismo de pesquisa, recupera√ß√£o de documento e feedback de relev√¢ncia aparecem √† direita na Figura 27.1. Em cada caixa, destacamos os conceitos e quest√µes importantes. O restante deste cap√≠tulo descreve alguns dos conceitos envolvidos nas diversas tarefas do processo de RI mostrado na Figura 27.1.

A Figura 27.2 mostra uma pipeline de processamento de RI simplificada. Para realizar a recupera√ß√£o, os documentos s√£o primeiro representados em uma forma adequada √† recupera√ß√£o. Os termos significativos e suas propriedades s√£o extra√≠dos dos documentos e representados em um √≠ndice de documento no qual as palavras/termos e suas propriedades s√£o armazenados em uma matriz que cont√©m esses termos e as refer√™ncias aos documentos que os cont√™m. Esse √≠ndice √© ent√£o convertido para um √≠ndice invertido (ver Figura 27.4) de uma palavra/termo versus matriz  de  documentos.  Dadas  as  palavras  de  consulta, os documentos que cont√™m essas palavras e as propriedades do documento, como data de cria√ß√£o, autor e tipo de documento - s√£o buscadas no √≠ndice invertido e comparadas com a consulta. Essa compara√ß√£o resulta em uma lista pontuada mostrada ao usu√°rio. O usu√°rio pode ent√£o oferecer feedback sobre os resultados, que dispara expans√£o de consulta impl√≠cita ou expl√≠cita para buscar resultados que sejam mais relevantes para o usu√°rio. A maioria dos sistemas de RI permite uma pesquisa interativa em que a consulta e os resultados s√£o sucessivamente refinados.

## 27.2 Modelos de recupera√ß√£o

Nesta  se√ß√£o,  descrevemos  rapidamente  os  importantes modelos de RI. Trata-se dos tr√™s modelos estat√≠sticos principais - booleano, espa√ßo de vetor e probabil√≠stico - e do modelo sem√¢ntico.

## 27.2.1 Modelo booleano

Nesse modelo, os documentos s√£o representados como um conjunto de termos .  As consultas s√£o formuladas  como  uma  combina√ß√£o  de  termos  usando os operadores te√≥ricos de conjunto-padr√£o da l√≥gica booleana, como AND, OR e NOT. A recupera√ß√£o e relev√¢ncia s√£o consideradas conceitos bin√°rios nesse modelo, de modo que os elementos recuperados s√£o uma recupera√ß√£o de 'combina√ß√£o exata' dos documentos relevantes. N√£o existe a no√ß√£o de pontua√ß√£o dos documentos resultantes. Todos os documentos recuperados s√£o considerados igualmente importantes - uma simplifica√ß√£o relevante, que n√£o considera frequ√™ncias de termos do documento ou sua proximidade com outros termos comparados com os termos da consulta.

Os modelos de recupera√ß√£o booleanos n√£o possuem  algoritmos  de  pontua√ß√£o  sofisticados  e  est√£o

Figura 27.1 Estrutura geral da RI.



entre  os  modelos  de  recupera√ß√£o  de  informa√ß√µes mais antigos e mais simples. Esses modelos facilitam a associa√ß√£o de informa√ß√µes de metadados e a escrita de  consultas  que  combinam  o  conte√∫do  dos  documentos bem como outras propriedades destes, como data de cria√ß√£o, autor e tipo de documento.

## 27.2.2 Modelo de espa√ßo de vetor

O modelo de espa√ßo de vetor oferece uma estrutura em que o peso do termo, a pontua√ß√£o dos documentos recuperados e o feedback de relev√¢n- cia  s√£o  poss√≠veis.  Os  documentos  s√£o  representados como recursos e pesos dos recursos do termo em um espa√ßo de vetor n -dimensional de termos. Recursos s√£o  um  subconjunto  dos  termos  em  um conjunto  de  documentos considerados  mais  relevantes para uma pesquisa de RI para esse conjunto de documentos em particular. O processo de selecionar  esses  termos  importantes  (recursos)  e  suas propriedades como uma lista esparsa (limitada) de um n√∫mero muito grande de termos dispon√≠veis (o vocabul√°rio  pode  conter  centenas  de  milhares  de termos)  √©  independente  da  especifica√ß√£o  do  mo-



Àùndice invertido

Figura 27.2 Pipeline simplificada do processo de RI.

delo. A consulta tamb√©m √© especificada como um vetor de termos (vetor de recursos) e este √© comparado aos vetores de documentos para avalia√ß√£o da similaridade/relev√¢ncia.

A fun√ß√£o de avalia√ß√£o de similaridade que compara  dois  vetores  n√£o  √©  inerente  ao  modelo  -  diferentes fun√ß√µes de similaridade podem ser usadas. Contudo, o cosseno do √¢ngulo entre a consulta e o vetor  de  documentos  √©  uma  fun√ß√£o  normalmente utilizada  para  avalia√ß√£o  de  similaridade.  √Ä  medida que o √¢ngulo entre os vetores diminui, o cosseno do √¢ngulo se aproxima de um, significando que a similaridade da consulta com um vetor de documentos aumenta. Os termos (recursos) s√£o proporcionalmente pesados √†s suas contagens de frequ√™ncia para refletir a import√¢ncia dos termos no c√°lculo da medida de relev√¢ncia. Isso √© diferente do modelo booleano, que n√£o leva em conta a frequ√™ncia das palavras no documento para combina√ß√£o de relev√¢ncia.

No modelo de vetor, o peso do termo do documento w ij (para  o  termo i no  documento  ) √© reprej sentado  com  base  em  alguma  varia√ß√£o  do  esquema TF (frequ√™ncia do termo) ou TF-IDF (frequ√™ncia do termo-frequ√™ncia  inversa  do  documento),  conforme descreveremos  mais  adiante. TF-IDF √©  uma  medida estat√≠stica  de  peso  usada  para  avaliar  a  import√¢ncia de uma palavra do documento em uma cole√ß√£o de documentos. A f√≥rmula a seguir costuma ser utilizada:

<!-- formula-not-decoded -->

Na f√≥rmula dada, usamos os seguintes s√≠mbolos:

- ¬Ñ d j √© o vetor do documento.
- ¬Ñ c √© o vetor de consulta.
- ¬Ñ w i j √© o peso do termo i no documento  . j
- ¬Ñ w iq √© o peso do termo i no vetor de consulta c .
- ¬Ñ | V | √© o n√∫mero de dimens√µes no vetor que √© o n√∫mero total de palavras-chave (ou recursos) importantes.

O esquema TF-IDF usa o produto da frequ√™ncia normalizada de um termo   ( i TF ij ) no documento Dj e

a frequ√™ncia inversa do documento do termo   ( i IDF i ) para pesar um termo em um documento. A ideia √© que os termos que capturam a ess√™ncia de um documento ocorrem com frequ√™ncia no documento (ou seja, seu TF √© alto), mas se tal termo for bom para discriminar o documento de outros, ele deve ocorrer em  apenas  alguns  documentos  na  popula√ß√£o  geral (ou seja, seu IDF deve ser alto tamb√©m).

Valores de IDF podem ser facilmente calculados para uma cole√ß√£o fixa de documentos. No caso de mecanismos de busca da Web, tomar uma amostra representativa  dos  documentos  aproxima  o  c√°lculo do IDF. As seguintes f√≥rmulas podem ser usadas:

<!-- formula-not-decoded -->

Nessas f√≥rmulas, o significado dos s√≠mbolos √©:

- ¬Ñ TF ij √© a frequ√™ncia do termo normalizada do termo   no documento i Dj .
- ¬Ñ f ij √© o n√∫mero de ocorr√™ncias do termo i no documento Dj .
- ¬Ñ IDF i √©  o  peso  de  frequ√™ncia  do  documento inverso para o termo  . i
- ¬Ñ N √© o n√∫mero de documentos na cole√ß√£o.
- ¬Ñ n i √© o n√∫mero de documentos em que o termo i ocorre.

Observe que, se um termo   ocorre em todos os i documentos, ent√£o n i = N e, portanto, IDF i = log (1) torna-se zero, anulando sua import√¢ncia e criando uma situa√ß√£o  em  que  a  divis√£o  por  zero  pode  ocorrer.  O peso do termo   no documento  , i j w ij , √© calculado com base em seu valor de TF-IDF em algumas t√©cnicas. Para impedir a divis√£o por zero, √© comum somar 1 ao denominador em f√≥rmulas como a do cosseno, acima.

√Äs vezes, a relev√¢ncia do documento com rela√ß√£o a uma consulta (rel( Dj , C )) √© medida diretamente como a soma dos valores de TF-IDF dos termos na Consulta C :

<!-- formula-not-decoded -->

O fator de normaliza√ß√£o (semelhante ao denominador  da  f√≥rmula  do  cosseno)  √©  incorporado  √† pr√≥pria f√≥rmula do TF-IDF, medindo assim a relev√¢ncia de um documento √† consulta pelo c√°lculo do produto escalar da consulta e vetores de documento.

10 Ver Rocchio (1971).

11 Para obter uma descri√ß√£o do sistema Cheshire II, ver Robertson (1997).

12 O teorema de Bayes √© uma t√©cnica-padr√£o para medir a probabilidade; ver Howson e Urbach (1993), por exemplo.

O algoritmo de Rocchio 10  √© um algoritmo de feedback de relev√¢ncia bem conhecido, com base no modelo de espa√ßo de vetor, que modifica o vetor de consulta inicial e seus pesos em resposta aos documentos relevantes identificados pelo usu√°rio. Ele expande o vetor de consulta original c para um novo vetor c e da seguinte forma:

<!-- formula-not-decoded -->

Aqui, Dr e Dir s√£o conjuntos de documentos relevantes e n√£o relevantes, e Œ± , Œ≤ e Œ≥ s√£o par√¢metros da equa√ß√£o. Os valores desses par√¢metros determinam como o feedback afeta a consulta original, e estes podem ser determinados ap√≥s uma s√©rie de experimentos de tentativa e erro.

## 27.2.3 Modelo probabil√≠stico

As medidas de similaridade no modelo de espa√ßo de vetor √†s vezes s√£o ocasionais. Por exemplo,  o  modelo  assume  que  os  documentos  mais pr√≥ximos  da  consulta  no  espa√ßo  do  cosseno  s√£o mais relevantes para o vetor de consulta. No modelo probabil√≠stico, uma abordagem mais concreta e definitiva √© realizada: pontuar os documentos por sua probabilidade estimada de relev√¢ncia com rela√ß√£o √† consulta e ao documento. Essa √© a base do Princ√≠pio  da  pontua√ß√£o  de  probabilidade ,  desenvolvido por Robertson. 11

Na estrutura probabil√≠stica, o sistema de RI precisa decidir se os documentos pertencem ao conjunto relevante ou ao conjunto n√£o relevante para uma consulta. Para tomar essa decis√£o, considera-se que existe um conjunto relevante predefinido e um conjunto n√£o relevante para a consulta - a tarefa √© calcular a probabilidade de que o documento perten√ßa ao conjunto relevante e comparar isso com a probabilidade de que o documento perten√ßa ao conjunto n√£o relevante.

Dada a representa√ß√£o D de um documento, estimar a relev√¢ncia R e  a  n√£o  relev√¢ncia NR desse documento envolve o c√°lculo da probabilidade condicional P R D ( | )  e P NR D ( | ).  Essas  probabilidades condicionais podem ser calculadas usando a Regra de Bayes: 12

P R D ( | ) = P D R ( | ) √ó P R ( )/ P D ( )

P NR D ( | ) = P D NR ( | ) √ó P NR P D) ( )/ (

Um documento D √© classificado como relevante se P R|D ( ) &gt; P NR|D ( ). Descartando a constante P D ( ), isso √© equivalente a dizer que um documento √© relevante se:

<!-- formula-not-decoded -->

A raz√£o de probabilidade P D|R ( )/ P D|NR ( ) √© usada como uma nota para determinar a probabilidade de o documento com representa√ß√£o D pertencer ao conjunto relevante.

A independ√™ncia de termo ou  suposi√ß√£o Na√Øve Bayes √© utilizada para estimar P D|R ( ) usando o c√°lculo de P t R ( i | ) para o termo t i . As raz√µes de probabilidade P D|R) P D|NR ( / ( ) dos documentos s√£o usadas como um substituto  para  a  pontua√ß√£o  baseada  na suposi√ß√£o de que documentos altamente pontuados ter√£o uma probabilidade alta de pertencerem ao conjunto relevante. 13

Com algumas suposi√ß√µes e estimativas razo√°veis  sobre  o  modelo  probabil√≠stico  ao  longo  das extens√µes para incorporar pesos de termo de consulta e pesos de termo de documento no modelo, um algoritmo de pontua√ß√£o probabil√≠stica chamado BM25 (Best Match 25) √© bastante popular. Esse esquema de pesos evoluiu de v√°rias vers√µes do sistema Okapi . 14

O peso do Okapi para o documento d j e consulta c √© calculado pela f√≥rmula a seguir. Eis algumas anota√ß√µes adicionais:

- ¬Ñ t i √© um termo.
- ¬Ñ f ij √© a contagem de frequ√™ncia bruta do termo t i do documento d j .
- ¬Ñ f ic √© a contagem de frequ√™ncia bruta do termo t i na consulta c .
- ¬Ñ N √© o n√∫mero total de documentos na cole√ß√£o.
- ¬Ñ df i √© o n√∫mero total de documentos que cont√™m o termo t i .
- ¬Ñ dl j √© o tamanho do documento (em bytes) de d j .
- ¬Ñ avdl √©  o  tamanho  de  documento  m√©dio  da cole√ß√£o.

A pontua√ß√£o de relev√¢ncia Okapi de um documento d j para uma consulta c √©  dada pela equa√ß√£o a seguir, onde k 1 (entre 1,0 e 2,0), b (normalmente, 0,75) e k 2 (entre 1 e 1.000) s√£o par√¢metros:

<!-- formula-not-decoded -->

## 27.2.4 Modelo sem√¢ntico

Por  mais  sofisticados  que  os  modelos  estat√≠sticos se tornem, eles podem perder muitos documentos relevantes,  pois  esses  modelos  n√£o  capturam  o  significado  completo  ou  a  necessidade  de  informa√ß√£o transmitida pela consulta de um usu√°rio. Nos modelos sem√¢nticos, o processo de combina√ß√£o de documentos com determinada consulta √© baseado no n√≠vel de conceito e combina√ß√£o sem√¢ntica, em vez de na combina√ß√£o do termo de √≠ndice (palavra-chave). Isso permite a recupera√ß√£o de documentos relevantes que compartilham associa√ß√µes significativas com outros documentos no resultado da consulta, mesmo quando essas associa√ß√µes n√£o s√£o inerentemente observadas ou estatisticamente capturadas.

Abordagens sem√¢nticas incluem diferentes n√≠veis de an√°lise, como as an√°lises morfol√≥gica, sint√°tica e sem√¢ntica, para recuperar documentos com mais efici√™ncia. Na an√°lise morfol√≥gica ,  ra√≠zes  e  afixos  s√£o analisados  para  determinar  as  partes  do  discurso (substantivos, verbos, adjetivos etc.) das palavras. Seguindo a an√°lise morfol√≥gica, a an√°lise sint√°tica divide e analisa as frases completas nos documentos. Por fim, os m√©todos sem√¢nticos precisam resolver ambiguidades de palavra e/ou gerar sin√¥nimos relevantes com base nos relacionamentos sem√¢nticos entre n√≠veis  de  entidades  estruturais  em  documentos (palavras, par√°grafos, p√°ginas ou documentos inteiros).

O  desenvolvimento  de  um  sistema  sem√¢ntico sofisticado requer bases de conhecimento complexas da informa√ß√£o sem√¢ntica, bem como heur√≠sticas de recupera√ß√£o.  Esses  sistemas  normalmente  exigem t√©cnicas de intelig√™ncia artificial e sistemas especialistas. Bases de conhecimento como Cyc 15  e WordNet 16 t√™m sido desenvolvidas para uso nos sistemas de RI baseados em conhecimento ,  com base nos modelos sem√¢nticos. A base de conhecimento Cyc, por exemplo, √© uma representa√ß√£o de uma vasta quantidade de conhecimento comum sobre asser√ß√µes (mais de 2,5 milh√µes de fatos e regras) inter-relacionando mais de

13 Os leitores dever√£o consultar Croft et al. (2009), p√°ginas 246-247, para obter uma descri√ß√£o detalhada.

14 City University of London Okapi System, de Robertson, Walker e Hancock-Beaulieu (1995).

15 Ver Lenat (1995).

16 Veja em Miller (1990) uma descri√ß√£o detalhada do WordNet.

155.000 conceitos para a conclus√£o sobre os objetos e eventos da vida di√°ria. WordNet √© um tesauro extenso (mais de 115.000 conceitos) usado por diversos sistemas que √© muito popular, e est√° em desenvolvimento cont√≠nuo (ver Se√ß√£o 27.4.3).

## 27.3 Tipos de consultas em sistemas de RI

Diferentes palavras-chave s√£o associadas ao conjunto de documentos durante o processo de indexa√ß√£o.  Essas  palavras-chave  geralmente  consistem  em palavras, frases e outras caracteriza√ß√µes de documentos, como data de cria√ß√£o, nomes de autor e tipo de documento.  Elas  s√£o  usadas  por  um  sistema  de  RI para montar um √≠ndice invertido (ver Se√ß√£o 27.5), que √©,  ent√£o,  consultado  durante  a  pesquisa.  As  consultas formuladas pelos usu√°rios s√£o comparadas com o conjunto de palavras-chave de √≠ndice. A maioria dos sistemas de RI tamb√©m permite o uso de operadores booleanos e outros para montar uma consulta complexa. A linguagem de consulta com esses operadores enriquece a expressividade da necessidade de informa√ß√£o de um usu√°rio.

## 27.3.1 Consultas por palavra-chave

As  consultas  baseadas  em  palavra-chave  s√£o  as formas  mais  simples  e  mais  utilizadas  de  consultas RI:  o  usu√°rio  apenas  informa combina√ß√µes de palavra-chave para recuperar documentos. Os termos da palavra-chave s√£o implicitamente conectados por um operador l√≥gico AND . Uma consulta como 'conceitos bancos de dados' recupera documentos que cont√™m as  palavras  'conceitos'  e  'bancos  de  dados'  no  topo dos resultados recuperados. Al√©m disso, a maioria dos sistemas  tamb√©m  recupera  documentos  que  cont√™m apenas  'bancos  de  dados'  ou  apenas  'conceitos'  em seu texto. Alguns sistemas removem as palavras que ocorrem com mais frequ√™ncia (como um o/a , , de etc., chamadas stopword ) como uma etapa de pr√©-processamento antes de enviar as palavras-chave de consulta filtradas ao mecanismo de RI. A maioria dos sistemas de RI n√£o presta aten√ß√£o √† ordena√ß√£o dessas palavras na consulta. Todos os modelos de recupera√ß√£o oferecem suporte para consultas de palavra-chave.

## 27.3.2 Consultas booleanas

Alguns sistemas de RI permitem o uso dos operadores booleanos AND, OR, NOT, ( ), + e - em combina√ß√µes de formula√ß√µes de palavra-chave. AND requer que os dois termos sejam encontrados. OR permite que um dos termos seja encontrado. NOT significa que qualquer registro contendo o segundo termo seja exclu√≠do.

'( )' significa que os operadores booleanos podem ser aninhados usando par√™nteses. '+' √© equivalente a AND, e exige o termo; o '+' deve ser colocado diretamente na frente do termo de pesquisa. '-' √© equivalente a AND NOT e significa excluir o termo; o '-' deve ser colocado diretamente na frente do termo de pesquisa n√£o desejado. Consultas booleanas complexas podem ser montadas com base nesses operadores e suas combina√ß√µes, e eles s√£o avaliados de acordo com as regras cl√°ssicas da √°lgebra booleana. Nenhuma pontua√ß√£o √© poss√≠vel, pois um documento ou satisfaz tal consulta (√© 'relevante') ou n√£o a satisfaz (√© 'n√£o relevante'). Um documento √© recuperado para uma consulta booleana se a consulta for logicamente verdadeira como uma combina√ß√£o exata no documento. Os usu√°rios n√£o costumam usar combina√ß√µes desses operadores booleanos complexos, e os sistemas de RI admitem uma vers√£o restrita  desses  operadores  de  conjunto.  Os  modelos de recupera√ß√£o booleanos podem aceitar diretamente implementa√ß√µes diferentes de operador booleano para esses tipos de consultas.

## 27.3.3 Consultas de frase

Quando os documentos s√£o representados usando  um  √≠ndice  de  palavra-chave  invertida  para  pesquisa, a ordem relativa dos termos no documento √© perdida. Para realizar uma recupera√ß√£o de frase exata, essas frases devem ser codificadas no √≠ndice invertido ou implementadas de modo diferente (com posi√ß√µes relativas de ocorr√™ncias de palavra nos documentos). Uma consulta de frase consiste em uma sequ√™ncia de palavras que comp√µem uma frase. A frase geralmente √© delimitada por aspas. Cada documento recuperado precisa  conter  pelo  menos  uma  ocorr√™ncia  da  frase exata. A consulta de frase √© uma vers√£o mais restrita e espec√≠fica da pesquisa por proximidade, que mencionamos a seguir. Por exemplo, uma consulta por pesquisa de frase poderia ser 'projeto conceitual banco de dados'. Se as frases forem indexadas pelo modelo de recupera√ß√£o,  qualquer  modelo  de  recupera√ß√£o  pode ser usado para esses tipos de consulta. Um tesauro de frases tamb√©m pode ser usado nos modelos sem√¢nticos para uma r√°pida pesquisa de frases em dicion√°rio.

## 27.3.4 Consultas por proximidade

A consulta por proximidade considera a proximidade  em  um  registro  com  que  m√∫ltiplos  termos devem estar um do outro. A op√ß√£o de consulta por proximidade mais utilizada √© uma consulta de frase que requer que os termos estejam na ordem exata. Outros operadores de proximidade podem especificar a proximidade com que os termos devem estar uns dos outros. Alguns tamb√©m especificar√£o a ordem dos termos de pesquisa. Cada mecanismo de pesquisa pode

definir operadores de proximidade de forma diferente, e  os  mecanismos de pesquisa utilizam v√°rios nomes de operador, como NEAR (pr√≥ximo), ADJ (adjacente) ou AFTER (depois). Em alguns casos, √© dada uma sequ√™ncia de palavras isoladas, junto com uma dist√¢ncia m√°xima permitida entre elas. Os modelos de espa√ßo de vetor, que tamb√©m mant√™m informa√ß√µes sobre posi√ß√µes e deslocamentos de tokens (palavras), possuem implementa√ß√µes robustas para esse tipo de consulta. Contudo, oferecer suporte para operadores de proximidade complexos torna-se computacionalmente dispendioso, pois requer o pr√©-processamento demorado dos documentos, e assim √© mais adequado para cole√ß√µes de documentos menores, e n√£o para a Web.

## 27.3.5 Consultas por curinga

A  consulta  por  curinga  em  geral  significa  dar suporte a express√µes regulares e √† pesquisa baseada em combina√ß√£o de padr√µes no texto. Em sistemas de RI, certos tipos de suporte para consulta por curinga podem ser implementados - normalmente, palavras com caracteres iniciais (por exemplo, 'data √© ' recuperaria data , database , datapoint , dataset etc.). Fornecer suporte para consultas por curinga em sistemas de RI envolve o overhead do pr√©-processamento, e o custo n√£o √© considerado compensador por muitos mecanismos de pesquisa na Web de hoje. Os modelos de recupera√ß√£o n√£o oferecem suporte direto para esse tipo de consulta.

## 27.3.6 Consultas em linguagem natural

Existem alguns mecanismos de consulta em linguagem natural que visam a entender a estrutura e o  significado  das  consultas  escritas  com  texto  em linguagem natural, geralmente como uma pergunta ou narrativa. Essa √© uma √°rea de pesquisa ativa, que emprega t√©cnicas como an√°lise sem√¢ntica superficial do texto, ou reformula√ß√µes de consulta com base no conhecimento da linguagem natural. O sistema tenta formular  respostas  para  tais  consultas  baseando-se nos resultados recuperados. Alguns sistemas de consulta est√£o come√ßando a oferecer interfaces de linguagem natural para fornecer respostas a tipos espec√≠ficos de perguntas, como as de defini√ß√£o e fatos interessantes,  que  pedem as defini√ß√µes de termos t√©cnicos ou fatos comuns que podem ser recuperados de bancos de dados especializados. Essas perguntas costumam ser mais f√°ceis de responder porque existem padr√µes lingu√≠sticos fortes que oferecem dicas para tipos espec√≠ficos de senten√ßas - por exemplo, 'definido como' ou 'refere-se a'. Os modelos sem√¢nticos podem oferecer suporte para esse tipo de consulta.

17 Para mais detalhes, consulte Croft et al. (2009), p√°ginas 75-90.

## 27.4 Pr√©-processamento de textos

Nesta se√ß√£o, analisamos as t√©cnicas de pr√©-processamento de textos mais usadas que fazem parte da tarefa de processamento de textos da Figura 27.1.

## 27.4.1 Remo√ß√£o da stopword

Stopwords s√£o muito utilizadas em um idioma e desempenham um papel importante na forma√ß√£o de uma senten√ßa, mas raramente contribuem para o significado dessa senten√ßa. Palavras que se espera que ocorram em 80 por cento ou mais dos documentos em uma cole√ß√£o costumam ser chamadas de stopwords , e elas se tornam potencialmente in√∫teis. Por serem muito comuns e devido √† fun√ß√£o dessas palavras, elas n√£o contribuem muito para a relev√¢ncia de um documento para uma pesquisa. Alguns exemplos (em ingl√™s) s√£o palavras como the , of , to , a , and , in , said , for , that , was , on , he , is , with , at , by , e it . Essas palavras s√£o apresentadas aqui com uma frequ√™ncia  de  ocorr√™ncia  decrescente,  vindas  de  um grande corpo de documentos, chamado AP89 . 17 As seis primeiras dessas palavras s√£o respons√°veis por 20 por cento de todas as palavras na listagem, e as 50 palavras mais frequentes s√£o respons√°veis por 40 por cento de todo o texto.

A remo√ß√£o de stopwords de um documento deve ser realizada antes da indexa√ß√£o. Artigos, preposi√ß√µes, conjun√ß√µes e alguns pronomes geralmente s√£o classificados como stopwords. As consultas tamb√©m devem ser  pr√©-processadas  para  remo√ß√£o  de  stopword  antes do processo de recupera√ß√£o real. A remo√ß√£o de stopwords resulta na elimina√ß√£o de poss√≠veis √≠ndices falsos, reduzindo assim o tamanho de uma estrutura de √≠ndice em cerca de 40 por cento ou mais. Contudo, isso poderia afetar  a  pesquisa  se  a  stopword  for  parte  integral  de uma consulta (por exemplo, uma pesquisa pela frase 'Ser  ou  n√£o  ser',  onde  a  remo√ß√£o  de  stopwords  torna a consulta impr√≥pria, pois todas elas na frase s√£o stopwords). Muitos mecanismos de pesquisa n√£o empregam a remo√ß√£o de stopword na consulta por esse motivo.

## 27.4.2 Ra√≠zes

A raiz de uma palavra √© definida como a palavra obtida depois de remover o sufixo e o prefixo de uma palavra original. Por exemplo, 'comput' √© a palavra raiz  para computador , computa√ß√£o e computadorizado .  Esses  sufixos  e  prefixos  s√£o  muito comuns no idioma portugu√™s, para dar suporte √† no√ß√£o de verbos, tempos e formas no plural. As ra√≠zes reduzem as diferentes formas da palavra formada por inflex√£o (devido a plurais e tempos) e deriva√ß√£o a uma raiz comum.

Um algoritmo de raiz pode ser aplicado para reduzir qualquer palavra a sua raiz. Em ingl√™s, o algoritmo de raiz mais famoso √© o de Martin Porter. O Porter stemmer 18  √© uma vers√£o simplificada da t√©cnica de Lovin que usa um conjunto reduzido de cerca de 60 regras (dos 260 padr√µes de sufixo da t√©cnica de Lovin) e as organiza em conjuntos; conflitos em um subconjunto de regras s√£o resolvidos antes de passar para o seguinte. O uso de ra√≠zes para o pr√©-processamento de dados resulta em uma diminui√ß√£o no tamanho da estrutura de indexa√ß√£o e em um aumento na revoca√ß√£o, possivelmente no custo da precis√£o.

## 27.4.3 Utilizando um tesauro

Um tesauro compreende uma lista pr√©-compilada de conceitos importantes e a palavra principal que descreve cada conceito para determinado dom√≠nio de conhecimento. Para cada conceito nessa lista, um conjunto de sin√¥nimos e palavras relacionadas tamb√©m √© compilado. 19 Assim, um sin√¥nimo pode ser convertido para seu conceito correspondente durante o pr√©-processamento. Essa etapa de pr√©-processamento auxilia no fornecimento de um vocabul√°rio padr√£o para indexa√ß√£o e pesquisa.

O uso de um tesauro, tamb√©m conhecido como uma cole√ß√£o de sin√¥nimos , tem um impacto substancial sobre a revoca√ß√£o dos sistemas de informa√ß√£o. Esse processo pode ser complicado porque muitas palavras possuem significados diferentes em variados contextos.

- O UMLS 20 √©  um  grande  tesauro  biom√©dico  com milh√µes de conceitos (chamado Metathesaurus ) e uma rede sem√¢ntica de metaconceitos e relacionamentos que organizam o Metathesaurus (ver Figura 27.3). Os conceitos recebem r√≥tulos da rede sem√¢ntica. Esse tesauro de conceitos cont√©m sin√¥nimos de termos m√©dicos, hierarquias de termos mais amplos e mais estritos, e outros relacionamentos entre palavras e conceitos, que o tornam um recurso muito extenso para recupera√ß√£o de informa√ß√µes de documentos no dom√≠nio m√©dico. A Figura 27.3 ilustra parte da UMLS Semantic Network.
- O WordNet 21 √©  um  tesauro  constru√≠do  manualmente, que agrupa palavras em conjuntos de sin√¥nimos estritos, chamados synsets . Esses synsets s√£o divididos em categorias de substantivo, verbo, adjetivo e adv√©rbio. Em cada categoria, tais synsets s√£o vinculados por relacionamentos  apropriados,  como  classe/subclasse ou relacionamentos '√©-um' para substantivos.

Figura 27.3



Uma parte da UMLS Semantic Network: hierarquia 'Fun√ß√£o biol√≥gica'.

Fonte : UMLS Reference Manual, National Library of Medicine.

18 Ver Porter (1980).

19 Ver Baeza-Yates e Ribeiro-Neto (1999).

20 Unified Medical Language System da National Library of Medicine.

21 Ver em Fellbaum (1998) uma descri√ß√£o detalhada do WordNet.

O WordNet est√° baseado na ideia de uso de um vocabul√°rio controlado para indexa√ß√£o, eliminando assim as redund√¢ncias. Ele tamb√©m √© √∫til para oferecer assist√™ncia a usu√°rios com a localiza√ß√£o de termos para uma formula√ß√£o de consulta apropriada.

## 27.4.4 Outras etapas de pr√©-processamento: d√≠gitos, h√≠fens, sinais de pontua√ß√£o, mai√∫sculas/min√∫sculas

D√≠gitos, datas, n√∫meros de telefone, endere√ßos de e-mail, URLs e outros tipos padr√£o de texto podem ou n√£o ser removidos durante o pr√©-processamento. Mecanismos de busca da Web, por√©m, os indexam a fim de usar esse tipo de informa√ß√£o nos metadados do documento, para melhorar a precis√£o e a revoca√ß√£o (veja na Se√ß√£o 27.6 defini√ß√µes detalhadas de precis√£o e revoca√ß√£o ).

H√≠fens e sinais de pontua√ß√£o podem ser tratados de maneiras diferentes. A frase inteira pode ser usada com os h√≠fens/sinais de pontua√ß√£o, ou ent√£o eles podem ser eliminados. Em alguns sistemas, o caractere que representa o h√≠fen/sinal de pontua√ß√£o pode ser removido, ou pode ser substitu√≠do por um espa√ßo. Diferentes  sistemas  de  recupera√ß√£o  de  informa√ß√µes seguem  diferentes  regras  de  processamento.  Tratar de h√≠fens de maneira autom√°tica pode ser complexo: pode ser feito como um problema de classifica√ß√£o ou, mais comumente, por algumas regras heur√≠sticas.

A maioria dos sistemas de recupera√ß√£o de informa√ß√µes realiza pesquisa sem considerar mai√∫sculas/ min√∫sculas,  convertendo  todas  as  letras  do  texto para mai√∫sculas ou min√∫sculas. Tamb√©m √© preciso observar que muitas dessas etapas de processamento de textos s√£o espec√≠ficas da linguagem, como aquelas que envolvem acentos e diacr√≠ticos, e as idiossincrasias que est√£o associadas a determinado idioma.

## 27.4.5 Extra√ß√£o de informa√ß√µes

A extra√ß√£o  de  informa√ß√µes (IE  -  Information Extraction) √© um termo gen√©rico usado para extrair conte√∫do  estruturado  do  texto.  Tarefas  anal√≠ticas de texto, como identificar frases substantivas, fatos, eventos, pessoas, lugares e relacionamentos s√£o exemplos de tarefas de IE. Essas tarefas tamb√©m s√£o chamadas  de tarefas  nomeadas  de  reconhecimento  de entidade e usam abordagens baseadas em regra com um  tesauro,  express√µes  regulares  e  gram√°ticas,  ou t√©cnicas probabil√≠sticas. Para RI e aplica√ß√µes de pesquisa, as tecnologias de IE s√£o usadas principalmente para identificar recursos contextualmente relevantes, que envolvem an√°lise de texto, combina√ß√£o e categoriza√ß√£o para melhorar a relev√¢ncia dos sistemas de pesquisa. As tecnologias da linguagem que utilizam marca√ß√£o de parte da voz s√£o aplicadas para anotar semanticamente os documentos com recursos extra√≠dos e auxiliar a relev√¢ncia da pesquisa.

## 27.5 ndexa√ß√£o invertida I

A forma mais simples de procurar ocorr√™ncias de termos de consulta em cole√ß√µes de texto pode ser realizada  ao  varrer  o  texto  sequencialmente.  Esse tipo de consulta on-line s√≥ √© apropriado quando cole√ß√µes de texto s√£o muito pequenas. A maioria dos sistemas de recupera√ß√£o de informa√ß√µes processa as cole√ß√µes de texto para criar √≠ndices e operar sobre a estrutura de dados de √≠ndice invertido (consulte a tarefa de indexa√ß√£o na Figura 27.1). Uma estrutura de √≠ndice invertido compreende informa√ß√µes de vocabul√°rio e documento. Vocabul√°rio √© um conjunto de termos de consulta distintos no conjunto de documentos. Cada termo em um conjunto de vocabul√°rio tem uma cole√ß√£o associada de informa√ß√µes sobre os documentos que cont√™m o termo, como id de documento, contagem de ocorr√™ncia e deslocamentos no documento em que o termo ocorre. A forma mais simples de termos de vocabul√°rio consiste em palavras de tokens individuais dos documentos. Em alguns casos, esses termos de vocabul√°rio tamb√©m consistem em frases, n -gramas, entidades, links, nomes, datas ou termos descritores atribu√≠dos manualmente com base em documentos e/ou p√°ginas Web. Para cada termo no vocabul√°rio, as ids de documento correspondentes, locais e n√∫mero de ocorr√™ncias do termo em cada documento e outras informa√ß√µes relevantes podem ser armazenados na se√ß√£o de informa√ß√µes do documento.

Pesos s√£o atribu√≠dos a termos do documento para  representar  uma  estimativa  da  utilidade  de determinado termo como um descritor para distinguir um documento de outros na mesma cole√ß√£o. Um termo pode ser um descritor melhor de um documento do que de outro, pelo processo de pesos (ver Se√ß√£o 27.2).

Um √≠ndice invertido de uma cole√ß√£o de documentos √© uma estrutura de dados que anexa termos distintos a uma lista de todos os documentos que cont√™m o termo. O processo de constru√ß√£o de √≠ndice invertido envolve as etapas de extra√ß√£o e processamento mostradas na Figura 27.2. O texto adquirido √© primeiro pr√©-processado e os documentos s√£o representados com os termos do vocabul√°rio. As estat√≠sticas dos documentos s√£o coletadas em tabelas de pesquisa de documento. Elas geralmente incluem contadores de termos de vocabul√°rio em documentos individuais, bem como diferentes cole√ß√µes, suas posi√ß√µes de ocorr√™ncia nos documentos e os tamanhos destes. Os termos do vocabul√°rio s√£o pesados em tempo de indexa√ß√£o, de acordo com dife-

rentes crit√©rios para cole√ß√µes. Por exemplo, em alguns casos, os termos nos t√≠tulos dos documentos podem ter peso maior do que os termos que ocorrem em outras partes dos documentos.

Um dos esquemas de peso mais populares √© a m√©trica  TF-IDF  ( term  frequency-inverse  document  frequency ) que foi descrita na Se√ß√£o 27.2. Para determinado termo, esse esquema de peso distingue at√© certo ponto os documentos em que o termo ocorre com mais frequ√™ncia daqueles em que o termo ocorre muito pouco ou nunca. Esses pesos s√£o normalizados para considerar tamanhos de documento vari√°veis, garantindo ainda mais que os documentos maiores, proporcionalmente com mais ocorr√™ncias de uma palavra, n√£o sejam favorecidos para recupera√ß√£o em rela√ß√£o a documentos menores,  com  ocorr√™ncias  proporcionalmente  menores.  Esses  fluxos  (matrizes)  de  documento-termo processados s√£o ent√£o invertidos para fluxos (matrizes) de termo-documento, para outras etapas de RI.

A Figura 27.4 mostra uma ilustra√ß√£o dos vetores de  termo-documento-posi√ß√£o  para  os  quatro  termos ilustrativos exemplo , invertido , √≠ndice e mercado -que se referem aos tr√™s documentos e √† posi√ß√£o em que ocorrem nesses documentos.

As  diferentes  etapas  envolvidas  na  constru√ß√£o do √≠ndice invertido podem ser resumidas da seguinte forma:

- 1. Divida os documentos em termos de vocabul√°rio  ao  criar  tokens,  limpar,  remover stopwords,  definir  a  raiz  e/ou  usar  um  tesauro adicional como vocabul√°rio.
- 2. Re√∫na estat√≠sticas de documento e armazene-as em uma tabela de pesquisa de documento.
- 3. Inverta  o  fluxo  documento-termo  para  um fluxo termo-documento, junto com informa√ß√µes adicionais como frequ√™ncias, posi√ß√µes e pesos de termo.

A pesquisa por documentos relevantes com base no √≠ndice invertido, dado um conjunto de termos de consulta, geralmente √© um processo em tr√™s etapas.

- 1. Pesquisa de vocabul√°rio. Se a consulta compreende m√∫ltiplos termos, eles s√£o separados e tratados como termos independentes. Cada termo  √©  pesquisado  no  vocabul√°rio.  Diversas  estruturas  de  dados,  como  varia√ß√µes  da B + -tree  ou  hashing,  podem  ser  usadas  para



|   ID | Termo     | Posi√ß¬™o do documento   |
|------|-----------|------------------------|
|    1 | exemplo   | 1:2, 1:5               |
|    2 | invertido | 1:8, 2:2               |
|    3 | √≠ndice    | 1:7, 2:1, 3:1          |
|    4 | mercado   | 3:5, 3:13              |

- otimizar o processo de pesquisa. Termos de consulta tamb√©m podem ser organizados em ordem lexicogr√°fica para melhorar a efici√™ncia do espa√ßo.
- 2. Recupera√ß√£o de informa√ß√µes do documento. As informa√ß√µes do documento para cada termo s√£o recuperadas.
- 3. Manipula√ß√£o  de  informa√ß√µes  recuperadas. O vetor de informa√ß√µes do documento para cada termo obtido na etapa 2 agora √© processado ainda mais para incorporar diversas formas de l√≥gica da consulta. V√°rios tipos de consultas,  como consultas de prefixo, intervalo,  contexto  e  proximidade  s√£o  processados  nesta  etapa  para  construir  o  resultado final  com  base  nas  cole√ß√µes  de  documentos retornadas na etapa 2.

## 27.6 Medidas de avalia√ß√£o de relev√¢ncia da pesquisa

Sem t√©cnicas de avalia√ß√£o apropriadas n√£o se pode comparar e medir a relev√¢ncia de diferentes modelos  de  recupera√ß√£o  e  sistemas  de  RI  a  fim de fazer melhorias. As t√©cnicas de avalia√ß√£o dos sistemas de RI medem a relev√¢ncia t√≥pica e a relev√¢ncia do usu√°rio . A relev√¢ncia t√≥pica mede a extens√£o √† qual o t√≥pico de um resultado combina com o t√≥pico da consulta. O mapeamento da necessidade de informa√ß√£o de algu√©m com consultas 'perfeitas' √© uma tarefa cognitiva, e muitos usu√°rios n√£o s√£o capazes de efetivamente formar consultas que recuperem resultados mais adequados a sua necessidade de informa√ß√£o. Al√©m disso, como uma parte importante das consultas do usu√°rio √© informativa por natureza, n√£o existe um conjunto fixo de respostas corretas para mostrar ao usu√°rio. A relev√¢ncia do usu√°rio √© um termo utilizado para descrever a 'virtude' de um resultado recuperado com rela√ß√£o √† necessidade de informa√ß√£o do usu√°rio. A relev√¢ncia do usu√°rio inclui outros fatores impl√≠citos, como sua percep√ß√£o, o contexto, o senso de oportunidade, o ambiente do usu√°rio e as necessidades da tarefa atual. A avalia√ß√£o da relev√¢ncia do usu√°rio tamb√©m pode envolver a an√°lise subjetiva e o estudo das tarefas de recupera√ß√£o do usu√°rio, a fim de capturar algumas das propriedades dos fatores impl√≠citos envolvidos na considera√ß√£o da percep√ß√£o dos usu√°rios para julgar o desempenho.

Na recupera√ß√£o de informa√ß√µes da Web, nenhuma  decis√£o  de  classifica√ß√£o  bin√°ria  √©  feita sobre  se  um  documento  √©  relevante  ou  n√£o  para uma consulta (enquanto o modelo de recupera√ß√£o booleano, ou bin√°rio, usa esse esquema, conforme discutimos  na  Se√ß√£o  27.2.1).  Ao  contr√°rio,  uma pontua√ß√£o  dos  documentos  √©  produzida  para  o usu√°rio.  Portanto,  algumas  medidas  de  avalia√ß√£o focalizam a compara√ß√£o de diferentes pontua√ß√µes produzidas  por  sistemas  de  RI.  Discutimos  algumas dessas medidas em seguida.

## 27.6.1 Revoca√ß√£o e precis√£o

M√©tricas de revoca√ß√£o e precis√£o s√£o baseadas na suposi√ß√£o de relev√¢ncia bin√°ria (se cada documento √© relevante ou n√£o para a consulta). A revoca√ß√£o √© definida como o n√∫mero de documentos relevantes recuperados por uma pesquisa dividido pelo n√∫mero total de documentos relevantes existentes.  A precis√£o √©  definida  como  o  n√∫mero  de documentos relevantes recuperados por uma pesquisa  dividido  pelo  n√∫mero  total  de  documentos recuperados  por  essa  pesquisa.  A  Figura  27.5  √© uma representa√ß√£o gr√°fica dos termos recuperado e relevante , mostrando como os resultados da pesquisa se relacionam com quatro conjuntos diferentes de documentos.

A nota√ß√£o para a Figura 27.5 √© a seguinte:

- ¬Ñ VP: verdadeiro positivo.
- ¬Ñ FP: falso positivo.
- ¬Ñ FN: falso negativo.
- ¬Ñ VN: verdadeiro negativo.

Os termos verdadeiro positivo, falso positivo, falso  negativo e verdadeiro  negativo costumam ser usados em qualquer tipo de tarefas de classifica√ß√£o para comparar determinada classifica√ß√£o de um item com a classifica√ß√£o correta desejada.

Figura 27.5



Resultados de pesquisa recuperados versus relevantes.

Usando o termo acertos para os documentos que verdadeiramente ou 'corretamente' correspondem √† solicita√ß√£o do usu√°rio, podemos definir:

## Revoca√ß√£o = |Acertos|/|Relevantes| Precis√£o = |Acertos|/|Recuperados|

Revoca√ß√£o e precis√£o tamb√©m podem ser definidas em um ambiente de recupera√ß√£o pontuada. A revoca√ß√£o na posi√ß√£o de pontua√ß√£o   para o documento i d c i (indicada por  ( )) ( r i d c i √© o documento recuperado na posi√ß√£o   para a consulta i c ) √© a fra√ß√£o de documentos relevantes de d c 1 a d c i no conjunto de resultados para a consulta. Considere o conjunto de documentos relevantes de d c 1 a d c i nesse conjunto como sendo S i com cardinalidade | S i |.  Considere que (| Dc |  seja  o  tamanho dos documentos relevantes para a consulta. Nesse caso, | S i | ‚â§ | Dc |). Ent√£o:

## Revoca√ß√£o r i ( ) = | S i |/| Dc |

A precis√£o na posi√ß√£o de pontua√ß√£o   ou docui mento d c i (indicada por p i ( )) √© a fra√ß√£o dos documentos de d c 1 a d c i no conjunto de resultados que s√£o relevantes:

## Precis√£o p i ( ) = | S i |/ i

A Tabela 27.2 ilustra as m√©tricas de p i ( ), r i ( )  e  a precis√£o m√©dia (a ser discutida na pr√≥xima se√ß√£o). V√™-se que a revoca√ß√£o pode ser aumentada ao apresentar mais  resultados  ao  usu√°rio,  mas  essa  t√©cnica  corre  o

Tabela 27.2

Precis√£o e revoca√ß√£o para a recupera√ß√£o pontuada.

|   Doc. n√∫mero |   Posi√ß√£o de pontua√ß√£o i | Relevante   | Precis√£o( i )   | Revoca√ß√£o( i )   |
|---------------|--------------------------|-------------|-----------------|------------------|
|            10 |                        1 | Sim         | 1/1 = 100%      | 1/10 = 10%       |
|             2 |                        2 | Sim         | 2/2 = 100%      | 2/10 = 20%       |
|             3 |                        3 | Sim         | 3/3 = 100%      | 3/10 = 30%       |
|             5 |                        4 | N√£o         | 3/4 = 75%       | 3/10 = 30%       |
|            17 |                        5 | N√£o         | 3/5 = 60%       | 3/10 = 30%       |
|            34 |                        6 | N√£o         | 3/6 = 50%       | 3/10 = 30%       |
|           215 |                        7 | Sim         | 4/7 = 57,1%     | 4/10 = 40%       |
|            33 |                        8 | Sim         | 5/8 = 62,5%     | 5/10 = 50%       |
|            45 |                        9 | N√£o         | 5/9 = 55,5%     | 5/10 = 50%       |
|            16 |                       10 | Sim         | 6/10 = 60%      | 6/10 = 60%       |

risco de diminuir a precis√£o. No exemplo, o n√∫mero de documentos relevantes para alguma consulta = 10. A posi√ß√£o de pontua√ß√£o e a relev√¢ncia de um documento individual s√£o mostradas. Os valores de precis√£o e revoca√ß√£o podem ser calculados em cada posi√ß√£o dentro da lista pontuada, como mostram as duas √∫ltimas colunas.

## 27.6.2 Precis√£o m√©dia

A precis√£o m√©dia √© calculada com base na precis√£o  em  cada  documento  relevante  na  pontua√ß√£o. Essa medida √© √∫til para calcular um √∫nico valor de precis√£o ao comparar diferentes algoritmos de recupera√ß√£o em uma consulta  . c

<!-- formula-not-decoded -->

Considere os valores de precis√£o de exemplo dos documentos  relevantes  da  Tabela  27.2.  A  precis√£o m√©dia (valor de P med ) para o exemplo da Tabela 27.2 √© P (1) + P (2) + P (3) + P (7) + P (8) + P (10)/6 = 79,93 por cento (somente documentos relevantes s√£o considerados nesse c√°lculo). Muitos algoritmos bons tendem a ter alta precis√£o m√©dia dos k primeiros para valores pequenos de k, com valores correspondentemente baixos de revoca√ß√£o.

## 27.6.3 Curva de revoca√ß√£o/precis√£o

Uma curva de revoca√ß√£o/precis√£o pode ser desenhada com base nos valores de precis√£o e revoca√ß√£o

em cada posi√ß√£o de pontua√ß√£o, onde o eixo x √© a revoca√ß√£o e o eixo y √© a precis√£o. Em vez de usar a precis√£o e a revoca√ß√£o em cada posi√ß√£o de pontua√ß√£o, a curva com frequ√™ncia √© desenhada usando n√≠veis de revoca√ß√£o  ( ) em 0 por cento, 10 por cento, 20 por cento... r i 100 por cento. A curva normalmente tem uma inclina√ß√£o  negativa,  refletindo  o  relacionamento  inverso entre precis√£o e revoca√ß√£o.

## 27.6.4 -Score F

F-score ( F ) √© a m√©dia harm√¥nica dos valores de precis√£o ( p ) e revoca√ß√£o ( ). A alta precis√£o √© alcanr √ßada quase sempre √† custa da revoca√ß√£o e vice-versa. Essa √© uma quest√£o de contexto da aplica√ß√£o sobre ajustar o sistema para alta precis√£o ou alta revoca√ß√£o. F-score √© uma √∫nica medida que combina precis√£o e revoca√ß√£o para comparar diferentes conjuntos de resultados:

<!-- formula-not-decoded -->

Uma  das  propriedades  da  m√©dia  harm√¥nica  √© que aquela de dois n√∫meros tende a ser mais pr√≥xima da menor das duas. Assim, F √© automaticamente enviesado para o menor entre os valores de precis√£o e revoca√ß√£o. Portanto, para um F-score alto, a precis√£o e a revoca√ß√£o devem ser altas.

<!-- formula-not-decoded -->

## 27.7 Pesquisa e an√°lise na Web 22

O surgimento da Web levou milh√µes de usu√°rios a procurar informa√ß√µes, que s√£o armazenadas em um n√∫mero muito grande de sites ativos. Para tornar essas informa√ß√µes acess√≠veis, mecanismos de busca como Google e Yahoo! precisam sondar e indexar esses sites e documentar cole√ß√µes em seus bancos de dados de √≠ndice. Al√©m do mais, os mecanismos de busca precisam regularmente  atualizar  seus  √≠ndices  dada  a  natureza din√¢mica da Web √† medida que novos sites web s√£o criados e os atuais s√£o atualizados ou exclu√≠dos. Como existem muitas milh√µes de p√°ginas dispon√≠veis na Web sobre diferentes t√≥picos, os mecanismos de busca precisam aplicar diversas t√©cnicas sofisticadas, como an√°lise de link, para identificar a import√¢ncia das p√°ginas.

al√©m  daqueles  que  regularmente  sondam  a  Web  e criam √≠ndices autom√°ticos: estes s√£o mecanismos de busca verticais, operados por humanos, ou mecanismos de metabusca. S√£o desenvolvidos com a ajuda de sistemas auxiliados por computador para ajudar os curadores com o processo de atribuir √≠ndices. Eles consistem em diret√≥rios Web especializados criados manualmente, que s√£o organizados de maneira hier√°rquica,  para  guiar  a  navega√ß√£o  do  usu√°rio  a  diferentes recursos na Web. Os mecanismos de busca verticais s√£o mecanismos personalizados, espec√≠ficos do t√≥pico, que sondam e indexam uma cole√ß√£o espec√≠fica de documentos na Web e oferecem resultados de  busca  dessa  cole√ß√£o  espec√≠fica. Mecanismos  de metabusca s√£o criados em cima dos mecanismos de busca: eles consultam diferentes mecanismos de busca simultaneamente, agregam e oferecem resultados de busca dessas fontes.

Outra fonte de documentos Web pesquis√°veis s√£o as bibliotecas digitais. Bibliotecas digitais podem ser definidas de modo geral como cole√ß√µes de recursos e servi√ßos eletr√¥nicos para a entrega de materiais em uma s√©rie de formatos. Essas cole√ß√µes podem incluir o cat√°logo da biblioteca de uma universidade, os cat√°logos de um grupo de universidades participantes no State of Florida University System, ou uma compila√ß√£o de v√°rios recursos externos na World Wide Web, como o Google Scholar ou o √≠ndice IEEE/ACM. Essas interfaces oferecem acesso universal a diferentes tipos de conte√∫do - como livros,  artigos,  √°udios  e  v√≠deos  -  situados  em  v√°rios sistemas de banco de dados e reposit√≥rios remotos. Semelhantes a bibliotecas reais, essas cole√ß√µes digitais s√£o mantidas por meio de um cat√°logo e organizadas em categorias  para  refer√™ncia  on-line.  Bibliotecas  digitais 'incluem cole√ß√µes pessoais, distribu√≠das e centralizadas, como cat√°logos de acesso p√∫blico on-line ( OPACs -On-line Public Access Catalogs) e bancos de dados bibliogr√°ficos, bancos de dados de documentos distribu√≠dos, listas acad√™micas e de discuss√£o profissional e jornais eletr√¥nicos, outros bancos de dados on-line, f√≥runs e quadros de avisos'. 23

## 27.7.1 An√°lise da Web e seu relacionamento com a recupera√ß√£o de informa√ß√µes

Existem  outros  tipos  de  mecanismos  de  busca

Al√©m da navega√ß√£o e busca na Web, outra atividade importante, bastante relacionada com a recupera√ß√£o de informa√ß√µes, √© analisar ou extrair informa√ß√µes na Web para novas informa√ß√µes de interesse. (Discutiremos a minera√ß√£o de dados baseada em arquivos e bancos de dados no Cap√≠tulo 28.) A aplica-

22 Agradecemos as contribui√ß√µes de Pranesh P. Ranganathan e Hari P . Kumar para esta se√ß√£o.

23 Covi e Kling (1996), p√°gina 672.

√ß√£o de t√©cnicas de an√°lise de dados para descoberta e an√°lise de informa√ß√µes √∫teis da Web √© conhecida como an√°lise  da  Web .  Durante  os  √∫ltimos  anos,  a World Wide Web surgiu como um reposit√≥rio importante de informa√ß√µes para muitas aplica√ß√µes do dia a dia para consumidores individuais, bem como uma plataforma significativa para com√©rcio eletr√¥nico (e-commerce) e redes sociais. Essas propriedades a tornam um alvo interessante para aplica√ß√µes de an√°lise de dados. O campo de minera√ß√£o e an√°lise da Web √© uma integra√ß√£o de uma grande gama de campos que se espalham por recupera√ß√£o de informa√ß√µes, an√°lise de texto, processamento em linguagem natural, minera√ß√£o de dados, aprendizado de m√°quina e an√°lise estat√≠stica.

Os objetivos da an√°lise da Web s√£o melhorar e personalizar a relev√¢ncia dos resultados de pesquisa e identificar tend√™ncias que possam ser valiosas para diversas empresas e organiza√ß√µes. Elaboramos esses objetivos a seguir.

- ¬Ñ Encontrando informa√ß√µes relevantes. As pessoas normalmente procuram informa√ß√µes espec√≠ficas na Web inserindo palavras-chave em  um  mecanismo  de  busca  ou  navegando por portais de informa√ß√£o e usando servi√ßos. Os  servi√ßos  de  pesquisa  s√£o  restritos  pelos problemas  de  relev√¢ncia  de  pesquisa,  pois precisam mapear e aproximar a necessidade de informa√ß√£o de milh√µes de usu√°rios como uma tarefa a priori . Ocorre uma baixa precis√£o (ver Se√ß√£o 27.6) por causa dos resultados que n√£o s√£o relevantes ao usu√°rio. No caso da Web, a alta revoca√ß√£o (ver Se√ß√£o 27.6) √© imposs√≠vel de se determinar devido √† incapacidade de indexar todas as p√°ginas na Web. Al√©m disso, a medi√ß√£o da revoca√ß√£o n√£o faz sentido,  pois  o  usu√°rio  se  preocupa  apenas com os poucos documentos do topo. O feedback mais relevante para o usu√°rio costuma ser apenas o dos primeiros resultados.
- ¬Ñ Personaliza√ß√£o da informa√ß√£o. Diferentes pessoas t√™m prefer√™ncias distintas de conte√∫do e apresenta√ß√£o. Ao coletar informa√ß√µes pessoais e depois gerar p√°ginas Web din√¢micas espec√≠ficas do usu√°rio, as p√°ginas s√£o personalizadas para ele. As ferramentas de personaliza√ß√£o usadas em diversas aplica√ß√µes baseadas na Web e servi√ßos, como a monitora√ß√£o por  meio  de  clique,  rastreamento  de  globo ocular, aprendizado do perfil de usu√°rio expl√≠cito ou impl√≠cito e composi√ß√£o de servi√ßo din√¢mico usando APIs da Web, s√£o utilizados para adapta√ß√£o e personaliza√ß√£o de servi√ßo. Um mecanismo de  personaliza√ß√£o  em  geral
- tem algoritmos que utilizam a informa√ß√£o de personaliza√ß√£o  do  usu√°rio  -  coletada  por v√°rias  ferramentas  -  para  gerar  resultados de pesquisa espec√≠ficos dele.
- ¬Ñ Encontrando informa√ß√µes de valor comercial. Esse problema lida com a descoberta de padr√µes nos interesses dos usu√°rios, comportamentos e seu uso de produtos e servi√ßos, que pode  ser  de  valor  comercial.  Por  exemplo, empresas como a ind√∫stria automobil√≠stica, de vestu√°rio, sapatos e cosm√©ticos podem melhorar seus servi√ßos ao identificar padr√µes como tend√™ncias  de  uso  e  prefer√™ncias  do  usu√°rio, com diversas t√©cnicas de an√°lise da Web.

Com base nesses objetivos, podemos classificar a an√°lise da Web em tr√™s categorias: an√°lise de conte√∫do da Web , que lida com a extra√ß√£o de informa√ß√µes/ conhecimento √∫til do conte√∫do da p√°gina Web; an√°lise de estrutura da Web , que descobre conhecimento de hiperlinks que representam a estrutura da Web; e an√°lise de uso da Web ,  que  extrai  os  padr√µes  de acesso do usu√°rio de logs de uso que registram a atividade de cada usu√°rio.

## 27.7.2 Pesquisando na Web

A World Wide Web √© um imenso corpo de informa√ß√µes, mas a localiza√ß√£o de recursos que sejam de alta qualidade e relevantes √†s necessidades do usu√°rio √© muito dif√≠cil. O conjunto de p√°ginas Web tomadas como um todo quase n√£o possui uma estrutura unificada,  com  variabilidade  no  estilo  de  autoria  e conte√∫do, tornando assim mais dif√≠cil localizar com precis√£o  a  informa√ß√£o  necess√°ria.  Mecanismos  de busca baseados em √≠ndices t√™m sido uma das principais ferramentas pelas quais os usu√°rios procuram informa√ß√µes na Web. Mecanismos de busca na Web sondam a rede e criam um √≠ndice para fins de pesquisa. Quando um usu√°rio especifica sua necessidade de informa√ß√£o ao fornecer palavras-chave, esses mecanismos de busca na Web consultam seu reposit√≥rio de √≠ndices e produzem links ou URLs com conte√∫do abreviado como resultados de pesquisa. Pode haver milhares de p√°ginas relevantes a determinada consulta. Surge um problema quando somente alguns poucos resultados mais relevantes devem ser retornados ao usu√°rio. A discuss√£o que tivemos sobre consulta e pontua√ß√£o baseada em relev√¢ncia nos sistemas de RI, nas  se√ß√µes  27.2  e  27.3,  se  aplica  a  mecanismos  de busca na Web. Esses algoritmos de pontua√ß√£o exploram a estrutura de links da Web.

As p√°ginas Web, diferentemente das cole√ß√µes de texto-padr√£o, cont√™m conex√µes com outras p√°ginas Web ou documentos (por meio do uso de hiperlinks),

permitindo que os usu√°rios naveguem de uma p√°gina para outra. Um hiperlink tem dois componentes: uma p√°gina de destino e um texto de √¢ncora que descreve o link. Por exemplo, uma pessoa pode se vincular ao site do Yahoo! em sua p√°gina Web com um texto de √¢ncora como 'Meu site favorito na Web'. Os textos de √¢ncora podem ser imaginados como endossos impl√≠citos. Eles oferecem uma anota√ß√£o humana em potencial  muito  importante.  Sup√µe-se  que  uma pessoa que se vincula a outras p√°ginas Web de sua p√°gina Web tem alguma rela√ß√£o com essas p√°ginas. Os  mecanismos  de  busca  na  Web  visam  a  destilar resultados por sua relev√¢ncia e autoridade. Existem muitos hiperlinks redundantes, como os links para a p√°gina principal (homepage) em cada p√°gina Web de um site. Esses hiperlinks precisam ser eliminados dos resultados da busca pelos mecanismos de busca.

Um hub √© uma p√°gina Web ou um site que se vincula a uma cole√ß√£o de sites proeminentes (autoridades) sobre um assunto comum. Uma boa autoridade √© uma p√°gina que √© apontada por muitos bons hubs, enquanto um bom hub √© uma p√°gina que aponta para muitas boas autoridades. Essas ideias s√£o usadas pelo algoritmo de pontua√ß√£o HITS, que √© descrito na Se√ß√£o 27.7.3. Sabe-se que p√°ginas confi√°veis n√£o s√£o muito autodescritivas, e as autoridades em t√≥picos gerais raramente se vinculam de maneira direta umas √†s outras. Essas propriedades dos hiperlinks est√£o sendo usadas ativamente para melhorar a pontua√ß√£o de resultados do mecanismo de busca da Web e organiz√°-los como hubs  e  autoridades.  Discutimos  rapidamente  alguns dos algoritmos de pontua√ß√£o a seguir.

## 27.7.3 Analisando a estrutura de link das p√°ginas Web

O objetivo da an√°lise de estrutura da Web √©  gerar um resumo estrutural sobre o Website e as p√°ginas Web. Ela focaliza a estrutura interna dos documentos e lida com a estrutura de link usando hiperlinks entre documentos. A estrutura e conte√∫do das p√°ginas Web normalmente s√£o combinados para recupera√ß√£o de informa√ß√µes pelos mecanismos de busca na Web. Dada uma  cole√ß√£o  de  documentos  Web  interconectados, fatos interessantes e informativos descrevendo sua conectividade no subconjunto da Web podem ser descobertos. A an√°lise de estrutura da Web tamb√©m √© usada para revelar a estrutura das p√°ginas Web, que ajuda com a navega√ß√£o e possibilita a compara√ß√£o/integra√ß√£o de esquemas de p√°gina Web. Esse aspecto da an√°lise de estrutura da Web facilita a classifica√ß√£o de documentos da Web e o agrupamento com base na estrutura.

- O algoritmo  de  pontua√ß√£o PageRank . Conforme j√° discutimos, os algoritmos de pontua√ß√£o s√£o usados para ordenar resultados de busca com base na relev√¢ncia e autoridade. O Google usa o conhecido algoritmo PageRank , 24 que √© baseado na 'import√¢ncia' de cada p√°gina. Cada p√°gina Web tem uma s√©rie de links adiante (arestas de sa√≠da) e links de volta (arestas de entrada). √â muito dif√≠cil determinar todos os links de volta de uma p√°gina Web, ao passo que √© relativamente simples determinar seus links adiante. De acordo com o algoritmo PageRank, p√°ginas altamente vinculadas s√£o mais importantes (possuem maior autoridade) do que p√°ginas com menos links. No entanto, nem todos os links de volta s√£o importantes. Um link de volta a uma p√°gina de uma fonte confi√°vel √© mais importante do que um link de alguma fonte qualquer. Assim, uma p√°gina tem uma pontua√ß√£o alta se a soma dos pontos de seus links de volta for alta. O PageRank foi uma tentativa de ver com que facilidade uma aproxima√ß√£o da 'import√¢ncia' de uma p√°gina pode ser obtida da estrutura do link.

O c√°lculo  da  pontua√ß√£o  de  p√°gina  segue  uma t√©cnica iterativa. O PageRank de uma p√°gina Web √© calculado como uma soma dos PageRanks de todos os seus links de volta. O PageRank trata a Web como um modelo de Markov . Um navegador da Web imagin√°rio visita uma sequ√™ncia infinita de p√°ginas clicando aleatoriamente. O PageRank de uma p√°gina √© uma estimativa da frequ√™ncia com que o navegador entra em determinada p√°gina. Ele √© uma medida da import√¢ncia independente da consulta de uma p√°gina/n√≥. Por exemplo, considere que P X ( ) seja o PageRank de qualquer p√°gina X e C X ( ) seja o n√∫mero de links de sa√≠da da p√°gina X , e considere que d seja o fator de amortecimento no intervalo 0 &lt; d &lt; 1. Em geral, d √© definido  como  0,85.  Ent√£o,  o  PageRank  para  uma p√°gina A pode ser calculado como:

<!-- formula-not-decoded -->

Aqui, T 1, T 2, ..., Tn s√£o as p√°ginas que apontam para a P√°gina A (ou seja, s√£o cita√ß√µes para a p√°gina A ). O PageRank forma uma distribui√ß√£o de probabilidade sobre p√°ginas Web, de modo que a soma dos PageRanks de todas as p√°ginas Web seja um.

- O  algoritmo  de  pontua√ß√£o HITS . O  algoritmo HITS 25  proposto por Jon Kleinberg √© outro tipo de algoritmo de pontua√ß√£o que explora a estrutura de link da Web. O algoritmo presume que um bom hub √© um documento que aponta para muitos hubs , e uma boa autoridade √© um documento que √© apontado por muitas outras autoridades. O algoritmo cont√©m duas

24 O algoritmo PageRank foi proposto por Lawrence Page (1998) e Sergey Brin, fundadores do Google. Para obter mais informa√ß√µes, consulte &lt;http:// en.wikipedia.org/wiki/PageRank&gt;.

25 Ver Kleinberg (1999).

etapas principais: um componente de amostragem e um componente de propaga√ß√£o de peso. O componente de amostragem constr√≥i uma cole√ß√£o focalizada S de p√°ginas com as seguintes propriedades:

- 1. S √© relativamente pequena.
- 2. S √© rica em p√°ginas relevantes.
- 3. S cont√©m a maioria das autoridades mais fortes.
- O componente de peso  calcula  recursivamente os valores de hub e autoridade para cada documento da seguinte forma:
- 1. Inicializa  valores  de  hub  e  autoridade  para todas as p√°ginas em S ao defini-los como 1.
- 2. Enquanto (valores de hub e autoridade n√£o convergem):
- a. Para cada p√°gina em S , calcule o valor de autoridade = Soma dos valores de hub de todas as p√°ginas apontando para a p√°gina atual.
- b. Para cada p√°gina em S , calcule valor do hub = Soma dos valores de autoridade de todas as p√°ginas apontadas pela p√°gina atual.
- c. Normalize os valores de hub e autoridade de modo que a soma de todos os valores de hub em   seja igual a 1 e a soma de todos os valoS res de autoridade em S seja igual a 1.

## 27.7.4 An√°lise de conte√∫do da Web

Como j√° dissemos, a an√°lise de conte√∫do da Web refere-se  ao  processo  de  descobrir  informa√ß√µes  √∫teis de conte√∫do/dados/documentos da Web. Os dados de conte√∫do da Web consistem em dados desestruturados,  como  texto  livre  de  documentos  armazenados eletronicamente, dados semiestruturados normalmente encontrados como documentos HTML, com dados de  imagem  embutidos,  e  dados  mais  estruturados, como dados tabulares e p√°ginas em HTML, XML ou outras linguagens de marca√ß√£o, geradas como sa√≠da de bancos de dados. De maneira mais geral, o termo conte√∫do Web refere-se a quaisquer dados reais na p√°gina Web que sejam voltados para o usu√°rio que acessa essa p√°gina. Isso costuma consistir em texto e gr√°ficos, mas n√£o se limita a isso.

Primeiro, discutiremos algumas tarefas preliminares de an√°lise de conte√∫do Web e, depois, veremos as  tarefas  de  an√°lise  tradicionais  da  classifica√ß√£o  e agrupamento de p√°gina Web.

Extra√ß√£o  de  dados  estruturados. Os  dados  estruturados na Web normalmente s√£o muito importantes,  pois  representam  informa√ß√µes  essenciais, como uma tabela estruturada que mostra os hor√°-

26 A Web profunda, conforme definida por Bergman (2001).

rios de voo entre duas cidades. Existem v√°rias t√©cnicas para a extra√ß√£o de dados estruturados. Uma inclui  a  escrita  de  um wrapper ,  ou  um  programa que procura diferentes caracter√≠sticas estruturais da informa√ß√£o na p√°gina e extrai o conte√∫do correto. Outra t√©cnica √© escrever manualmente um programa de extra√ß√£o para cada Website com base nos padr√µes  de  formato  observados  do  site,  o  que  √© muito  trabalhoso  e  demorado.  Isso  n√£o  funciona com um n√∫mero muito grande de sites. Uma terceira t√©cnica √© a indu√ß√£o de wrapper ou aprendizado de wrapper , em que o usu√°rio primeiro rotula manualmente um conjunto de p√°ginas de treinamento, e o sistema de aprendizado gera regras - com base nas  p√°ginas  de  aprendizado  -  que  s√£o  aplicadas para extrair itens-alvo de outras p√°ginas Web. Uma quarta t√©cnica √© a autom√°tica, que visa a encontrar padr√µes/gram√°ticas das p√°ginas Web e depois usa a gera√ß√£o de wrapper para produzir um wrapper a fim de extrair dados automaticamente.

Integra√ß√£o de informa√ß√µes da Web. A Web √© imensa e tem milh√µes de documentos, criados por pessoas e organiza√ß√µes diferentes. Por causa disso, as p√°ginas Web que cont√™m informa√ß√µes semelhantes podem ter uma sintaxe diferente e palavras distintas para descrever os mesmos conceitos. Isso cria a necessidade de  integrar  informa√ß√µes  de  diversas  p√°ginas  Web. Duas t√©cnicas populares para integra√ß√£o de informa√ß√£o da Web s√£o:

- 1. Integra√ß√£o  de  interface  de  consulta  Web , para  habilitar  a  consulta  de  m√∫ltiplos  bancos  de  dados  na  Web  que  n√£o  s√£o  vis√≠veis nas  interfaces  externas  e  est√£o  ocultos  na 'Web profunda'. A Web profunda 26 consiste nas  p√°ginas  que  n√£o  existem  at√©  que  sejam criadas  dinamicamente  como  resultado  de uma pesquisa de banco de dados espec√≠fica, que produz algumas das informa√ß√µes na p√°gina (ver Cap√≠tulo 14). Como os crawlers de mecanismo de busca tradicionais n√£o podem sondar e coletar informa√ß√µes de tais p√°ginas, a Web profunda at√© agora tem ficado escondida deles.
- 2. Combina√ß√£o de esquema , como a integra√ß√£o de diret√≥rios e cat√°logos para chegar a um esquema global para aplica√ß√µes. Um exemplo de tal aplica√ß√£o seria combinar um registro de sa√∫de pessoal de um indiv√≠duo ao combinar  e  coletar  dados  de  v√°rias  fontes dinamicamente, cruzando registros de sa√∫de de m√∫ltiplos sistemas.

Essas  t√©cnicas  continuam  sendo  uma  √°rea  de pesquisa ativa, e uma discuss√£o detalhada delas est√° al√©m do escopo deste livro. Consulte a bibliografia selecionada, ao final deste cap√≠tulo, para obter mais detalhes.

## Integra√ß√£o de informa√ß√µes baseada em ontologia.

Essa tarefa envolve o uso de ontologias para efetivamente  combinar  informa√ß√µes  de  diversas  fontes  heterog√™neas. Ontologias - modelos de representa√ß√£o formais com conceitos definidos explicitamente e relacionamentos nomeados vinculando-os - s√£o usadas para resolver as quest√µes de heterogeneidade sem√¢ntica nas fontes de dados. Diferentes classes de t√©cnicas para integra√ß√£o de informa√ß√µes usam ontologias.

- ¬Ñ T√©cnicas  de  ontologia  √∫nica utilizam  uma ontologia global que oferece um vocabul√°rio compartilhado  para  a  especifica√ß√£o  da  sem√¢ntica.  Elas  funcionam  se  todas  as  fontes de informa√ß√£o a serem integradas oferecerem quase a mesma vis√£o em um dom√≠nio de conhecimento. Por exemplo, o UMLS (descrito na Se√ß√£o 27.4.3) pode servir como uma ontologia comum para aplica√ß√µes biom√©dicas.
- ¬Ñ Em uma t√©cnica de ontologia m√∫ltipla , cada fonte de informa√ß√£o √© descrita pela pr√≥pria ontologia. Em princ√≠pio, a 'ontologia de origem'  pode  ser  uma  combina√ß√£o  de  v√°rias outras ontologias, mas n√£o se pode assumir que as diferentes 'ontologias de origem' compartilham o mesmo vocabul√°rio. Lidar com ontologias m√∫ltiplas, parcialmente sobrepostas e potencialmente em conflito, √© um problema  muito  dif√≠cil  enfrentado  por  muitas aplica√ß√µes, incluindo aquelas na √°rea de bioinform√°tica e outras √°reas de conhecimento complexas.
- ¬Ñ T√©cnicas de ontologia h√≠bridas s√£o semelhantes  √†s  t√©cnicas  de  ontologia  m√∫ltiplas:  a  sem√¢ntica de cada fonte √© descrita pela pr√≥pria ontologia. Por√©m, para tornar as ontologias de origem compar√°veis entre si, elas s√£o baseadas em um vocabul√°rio global compartilhado. O vocabul√°rio compartilhado cont√©m termos b√°sicos (os primitivos) de um dom√≠nio de conhecimento. Como cada termo da ontologia de origem se baseia nos primitivos, os termos se tornam mais facilmente compar√°veis do que nas t√©cnicas de ontologia m√∫ltipla. A vantagem de uma t√©cnica h√≠brida √© que novas fontes podem ser facilmente acrescentadas sem a necessidade de modificar os mapeamentos ou o vocabul√°rio compartilhado. Nas t√©cnicas m√∫ltipla e h√≠brida, v√°rias ques-

t√µes de pesquisa, como mapeamento, alinhamento  e  mesclagem  da  ontologia,  precisam ser resolvidas.

Criando  hierarquias  de  conceito. Um  modo  comum de organizar os resultados da pesquisa √© por meio de uma lista pontuada linear de documentos. Mas, para alguns usu√°rios e aplica√ß√µes, uma maneira melhor de exibir resultados seria criar agrupamentos de documentos relacionados no resultado da busca. Um modo de organizar documentos em um resultado de pesquisa, e organizar informa√ß√µes em geral, √© criando uma hierarquia de conceito . Os documentos em  um  resultado  de  pesquisa  s√£o  organizados  em grupos,  em  um  padr√£o  hier√°rquico.  Outras  t√©cnicas  relacionadas  para  organizar  documentos  s√£o  a classifica√ß√£o e  o agrupamento (ver Cap√≠tulo 28). O agrupamento cria grupos de documentos, nos quais os documentos em cada grupo compartilham muitos conceitos comuns.

## Segmenta√ß√£o de p√°ginas Web e detec√ß√£o de ru√≠do.

Existem muitas partes sup√©rfluas em um documento Web, como an√∫ncios e pain√©is de navega√ß√£o. A informa√ß√£o e o texto nessas partes sup√©rfluas devem ser eliminados como ru√≠do antes de classificar os documentos com base em seu conte√∫do. Logo, antes de aplicar algoritmos de classifica√ß√£o ou agrupamento a um conjunto de documentos, as √°reas ou blocos dos documentos que cont√™m ru√≠do devem ser removidos.

## 27.7.5 √©cnicas de an√°lise do conte√∫do T Web

As duas t√©cnicas principais para an√°lise de conte√∫do Web s√£o (1) baseada em agente (vis√£o RI) e (2) baseada em banco de dados (vis√£o BD).

A t√©cnica baseada em agente envolve o desenvolvimento de sistemas sofisticados de intelig√™ncia artificial que podem atuar de forma aut√¥noma ou semi-aut√¥noma em favor de um usu√°rio em particular, para descobrir e processar informa√ß√µes baseadas na Web. Em geral, os sistemas de an√°lise Web baseados em agente podem ser colocados nas tr√™s categorias a seguir:

- ¬Ñ Agentes Web inteligentes s√£o agentes de software que procuram informa√ß√µes relevantes usando  caracter√≠sticas  de  um  dom√≠nio  de aplica√ß√£o em particular (e possivelmente um perfil de usu√°rio) para organizar e interpretar a  informa√ß√£o  descoberta.  Por  exemplo,  um agente inteligente que recupera informa√ß√µes de produto de uma s√©rie de sites de vendedor utilizando apenas informa√ß√µes gerais sobre o dom√≠nio de produto.

- ¬Ñ Filtragem/categoriza√ß√£o de informa√ß√µes √© outra t√©cnica que utiliza agentes Web para categorizar documentos Web. Esses agentes Web empregam m√©todos da recupera√ß√£o de informa√ß√µes e informa√ß√µes sem√¢nticas com base nos links entre v√°rios documentos para organizar documentos em uma hierarquia de conceito.
- ¬Ñ Agentes Web personalizados s√£o  outro  tipo de agentes Web que utilizam as prefer√™ncias pessoais  dos  usu√°rios  para  organizar  resultados de pesquisa ou descobrir informa√ß√µes e  documentos  que  poderiam  ter  valor  para determinado usu√°rio. As prefer√™ncias do usu√°rio poderiam ser descobertas com base em escolhas de usu√°rio anteriores, ou de outros indiv√≠duos que se considera terem prefer√™ncias semelhantes para o usu√°rio.

A  t√©cnica  baseada  em  banco  de  dados visa  a deduzir a estrutura do Website ou transformar um Website para organiz√°-lo como um banco de dados de modo que possibilite melhor gerenciamento de informa√ß√µes e consulta na Web. Essa t√©cnica de an√°lise de  conte√∫do  Web  tenta  principalmente  modelar  os dados na Web e integr√°-los de modo que consultas mais sofisticadas do que a pesquisa por palavra-chave possam ser realizadas. Estas poderiam ser obtidas ao encontrar o esquema de documentos Web, montar um warehouse de documento Web, uma base de conhecimento da Web ou um banco de dados virtual. A t√©cnica baseada em banco de dados pode usar um modelo como o Object Exchange Model (OEM), 27 que representa dados semiestruturados por um grafo rotulado. Os dados no OEM s√£o vistos como um grafo,  com  objetos  como  v√©rtices  e  r√≥tulos  como arestas. Cada objeto √© identificado por um identificador de objeto e um valor que √© at√¥mico - como inteiro, string, imagem GIF ou documento HTML ou complexo, na forma de um conjunto de refer√™ncias de objeto.

- O foco principal da t√©cnica baseada em banco de  dados  tem  sido  com  o  uso  de  bancos  de  dados multin√≠vel e sistemas de consulta Web. Um banco de dados multin√≠vel em seu n√≠vel mais baixo √© um banco de dados que cont√©m informa√ß√µes semiestruturadas primitivas armazenadas em diversos reposit√≥rios da Web, como documentos de hipertexto. Nos n√≠veis mais  altos,  metadados  ou  generaliza√ß√µes  s√£o  extra√≠dos  dos  n√≠veis  mais  baixos  e  organizados  em  cole√ß√µes estruturadas, como bancos de dados relacionais ou orientados a objeto. Em um sistema de consulta Web ,  as  informa√ß√µes sobre o conte√∫do e a estrutura dos documentos Web s√£o extra√≠das e organizadas

27 Ver Kosala e Blockeel (2000).

usando t√©cnicas tipo banco de dados. Linguagens de consulta similares √† SQL podem ent√£o ser utilizadas para  pesquisar  e  consultar  documentos  Web.  Elas combinam consultas estruturais, baseadas na organiza√ß√£o de documentos de hipertexto, e consultas baseadas em conte√∫do.

## 27.7.6 An√°lise de uso da Web

An√°lise de uso da Web √© a aplica√ß√£o das t√©cnicas de an√°lise de dados para descobrir padr√µes de uso com base em dados da Web, a fim de entender e atender melhor as necessidades das aplica√ß√µes baseadas na  Web.  Essa  atividade  n√£o  contribui  diretamente para a recupera√ß√£o de informa√ß√µes; mas √© importante melhorar ou aprimorar a experi√™ncia de pesquisa dos usu√°rios. Os dados de uso da Web descrevem o padr√£o de uso das p√°ginas Web, como endere√ßos IP, refer√™ncias de p√°gina, data e hora dos acessos para um usu√°rio, grupo de usu√°rios ou uma aplica√ß√£o. A an√°lise de uso da Web normalmente consiste em tr√™s fases  principais:  pr√©-processamento,  descoberta  de padr√£o e an√°lise de padr√£o.

- 1. Pr√©-processamento. O pr√©-processamento converte a informa√ß√£o coletada sobre estat√≠sticas e padr√µes de uso para um formato que possa ser utilizado pelos m√©todos de descoberta de padr√£o. Usamos o termo 'vis√£o de p√°gina' para nos referir √†s p√°ginas vistas ou visitadas por um usu√°rio. Existem v√°rios tipos de t√©cnicas de pr√©-processamento dispon√≠veis:
- ¬Ñ Pr√©-processamento  de  uso analisa  os  dados coletados  dispon√≠veis  sobre  padr√µes  de  uso de usu√°rios, aplica√ß√µes e grupos de usu√°rios. Como esses dados normalmente s√£o incompletos, o processo √© dif√≠cil. T√©cnicas de limpeza de dados s√£o necess√°rias para eliminar o impacto de itens irrelevantes no resultado da an√°lise. Frequentemente, os dados de uso s√£o identificados por um endere√ßo IP e consistem em fluxos de cliques coletados no servidor. Dados melhores est√£o dispon√≠veis se um processo de rastreamento de uso for instalado no site do cliente.
- ¬Ñ Pr√©-processamento de conte√∫do √© o processo de  converter  texto,  imagem,  scripts  e  outro conte√∫do para um formato que possa ser utilizado pela an√°lise de uso. Em geral, isso consiste em realizar a an√°lise de conte√∫do como classifica√ß√£o ou agrupamento. As t√©cnicas de agrupamento ou classifica√ß√£o podem agrupar informa√ß√µes  de  uso  para  tipos  semelhantes de p√°ginas Web, de modo que os padr√µes de uso podem ser descobertos para classes espe-

- c√≠ficas de p√°ginas Web que descrevem t√≥picos em particular.  As  vis√µes  de  p√°gina  tamb√©m podem  ser  classificadas  de  acordo  com  seu uso intencionado, como para vendas, descoberta ou outros usos.
- ¬Ñ Pr√©-processamento  de  estrutura: o  pr√©-processamento  de  estrutura  pode  ser  feito  ao analisar e reformatar a informa√ß√£o sobre hiperlinks  e  estrutura  entre  as  p√°ginas  vistas. Uma  dificuldade  √©  que  a  estrutura  do  site pode ser din√¢mica e ter de ser constru√≠da para cada sess√£o do servidor.
- 2. Descoberta de padr√£o. As t√©cnicas usadas na descoberta de padr√£o s√£o baseadas nos m√©todos dos campos de estat√≠stica, aprendizado de m√°quina, reconhecimento de padr√£o, an√°lise  de  dados,  minera√ß√£o  de  dados  e  outras √°reas  semelhantes.  Essas  t√©cnicas  s√£o  adaptadas de modo que levem em considera√ß√£o o conhecimento  espec√≠fico  e  as  caracter√≠sticas para an√°lise da Web. Por exemplo, na descoberta da regra de associa√ß√£o (ver Se√ß√£o 28.2), a  no√ß√£o  de  uma  transa√ß√£o  para  an√°lise  de cesta de mercado considera os itens estarem desordenados.  Mas  a  ordem  de  acesso  das p√°ginas Web √© importante, e por isso deve ser considerada na an√°lise de uso da Web. Logo, a descoberta de padr√£o envolve sequ√™ncias de minera√ß√£o das vis√µes de p√°gina. Em geral, ao usar dados de uso da Web, os tipos de atividades de minera√ß√£o de dados a seguir podem ser realizados para descoberta de padr√£o.
- ¬Ñ An√°lise estat√≠stica. T√©cnicas estat√≠sticas s√£o o m√©todo mais comum de extrair conhecimento sobre visitantes de um Website. Ao analisar o log da sess√£o, √© poss√≠vel aplicar medidas estat√≠sticas como m√©dia, mediana e contagem de frequ√™ncia a par√¢metros como p√°ginas vistas, tempo de visualiza√ß√£o por p√°gina, extens√£o dos caminhos de navega√ß√£o entre p√°ginas e  outros  par√¢metros  relevantes  √†  an√°lise  de uso da Web.
- ¬Ñ Regras de associa√ß√£o. No contexto da an√°lise de uso da Web, regras de associa√ß√£o referem-se a conjuntos de p√°ginas que s√£o acessadas juntas com um valor de suporte que excede algum limite especificado. (Veja a Se√ß√£o 28.2, sobre regras de associa√ß√£o.) Essas p√°ginas podem n√£o estar conectadas diretamente umas √†s outras por hiperlinks. Por exemplo, a descoberta da regra de associa√ß√£o pode revelar uma correla√ß√£o entre usu√°rios que visitaram uma p√°gina contendo produtos eletr√¥nicos e
- aqueles que visitam uma p√°gina sobre equipamento esportivo.
- ¬Ñ Clustering (agrupamento). No dom√≠nio de uso da Web, existem dois tipos de grupos interessantes  a  serem  descobertos:  cluster de  usu√°rios  e  grupos  de  p√°ginas.  O agrupamento  de  usu√°rios tende  a  estabelecer grupos  de  usu√°rios  exibindo  padr√µes  de navega√ß√£o  semelhantes.  Esse  conhecimento  √© √∫til especialmente  para  deduzir  as demografias  de  usu√°rios  a  fim  de  realizar segmenta√ß√£o de mercado em aplica√ß√µes de com√©rcio eletr√¥nico (e-commerce) ou para fornecer  conte√∫do  Web  personalizado  aos usu√°rios. O agrupamento de p√°ginas √© baseado no conte√∫do das p√°ginas, e p√°ginas com  conte√∫do  semelhante  s√£o  agrupadas. Esse tipo de agrupamento pode ser utilizado em mecanismos de busca da Internet e em ferramentas que oferecem assist√™ncia √† navega√ß√£o Web.
- ¬Ñ Classifica√ß√£o. No dom√≠nio Web, um objetivo √©  desenvolver  um  perfil  de  usu√°rios  pertencentes a determinada classe ou categoria. Isso exige extra√ß√£o e sele√ß√£o de recursos que melhor descrevam as propriedades de determinada classe ou categoria de usu√°rios. Como exemplo,  um  padr√£o  interessante  que  pode ser  descoberto  seria:  60  por  cento  dos  usu√°rios que fazem um pedido on-line em /Product/Books est√£o na faixa et√°ria de 18 a 25 anos e moram em apartamentos alugados.
- ¬Ñ Padr√µes sequenciais. Esses tipos de padr√µes identificam  sequ√™ncias  de  acessos  √†  Web, que podem ser usados para prever o pr√≥ximo conjunto de p√°ginas Web a serem acessadas  por  certa  classe  de  usu√°rios.  Esses padr√µes podem ser utilizados por marqueteiros para produzir an√∫ncios direcionados nas p√°ginas Web. Outro tipo de padr√£o sequencial pertence a quais itens normalmente s√£o adquiridos ap√≥s a compra de determinado item. Por exemplo, depois de comprar um computador, uma impressora costuma ser comprada.
- ¬Ñ Modelagem de depend√™ncia. A modelagem de depend√™ncia visa a determinar e modelar depend√™ncias significativas entre as diversas vari√°veis no dom√≠nio da Web. Como exemplo,  pode-se  estar  interessado  em  montar um  modelo  que  represente  os  diferentes est√°gios pelos quais um visitante passa en-

quanto compra em uma loja on-line, com base nas a√ß√µes escolhidas (por exemplo, de um visitante casual at√© um comprador s√©rio em potencial).

- 3. An√°lise de padr√£o. A √∫ltima etapa √© retirar aquelas regras ou padr√µes que n√£o s√£o considerados de interesse com base nos padr√µes descobertos.  A  metodologia  de  an√°lise  em particular √© baseada na aplica√ß√£o. Uma t√©cnica  comum  para  an√°lise  de  padr√£o  √©  usar uma linguagem de consulta como a SQL para detectar diversos padr√µes e relacionamentos. Outra t√©cnica envolve carregar dados de uso em um data warehouse com ferramentas de ETL e realizar opera√ß√µes OLAP para v√™-los por v√°rias dimens√µes (ver Se√ß√£o 29.3). √â comum utilizar t√©cnicas de visualiza√ß√£o, como padr√µes gr√°ficos, ou atribuir cores para diferentes valores, para destacar padr√µes ou tend√™ncias nos dados.

## 27.7.7 Aplica√ß√µes pr√°ticas da an√°lise da Web

An√°lise  da  Web. O objetivo  da an√°lise  da  Web √© entender e otimizar o desempenho do uso da Web. Isso requer coleta, an√°lise e monitoramento do desempenho dos dados de uso da Internet. A an√°lise da Web no site mede o desempenho de um Website em um contexto comercial. Esses dados normalmente s√£o comparados com os principais indicadores de desempenho para medir a efic√°cia ou o desempenho do Website como um todo, e podem ser usados para melhorar um site ou as estrat√©gias de marketing.

Web Spamming. Tem se tornado cada vez mais importante  para  empresas  e  indiv√≠duos  ter  seus  sites/ p√°ginas  Web  aparecendo  nos  principais  resultados de busca. Para conseguir isso, √© essencial entender os algoritmos de pontua√ß√£o dos mecanismos de busca e  apresentar a informa√ß√£o na p√°gina de algu√©m de modo que a p√°gina tenha uma pontua√ß√£o alta quando as respectivas palavras-chave forem consultadas. Existe  uma  linha  t√™nue  separando  a  otimiza√ß√£o  de p√°gina leg√≠tima para fins comerciais e o spamming. Web spamming , portanto, √© definido como uma atividade deliberada de promover a p√°gina de algu√©m ao manipular os resultados retornados pelos mecanismos de busca. A an√°lise da Web pode ser usada para detectar tais p√°ginas e descart√°-las dos resultados da busca.

Seguran√ßa da Web. A an√°lise da Web pode ser utilizada para encontrar padr√µes de uso interessantes dos sites  Web.  Se  qualquer  falha  em  um  site  tiver  sido explorada, isso pode ser deduzido com a an√°lise da Web, permitindo assim o projeto de sites mais robustos. Por exemplo, a porta dos fundos ou o vazamento de informa√ß√µes dos servidores Web podem ser detectados usando t√©cnicas de an√°lise da Web sobre alguns dados anormais no log da aplica√ß√£o Web. T√©cnicas de an√°lise de seguran√ßa, como detec√ß√£o de intrus√£o e ataques de nega√ß√£o de servi√ßo, s√£o baseadas na an√°lise de padr√£o de acesso da Web.

Web  Crawlers. Web  crawlers s√£o  programas  que visitam p√°ginas Web e criam c√≥pias de todas as p√°ginas visitadas, para que possam ser processadas por um mecanismo de busca para indexa√ß√£o das p√°ginas baixadas, oferecendo buscas r√°pidas. Outro uso dos crawlers  √©  para  verificar  e  manter  automaticamente os Websites. Por exemplo, o c√≥digo HTML e os links em um site Web podem ser verificados e validados pelo crawler. Outro uso infeliz dos crawlers √© para coletar endere√ßos de e-mail das p√°ginas Web, de modo que possam ser utilizados para e-mails de spam mais tarde.

## 27.8 end√™ncias na recupera√ß√£o de T informa√ß√µes

Nesta se√ß√£o, revisamos alguns conceitos que est√£o sendo considerados no trabalho de pesquisa mais recente sobre a recupera√ß√£o de informa√ß√µes.

## 27.8.1 Busca facetada

A busca facetada √© uma t√©cnica que permite a experi√™ncia integrada de busca e navega√ß√£o, ao permitir que os usu√°rios explorem filtrando a informa√ß√£o  dispon√≠vel.  Essa  t√©cnica  de  busca  √©  usada  com frequ√™ncia em sites de e-commerce e aplica√ß√µes que permitem que usu√°rios naveguem por um espa√ßo de informa√ß√µes  multidimensional.  Facetas  geralmente s√£o usadas para o tratamento de transa√ß√µes ou mais dimens√µes de classifica√ß√£o. Isso permite que o esquema  de  classifica√ß√£o  facetada classifique  um  objeto de v√°rias maneiras com base nos diferentes crit√©rios taxon√¥micos. Por exemplo, uma p√°gina Web pode ser  classificada  de  v√°rias  maneiras:  por  conte√∫do (companhias a√©reas, m√∫sica, not√≠cias etc.); por uso (vendas,  informa√ß√µes,  registro  etc.);  por  local;  por linguagem utilizada (HTML, XML etc.) e de outras maneiras ou facetas. Logo, o objeto pode ser classificado de v√°rias maneiras com base em diversas taxonomias.

Uma faceta define propriedades ou caracter√≠sticas de uma classe de objetos. As propriedades devem ser mutuamente exclusivas e completas. Por exemplo, uma cole√ß√£o de objetos de arte poderia ser classifica-

da usando uma faceta do artista (nome do artista), uma faceta de √©poca (quando a arte foi criada), uma faceta de tipo (pintura, escultura, mural etc.), uma faceta de pa√≠s de origem, uma faceta de m√≠dia (√≥leo, aquarela, pedra, metal, m√≠dia mista etc.), uma faceta de cole√ß√£o (onde a arte reside), e assim por diante.

A busca facetada utiliza a classifica√ß√£o facetada, que permite que um usu√°rio navegue por informa√ß√µes ao longo de m√∫ltiplos caminhos, correspondentes a diferentes ordena√ß√µes das facetas. Isso √© diferente das taxonomias tradicionais, em que a hierarquia das categorias √© fixa e inalter√°vel. O projeto Flamenco da Universidade da Calif√≥rnia em Berkeley 28  √© um dos primeiros exemplos de um sistema de busca facetada.

## 27.8.2 Busca social

A vis√£o tradicional da navega√ß√£o na Web considera que um √∫nico usu√°rio est√° procurando informa√ß√µes. Essa vis√£o √© contr√°ria √† pesquisa anterior por cientistas  de  biblioteca,  que  estudavam  os  h√°bitos de busca de informa√ß√£o dos usu√°rios. Tal pesquisa demonstrou que outros indiv√≠duos podem ser recursos de informa√ß√£o valiosos durante a busca de informa√ß√µes por um √∫nico usu√°rio. Mais recentemente, a pesquisa indicou que com frequ√™ncia existe coopera√ß√£o direta do usu√°rio durante a busca por informa√ß√µes baseada na Web. Alguns estudos informam que segmentos  significativos  da  popula√ß√£o  de  usu√°rios est√£o engajados na colabora√ß√£o expl√≠cita sobre tarefas de busca conjunta na Web. A colabora√ß√£o ativa por v√°rias partes tamb√©m ocorre em certos casos (por exemplo, ambientes de empresa); em outras ocasi√µes, e talvez para a maioria das buscas, os usu√°rios costumam interagir com outros remota, ass√≠ncrona e at√© mesmo involunt√°ria e implicitamente.

A  busca  de  informa√ß√µes  on-line  habilitada  socialmente (busca social) √© um novo fen√¥meno facilitado pelas recentes tecnologias Web. A busca social colaborativa envolve  diferentes  formas  de  envolvimento ativo nas atividades relacionadas √† pesquisa, como a busca colocalizada, colabora√ß√£o remota em tarefas de busca, uso de rede social para busca, uso de redes especialistas, envolvimento em minera√ß√£o de dados sociais ou intelig√™ncia coletiva para melhorar o processo de busca e at√© mesmo intera√ß√µes sociais para facilitar a busca de informa√ß√µes e a l√≥gica. Essa atividade de busca social pode ser feita s√≠ncrona, assincronamente, colocalizada ou em espa√ßos de trabalho compartilhados remotos. Psic√≥logos sociais t√™m experimentalmente validado que o ato das discuss√µes sociais facilita o desempenho cognitivo. As pessoas nos grupos sociais podem oferecer solu√ß√µes (respos-

28 Yee (2003) descreve os metadados facetados para busca por imagem.

tas a perguntas), ponteiros para bancos de dados ou para outras pessoas (metaconhecimento), valida√ß√£o e legitima√ß√£o de ideias, e podem servir como aux√≠lios √† mem√≥ria e ajuda com a reformula√ß√£o de problema. A participa√ß√£o orientada √© um processo em que as pessoas constroem conhecimento junto com colegas em sua comunidade. A busca de informa√ß√µes √© em grande parte  uma atividade solit√°ria  na  Web hoje em dia. Algum trabalho recente sobre busca colaborativa relata v√°rios achados interessantes e o potencial dessa tecnologia para melhor acesso √† informa√ß√£o.

## 27.8.3 Busca conversacional

A busca conversacional ( CS -  Conversational Search) √© uma intera√ß√£o para localiza√ß√£o de informa√ß√µes interativas e colaborativas. Os participantes se engajam em uma conversa√ß√£o e realizam uma atividade de busca social que √© auxiliada por agentes inteligentes. A atividade de pesquisa colaborativa ajuda o agente a aprender sobre conversa√ß√µes com intera√ß√µes e feedback dos participantes. Ela usa o modelo de recupera√ß√£o sem√¢ntico com conhecimento da linguagem natural para oferecer aos usu√°rios resultados de busca mais r√°pidos e relevantes. E transforma a busca de uma atividade solit√°ria em uma atividade mais participativa para o usu√°rio. O agente de busca realiza v√°rias tarefas de localiza√ß√£o de informa√ß√µes relevantes  e  reuni√£o  dos  usu√°rios;  os  participantes oferecem  feedback  ao  agente  durante  as  conversa√ß√µes, permitindo que este √∫ltimo funcione melhor.

## Resumo

Neste  cap√≠tulo,  analisamos  uma  √°rea  importante, chamada recupera√ß√£o de informa√ß√µes (RI), que est√° intimamente relacionada com bancos de dados. Com o advento da Web, dados desestruturados com texto, imagens, √°udio e v√≠deo est√£o se proliferando em velocidades  fenomenais.  Embora os sistemas de gerenciamento de banco de dados tenham uma boa rela√ß√£o com dados estruturados, os dados desestruturados que cont√™m diversos tipos de dados est√£o sendo armazenados principalmente em reposit√≥rios de informa√ß√µes ad hoc na Web, que est√£o dispon√≠veis para consumo principalmente por meio de sistemas de RI. Google, Yahoo e mecanismos de  busca  semelhantes  s√£o  sistemas  de  RI  que  tornam os  avan√ßos  nesse  campo  prontamente  dispon√≠veis  para o usu√°rio final comum, dando-lhes uma experi√™ncia de busca mais rica, com melhoria cont√≠nua.

Come√ßamos definindo a terminologia b√°sica da RI, apresentamos os modos de intera√ß√£o de consulta e navega√ß√£o nos sistemas RI e oferecemos uma compara√ß√£o das tecnologias de RI e de banco de dados. Apresentamos os

esquemas do processo de RI em um n√≠vel detalhado e de vis√£o geral, e depois discutimos as bibliotecas digitais, que  s√£o  reposit√≥rios  de  conte√∫do  direcionado  na  Web para  institui√ß√µes  acad√™micas,  bem  como  comunidades profissionais, e apresentamos um r√°pido hist√≥rico da RI.

Apresentamos os diversos modelos de recupera√ß√£o, incluindo modelos booleanos, espa√ßo de vetor, probabil√≠stico e sem√¢ntico. Eles permitem medir se um documento √© relevante a uma consulta de usu√°rio e oferecer heur√≠sticas de  medi√ß√£o  de  similaridade.  Depois  discutimos  diversas m√©tricas de avalia√ß√£o, como revoca√ß√£o e precis√£o e F-score para medir a qualidade dos resultados das consultas de RI. Ent√£o, apresentamos diferentes tipos de consultas al√©m de consultas baseadas em palavra-chave, que s√£o dominantes, existem outros tipos incluindo booleano, frase, proximidade, linguagem natural e outros, para os quais um suporte expl√≠cito precisa ser fornecido pelo modelo de recupera√ß√£o. O processamento de textos √© importante nos sistemas RI, e foram discutidas diversas atividades, como remo√ß√£o de stopword, ra√≠zes e o uso de tesauro. Depois, discutimos a constru√ß√£o e o uso de √≠ndices invertidos, que est√£o no n√∫cleo dos sistemas de RI e contribuem para fatores que envolvem efici√™ncia da busca. O feedback de relev√¢ncia foi analisado rapidamente - √© importante modificar e melhorar a recupera√ß√£o de informa√ß√µes pertinentes para o usu√°rio por meio de sua intera√ß√£o e engajamento no processo de busca.

Fizemos uma introdu√ß√£o um tanto detalhada √† an√°lise da Web, relacionada √† recupera√ß√£o de informa√ß√µes. Dividimos esse tratamento na an√°lise de conte√∫do, estrutura e uso da Web. A busca na Web foi discutida, incluindo uma an√°lise da estrutura de link da Web, seguida por uma introdu√ß√£o aos algoritmos para pontua√ß√£o dos resultados de uma busca na Web, como PageRank e HITS. Por fim, discutimos rapidamente as tend√™ncias atuais, incluindo a busca facetada, a busca social e a busca conversacional. Trata-se de um tratamento introdut√≥rio a um campo muito vasto, e o leitor deve consultar os livros-texto especializados em recupera√ß√£o de informa√ß√µes e mecanismos de busca.

## Perguntas de revis√£o

- 27.1. O que s√£o dados estruturados e dados desestruturados? D√™ um exemplo de cada um pela experi√™ncia com os dados que voc√™ pode ter usado.
- 27.2. D√™ uma defini√ß√£o geral de recupera√ß√£o de informa√ß√µes (RI). O que a recupera√ß√£o de informa√ß√µes envolve quando consideramos informa√ß√µes na Web?
- 27.3. Discuta os tipos de dados e os tipos de usu√°rios nos sistemas de recupera√ß√£o de informa√ß√µes de hoje.
- 27.4. O que significa busca navegacional, informativa e transformativa?
- 27.5. Quais s√£o os dois modos principais de intera√ß√£o com um sistema RI? Descreva com exemplos.
- 27.6. Explique as principais diferen√ßas entre banco de dados e sistemas de RI mencionados na Tabela 27.1.
- 27.7. Descreva os principais componentes do sistema RI mostrado na Figura 27.1.
- 27.8. O que s√£o bibliotecas digitais? Que tipos de dados normalmente s√£o encontrados nelas?
- 27.9. Cite algumas bibliotecas digitais que voc√™ acessou. O que elas cont√™m e at√© que ponto no passado os dados v√£o?
- 27.10. Cite  um  r√°pido  hist√≥rico  da  RI  e  mencione  os marcos no desenvolvimento.
- 27.11. O que √© o modelo booleano de RI? Quais s√£o suas limita√ß√µes?
- 27.12. O que  √©  o  modelo  de  espa√ßo  de  vetor  da  RI? Como um vetor √©  constru√≠do  para  representar um documento?
- 27.13. Defina  o  esquema  TF-IDF  de  determina√ß√£o  do peso de uma palavra-chave em um documento. Qual √© a necessidade de incluir IDF no peso de um termo?
- 27.14. O que s√£o modelos probabil√≠stico e sem√¢ntico da RI?
- 27.15. Defina revoca√ß√£o e precis√£o nos sistemas RI.
- 27.16. D√™ a defini√ß√£o de precis√£o e revoca√ß√£o em uma lista pontuada de resultados na posi√ß√£o  . i
- 27.17. De que  forma  o  F-score  √©  definido  como  uma medida de recupera√ß√£o de informa√ß√£o? De que modo ele considera precis√£o e revoca√ß√£o?
- 27.18. Quais s√£o os diferentes tipos de consultas em um sistema de RI? Descreva cada um com um exemplo.
- 27.19. Quais s√£o as t√©cnicas para o processamento de consultas por frase e proximidade?
- 27.20. Descreva o processo de RI detalhado mostrado na Figura 27.2.
- 27.21. O que √© remo√ß√£o de stopword e o uso de ra√≠zes? Por que esses processos s√£o necess√°rios para uma melhor recupera√ß√£o de informa√ß√£o?
- 27.22. O que √© um tesauro? Como ele √© ben√©fico √† RI? 27.23.
- O que √© extra√ß√£o de informa√ß√£o? Quais s√£o os diferentes  tipos  de  extra√ß√£o  de  informa√ß√£o  do texto estruturado?
- 27.24. O que s√£o vocabul√°rios nos sistemas de RI? Que papel eles desempenham na indexa√ß√£o de documentos?
- 27.25. Recupere  cinco  documentos  com  cerca  de  tr√™s senten√ßas cada um com algum conte√∫do relacionado. Construa um √≠ndice invertido de todas as ra√≠zes importantes (palavras-chave) desses documentos.
- 27.26. Descreva o processo de constru√ß√£o do resultado de uma solicita√ß√£o de pesquisa usando um √≠ndice invertido.

| 27.27.   | Defina feedback de relev√¢ncia .                                                                                                                                                                                                                             |
|----------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 27.28.   | Descreva os tr√™s tipos de an√°lises da Web discu- tidos neste cap√≠tulo.                                                                                                                                                                                      |
| 27.29.   | Liste as tarefas importantes mencionadas que es- t√£o envolvidas na an√°lise do conte√∫do da Web. Descreva cada uma com algumas senten√ßas.                                                                                                                     |
| 27.30.   | Quais s√£o as tr√™s categorias de an√°lise de con- te√∫do da Web baseada em agente mencionadas neste cap√≠tulo?                                                                                                                                                  |
| 27.31.   | O que √© a t√©cnica baseada em banco de dados para a an√°lise do conte√∫do da Web? O que s√£o sistemas de consulta da Web?                                                                                                                                       |
| 27.32.   | Que algoritmos s√£o populares na pontua√ß√£o ou na determina√ß√£o da import√¢ncia das p√°ginas Web? Que algoritmo foi proposto pelos funda- dores da Google?                                                                                                       |
| 27.33.   | Qual √© a ideia b√°sica por tr√°s do algoritmo Page- Rank?                                                                                                                                                                                                     |
| 27.34.   | O que s√£o hubs e p√°ginas de autoridade? Como o algoritmo HITS usa esses conceitos?                                                                                                                                                                          |
| 27.35.   | O que voc√™ pode descobrir com a an√°lise de uso da Web? Que dados ela gera?                                                                                                                                                                                  |
| 27.36.   | Que opera√ß√µes de minera√ß√£o costumam ser rea- lizadas sobre os dados de uso da Web? D√™ um exemplo de cada.                                                                                                                                                   |
| 27.37.   | Quais s√£o as aplica√ß√µes da minera√ß√£o de uso da Web?                                                                                                                                                                                                         |
| 27.38.   | O que √© relev√¢ncia de busca? Como ela √© deter- minada?                                                                                                                                                                                                      |
| 27.39.   | Defina busca facetada . Crie um conjunto de facetas para um banco de dados que contenha todos os tipos de pr√©dios. Por exemplo, duas fa- cetas poderiam ser 'valor ou pre√ßo do pr√©dio' e 'tipo de pr√©dio (residencial, comercial, dep√≥sito, f√°brica etc.)'. |
| 27.40.   | O que √© busca social? O que a busca social cola- borativa envolve?                                                                                                                                                                                          |

- 27.41. Defina e explique busca conversacional .

## Bibliografia selecionada

As tecnologias de recupera√ß√£o e busca de informa√ß√µes s√£o √°reas de pesquisa e desenvolvimento ativas nos setores industrial e acad√™mico. Existem muitos livros-texto sobre RI que oferecem uma discuss√£o detalhada sobre o material que apresentamos rapidamente neste cap√≠tulo. Um livro recente, intitulado Search Engines: Information Retrieval in Practice , de Croft, Metzler e Strohman (2009), oferece uma vis√£o geral pr√°tica dos conceitos e princ√≠pios de mecanismo de busca. Introduction to Information Retrieval , de Manning, Raghavan e Schutze (2008) √© um livro definitivo sobre recupera√ß√£o de informa√ß√µes. Outro livro-texto introdut√≥rio em RI √© Modern Information Retrieval ,  de Ricardo Baeza-Yates e Berthier Ribeiro-Neto (1999), que oferece  uma  cobertura  detalhada  dos  diversos  aspectos da tecnologia de RI. Os livros cl√°ssicos de Gerald Salton

(1968) e Van Rijsbergen (1979) sobre recupera√ß√£o de informa√ß√µes fornecem excelentes descri√ß√µes da pesquisa de base feita no campo de RI at√© o final da d√©cada de 1960. Salton tamb√©m introduziu o modelo de espa√ßo de vetor como um modelo de RI. Manning e Schutze (1999) oferecem um bom resumo das tecnologias de linguagem natural e pr√©-processamento de texto. 'Interactive Information Retrieval in Digital Environments', de Xie (2008), oferece uma boa abordagem centrada em seres humanos para a  recupera√ß√£o de informa√ß√µes. O livro Managing Gigabytes , de Witten, Moffat e Bell (1999) oferece discuss√µes detalhadas para t√©cnicas de indexa√ß√£o. O livro TREC, de Voorhees e Harman (2005), faz uma descri√ß√£o dos procedimentos de coleta e avalia√ß√£o de teste no contexto das competi√ß√µes TREC.

Broder (2002) classifica consultas da Web em tr√™s classes  distintas  -  navegacional,  informativa  e  transacional - e apresenta uma taxonomia detalhada da busca  na  Web.  Covi  e  Kling  (1996)  d√£o  uma  defini√ß√£o ampla para bibliotecas digitais em seu papel e discutem as dimens√µes organizacionais do uso eficaz da biblioteca digital.  Luhn (1957) realizou algum trabalho  inicial  em  RI  na  IBM,  na  d√©cada  de  1950,  sobre autoindexa√ß√£o e intelig√™ncia de neg√≥cios, que recebeu muita aten√ß√£o na √©poca. O sistema SMART (Salton et al., 1993), desenvolvido na Cornell, foi um dos primeiros sistemas de RI avan√ßados que usavam indexa√ß√£o de termo totalmente autom√°tica, clustering (agrupamento) hier√°rquico e pontua√ß√£o de documentos por grau de  similaridade  com  a  consulta.  O  sistema  SMART representava documentos e consultas como vetores de termo ponderados de acordo com o modelo de espa√ßo de vetor. Porter (1980) tem o cr√©dito pelos algoritmos de ra√≠zes fracas e fortes que se tornaram padr√µes. Robertson (1997) desenvolveu um esquema de peso sofisticado no sistema Okapi da City University de Londres, que se tornou muito popular nas competi√ß√µes TREC. Lenat (1995) iniciou o projeto Cyc na d√©cada de 1980 para incorporar l√≥gica formal e bases de conhecimento nos sistemas de processamento de informa√ß√µes. Os esfor√ßos para a cria√ß√£o do tesauro WordNet continuaram na d√©cada de 1990 e ainda est√£o em andamento. Os conceitos e princ√≠pios do WordNet s√£o descritos no livro  de  Fellbaum (1998). Rocchio (1971) descreve o algoritmo de feedback de relev√¢ncia, que √© abordado no livro de Salton (1971) sobre The SMART Retrieval System-Experiments in Automatic Document Processing . (O sistema de recupera√ß√£o SMART - experimentos em processamento autom√°tico de documentos.)

Abiteboul, Buneman e Suciu (1999) oferecem uma discuss√£o extensa dos dados na Web em seu livro que enfatiza  dados  semiestruturados.  Atzeni  e  Mendelzon (2000) escreveram um editorial no jornal VLDB sobre bancos de dados e a Web. Atzeni et al. (2002) propuseram modelos e transforma√ß√µes para dados baseados na Web. Abiteboul et al. (1997) propuseram a linguagem de consulta Lord para gerenciar dados semi-estruturados.

Chakrabarti (2002) √© um excelente livro sobre descoberta de conhecimento com base na Web. O livro de Liu  (2006)  consiste  em  v√°rias  partes,  cada  uma  oferecendo uma vis√£o geral abrangente dos conceitos envolvidos com a an√°lise de dados da Web e suas aplica√ß√µes. Excelentes artigos de estudo sobre an√°lise da Web s√£o Kosala  e  Blockeel  (2000)  e  Liu  et  al.  (2004).  Etzioni (1996) oferece um bom ponto de partida para entender a minera√ß√£o da Web e descreve as tarefas e quest√µes relacionadas com a World Wide Web. Uma excelente vis√£o geral  das  quest√µes  de  pesquisa,  t√©cnicas  e  esfor√ßos de  desenvolvimento associados ao conte√∫do da Web e an√°lise de uso √© apresentada por Cooley et al. (1997). Cooley (2003) focaliza a minera√ß√£o de padr√µes de uso da Web por meio do uso da estrutura da Web. Spiliopoulou (2000) descreve a an√°lise de uso da Web com detalhes. A minera√ß√£o da Web baseada na estrutura de p√°gina √© descrita em Madria et al. (1999) e Chakraborti et al. (1999). Os algoritmos para calcular a pontua√ß√£o de uma p√°gina Web s√£o dados por Page et al. (1999), que descrevem o famoso algoritmo PageRank, e por Kleinberg (1998), que apresenta o algoritmo HITS.



N as √∫ltimas tr√™s d√©cadas, muitas organiza√ß√µes t√™m gerado uma grande quantidade de dados leg√≠veis √† m√°quina na forma de arquivos e bancos de dados. Para  processar  esses  dados,  temos  a  tecnologia  de banco de dados dispon√≠vel, que d√° suporte a linguagens de consulta como a SQL. O problema com a SQL √© que ela √© uma linguagem estruturada, que assume que o usu√°rio est√° ciente do esquema do banco de dados. A SQL d√° suporte a opera√ß√µes da √°lgebra relacional  que  permitem  que  um  usu√°rio  selecione linhas  e  colunas  de  dados  das  tabelas  ou  informa√ß√µes relacionadas √† jun√ß√£o de tabelas com base em campos comuns. No pr√≥ximo cap√≠tulo, veremos que a tecnologia de data warehouse merece v√°rios tipos de funcionalidade: de consolida√ß√£o, agrega√ß√£o e resumo de dados. Os data warehouses (ou armaz√©ns de  dados)  nos  permitem  ver  a  mesma  informa√ß√£o por m√∫ltiplas dimens√µes. Neste cap√≠tulo, voltaremos nossa aten√ß√£o para outra √°rea de interesse muito popular, conhecida como minera√ß√£o de dados (ou data mining ). Como o termo indica, minera√ß√£o de dados refere-se √† minera√ß√£o ou descoberta de novas informa√ß√µes em termos de padr√µes ou regras com base em grandes quantidades de dados. Para ser √∫til na pr√°tica, a minera√ß√£o de dados precisa ser executada de modo eficiente em grandes arquivos e bancos de dados. Embora alguns recursos de minera√ß√£o de dados estejam sendo fornecidos em SGBDRs, ela n√£o √©  bem  integrada  aos  sistemas  de  gerenciamento  de banco de dados.

## Conceitos de minera√ß√£o de dados

Destacaremos a natureza da informa√ß√£o que √© descoberta,  os  tipos  de  problemas  enfrentados  quando se tenta minerar bancos de dados e os tipos de aplica√ß√µes da minera√ß√£o de dados. Tamb√©m analisaremos o que h√° de mais moderno em uma s√©rie de ferramentas comerciais dispon√≠veis (ver Se√ß√£o 28.7) e descreveremos v√°rios  avan√ßos  de  pesquisa  necess√°rios  para  tornar essa √°rea vi√°vel.

## 28.1 Vis√£o geral da tecnologia de minera√ß√£o de dados

Em relat√≥rios como o popular Gartner Report, 1 a minera√ß√£o de dados tem sido aclamada como uma das  principais  tecnologias  para  o  futuro  pr√≥ximo. Nesta se√ß√£o, relacionamos a minera√ß√£o de dados √† √°rea  mais  ampla,  chamada descoberta  do  conhecimento , e comparamos as duas por meio de um exemplo ilustrativo.

## 28.1.1 Minera√ß√£o de dados versus data warehousing

Vamos revisar rapidamente o que h√° de mais moderno nesse vasto campo da minera√ß√£o de dados, que utiliza t√©cnicas de √°reas como aprendizado de m√°quina,  estat√≠stica,  redes  neurais  e  algoritmos  gen√©ticos.

O objetivo de um data warehouse (ver Cap√≠tulo 29) √© dar suporte √† tomada de decis√£o com dados. A  minera√ß√£o  de  dados  pode  ser  usada  junto  com um data warehouse para ajudar com certos tipos de decis√µes. A minera√ß√£o de dados pode ser aplicada a bancos de dados operacionais com transa√ß√µes individuais. Para tornar a minera√ß√£o de dados mais eficiente, o data warehouse deve ter uma cole√ß√£o de dados agregada ou resumida. A minera√ß√£o de dados ajuda na extra√ß√£o de novos padr√µes significativos que n√£o podem  ser  necessariamente  encontrados  apenas  ao

1 O Gartner Report √© um exemplo das muitas publica√ß√µes de pesquisa de tecnologia que os gerentes corporativos utilizam para elaborar discuss√µes sobre sele√ß√£o de tecnologia.

consultar ou processar dados ou metadados no data warehouse.  Portanto,  as  aplica√ß√µes  de  minera√ß√£o de  dados  devem ser fortemente consideradas desde cedo, durante o projeto de um data warehouse. Al√©m disso, ferramentas de minera√ß√£o de dados devem ser projetadas  para  facilitar  seu  uso  juntamente  com data warehouse. De fato, para bancos de dados muito grandes, que rodam terabytes ou at√© petabytes de dados, o uso bem-sucedido das aplica√ß√µes de minera√ß√£o de dados depender√°, primeiro, da constru√ß√£o de um data warehouse.

## 28.1.2 Minera√ß√£o de dados como parte do processo de descoberta do conhecimento

A descoberta  de  conhecimento  nos  bancos  de dados , abreviada como KDD ( Knowledge Discovery in Databases ), normalmente abrange mais do que a minera√ß√£o de dados. O processo de descoberta de conhecimento compreende seis fases: 2  sele√ß√£o de dados, limpeza de dados, enriquecimento, transforma√ß√£o ou codifica√ß√£o de dados, minera√ß√£o de dados e o relat√≥rio e exibi√ß√£o da informa√ß√£o descoberta.

Como exemplo, considere um banco de dados de transa√ß√£o mantido por um revendedor de bens de consumo especializados. Suponha que os dados do cliente incluam um nome de cliente, CEP, n√∫mero de telefone, data de compra, c√≥digo do item, pre√ßo, quantidade e valor total. Uma grande quantidade  de  conhecimento  novo  pode  ser  descoberta pelo processamento KDD nesse banco de dados de cliente.  Durante  a sele√ß√£o  de  dados ,  dados  sobre itens espec√≠ficos ou categorias de itens, ou de lojas em uma regi√£o ou √°rea espec√≠fica do pa√≠s, podem ser selecionados. O processo de limpeza de dados , ent√£o,  pode  corrigir  c√≥digos  postais  inv√°lidos  ou eliminar registros com prefixos de telefone incorretos. O enriquecimento normalmente melhora os dados  com  fontes  de  informa√ß√£o  adicionais.  Por exemplo, dados os nomes de cliente e n√∫meros de telefone, a loja pode adquirir outros dados sobre idade, renda e avalia√ß√£o de cr√©dito e anex√°-los a cada registro. A transforma√ß√£o de dados e a codifica√ß√£o podem ser feitas para reduzir a quantidade de dados. Por exemplo, os c√≥digos de item podem ser agrupados em rela√ß√£o a categorias de produtos, em √°udio, v√≠deo, suprimentos, aparelhos eletr√¥nicos, c√¢mera, acess√≥rios, e assim por diante. Os c√≥digos postais podem ser agregados em regi√µes geogr√°ficas, as rendas podem ser divididas em faixas, e assim por diante. Na Figura 29.1, mostraremos uma etapa chamada limpeza como  um  precursor para a cria√ß√£o do data warehouse. Se a minera√ß√£o

2 Esta discuss√£o em grande parte √© baseada em Adriaans e Zantinge (1996).

de dados for baseada em um data warehouse existente para essa cadeia de varejo, podemos esperar que  a  limpeza  j√°  tenha  sido  aplicada.  √â  somente depois  do  pr√©-processamento  que  as  t√©cnicas  de minera√ß√£o de dados s√£o usadas para extrair diferentes regras e padr√µes.

- O resultado da minera√ß√£o pode ser descobrir o seguinte tipo de informa√ß√£o nova :
- ¬Ñ Regras de associa√ß√£o - por exemplo, sempre que um cliente compra equipamento de v√≠deo, ele ou ela tamb√©m compra outro aparelho eletr√¥nico.
- ¬Ñ Padr√µes sequenciais - por exemplo, suponha que um cliente compre uma c√¢mera e dentro de tr√™s meses ele ou ela compre suprimentos fotogr√°ficos, depois, dentro de seis meses, ele ou ela provavelmente comprar√° um item de acess√≥rio.  Isso  define  um  padr√£o  sequencial de transa√ß√µes. Um cliente que compra mais que  o  dobro  em  per√≠odos  fracos  provavelmente poder√° comprar pelo menos uma vez durante o per√≠odo de Natal.
- ¬Ñ √Årvores de classifica√ß√£o - por exemplo, os clientes podem ser classificados por frequ√™ncia de visitas, tipos de financiamento utilizado, valor da compra ou afinidade para tipos de itens; algumas estat√≠sticas reveladoras podem ser geradas para essas classes.

Podemos ver que existem muitas possibilidades para descobrir novos conhecimentos sobre padr√µes de compra,  relacionando  fatores  como  idade,  grupo de renda, local de resid√™ncia, o que e quanto os clientes compram. Essa informa√ß√£o pode ent√£o ser utilizada para planejar locais adicionais de loja com base em demografias, realizar promo√ß√µes, combinar itens em propagandas  ou  planejar  estrat√©gias  de  marketing sazonal. Conforme mostra esse exemplo de loja de varejo, a minera√ß√£o de dados precisa ser precedida por uma prepara√ß√£o significativa nos dados, antes de gerar informa√ß√µes √∫teis que possam influenciar diretamente as decis√µes de neg√≥cios.

Os resultados da minera√ß√£o de dados podem ser informados  em  diversos  formatos,  como  listagens, sa√≠das gr√°ficas, tabelas de resumo ou visualiza√ß√µes.

## 28.1.3 Objetivos da minera√ß√£o de dados e da descoberta do conhecimento

A  minera√ß√£o  de  dados  costuma  ser  executada com  alguns  objetivos  finais  ou  aplica√ß√µes.  De  um modo geral, esses objetivos se encontram nas seguintes classes: previs√£o, identifica√ß√£o, classifica√ß√£o e otimiza√ß√£o.

- ¬Ñ Previs√£o. A minera√ß√£o de dados pode mostrar como certos atributos dos dados se comportar√£o no futuro. Alguns exemplos de minera√ß√£o de dados previs√≠vel incluem a an√°lise de transa√ß√µes de compra para prever o que os consumidores comprar√£o sob certos descontos,  quanto  volume  de  vendas  uma  loja gerar√° em determinado per√≠odo e se a exclus√£o  de  uma  linha  de  produtos  gerar√°  mais lucros. Em tais aplica√ß√µes, a l√≥gica de neg√≥cios √© usada junto com a minera√ß√£o de dados. Em um contexto cient√≠fico, certos padr√µes de onda  s√≠smica  podem  prever  um  terremoto com alta probabilidade.
- ¬Ñ Identifica√ß√£o. Os  padr√µes  de  dados  podem ser usados para identificar a exist√™ncia de um item, um evento ou uma atividade. Por exemplo,  intrusos  tentando  quebrar  um  sistema podem ser identificados pelos programas executados, arquivos acessados e tempo de CPU por sess√£o. Em aplica√ß√µes biol√≥gicas, a exist√™ncia de um gene pode ser identificada por certas sequ√™ncias de s√≠mbolos nucleot√≠deos na sequ√™ncia de DNA. A √°rea conhecida como autentica√ß√£o √©  uma  forma  de  identifica√ß√£o. Ela confirma se um usu√°rio √© realmente um usu√°rio espec√≠fico ou de uma classe autorizada,  e  envolve  uma  compara√ß√£o  de  par√¢metros, imagens ou sinais contra um banco de dados.
- ¬Ñ Classifica√ß√£o. A  minera√ß√£o  de  dados  pode particionar os dados de modo que diferentes classes ou categorias possam ser identificadas com base em combina√ß√µes de par√¢metros. Por exemplo, os clientes em um supermercado podem  ser  categorizados  em  compradores  que buscam  desconto,  compradores  com  pressa, compradores regulares leais, compradores ligados  a  marcas  conhecidas  e  compradores eventuais.  Essa  classifica√ß√£o  pode  ser  usada em diferentes an√°lises de transa√ß√µes de compra de cliente como uma atividade p√≥s-minera√ß√£o. √Äs vezes, a classifica√ß√£o baseada em conhecimento  de  dom√≠nio  comum  √©  utilizada  como uma entrada  para  decompor  o  problema  de minera√ß√£o e torn√°-lo mais simples. Por exemplo,  alimentos  saud√°veis,  alimentos  de  festa ou alimentos de lanche escolar s√£o categorias distintas  nos  neg√≥cios do supermercado. Faz sentido analisar os relacionamentos dentro e entre  categorias  como  problemas  separados. Essa categoriza√ß√£o pode servir para codificar os dados corretamente antes de submet√™-los a mais minera√ß√£o de dados.
- ¬Ñ Otimiza√ß√£o. Um objetivo relevante da minera√ß√£o  de  dados  pode  ser  otimizar  o  uso  de recursos limitados, como tempo, espa√ßo, dinheiro ou materiais e maximizar vari√°veis de sa√≠da como vendas ou lucros sob determinado conjunto de restri√ß√µes. Como tal, esse objetivo da minera√ß√£o de dados √© semelhante √† fun√ß√£o objetiva, usada em problemas de pesquisa  operacional,  que  lida  com  otimiza√ß√£o sob restri√ß√µes.
- O termo minera√ß√£o de dados √© usado popularmente em um sentido muito amplo. Em algumas situa√ß√µes, ele inclui an√°lise estat√≠stica e otimiza√ß√£o restrita, bem como aprendizado de m√°quina. N√£o existe uma linha  n√≠tida  separando  a  minera√ß√£o  de  dados dessas disciplinas. Portanto, est√° al√©m do nosso escopo discutir com detalhes a gama inteira de aplica√ß√µes que  comp√µem  esse  vasto  corpo  de  trabalho.  Para um entendimento detalhado do assunto, os leitores poder√£o consultar livros especializados, dedicados √† minera√ß√£o de dados.

## 28.1.4 Tipos de conhecimento descobertos durante a minera√ß√£o de dados

O termo conhecimento √© interpretado de forma livre como algo que envolve algum grau de intelig√™ncia. Existe uma progress√£o de dados brutos da informa√ß√£o para conhecimento, enquanto passamos pelo processamento  adicional.  O  conhecimento  normalmente √© classificado como indutivo versus dedutivo. O conhecimento dedutivo deduz novas informa√ß√µes com base na aplica√ß√£o de regras l√≥gicas previamente especificadas de  dedu√ß√£o sobre o dado indicado. A minera√ß√£o de dados enfoca o conhecimento indutivo , que descobre novas regras e padr√µes com base nos dados  fornecidos.  O  conhecimento  pode  ser  representado de v√°rias maneiras: em um sentido desestruturado, ele pode ser representado por regras ou pela l√≥gica proposicional. Em uma forma estruturada, ele pode ser representado em √°rvores de decis√£o, redes sem√¢nticas,  redes  neurais  ou  hierarquias  de  classes ou frames. √â comum descrever o conhecimento descoberto durante a minera√ß√£o de dados da seguinte forma:

- ¬Ñ Regras de associa√ß√£o. Essas regras correlacionam a presen√ßa de um itemset com outra faixa de valores para um conjunto de vari√°veis diverso. Exemplos: (1) Quando uma compradora  adquire  uma  bolsa,  ela  provavelmente compra sapatos. (2) Uma imagem de raio X contendo caracter√≠sticas a e b provavelmente tamb√©m exibe a caracter√≠stica c.

- ¬Ñ Hierarquias  de  classifica√ß√£o. O  objetivo  √© trabalhar  partindo  de  um  conjunto  existente  de  eventos  ou  transa√ß√µes  para  criar  uma hierarquia  de  classes.  Exemplos:  (1)  Uma popula√ß√£o pode ser dividida em cinco faixas de possibilidade de cr√©dito com base em um hist√≥rico de transa√ß√µes de cr√©dito anteriores. (2)  Um  modelo pode ser desenvolvido para os fatores que determinam o desejo de obter a localiza√ß√£o de loja em uma escala de 1 a 10. (3) Companhias de investimentos podem ser classificadas com base nos dados de desempenho usando caracter√≠sticas como crescimento, receita e estabilidade.
- ¬Ñ Padr√µes sequenciais. Uma sequ√™ncia de a√ß√µes ou  eventos  √©  buscada.  Exemplo:  se  um  paciente passou por uma cirurgia de ponte de safena para art√©rias bloqueadas e um aneurisma e, depois, desenvolveu ureia sangu√≠nea alta  dentro  de  um  ano  da  cirurgia,  ele  provavelmente sofrer√° de insufici√™ncia renal nos pr√≥ximos 18 meses. A detec√ß√£o de padr√µes sequenciais √© equivalente √† detec√ß√£o de associa√ß√µes  entre  eventos  com  certos  relacionamentos temporais.
- ¬Ñ Padr√µes dentro de s√©rie temporal. As similaridades podem ser detectadas dentro de posi√ß√µes de uma s√©rie temporal de dados, que √© uma sequ√™ncia de dados tomados em intervalos regulares, como vendas di√°rias ou pre√ßos de a√ß√µes de fechamento  di√°rio.  Exemplos:  (1)  As  a√ß√µes de uma companhia de energia, ABC Power, e uma  companhia  financeira,  XYZ  Securities, mostraram o mesmo padr√£o durante 2009 em mat√©ria de pre√ßos de fechamento de a√ß√µes. (2) Dois produtos mostraram o mesmo padr√£o de vendas no ver√£o, mas um padr√£o diferente no inverno. (3) Um padr√£o no vento magn√©tico solar pode ser usado para prever mudan√ßas nas condi√ß√µes atmosf√©ricas da Terra.

Exemplos: (1) Uma popula√ß√£o inteira de dados de transa√ß√£o sobre uma doen√ßa pode ser dividida em grupos com base na similaridade  dos  efeitos  colaterais  produzidos.  (2)  A popula√ß√£o  adulta  nos  Estados  Unidos  pode ser categorizada em cinco grupos, desde mais prov√°veis de comprar at√© menos prov√°veis de comprar um novo produto. (3) Os acessos √† Web feitos por uma cole√ß√£o de usu√°rios contra  um  conjunto  de  documentos  (digamos, em uma biblioteca digital) podem ser analisados em rela√ß√£o √†s palavras-chave dos documentos para revelar grupos ou categorias de usu√°rios.

Para a maioria das aplica√ß√µes, o conhecimento desejado √© uma combina√ß√£o dos tipos citados. Expandimos cada um desses tipos de conhecimento nas pr√≥ximas se√ß√µes.

## 28.2 Regras de associa√ß√£o

## 28.2.1 Modelo de cesta de mercado, suporte e confian√ßa

Uma  das  principais  tecnologias  em  minera√ß√£o de dados envolve a descoberta de regras de associa√ß√£o. O banco de dados √© considerado uma cole√ß√£o de transa√ß√µes,  cada  uma  envolvendo  um  itemset.  Um exemplo comum √© o de dados de cesta de mercado . Aqui, a cesta de mercado corresponde aos conjuntos de itens que um consumidor compra em um supermercado durante uma visita. Considere quatro dessas transa√ß√µes em uma amostra aleat√≥ria exibida na Figura 28.1.

- ¬Ñ Agrupamento. Determinada popula√ß√£o de eventos ou itens pode ser particionada (segmentada) em  conjuntos  de  elementos  'semelhantes'.

Uma regra de associa√ß√£o tem a forma X =&gt; Y , onde X = { x 1 , x 2 , ..., x n } e Y = { y 1 , y 2 , ..., y n } s√£o conjuntos de itens, com x i e y j sendo itens distintos para todo    e  todo i j .  Essa  associa√ß√£o  indica  que,  se  um cliente compra X , ele ou ela tamb√©m provavelmente comprar√° Y . Em geral, qualquer regra de associa√ß√£o tem a forma LHS (lado esquedo ou left-hand side ) =&gt; RHS (lado direito ou right-hand side ),  onde LHS e RHS s√£o conjuntos de itens. O conjunto LHS ‚à™ RHS √©

Figura 28.1

|   Id_transa√ß√£o | Hora   | Itens_comprados            |
|----------------|--------|----------------------------|
|            101 | 6:35   | leite, p√£o, biscoito, suco |
|            792 | 7:38   | leite, suco                |
|           1130 | 8:05   | leite, ovos                |
|           1735 | 8:40   | p√£o, biscoito, caf√©        |

Exemplo de transa√ß√µes no modelo de cesta de mercado.

chamado de itemset , o conjunto dos itens comprados pelos clientes. Para que uma regra de associa√ß√£o seja de interesse para um minerador de dados, a regra deve satisfazer alguma medida de interesse. Duas  medidas  de  interesse  comuns  s√£o  suporte  e confian√ßa.

O suporte para  uma  regra  LHS  =&gt;  RHS  √© com  rela√ß√£o  ao  itemset;  ele  se  refere  √†  frequ√™ncia  com  que  um  itemset  espec√≠fico  ocorre  no  banco  de  dados.  Ou  seja,  o  suporte  √©  o  percentual  de transa√ß√µes que cont√™m todos os itens no itemset LHS ‚à™ RHS. Se o suporte for baixo, isso implica que n√£o existe evid√™ncia forte de que os itens no LHS ‚à™ RHS ocorrem juntos, pois o itemset ocorre em apenas uma pequena fra√ß√£o das transa√ß√µes. Outro termo para suporte √© preval√™ncia da regra.

A confian√ßa √© com rela√ß√£o √† implica√ß√£o mostrada na regra. A confian√ßa da regra LHS =&gt; RHS √© calculada como o suporte(LHS ‚à™ RHS)/suporte(LHS). Podemos pensar nela como a probabilidade de que os itens no RHS sejam comprados, dado que os itens no LSH s√£o comprados por um cliente. Outro termo para confian√ßa √© for√ßa da regra.

Como um exemplo de suporte e confian√ßa, considere  as  duas  regras  a  seguir:  leite  =&gt;  suco  e  p√£o =&gt;  suco.  Examinando  nossas  quatro  transa√ß√µes  de exemplo na Figura 28.1, vemos que o suporte de {leite, suco} √© 50 por cento e o suporte de {p√£o, suco} √© apenas 25 por cento. A confian√ßa de leite =&gt; suco √© de 66,7 por cento (significando que, das tr√™s transa√ß√µes em que ocorre leite, duas cont√™m suco) e a confian√ßa de p√£o =&gt; suco √© de 50 por cento (significando que uma de duas transa√ß√µes que cont√™m p√£o tamb√©m cont√©m suco).

Como podemos ver, o suporte e a confian√ßa n√£o necessariamente  andam  lado  a  lado.  O  objetivo  da minera√ß√£o de regras de associa√ß√£o, ent√£o, √© gerar todas as regras poss√≠veis que excedem alguns patamares m√≠nimos de suporte e confian√ßa especificados pelo usu√°rio. O problema, portanto, √© decomposto em dois subproblemas:

- 1. Gerar todos os itemsets que t√™m um suporte que  excede  o  1-itemset.  Esses  conjuntos  de itens  s√£o  chamados de itemsets grandes (ou frequentes) . Observe que grande aqui significa grande suporte.
- 2. Para cada itemset grande, todas as regras que t√™m  uma  confian√ßa  m√≠nima  s√£o  geradas  da seguinte forma: para um itemset grande X e Y ‚äÇ X ,  considere que Z = X -Y ;  ent√£o, se suporte( X )/suporte( Z ) &gt; confian√ßa m√≠nima, a regra Z =&gt; Y (ou seja, X -Y =&gt; Y ) √© uma regra v√°lida.

A  gera√ß√£o  de  regras  usando  todos  os  itemsets grandes e seus suportes √© relativamente simples. Por√©m,  descobrir  todos  os  itemset  junto  com  o  valor para seu suporte √© um problema dif√≠cil se a cardinalidade do itemset for muito alta. Um supermercado t√≠pico possui milhares de itens. O n√∫mero de itemsets distintos √© 2 , onde n n √© o n√∫mero de itens, e contar o suporte para todos os conjuntos de itemsets poss√≠veis torna-se uma tarefa muito intensa em computa√ß√£o. Para reduzir o espa√ßo de pesquisa combinat√≥ria, os algoritmos para encontrar regras de associa√ß√£o utilizam as seguintes propriedades:

- ¬Ñ Um subconjunto de um itemset grande tamb√©m deve ser grande (ou seja, cada subconjunto de um itemset grande excede o suporte m√≠nimo exigido).
- ¬Ñ Reciprocamente,  um  superconjunto  de  um itemset  pequeno  tamb√©m  √©  pequeno  (implicando que ele n√£o tem suporte suficiente).

A  primeira  propriedade  √©  conhecida  como fechamento  para  baixo .  A  segunda  propriedade, chamada antimonotonicidade ,  ajuda  a  reduzir  o espa√ßo  de  busca  de  poss√≠veis  solu√ß√µes.  Ou  seja, quando  se  descobre  que  um  itemset  √©  pequeno (n√£o  um  itemset  grande),  ent√£o  qualquer  extens√£o a esse itemset, formada ao acrescentar um ou mais itens ao conjunto, tamb√©m gerar√° um itemset pequeno.

## 28.2.2 Algoritmo Apriori

O primeiro algoritmo a usar as propriedades de  fechamento  para  baixo  e  antimonotonicidade foi  o algoritmo  Apriori ,  mostrado  como  o  Algoritmo 28.1.

Ilustramos  o  Algoritmo  28.1  utilizando  os dados de transa√ß√£o da Figura 28.1 que usam um suporte m√≠nimo de 0,5. Os 1-itemsets scandidatos s√£o  {leite,  p√£o,  suco,  biscoito,  ovos,  caf√©}  e  seus respectivos suportes s√£o 0,75, 0,5, 0,5, 0,5, 0,25 e 0,25. Os quatro primeiros itens se qualificam para L 1 ,  pois  cada suporte √© maior ou igual a 0,5. Na primeira  itera√ß√£o  do  loop-repita,  estendemos  os 1-itemsets frequentes para criar os 2-itemsets frequentes candidatos, C 2 . C 2 cont√©m {leite, p√£o}, {leite, suco}, {p√£o, suco}, {leite, biscoito}, {p√£o, biscoito} e {suco, biscoito}. Observe, por exemplo, que {leite, ovos} n√£o aparece em C 2 ,  pois {ovos} √© pequeno (pela propriedade da antimonotonicidade) e n√£o aparece em L 1 . O suporte para os seis conjuntos contidos em C 2 s√£o 0,25, 0,5, 0,25, 0,25, 0,5 e 0,25 e s√£o calculados com a varredura do conjunto de transa√ß√µes. Somente o segundo 2-itemset {leite,

suco} e o quinto 2-itemset {p√£o, biscoito} t√™m suporte maior ou igual a 0,5. Esses dois 2-itemsets formam os conjuntos de 2 itens frequentes, L . 2

Algoritmo 28.1. O Algoritmo Apriori para encontrar itemsets frequentes (grandes)

Entrada: banco de dados de m transa√ß√µes, D , e um suporte m√≠nimo, mins , representado como uma fra√ß√£o de m.

Sa√≠da: itemsets frequentes, L 1 , L 2 , ..., L k

In√≠cio / ÔÉ© etapas  ou  instru√ß√µes  s√£o  numeradas  para aumentar a legibilidade ÔÉ© /

- 1. Calcule  suporte( i j )  =  conta( i j )/ m para  cada item individual, i 1 , i 2 , ..., i n fazendo a varredura do banco de dados uma vez e contando o n√∫mero de transa√ß√µes em que o item   aparei j ce (ou seja, conta( i j ));
- 2. O 1-itemset frequente candidato, C 1 ,  ser√°  o itemset i 1 , i 2 , ..., i n ;
- 3. O  subconjunto  de  itens  contendo i j de C 1 onde suporte( ) &gt;= mins torna-se o 1-itemset i j frequente, L 1 ;

termina = false;

- 4. k = 1; repita
- 1. L k +1 = ;
- 2. Crie  o  ( k +1)-itemset  frequente  candidato, C k +1 ,  combinando  membros  de L k que  t√™m k -1  itens  em  comum  (isso  forma  os  ( k +1)-itemsets  frequentes  candidatos  ao  estender seletivamente os k -itemsets frequentes em um item);
- 3. Al√©m disso, apenas considere como elementos  de C k +1 aqueles k +1  itens  tais  que  cada subconjunto de tamanho k apare√ßa em L k ;
- 4. Fa√ßa  a  varredura  do  banco  de  dados  uma vez e calcule o suporte para cada membro de C k +1 ; se o suporte para um membro de C k +1 &gt;= mins, ent√£o acrescente o membro em L k +1 ;
- 5. Se L k +1 for vazio, ent√£o termina = true, se n√£o, k = k + 1;

at√© que termina;

Fim;

Na pr√≥xima itera√ß√£o do loop-repita, constru√≠mos  3-itemsets  frequentes  candidatos  acrescentando itens adicionais aos conjuntos em L 2 .  Contudo,  para  nenhuma  extens√£o  de  itemsets  em L 2 todos os subconjuntos de 2-item estar√£o contidos em L 2 .  Por  exemplo,  considere  {leite,  suco,  p√£o};

o 2-itemset {leite, p√£o} n√£o est√° em L 2 , logo {leite, suco,  p√£o}  n√£o  pode  ser  um  3-itemset  frequentes pela propriedade de fechamento para baixo. Nesse ponto, o algoritmo termina com L 1 igual a {{leite}, {p√£o}, {suco}, {biscoito}} e L 2 igual a {{leite, suco}, {p√£o, biscoito}}.

V√°rios outros algoritmos foram propostos para  minerar  regras  de  associa√ß√£o.  Eles  variam principalmente  em  rela√ß√£o  a  como  os  itemsets candidatos  s√£o  gerados  e  como  os  suportes  para os itemsets candidatos s√£o contados. Alguns algoritmos  usam  essas  estruturas  de  dados  como  mapas  de  bits  e  √°rvores  de  hash  para  manter  informa√ß√µes  sobre  itemsets.  V√°rios  algoritmos  foram propostos para usar m√∫ltiplas varreduras do banco de dados, pois o n√∫mero em potencial de itemsets, 2 , pode ser muito grande para configurar contam dores durante uma √∫nica varredura. Examinaremos tr√™s  algoritmos  melhorados  (em  compara√ß√£o  com o  algoritmo  Apriori)  para  minera√ß√£o  da  regra  de associa√ß√£o: o algoritmo de amostragem, o algoritmo de √°rvore de padr√£o frequente e o algoritmo de parti√ß√£o.

## 28.2.3 Algoritmo de amostragem

A ideia principal para o algoritmo de amostragem √© selecionar uma amostra pequena, que caiba na mem√≥ria principal, do banco de dados de transa√ß√µes e determinar os itemsets frequentes com base nessa amostra. Se esses itemsets frequentes formarem um superconjunto dos itemsets frequentes para o banco de dados inteiro, ent√£o podemos determinar os itemsets frequentes reais fazendo a varredura do restante do banco de dados a fim de calcular os valores de suporte  exatos  para  os  itemsets  do  superconjunto. Um superconjunto dos itemsets frequentes em geral pode ser encontrado na amostra usando, por exemplo, o algoritmo Apriori, com um suporte m√≠nimo reduzido.

Em casos raros, alguns itemsets frequentes podem ser perdidos e uma segunda varredura do banco de dados √© necess√°ria. Para decidir se quaisquer itemsets frequentes foram perdidos, o conceito de borda negativa √© usado. A borda negativa com rela√ß√£o a um itemset frequente, S , e itemset, I , s√£o os itemsets m√≠nimos contidos em PowerSet( ) e n√£o em I S . A ideia b√°sica √© que a borda negativa de um conjunto de item  sets frequentes cont√©m os itemsets mais pr√≥ximos que tamb√©m poderiam ser frequentes. Considere o caso em que um conjunto X n√£o est√° contido nos itemsets frequentes. Se todos os subconjuntos de X estiverem contidos no conjunto de itemsets frequentes, ent√£o X estaria na borda negativa.

Ilustramos isso com o exemplo a seguir. Considere o itemset   = {A, B, C, D, E} e que os itemsets freI quentes combinados de tamanho 1 a 3 sejam   = {{A}, S {B}, {C}, {D}, {AB}, {AC}, {BC}, {AD}, {CD}, {ABC}}. A borda negativa √© {{E}, {BD}, {ACD}}. O conjunto {E} √© o √∫nico 1-itemset n√£o contido em S ,  {BD} √© o √∫nico 2-itemset que n√£o est√£o em S , mas cujos subconjuntos de 1-itemset est√£o, e {ACD} √© o √∫nico 3-itemset cujos subconjuntos de 2-itemset est√£o todos em S . A borda negativa √© importante porque ela √© necess√°ria para determinar o suporte para esses itemsets na borda negativa, garantindo que nenhum itemset grande se perca da an√°lise dos dados de amostra.

- O suporte para a borda negativa √© determinado quando o restante do banco de dados √© varrido. Se descobrirmos que um itemset X na  borda  negativa pertence ao conjunto de todos os itemsets frequentes, ent√£o existe um potencial para um superconjunto de X tamb√©m ser frequente. Se isso acontecer, uma segunda passada pelo banco de dados √© necess√°ria para garantir que todos os itemsets frequentes sejam localizados.

## 28.2.4 Algoritmo de √°rvore de padr√£o frequente (FP) e de crescimento FP

- O algoritmo de √°rvore de padr√£o frequente (√°rvore FP) √© motivado pelo fato de os algoritmos baseados no Apriori poderem gerar e testar um n√∫mero muito grande de itemsets candidatos. Por exemplo, com 1.000 1-itemsets frequentes, o algoritmo Apriori teria de gerar

<!-- formula-not-decoded -->

ou  499.500  2-itemsets  candidatos.  O algoritmo de crescimento FP √© uma t√©cnica que elimina a gera√ß√£o de um grande n√∫mero de itemsets candidatos.

- O  algoritmo  primeiro  produz  uma  vers√£o compactada do banco de dados em rela√ß√£o a uma √°rvore FP (√°rvore de padr√£o frequente). A √°rvore FP armazena informa√ß√µes relevantes do itemset e permite a descoberta eficiente de itemsets frequentes.  O  processo real de minera√ß√£o adota uma estrat√©gia de dividir-e-conquistar, em que o processo de  minera√ß√£o  √©  decomposto  em  um  conjunto  de tarefas menores que cada um opera em uma √°rvore  FP  condicional,  um subconjunto (proje√ß√£o) da √°rvore original. Para come√ßar, examinamos como a √°rvore FP √© constru√≠da. O banco de dados √© primeiro varrido e os 1-itemsets frequentes junto com seu  suporte  s√£o  calculados.  Com  esse  algoritmo, o suporte √© a contagem de transa√ß√µes que cont√™m

o item em vez da fra√ß√£o de transa√ß√µes contendo o item.  Os  1-itemsets  frequentes  s√£o  ent√£o  classificados em ordem n√£o crescente de seu suporte. Em seguida, a raiz da √°rvore FP √© criada com um r√≥tulo NULL . O banco de dados √© varrido uma segunda vez e, para cada transa√ß√£o T no banco de dados, os 1-itemsets mais frequentes em T s√£o colocados na ordem que foi feita com os 1-itemsets frequentes. Podemos designar essa lista ordenada para T como consistindo  em  um  primeiro  item,  a  cabe√ßa,  e  os itens restantes, a cauda. A informa√ß√£o do itemset (cabe√ßa, cauda) √© inserida na √°rvore FP recursivamente, come√ßando no n√≥ raiz, da seguinte forma:

- 1. Se o n√≥ atual, N , da √°rvore FP tiver um filho com um nome de item = cabe√ßa, ent√£o, incremente o contador associado ao n√≥ N em 1, sen√£o, crie outro n√≥, N , com uma contagem de 1, vincule N a seu pai e vincule N √† tabela do cabe√ßalho do item (usada para travessia eficiente da √°rvore).
- 2. Se a cauda n√£o for vazia, ent√£o repita a etapa (1) usando como lista ordenada somente a  cauda,  ou  seja,  a  antiga  cabe√ßa  √©  removida,  a  nova  cabe√ßa  √©  o  primeiro  item  da cauda e os itens restantes tornam-se a nova cauda.

A tabela de cabe√ßalho do item, criada durante o processo de constru√ß√£o da √°rvore FP, cont√©m tr√™s campos por entrada para cada item frequente: identificador de item, contador de suporte e link de n√≥. O identificador de item e o contador de suporte s√£o autoexplicativos. O link do n√≥ √© um ponteiro para uma ocorr√™ncia desse item na √°rvore FP. Como v√°rias  ocorr√™ncias  de  um  √∫nico  item  podem  aparecer na √°rvore FP, esses itens s√£o vinculados como uma lista em que seu in√≠cio √© apontado pelo link do n√≥ na tabela de cabe√ßalho do item. Ilustramos a constru√ß√£o da √°rvore FP com os dados de transa√ß√£o da Figura 28.1. Vamos usar um suporte m√≠nimo de dois. Uma passada  pelas  quatro  transa√ß√µes  gera  os  seguintes 1-itemsets frequentes com suporte associado: {{(leite, 3)}, {(p√£o, 2)}, {(biscoito, 2)}, {(suco, 2)}}. O banco de dados √© varrido uma segunda vez e cada transa√ß√£o ser√° processada novamente.

Para a primeira transa√ß√£o, criamos a lista ordenada, T = {leite, p√£o, biscoito, suco}. Os itens em T s√£o  conjuntos  de  um  item  frequentes  com  base  na primeira transa√ß√£o. Os itens s√£o ordenados com base na ordem n√£o crescente do contador dos 1-itemsets encontrados  na  passada  1  (ou  seja,  leite  primeiro, p√£o em segundo, e assim por diante). Criamos um n√≥ raiz NULL para a √°rvore FP e inserimos leite como um filho da raiz, p√£o como um filho de leite , biscoito

como um filho de p√£o , e suco como um filho de biscoito . Ajustamos as entradas para os itens frequentes na tabela de cabe√ßalho do item.

Para a segunda transa√ß√£o, temos a lista ordenada {leite, suco}. Come√ßando na raiz, vemos que o n√≥ filho com r√≥tulo leite existe, de modo que movemos para esse n√≥ e atualizamos seu contador (para considerar a segunda transa√ß√£o que cont√©m leite). Vemos que  n√£o  existe  filho  do  n√≥  atual  com  r√≥tulo suco , ent√£o criamos um n√≥ com r√≥tulo suco .  A tabela de cabe√ßalho do item √© ajustada.

A terceira transa√ß√£o s√≥ tem um item frequente, {leite}.  Novamente,  come√ßando  na  raiz,  vemos  que o n√≥ com r√≥tulo leite existe, de modo que movemos para esse n√≥, incrementamos seu contador e ajustamos a tabela de cabe√ßalho do item. A transa√ß√£o final cont√©m itens frequentes, {p√£o, biscoito}. No n√≥ raiz, vemos que um filho com r√≥tulo p√£o n√£o existe. Assim, criamos outro filho da raiz, inicializamos seu contador e depois inserimos biscoito como um filho desse  n√≥,  inicializando  seu  contador.  Depois  que  a tabela de cabe√ßalho do item √© atualizada, acabamos ficando com a √°rvore FP e a tabela de cabe√ßalho do item  como  mostra  a  Figura  28.2.  Se  examinarmos essa √°rvore FP, vemos que ela realmente representa as transa√ß√µes originais em um formato compactado (ou seja, apenas mostrando os itens de cada transa√ß√£o que s√£o 1-itemsets grandes).

condicional √© composta por um conjunto de caminhos de prefixo, ou seja, onde o item frequente √© um sufixo. Por exemplo, se considerarmos o item suco, vemos pela Figura 28.2 que existem dois caminhos na √°rvore FP que terminam com suco: (leite, p√£o, biscoito, suco) e (leite, suco). Os dois caminhos de prefixo associados s√£o (leite, p√£o, biscoito) e (leite). A √°rvore FP condicional √© constru√≠da a partir dos padr√µes na base de padr√£o condicional. A minera√ß√£o √© realizada recursivamente nessa √°rvore FP. Os padr√µes frequentes s√£o formados ao concatenar o padr√£o de sufixo com os padr√µes frequentes produzidos de uma √°rvore FP condicional.

Algoritmo 28.2. Algoritmo de crescimento FP para localizar itemsets frequentes

Input: √°rvore FP e um suporte m√≠nimo, mins

Output: padr√µes  frequentes  (itemsets)  procedimento-crescimento-FP (√°rvore-beta, beta);

## Begin

se √°rvore cont√©m um √∫nico caminho P ent√£o para cada combina√ß√£o, beta, dos n√≥s no caminho com suporte = suporte m√≠nimo de n√≥s

gera padr√£o (beta ‚à™ alfa) em beta se n√£o

O algoritmo 28.2 √© usado para minera√ß√£o da √°rvore FP para padr√µes frequentes. Com a √°rvore FP, √© poss√≠vel encontrar todos os padr√µes frequentes que cont√™m determinado item frequente, come√ßando da tabela de cabe√ßalho do item para esse item e atravessando os links do n√≥ na √°rvore FP. O algoritmo come√ßa com um 1-itemset frequente (padr√£o de sufixo) e constr√≥i sua base de padr√£o condicional e depois sua √°rvore FP condicional. A base de padr√£o para  cada  item, i ,  no  cabe√ßalho  da  √°rvore fa√ßa in√≠cio

gera padr√£o beta = ( i ‚à™ alfa)  com suporte =  .suporte; i constr√≥i  base  de  padr√£o  condicional de beta;

constr√≥i  √°rvore  FP  condicional  de beta, √°rvore\_beta;

Figura 28.2 √Årvore FP e tabela de cabe√ßalho do item.



fim;

Fim;

Ilustramos o algoritmo usando os dados da Figura 28.1 e a √°rvore da Figura 28.2. O procedimento crescimento-FP √© chamado com dois par√¢metros: a √°rvore FP original e NULL para a vari√°vel alfa. Como a √°rvore FP original tem mais do que um √∫nico caminho, executamos a parte se n√£o da primeira instru√ß√£o se. Come√ßamos com o item frequente, suco. Examinaremos os itens frequentes em ordem de menor suporte (ou seja, da √∫ltima entrada na tabela para a primeira). A vari√°vel beta √© definida como suco com suporte igual a dois.

Seguindo o link do n√≥ na tabela de cabe√ßalho do item, constru√≠mos a base de padr√£o condicional que consiste em dois caminhos (com suco como sufixo). Estes s√£o (leite, p√£o, biscoito: 1) e (leite: 1). A √°rvore FP condicional consiste em apenas um √∫nico n√≥, leite: 2. Isso se deve a um suporte de apenas 1 para o n√≥ p√£o e biscoito, que est√° abaixo do suporte m√≠nimo de 2. O algoritmo √© chamado recursivamente com uma √°rvore FP de apenas um √∫nico n√≥ (ou seja, leite: 2) e um valor beta de suco. Como essa √°rvore FP tem apenas um caminho, todas as combina√ß√µes de beta e n√≥s no caminho s√£o geradas - ou seja, {leite, suco} - com suporte de 2.

Em seguida, o item frequente, biscoito, √© utilizado. A vari√°vel beta √© definida como biscoito com suporte = 2. Seguido o link do n√≥ na tabela de cabe√ßalho  do  item,  constru√≠mos  a  base  de  padr√£o  condicional  que  consiste  em  dois  caminhos.  Estes  s√£o (leite, p√£o: 1) e (p√£o: 1). A √°rvore FP condicional tem apenas um √∫nico n√≥, p√£o: 2. O algoritmo √© chamado recursivamente com uma √°rvore FP de apenas um √∫nico n√≥ (ou seja, p√£o: 2) e um valor beta de biscoito. Como esta √°rvore FP s√≥ tem um caminho, todas as combina√ß√µes de beta e n√≥s no caminho s√£o geradas, ou seja, {p√£o, biscoito} com suporte de 2. O item frequente,  p√£o,  √©  considerado  em  seguida.  A  vari√°vel beta √© definida como p√£o com suporte = 2. Seguindo o link do n√≥ na tabela de cabe√ßalho do item, constru√≠mos a base de padr√£o condicional que consiste em um caminho, que √© (leite: 1). A √°rvore FP condicional √© vazia, pois a contagem √© menor do que o suporte m√≠nimo. Como a √°rvore FP condicional √© vazia, nenhum padr√£o frequente ser√° gerado.

re FP condicional vazia. Em resultado, nenhum padr√£o frequente √© acrescentado. O resultado de execu√ß√£o do algoritmo s√£o os seguintes padr√µes frequentes (ou itemsets) com seu suporte: {{leite: 3}, {p√£o: 2}, {biscoito: 2}, {suco: 2}, {leite, suco: 2}, {p√£o, biscoito: 2}}.

## 28.2.5 Algoritmo de parti√ß√£o

Outro algoritmo, chamado algoritmo de parti√ß√£o , 3 √©  resumido a seguir. Se recebermos um banco de dados com um pequeno n√∫mero de itemsets grandes em potencial, digamos, alguns milhares, ent√£o o suporte para todos eles pode ser testado em uma s√≥ varredura usando uma t√©cnica de particionamento. O particionamento divide o banco de dados em subconjuntos n√£o sobrepostos. Estes s√£o individualmente considerados como bancos de dados separados e todos os itemsets grandes para essa parti√ß√£o, chamados itemsets frequentes locais ,  s√£o gerados em uma passada. O algoritmo Apriori pode ent√£o ser usado de modo eficiente em cada parti√ß√£o se couber inteiramente na mem√≥ria principal. As parti√ß√µes s√£o escolhidas de modo que cada uma possa ser acomodada na mem√≥ria principal. Como tal, uma parti√ß√£o √© lida apenas uma vez em cada passada. A √∫nica desvantagem com esse m√©todo √© que o suporte m√≠nimo usado para cada parti√ß√£o tem um significado ligeiramente diferente do valor original. O suporte m√≠nimo √© baseado no tamanho da parti√ß√£o, em vez de no tamanho do banco de dados, para determinar os itemsets frequentes locais (grandes). O valor do threshold de suporte real √© o mesmo dado anteriormente, mas o suporte √© calculado apenas para uma parti√ß√£o.

O √∫ltimo item frequente a considerar √© leite. Esse √© o item do topo na tabela de cabe√ßalho do item e, como tal, tem uma base de padr√£o condicional vazia e √°rvo-

Ao final  da  passada  um,  recuperamos  a  uni√£o de  todos  os  itemsets  frequentes  de  cada  parti√ß√£o. Isso forma os itemsets frequentes candidatos globais para o banco de dados inteiro. Quando essas listas s√£o mescladas, elas podem conter alguns falsos positivos. Ou seja, alguns dos itemsets que s√£o frequentes (grandes) em uma parti√ß√£o podem n√£o se qualificar em v√°rias outras parti√ß√µes e, portanto, podem n√£o exceder o suporte m√≠nimo quando o banco de dados original  for  considerado.  Observe  que  n√£o  existem falsos negativos; nenhum itemset grande ser√° perdido. Os itemsets grandes candidatos globais identificados na passada 1 s√£o verificados na passada 2; ou seja, seu suporte real √© medido para o banco de dados inteiro . Ao final da fase 2, todos os itemsets grandes globais  s√£o  identificados.  O  algoritmo  de  parti√ß√£o serve naturalmente para uma implementa√ß√£o paralela ou distribu√≠da, para melhor efici√™ncia. Outras melhorias nesse algoritmo foram sugeridas. 4

3 Veja em Savasere et al. (1995) os detalhes do algoritmo, as estruturas de dados usadas para implement√°-lo e suas compara√ß√µes de desempenho.

4 Ver Cheung et al. (1996) e Lin e Dunham (1998).

se √°rvore\_beta n√£o est√° vazio ent√£o crescimento-FP(√°rvore\_beta, beta);

## 28.2.6 Outros tipos de regras de associa√ß√£o

Regras  de  associa√ß√£o  entre  hierarquias. Existem certos tipos de associa√ß√µes que s√£o particularmente interessantes por um motivo especial. Essas associa√ß√µes ocorrem entre hierarquias de itens. Em geral,  √©  poss√≠vel  dividir  os  itens  entre  hierarquias disjuntas  com  base  na  natureza  do  dom√≠nio.  Por exemplo, alimentos em um supermercado, itens em uma loja de departamentos ou artigos em uma loja de  esportes  podem  ser  categorizados  em  classes  e subclasses  que  fazem  surgir  hierarquias.  Considere a Figura 28.3, que mostra a taxonomia de itens em um supermercado. A figura mostra duas hierarquias - bebidas e sobremesas, respectivamente. Os grupos inteiros podem n√£o produzir associa√ß√µes da forma bebidas =&gt; sobremesas, ou sobremesas =&gt; bebidas. Por√©m, associa√ß√µes do tipo iogurte congelado saud√°vel =&gt; √°gua engarrafada, ou sorvete cremoso =&gt; cooler de vinho podem produzir confian√ßa e suporte  suficientes  para  serem  regras  de  associa√ß√£o v√°lidas de interesse.

Portanto, se a √°rea de aplica√ß√£o tiver uma classifica√ß√£o  natural  dos  conjuntos  de  itens  em  hierarquias,  descobrir  associa√ß√µes dentro das  hierarquias n√£o  tem  qualquer  interesse  particular.  Aquelas  de interesse espec√≠fico s√£o associa√ß√µes entre hierarquias.

Elas podem ocorrer entre agrupamentos de item em diferentes n√≠veis.

Associa√ß√µes  multidimensionais. A  descoberta  de regras de associa√ß√£o envolve a procura por padr√µes em um arquivo. Na Figura 28.1,  temos  um  exemplo de um arquivo de transa√ß√µes de cliente com tr√™s dimens√µes:  Id\_transa√ß√£o,  Hora  e  Itens\_comprados. Por√©m, nossas tarefas e algoritmos de minera√ß√£o de dados apresentados at√© este ponto s√≥ envolvem uma dimens√£o: Itens\_comprados. A regra a seguir √© um exemplo de inclus√£o do r√≥tulo da √∫nica dimens√£o: Itens\_comprados(leite) =&gt; Itens\_comprados(suco). Pode ser interessante encontrar regras de associa√ß√£o que  envolvam  m√∫ltiplas  dimens√µes,  por  exemplo, Hora(6:30...8:00) =&gt; Itens\_comprados(leite). Regras como  estas  s√£o  chamadas  de regras  de  associa√ß√£o multidimensionais .  As  dimens√µes  representam  atributos de registros de um arquivo ou, em mat√©ria de rela√ß√µes, colunas de linhas de uma rela√ß√£o, e podem ser  categ√≥ricas  ou  quantitativas.  Os  atributos  categ√≥ricos t√™m um conjunto finito de valores que n√£o exibem qualquer relacionamento de ordena√ß√£o. Atributos quantitativos s√£o num√©ricos e seus valores exibem um relacionamento de ordena√ß√£o, por exemplo, &lt;. Itens\_comprados √© um exemplo de atributo categ√≥rico e Id\_transa√ß√£o e Hora s√£o quantitativos.

Figura 28.3



Uma t√©cnica para lidar com um atributo quantitativo √© dividir seus valores em intervalos n√£o sobrepostos  que  sejam  r√≥tulos  atribu√≠dos.  Isso  pode ser feito de uma maneira est√°tica com base no conhecimento  espec√≠fico  do  dom√≠nio.  Por  exemplo, uma hierarquia de conceitos pode agrupar valores para Salario em tr√™s classes distintas: baixa renda (0 &lt; Salario &lt; 29.999), renda m√©dia (30.000 &lt; Salario &lt; 74.999) e alta renda ( Salario &gt; 75.000). Daqui, o algoritmo  do  tipo  Apriori  t√≠pico,  ou  uma  de  suas variantes, pode ser usado para a minera√ß√£o de regra, pois os atributos quantitativos agora se parecem com atributos categ√≥ricos. Outra t√©cnica para o  particionamento  √©  agrupar  valores  de  atributo com base  na  distribui√ß√£o  de  dados,  por  exemplo, particionamento de mesma profundidade, e atribuir valores inteiros a cada parti√ß√£o. O particionamento nesse est√°gio pode ser relativamente bom, ou seja, um n√∫mero maior de intervalos. Depois, durante o processo  de  minera√ß√£o,  essas  parti√ß√µes  podem  ser combinadas com outras parti√ß√µes adjacentes se seu suporte for menor que algum valor m√°ximo predefinido. Um algoritmo de tipo Apriori pode ser usado aqui, bem como para a minera√ß√£o de dados.

Associa√ß√µes negativas. O problema da descoberta de uma associa√ß√£o negativa √© mais dif√≠cil do que o da descoberta de uma associa√ß√£o positiva. Uma associa√ß√£o negativa tem o seguinte tipo: 60 por cento dos clientes  que  compram  batatas  fritas  n√£o  compram √°gua engarrafada .  (Aqui,  os  60  por  cento  referem-se √† confian√ßa para a regra de associa√ß√£o negativa.) Em um banco de dados com 10.000 itens, existem 210.000 combina√ß√µes poss√≠veis de itens, sendo que a  maioria deles n√£o aparece nem uma vez no banco de dados. Se a aus√™ncia de certa combina√ß√£o de itens  significar  uma  associa√ß√£o  negativa,  ent√£o  potencialmente temos milh√µes e milh√µes de regras de associa√ß√£o negativa com RHSs que n√£o s√£o de nosso interesse. O problema, ent√£o, √© encontrar apenas regras negativas de interesse .  Em geral, estamos interessados em casos em que dois conjuntos espec√≠ficos de itens aparecem muito raramente na mesma transa√ß√£o. Isso imp√µe dois problemas.

- 1. Para um estoque total de 10.000 itens, a pro-



Soda

Fanta

Mineirinho

- babilidade de dois quaisquer serem comprados juntos √© (1/10.000) ÔÉ© (1/10.000) = 10 -8 . Se descobrirmos que o suporte real para esses dois ocorrerem juntos √© zero, isso n√£o representa um desvio significativo da expectativa e, portanto, n√£o √© uma associa√ß√£o (negativa) interessante.
- 2. O outro problema √© mais s√©rio. Estamos procurando  combina√ß√µes  de  itens  com  suporte muito baixo, e existem milh√µes e milh√µes com suporte baixo ou mesmo zero. Por exemplo, um conjunto de dados de 10 milh√µes de transa√ß√µes tem a maioria dos 2,5 bilh√µes de combina√ß√µes de pares de 10.000 itens faltando. Isso geraria bilh√µes de regras in√∫teis.

Portanto,  para  tornar  as  regras  de  associa√ß√£o negativas interessantes, temos de usar o conhecimento pr√©vio sobre os conjuntos de itens. Nossa t√©cnica √©  empregar hierarquias. Suponha que utilizemos as hierarquias de refrigerantes e batatas fritas mostrada na Figura 28.4.

Uma associa√ß√£o positiva forte foi mostrada entre  refrigerantes  e  batatas  fritas.  Se  encontrarmos um suporte grande para o fato de que, quando os clientes compram batatas fritas Diurnas, eles predominantemente  compram  Mineirinho  e n√£o Soda e n√£o Fanta, isso seria interessante, pois normalmente esperar√≠amos que, se houvesse uma associa√ß√£o forte entre Diurnas e Mineirinho, tamb√©m deveria haver uma associa√ß√£o forte entre Diurnas e Soda ou Diurnas e Fanta. 5

Nos  agrupamentos  de  iogurte  congelado  e √°gua  engarrafada  mostrados  na  Figura  28.3,  suponha que a divis√£o entre Baixa caloria e Saud√°vel seja 80-20 e a divis√£o das marcas Comum e Clara seja 60-40 entre as respectivas categorias. Isso daria  uma probabilidade conjunta de um iogurte congelado  Baixa  caloria  ser  comprado  com  √°gua engarrafada Comum como 48 por cento entre as transa√ß√µes  que  cont√™m  um  iogurte  congelado  e √°gua engarrafada. Se esse suporte, por√©m, for de apenas 20 por cento, isso indicaria uma associa√ß√£o negativa significativa entre o iogurte de Baixa caloria e a √°gua engarrafada Comum; mais uma vez,



Diurnas

Noturnas

Festas

Figura 28.4 Hierarquia simples de refrigerantes e batatas fritas.

5 Para simplificar, estamos considerando uma distribui√ß√£o uniforme de transa√ß√µes entre os membros de uma hierarquia.

isso seria interessante.

O problema de encontrar associa√ß√£o negativa √© importante nas situa√ß√µes acima dado o conhecimento de dom√≠nio na forma de hierarquias de generaliza√ß√£o de item (ou seja, as hierarquias dadas de bebida e sobremesa mostradas na Figura 28.3), as associa√ß√µes  positivas  existentes  (como  entre  os  grupos  de iogurte congelado e √°gua engarrafada) e a distribui√ß√£o dos itens (como as marcas dentro de grupos relacionados). O escopo da descoberta de associa√ß√µes negativas √© limitado em rela√ß√£o ao conhecimento das hierarquias  e  distribui√ß√µes  de  itens.  O  crescimento exponencial de associa√ß√µes negativas continua sendo um desafio.

## 28.2.7 Considera√ß√µes adicionais para regras de associa√ß√£o

Minerar regras de associa√ß√£o nos bancos de dados da vida real √© complicado pelos seguintes fatores:

- ¬Ñ A  cardinalidade  dos  conjuntos  de  itens  na maioria das situa√ß√µes √© extremamente grande, e  o  volume  de  transa√ß√µes  √©  muito  alto  tamb√©m.  Alguns  bancos  de  dados  operacionais nos setores de varejo e comunica√ß√µes coletam dezenas de milh√µes de transa√ß√µes por dia.
- ¬Ñ As transa√ß√µes mostram variabilidade em fatores como localiza√ß√£o geogr√°fica e esta√ß√µes, dificultando a amostragem.
- ¬Ñ As classifica√ß√µes de itens existem ao longo de m√∫ltiplas dimens√µes. Logo, controlar o processo  de  descoberta  com  conhecimento  de dom√≠nio, particularmente para regras negativas, √© bastante dif√≠cil.
- ¬Ñ A  qualidade  dos  dados  √©  vari√°vel;  existem problemas significativos com dados faltando, err√¥neos,  em  conflito,  bem  como  dados  redundantes em muitos setores.

## 28.3 Classifica√ß√£o

Classifica√ß√£o √© o processo de aprender um modelo que descreve diferentes classes de dados. As classes s√£o predefinidas. Por exemplo, em uma aplica√ß√£o banc√°ria, os clientes que solicitam um cart√£o de cr√©dito podem ser classificados como risco fraco, risco m√©dio ou risco  bom .  Logo,  esse  tipo  de  atividade tamb√©m √© chamada de aprendizado supervisionado . Quando o modelo √© criado, ele pode ser usado para classificar novos dados. O primeiro passo - aprendizado do modelo - √© realizado com um conjunto de treinamento de dados que j√° foram classificados. Cada registro nos dados de treinamento cont√©m um atributo, chamado r√≥tulo de classe , que indica a que classe o registro pertence. O modelo que √© produzido costuma ser na forma de uma √°rvore de decis√£o ou um conjunto de regras. Algumas das quest√µes importantes com rela√ß√£o ao modelo e o algoritmo que produz o modelo incluem a capacidade do modelo de prever a classe correta de novos dados, o custo computacional associado ao algoritmo e a escalabilidade do algoritmo.

Examinaremos a t√©cnica em que nosso modelo est√° na forma de uma √°rvore de decis√£o. Uma √°rvore  de  decis√£o √©  simplesmente  uma  representa√ß√£o  gr√°fica  da  descri√ß√£o  de  cada  classe  ou,  em outras palavras, uma representa√ß√£o das regras de classifica√ß√£o. Uma √°rvore de decis√£o de exemplo √© representada  na  Figura  28.5.  Vemos,  pela  Figura 28.5, que se um cliente for casado e  se  o  sal√°rio &gt;= 50K, ent√£o ele tem um risco bom para um cart√£o de cr√©dito banc√°rio. Essa √© uma das regras que descrevem a classe risco bom . Atravessar a √°rvore de decis√£o saindo da raiz para cada n√≥ folha forma outras regras para essa classe e as duas outras classes. O Algoritmo 28.3 mostra o procedimento para construir uma √°rvore de decis√£o com base em um conjunto  de  dados  de  treinamento.  Inicialmente, todas as amostras de treinamento est√£o na raiz da √°rvore.  As  amostras  s√£o  particionadas  de  maneira recursiva com base nos atributos selecionados. O atributo  usado  em  um  n√≥  para  particionar  as amostras √© aquele com o melhor crit√©rio de divis√£o, por exemplo, aquele que maximiza a medida de ganho da informa√ß√£o.

Algoritmo 28.3 . Algoritmo para indu√ß√£o da √°rvore de decis√£o

Entrada: Conjunto de registros de dados de treinamento: R 1 , R 2 , ..., R m e conjunto de atributos: A 1 , A 2 , ..., A n procedimento  construcao\_arvore  (registros,  atribu-

Sa√≠da: √Årvore de decis√£o tos);

## In√≠cio

crie um n√≥ N ; se todos os registros pertencem √† mesma classe, C ent√£o retorna N como  n√≥  folha  com  r√≥tulo  de classe C ; se atributos √© vazio ent√£o como  n√≥  folha  com  r√≥tulo  de retorna N classe C , de modo que a maioria dos registros perten√ßa a ele;

seleciona atributo A i ( com o ganho de informa-

Figura 28.5



√Årvore de decis√£o da amostra para aplica√ß√µes de cart√£o de cr√©dito.

√ß√£o mais alto ) dos atributos; rotula n√≥ N com A i ; para cada valor conhecido, v j , de A i fa√ßa in√≠cio acrescenta  um  ramo  do  n√≥ N para  a condi√ß√£o A i = v j ; S j = subconjunto de registros onde A i = v j ; se S j √© vazio ent√£o inclua uma folha, L ,  com  r√≥tulo  de classe C , tal que a maioria dos registros perten√ßa a ela e retorne L se  n√£o inclui o n√≥ retornado por Con-trucao\_arvore ( S j , atributos A i );

fim;

## Fim;

Antes de ilustrarmos o Algoritmo 28.3, explicaremos  a  medida  do ganho  de  informa√ß√£o com mais  detalhes.  O  uso  de entropia como  medida de ganho de informa√ß√£o √© motivado pelo objetivo de minimizar  a  informa√ß√£o  necess√°ria  para  classificar os dados de amostra nas parti√ß√µes resultantes e,  assim,  minimizar  o  n√∫mero  esperado  de  testes condicionais necess√°rios para classificar um novo registro.  A  informa√ß√£o  esperada  necess√°ria  para classificar  dados  de  treinamento  de s amostras, onde o atributo Classe tem n valores ( v 1 , ..., v n ) e s i √© o n√∫mero de amostras pertencentes ao r√≥tulo de classe v i , √© dada por

<!-- formula-not-decoded -->

onde p i √© a probabilidade de que uma amostra aleat√≥ria perten√ßa √† classe com r√≥tulo v i . Uma estimativa para p i √© s i / s . Considere um atributo A com valores { v 1 ,  ..., v m }  usado como atributo de teste para divis√£o na √°rvore de decis√£o. O atributo A particiona as amostras nos subconjuntos S 1 , ..., S m onde amostras em cada S j t√™m  um  valor  de v j para  o  atributo A . Cada S j pode conter amostras que pertencem a qualquer uma das classes. O n√∫mero de amostras em S j que pertencem √† classe   pode ser indicado como i s ij . A entropia associada ao uso do atributo A como atributo de teste √© definida como

<!-- formula-not-decoded -->

I s ( 1 j ,  ..., s nj )  pode  ser  definido  utilizando  a  formula√ß√£o para I s ( 1 ,  ..., s n )  com p i sendo  substitu√≠do por p ij , onde p ij = s ij / s j . Agora, o ganho de informa√ß√£o ao particionar no atributo A ,  Ganho( A ),  √©  definido como  ( I s 1 , ..., s n ) -E A ( ). Podemos usar os dados de treinamento de amostra da Figura 28.6 para ilustrar o algoritmo.

O atributo RID representa o identificador de registro  usado  para  identificar  um  registro  individual  e √© um atributo interno. N√≥s o utilizamos para identificar um registro em particular em nosso exemplo. Primeiro, calculamos a informa√ß√£o esperada necess√°ria para classi-

|   RID | Casado   | Sal√°rio     | Saldo_conta   | Idade   | Emprestar   |
|-------|----------|-------------|---------------|---------|-------------|
|     1 | n√£o      | >=50K       | <5K           | >=25    | sim         |
|     2 | sim      | >=50K       | >=5K          | >=25    | sim         |
|     3 | sim      | 20K. . .50K | <5K           | <25     | n√£o         |
|     4 | n√£o      | <20K        | >=5K          | <25     | n√£o         |
|     5 | n√£o      | <20K        | <5K           | >=25    | n√£o         |
|     6 | sim      | 20K. . .50K | >=5K          | >=25    | sim         |

## Figura 28.6

Dados de treinamento de exemplo para algoritmo de classifica√ß√£o.

Figura 28.7



√Årvore de decis√£o baseada nos dados de treinamento da amostra onde os n√≥s folha s√£o representados por um conjunto de RIDs de registros particionados.

ficar os dados de treinamento de seis registros como  ( I s 1 , s 2 ), onde existem duas classes: o primeiro valor de r√≥tulo de classe corresponde a sim e o segundo, a n√£o . Assim,

<!-- formula-not-decoded -->

Agora, calculamos a entropia para cada um dos quatro atributos, como mostrado a seguir. Para Casado = sim, temos s 11 = 2, s 21 = 1 e I s ( 11 , s 21 ) = 0,92. Para Casado = n√£o, temos s 12 = 1, s 22 = 2 e I s ( 12 , s 22 ) = 0,92. Portanto, a informa√ß√£o esperada necess√°ria para classificar uma amostra usando o atributo Casado como atributo de particionamento √©

<!-- formula-not-decoded -->

O ganho na informa√ß√£o, Ganho( Casado ), seria 1 - 0,92 = 0,08. Se seguirmos etapas semelhantes para calcular o ganho com rela√ß√£o aos outros tr√™s atributos, acabamos com

Como  o  maior  ganho  ocorre  para  o  atributo Sal√°rio, ele √© escolhido como atributo de particionamento. A raiz da √°rvore √© criada com r√≥tulo Sal√°rio e tem tr√™s ramos, um para cada valor de Salario . Para dois dos tr√™s valores, ou seja, &lt;20K e &gt;=50K, todas as amostras que s√£o particionadas de acordo (registros com RIDs 4 e 5 para &lt;20K e registros com RIDs 1 e 2 para &gt;=50K) caem na mesma classe emprestar n√£o e emprestar sim , respectivamente, para esses dois valores. Assim, criamos um n√≥ folha para cada um. O √∫nico ramo que precisa ser expandido √© para o valor 20K...50K com duas amostras, registros com RIDs 3 e 6 nos dados de treinamento. Continuando o  processo  com  esses  dois  registros,  descobrimos que Ganho( Casado )  √©  0,  Ganho( Saldo\_conta )  √©  1  e Ganho( Idade ) √© 1.

<!-- formula-not-decoded -->

E ( Saldo\_conta ) = 0,92 e Ganho( Saldo\_conta ) = 0,08

<!-- formula-not-decoded -->

Podemos escolher Idade ou Saldo\_conta , pois ambos t√™m o maior ganho. Vamos escolher Idade como atributo  de  particionamento.  Acrescentamos  um  n√≥ com r√≥tulo Idade que tem dois ramos, menor que 25, e maior ou igual a 25. Cada ramo particiona os dados de amostra restantes de modo que um registro de amostra pertence a cada ramo e, portanto, a uma classe. Dois n√≥s folha s√£o criados e n√≥s terminamos. A √°rvore de decis√£o final est√° representada na Figura 28.7.

## 28.4 Agrupamento

A  tarefa  de  minera√ß√£o  de  dados  anterior,  de classifica√ß√£o, lida com o particionamento de dados com base no uso de uma amostra de treinamento pr√©-classificada. Contudo, em geral √© √∫til particionar os dados sem ter uma amostra de treinamento; isso  tamb√©m  √©  conhecido  como aprendizado  n√£o supervisionado .  Por  exemplo,  no  com√©rcio,  pode ser  importante determinar grupos de clientes que t√™m  padr√µes  de  compra  semelhantes,  ou,  na  medicina, pode ser importante determinar grupos de pacientes  que  mostram  rea√ß√µes  semelhantes  aos medicamentos  receitados.  O  objetivo  do  agrupamento √© colocar registros em grupos, de modo que os  registros  em  um  grupo  sejam  semelhantes  uns aos outros e diferentes dos registros em outros grupos. Os grupos costumam ser disjuntos .

Uma  faceta  importante  do  agrupamento  √©  a fun√ß√£o  de  similaridade  usada.  Quando  os  dados s√£o  num√©ricos,  uma  fun√ß√£o  de  similaridade  baseada  na  dist√¢ncia  normalmente  √©  utilizada.  Por exemplo,  a  dist√¢ncia  Euclideana  pode  ser  usada para medir a similaridade. Considere dois pontos de  dados n -dimensionais  (registros) r j e r k .  Podemos considerar o valor da  -√©sima dimens√£o como i r ji e r ki para os dois registros. A dist√¢ncia Euclideana entre os pontos r j e r k no espa√ßo n -dimensional √© calculado como:

<!-- formula-not-decoded -->

Quanto  menor  a  dist√¢ncia  entre  dois  pontos, maior √© a similaridade conforme pensamos nelas. Um algoritmo de agrupamento cl√°ssico √© o algoritmo de kmeans, o Algoritmo 28.4.

Algoritmo  28.4. Algoritmo  de  agrupamento  de k-mean

Entrada: um banco de dados D , de m registros, r 1 , ..., r m e um n√∫mero desejado de clusters k

Sa√≠da: conjunto de k clusters que minimiza o crit√©rio de erro ao quadrado

## In√≠cio

escolha aleatoriamente k registros como os centroides para os k clusters; repita atribua cada registro, r i ,  a  um cluster tal que a dist√¢ncia entre r i e o centroide do cluster (m√©dia) √© o menor entre k clusters; recalcule o centroide (m√©dia) para cada cluster com base nos registrosatribu√≠dos ao cluster; at√© que nenhuma mudan√ßa;

## Fim;

O algoritmo come√ßa escolhendo aleatoriamente k registros  para  representar  os  centroides  (m√©dias), m 1 , ..., mk , dos clusters, C 1 , ..., C k . Todos os registros s√£o colocados em determinado cluster com base na dist√¢ncia entre o registro e a m√©dia do cluster. Se a dist√¢ncia entre mi e o registro r j √© a menor entre todas as m√©dias de cluster, ent√£o o registro r j √© colocado no cluster C i . Quando todos os registros tiverem sido colocados inicialmente em um cluster, a m√©dia para cada cluster √© recalculada. Depois o processo se repete, examinando cada registro novamente e colocando-o no cluster cuja m√©dia √© mais pr√≥xima.  V√°rias  itera√ß√µes  podem  ser  necess√°rias, mas o algoritmo  convergir√°,  embora  possa  terminar em um ponto ideal local. A condi√ß√£o de t√©rmino normalmente √© o crit√©rio de erro ao quadrado. Para os clusters C 1 , ..., C k com m√©dias m 1 , ..., mk , o erro √© definido como:

<!-- formula-not-decoded -->

Examinaremos como o Algoritmo 28.4 funciona com os registros (bidimensionais) na Figura 28.8. Suponha que o n√∫mero de clusters k desejados seja 2. Considere que o algoritmo escolha registros com

Figura 28.8

|   RID |   Idade |   Anos_de_servico |
|-------|---------|-------------------|
|     1 |      30 |                 5 |
|     2 |      50 |                25 |
|     3 |      50 |                15 |
|     4 |      25 |                 5 |
|     5 |      30 |                10 |
|     6 |      55 |                25 |

Registros de duas dimens√µes de amostra para o exemplo de agrupamento (a coluna RID n√£o √© considerada).

RID 3 para o cluster C 1 e RID 6 para o cluster C 2 como centroides de cluster iniciais.  Os  registros  restantes ser√£o atribu√≠dos a um desses clusters durante a primeira itera√ß√£o do loop-repita. O registro com RID 1 tem uma dist√¢ncia de C 1 igual a 22,4 e uma dist√¢ncia de C 2 de  32,0, de modo que se junta ao cluster C 1 . O registro com RID 2 tem uma dist√¢ncia de C 1 igual a 10,0 e uma dist√¢ncia de C 2 igual a 5,0, de modo que se junta ao cluster C 2 . O registro com RID 4 tem uma dist√¢ncia de C 1 igual  a  25,5  e  uma  dist√¢ncia  de C 2 igual a 36,6, de modo que se junta ao cluster C 1 . O registro com RID 5 tem uma dist√¢ncia de C 1 igual a 20,6 e uma dist√¢ncia de C 2 igual a 29,2, de modo que se junta ao cluster C 1 . Agora, a nova m√©dia (centroide) para os dois clusters √© calculada. A m√©dia para um cluster, C i ,  com n registros de m dimens√µes √© o vetor:

<!-- formula-not-decoded -->

A nova m√©dia para C 1 √© (33,75; 8,75) e a nova m√©dia para C 2 √© (52,5; 25). Uma segunda itera√ß√£o precede e os seis registros s√£o colocados nos dois clusters da seguinte forma: os registros com RID s 1, 4, 5 s√£o colocados em C 1 e os registros com RID s 2, 3, 6 s√£o colocados em C 2 . A m√©dia para C 1 e C 2 √© recalculada como (28,3; 6,7) e (51,7; 21,7), respectivamente. Na pr√≥xima itera√ß√£o, todos os registros permanecem em seus clusters anteriores e o algoritmo termina.

Tradicionalmente, os algoritmos de agrupamento assumem que o conjunto de dados inteiro cabe na mem√≥ria principal. Mais recentemente, os pesquisadores desenvolveram algoritmos que s√£o eficientes e escal√°veis para bancos de dados muito grandes. Um desses  algoritmos √© chamado de BIRCH. BIRCH √© uma abordagem h√≠brida, que usa agrupamento hier√°rquico e monta uma representa√ß√£o de √°rvore dos dados,  bem  como  m√©todos  de  agrupamento  adicionais, que s√£o aplicados aos n√≥s folha da √°rvore. Dois par√¢metros de entrada s√£o utilizados pelo algoritmo BIRCH. Um especifica a quantidade de mem√≥ria principal dispon√≠vel e o outro √© um threshold inicial  para  o  raio  de  qualquer  cluster.  A  mem√≥ria principal serve para armazenar informa√ß√µes de cluster descritivas, como o centro (m√©dia) de um cluster e o raio do cluster (clusters s√£o considerados esf√©ricos em forma). O threshold do raio afeta o n√∫mero de clusters que s√£o produzidos. Por exemplo, se o valor de threshold do raio for grande, ent√£o menos clusters de muitos registros ser√£o formados. O algoritmo tenta manter o n√∫mero de clusters de modo que seu raio esteja abaixo do threshold do raio. Se a mem√≥ria dis- pon√≠vel for insuficiente, ent√£o o threshold do raio √© aumentado.

O algoritmo BIRCH l√™ os registros de dados sequencialmente e os insere em uma estrutura de √°rvore na mem√≥ria, que tenta preservar a estrutura de agrupamento dos dados. Os registros s√£o inseridos em n√≥s folha apropriados (clusters em potencial) com base na dist√¢ncia entre o registro e o centro do cluster. O n√≥ folha onde a inser√ß√£o acontece pode ter de ser dividido, dependendo do centro atualizado,  raio do cluster e do par√¢metro de threshold do raio. Al√©m disso,  ao  dividir,  informa√ß√µes  extras  do  cluster  s√£o armazenadas, e se a mem√≥ria se tornar insuficiente, ent√£o o threshold do raio ser√° aumentado. Aumentar o threshold do raio pode realmente produzir um efeito colateral de reduzir o n√∫mero de clusters, pois alguns n√≥s podem ser mesclados.

Em geral, o BIRCH √© um m√©todo de agrupamento eficiente, com uma complexidade computacional linear  em  rela√ß√£o  ao  n√∫mero  de  registros  a  serem agrupados.

## 28.5 Abordagens para outros problemas de minera√ß√£o de dados

## 28.5.1 Descoberta de padr√µes sequenciais

A descoberta de padr√µes sequenciais √© baseada no conceito de uma sequ√™ncia de conjuntos de itens. Consideramos que transa√ß√µes  como  as  de  cesta  de mercado, que discutimos anteriormente, s√£o ordenadas por momento da compra. Essa ordena√ß√£o gera uma sequ√™ncia de itemsets. Por exemplo, {leite, p√£o, suco}, {p√£o, ovos}, {biscoito, leite, caf√©} podem ser tal sequ√™ncia de itemsets com base em tr√™s visitas pelo mesmo cliente ao mercado. O suporte para uma sequ√™ncia S de itemsets √© a porcentagem do conjunto indicado U de sequ√™ncias das quais S √© uma subsequ√™ncia. Neste exemplo, {leite, p√£o, suco} {p√£o, ovos} e {p√£o, ovos} {biscoito, leite, caf√©} s√£o consideradas subsequ√™ncias . O problema de identificar padr√µes sequenciais, ent√£o, √© encontrar todas as subsequ√™ncias para os conjuntos de sequ√™ncias indicados que possuem um suporte m√≠nimo definido pelo usu√°rio. A sequ√™ncia S 1 , S 2 , S 3 , ... √© um indicador do fato de que um cliente que compra o itemsets S 1 provavelmente comprar√° o itemsets S 2 e depois S 3 , e assim por diante.  Essa  previs√£o √© baseada na frequ√™ncia (suporte) dessa sequ√™ncia no passado. Diversos algoritmos foram investigados para a detec√ß√£o de sequ√™ncia.

## 28.5.2 Descoberta de padr√µes na s√©rie temporal

S√©ries temporais s√£o sequ√™ncias de eventos; cada evento pode ser um certo tipo fixo de uma transa√ß√£o. Por exemplo, o pre√ßo de fechamento de uma a√ß√£o ou de um fundo √© um evento que ocorre a cada dia da semana para cada a√ß√£o e fundo. A sequ√™ncia desses valores por a√ß√£o ou fundo constitui uma s√©rie temporal. Para uma s√©rie temporal, pode-se procurar  uma s√©rie de padr√µes ao analisar sequ√™ncias e subsequ√™ncias,  como  fizemos  antes.  Por  exemplo, poder√≠amos achar o per√≠odo durante o qual o pre√ßo da a√ß√£o subiu ou se manteve constante por n dias, ou  poder√≠amos  achar  o  per√≠odo  mais  longo  sobre o qual o pre√ßo da a√ß√£o teve uma flutua√ß√£o de n√£o mais do que 1 por cento em rela√ß√£o ao pre√ßo de fechamento anterior, ou poder√≠amos achar o trimestre durante o qual o pre√ßo da a√ß√£o teve o maior ganho percentual  ou  perda  percentual.  A  s√©rie  temporal pode ser  comparada  estabelecendo  medidas  de  similaridade para identificar empresas cujas a√ß√µes se comportam de um modo semelhante. A an√°lise e a minera√ß√£o de s√©ries temporais √© uma funcionalidade estendida do gerenciamento de dados temporais (ver Cap√≠tulo 26).

## 28.5.3 Regress√£o

A regress√£o √©  uma  aplica√ß√£o  especial  da  regra de classifica√ß√£o. Se uma regra de classifica√ß√£o √© considerada uma fun√ß√£o sobre as vari√°veis, que mapeia essas  vari√°veis  em  uma  vari√°vel  de  classe  de  destino, a regra √© denominada regra de regress√£o .  Uma aplica√ß√£o geral da regress√£o ocorre quando, em vez de mapear uma tupla de dados de uma rela√ß√£o para uma classe espec√≠fica, o valor de uma vari√°vel √© previsto com base nessa tupla. Por exemplo, considere uma rela√ß√£o

TESTS\_LAB (ID paciente, teste 1, teste 2, ..., teste n )

que cont√©m valores que s√£o resultados de uma s√©rie de n testes para um paciente. A vari√°vel de destino que queremos prever √© P , a probabilidade de sobreviv√™ncia  do  paciente.  Ent√£o  a  regra  para  regress√£o toma a forma:

(teste 1 no intervalo ) 1 e (teste 2 no intervalo )  e  ...  (teste 2 n no  intervalo ) n √∞ P = x , ou x &lt; P ‚â§ y

A escolha depende de podermos prever um valor √∫nico de P ou um intervalo de valores para P . Se considerarmos P uma fun√ß√£o:

P = f ( teste 1, teste 2, ..., teste n )

a fun√ß√£o √© denominada fun√ß√£o de regress√£o para prever P . Em geral, se a fun√ß√£o aparece como

<!-- formula-not-decoded -->

e   √© linear nas vari√°veis de dom√≠nio f x i , o processo de derivar f de um conjunto dado de tuplas para &lt; X 1 , X , ..., 2 X n , y &gt; √© denominado regress√£o linear . A regress√£o linear  √©  uma  t√©cnica  estat√≠stica  comumente utilizada para ajustar um conjunto de observa√ß√µes ou pontos em n dimens√µes com a vari√°vel de destino y .

A an√°lise de regress√£o √© uma ferramenta muito comum para an√°lise de dados em diversos dom√≠nios de pesquisa. A descoberta da fun√ß√£o para prever a vari√°vel de destino √© equivalente a uma opera√ß√£o de minera√ß√£o de dados.

## 28.5.4 Redes neurais

Uma rede neural √© uma t√©cnica derivada da pesquisa  de  intelig√™ncia  artificial  que  usa  a  regress√£o generalizada  e  oferece  um  m√©todo  iterativo  para execut√°-la. As redes neurais usam a t√©cnica de ajuste de curva para deduzir uma fun√ß√£o de um conjunto de amostras. Essa t√©cnica oferece um enfoque de aprendizado ;  ela  √©  controlada  por  uma  amostra de teste que √© usada para a infer√™ncia e o aprendizado iniciais. Com esse tipo de m√©todo de aprendizado, as respostas √†s novas entradas podem ser capazes de ser interpoladas com base nas amostras conhecidas. Essa interpola√ß√£o, por√©m, depende do modelo do mundo (representa√ß√£o interna do dom√≠nio do problema) desenvolvido pelo m√©todo de aprendizado.

As  redes  neurais  podem  ser  classificadas  de modo  geral  em  duas  categorias:  redes  supervisionadas  e  n√£o  supervisionadas.  M√©todos  adaptativos que tentam reduzir o erro da sa√≠da s√£o m√©todos de aprendizado  supervisionado ,  enquanto  aqueles  que desenvolvem representa√ß√µes  internas  sem  sa√≠das  de amostra s√£o denominados m√©todos de aprendizado n√£o supervisionado .

As redes neurais se autoadaptam; ou seja, elas aprendem  pela  informa√ß√£o  sobre  um  problema  espec√≠fico. Elas funcionam bem em tarefas de classifica√ß√£o e, portanto, s√£o √∫teis na minera√ß√£o de dados. Mesmo assim,  elas  n√£o  est√£o  livres  de  problemas. Embora aprendam, n√£o oferecem uma boa representa√ß√£o do que aprenderam. Suas sa√≠das s√£o altamente quantitativas e dif√≠ceis de entender. Como outra limita√ß√£o, as representa√ß√µes internas desenvolvidas por redes neurais n√£o s√£o √∫nicas. Al√©m disso, em geral, as redes neurais enfrentam problema na modelagem dos dados de s√©rie de tempo. Apesar desses inconve-

nientes, elas s√£o populares e constantemente usadas por v√°rios vendedores comerciais.

## 28.5.5 Algoritmos gen√©ticos

Algoritmos  gen√©ticos (GAs  -  Genetic  Algorithms) s√£o uma classe de procedimentos de pesquisa aleat√≥rios capazes de realizar pesquisa adaptativa e robusta por uma grande faixa de topologias de espa√ßo de pesquisa. Modelados ap√≥s o surgimento adaptativo  de  esp√©cies  biol√≥gicas  de  mecanismos  evolucion√°rios, e introduzidos por Holland, 6  os GAs t√™m sido aplicados com sucesso em campos t√£o diversificados quanto a an√°lise de imagens, escalonamento e projeto de engenharia.

Os algoritmos gen√©ticos estendem a ideia da gen√©tica humana do alfabeto de quatro letras (com base nos nucleot√≠deos A, C, T , G) do c√≥digo de DNA humano. A constru√ß√£o de um algoritmo gen√©tico envolve a idealiza√ß√£o de um alfabeto que codifica as solu√ß√µes para o problema de decis√£o em mat√©ria de sequ√™ncias desse alfabeto. As sequ√™ncias s√£o equivalentes para indiv√≠duos. Uma fun√ß√£o de ajuste define quais solu√ß√µes podem sobreviver e quais n√£o podem. As formas como as solu√ß√µes podem ser combinadas s√£o moldadas pela opera√ß√£o cruzada de cortar e combinar sequ√™ncias de um pai e uma m√£e. Uma popula√ß√£o inicial bem variada √© oferecida, e um jogo de evolu√ß√£o √© realizado, no qual muta√ß√µes ocorrem entre sequ√™ncias. Elas se combinam para produzir uma nova gera√ß√£o de indiv√≠duos; os mais qualificados sobrevivem e realizam muta√ß√£o, at√© que uma fam√≠lia de solu√ß√µes bem-sucedidas se desenvolva.

As solu√ß√µes produzidas pelos GAs s√£o distinguidas da maioria das outras t√©cnicas de pesquisa pelas seguintes caracter√≠sticas:

- ¬Ñ Uma pesquisa de GA usa um conjunto de solu√ß√µes durante cada gera√ß√£o, em vez de uma √∫nica solu√ß√£o.
- ¬Ñ A pesquisa no espa√ßo da sequ√™ncia representa uma pesquisa paralela muito maior no espa√ßo das solu√ß√µes codificadas.
- ¬Ñ A mem√≥ria da pesquisa feita √© representada unicamente pelo conjunto de solu√ß√µes dispon√≠veis para uma gera√ß√£o.
- ¬Ñ Um algoritmo gen√©tico √© um algoritmo que se torna aleat√≥rio, pois os mecanismos de pesquisa utilizam operadores probabil√≠sticos.
- Ao prosseguir de uma gera√ß√£o para a seguinte, um GA encontra o equil√≠brio quase ideal entre aquisi√ß√£o do conhecimento e explora√ß√£o ao manipular solu√ß√µes codificadas.

Os algoritmos gen√©ticos s√£o usados para solu√ß√£o e agrupamento de problemas. Sua capacidade de solucionar problemas em paralelo oferece uma ferramenta poderosa para minera√ß√£o de dados. As desvantagens dos GAs incluem a grande superprodu√ß√£o de solu√ß√µes individuais, o car√°ter aleat√≥rio do processo de pesquisa e a alta demanda no processamento do computador. Em geral, um poder de computa√ß√£o substancial √© exigido para se conseguir algo significativo com algoritmos gen√©ticos.

## 28.6 Aplica√ß√µes de minera√ß√£o de dados

Tecnologias de minera√ß√£o de dados podem ser aplicadas  a  uma  grande  variedade  de  contextos  de tomada de decis√£o nos neg√≥cios. Em particular, algumas √°reas de ganhos significativos devem incluir as seguintes:

- ¬Ñ Marketing. As aplica√ß√µes incluem an√°lise de comportamento  do  consumidor  com  base nos padr√µes de compra; a determina√ß√£o das estrat√©gias de marketing que incluem propaganda,  local  da  loja  e  correio  direcionado; segmenta√ß√£o de clientes, lojas ou produtos; e projeto de cat√°logos, layouts de loja e campanhas publicit√°rias.
- ¬Ñ Finan√ßas. As  aplica√ß√µes  incluem  an√°lise  de cr√©dito  de  clientes,  segmenta√ß√£o  de  contas a receber, an√°lise de desempenho de investimentos financeiros, como a√ß√µes, t√≠tulos e fundos de investimentos; avalia√ß√£o de op√ß√µes de financiamento; e detec√ß√£o de fraude.
- ¬Ñ Manufatura. As aplica√ß√µes  envolvem  otimiza√ß√£o  de  recursos  como  m√°quinas,  m√£o  de obra e materiais; e o projeto ideal de processos de manufatura, layout de galp√µes e projeto de produtos, como autom√≥veis baseados em requisitos do cliente.
- ¬Ñ Sa√∫de. Algumas  aplica√ß√µes  s√£o  descoberta de  padr√µes  em  imagens  radiol√≥gicas,  an√°lise  de  dados experimentais de microarray (chip  de  gene)  para  agrupar  genes  e  relacionar sintomas ou doen√ßas, an√°lise de efeitos colaterais de drogas e efic√°cia de certos tratamentos,  otimiza√ß√£o  de  processos  em um hospital  e  o  relacionamento  de  dados de bem-estar do paciente com qualifica√ß√µes do m√©dico.

6 O trabalho inicial de Holland (1975), intitulado Adaptation in Natural and Artificial Systems , introduziu a ideia de algoritmos gen√©ticos.

## 28.7 erramentas comerciais de F minera√ß√£o de dados

Atualmente, as ferramentas comerciais de minera√ß√£o de dados usam diversas t√©cnicas comuns para extrair conhecimento. Entre elas est√£o regras de associa√ß√£o,  agrupamento,  redes  neurais  sequencia√ß√£o e  an√°lise  estat√≠stica.  J√°  discutimos  sobre  elas.  Tamb√©m s√£o usadas √°rvores de decis√£o, que s√£o uma representa√ß√£o das regras utilizadas na classifica√ß√£o ou agrupamento, e an√°lises estat√≠sticas, que podem incluir regress√£o e muitas outras t√©cnicas. Outros produtos comerciais utilizam t√©cnicas avan√ßadas, como algoritmos gen√©ticos, l√≥gica baseada em caso, redes bayesianas, regress√£o n√£o linear, otimiza√ß√£o combinat√≥ria, combina√ß√£o de padr√£o e l√≥gica fuzzy. Neste cap√≠tulo, j√° discutimos alguns deles.

A  maioria  das  ferramentas  de  minera√ß√£o  de dados  utiliza  a  interface  ODBC  ( Open Database Connectivity ).  ODBC  √©  um  padr√£o  da  ind√∫stria que  funciona  com  bancos  de  dados;  ele  permite o acesso aos dados na maioria dos programas de banco de dados populares, como Access, dBASE, Informix, Oracle e SQL Server. Alguns desses pacotes de software oferecem interfaces para programas espec√≠ficos de banco de dados; os mais comuns s√£o Oracle, Access e SQL Server. A maior parte das ferramentas funciona no ambiente Microsoft Windows  e  algumas,  no  sistema  operacional  UNIX. A tend√™ncia  √©  que  todos  os  produtos  operem  no ambiente Microsoft Windows. Uma ferramenta, o Data  Surveyor,  menciona  a  compatibilidade  com ODMG; ver Cap√≠tulo 11, no qual discutimos o padr√£o orientado a objeto ODMG.

Em  geral,  esses  programas  realizam  processamento  sequencial  em  uma  √∫nica  m√°quina.  Muitos desses produtos atuam no modo cliente-servidor. Alguns deles incorporam o processamento paralelo em arquiteturas de computador paralelas e atuam como uma parte das ferramentas de processamento anal√≠tico on-line (OLAP).

## 28.7.1 nterface com o usu√°rio I

A maioria das ferramentas √© executada em um ambiente  de  interface  gr√°fica  com  o  usu√°rio  (GUI, do ingl√™s Graphical User Interface ).  Alguns produtos incluem t√©cnicas de visualiza√ß√£o sofisticadas para exibir dados e regras (por exemplo, MineSet da SGI) e s√£o at√© capazes de manipular dados assim interativamente. As interfaces de texto s√£o raras e mais comuns em ferramentas dispon√≠veis para UNIX, como o Intelligent Miner da IBM.

## 28.7.2 nterface de programa√ß√£o de I aplica√ß√µes

Normalmente, a interface de programa√ß√£o de aplica√ß√µes (API) √© uma ferramenta opcional. A maioria  dos  produtos  n√£o  permite  o  uso  de  suas fun√ß√µes internas. Por√©m, alguns deles permitem que o programador de aplica√ß√£o reutilize seu c√≥digo. As interfaces  mais  comuns  s√£o  bibliotecas  C  e  Dynamic  Link  Libraries  (DLLs).  Algumas  ferramentas incluem linguagens pr√≥prias de comando de banco de dados.

Na Tabela 28.1, listamos 11 ferramentas de minera√ß√£o de dados representativas.  At√©  o  momento, existem quase cem produtos de minera√ß√£o de dados comerciais dispon√≠veis em todo o mundo. Fora dos EUA, temos o Data Surveyor, da Holanda, e o PolyAnalyst, da R√∫ssia.

## 28.7.3 Dire√ß√µes futuras

As ferramentas de minera√ß√£o de dados est√£o continuamente evoluindo, com base nas ideias da pesquisa cient√≠fica mais recente. Muitas dessas ferramentas incorporam os algoritmos mais recentes tomados da intelig√™ncia artificial (IA), estat√≠stica e otimiza√ß√£o.

Atualmente,  o  processamento  r√°pido  √©  feito usando t√©cnicas modernas de banco de dados - como o processamento distribu√≠do - em arquiteturas  cliente-servidor,  em  bancos  de  dados paralelos e em data warehouse). Para o futuro, a tend√™ncia √© em dire√ß√£o ao desenvolvimento de capacidades de Internet mais completas. Al√©m disso, abordagens h√≠bridas se tornar√£o comuns, e o processamento  ser√°  feito  usando  todos  os  recursos dispon√≠veis. O processamento tirar√° proveito dos ambientes de computa√ß√£o paralelo e distribu√≠do. Essa  mudan√ßa  √©  especialmente  importante  porque  os  bancos  de  dados  modernos  cont√™m  uma quantidade  de  informa√ß√£o  muito  grande.  N√£o apenas  os  bancos  de  dados  de  multim√≠dia  est√£o crescendo, mas tamb√©m o armazenamento e a recupera√ß√£o de imagens s√£o opera√ß√µes lentas. Al√©m do  mais,  o  custo  do  armazenamento  secund√°rio est√°  diminuindo,  de  modo  que  o  armazenamento maci√ßo de informa√ß√µes ser√° vi√°vel, at√© mesmo para pequenas empresas. Assim, os programas de minera√ß√£o de dados ter√£o de lidar com conjuntos de dados maiores de mais empresas.

A maioria dos softwares de minera√ß√£o de dados usar√° o padr√£o ODBC para extrair dados de bancos de dados comerciais; formatos de entrada

Tabela 28.1 Algumas ferramentas de minera√ß√£o de dados representativas.

| Empresa                 | Produto                         | T√©cnica                                                             | Plataforma                       | Interface*               |
|-------------------------|---------------------------------|---------------------------------------------------------------------|----------------------------------|--------------------------|
| AcknoSoft               | Kate                            | √Årvores de decis√£o, racioc√≠nio baseado em caso                      | Windows UNIX                     | Microsoft Access         |
| Angoss                  | Knowledge SEEKER                | √Årvores de decis√£o, estat√≠stica                                     | Windows                          | ODBC                     |
| Business Objects        | Business Miner                  | Redes neurais, aprendizado de m√°quina                               | Windows                          | ODBC                     |
| CrossZ                  | QueryObject                     | An√°lise estat√≠stica, algoritmo de otimiza√ß√£o                        | Windows MVS UNIX                 | ODBC                     |
| Data Distilleries       | Data Surveyor                   | Abrangente, pode misturar diferentes tipos de minera√ß√£o de dados    | UNIX                             | ODBC compat√≠vel com ODMG |
| DBMiner Technology Inc. | DBMiner                         | An√°lise OLAP, associa√ß√µes, classifica√ß√£o, algoritmos de agrupamento | Windows                          | Microsoft 7.0 OLAP       |
| IBM                     | Intelligent Miner               | Classifica√ß√£o, regras de associa√ß√£o, modelos de previs√£o            | UNIX (AIX)                       | IBM DB2                  |
| Megaputer Intelligence  | PolyAnalyst                     | Aquisi√ß√£o de conhecimento simb√≥lico, programa√ß√£o evolucion√°ria      | Windows OS/2                     | ODBC Oracle DB2          |
| NCR                     | Management Discovery Tool (MDT) | Regras de associa√ß√£o                                                | Windows                          | ODBC                     |
| Purple Insight          | MineSet                         | √Årvores de decis√£o, regras de associa√ß√£o                            | UNIX (Irix)                      | Oracle Sybase Informix   |
| SAS                     | Enterprise Miner                | √Årvores de decis√£o, redes neurais, regress√£o, agrupamento           | UNIX (Solaris) Windows Macintosh | ODBC Oracle AS/400       |

*ODBC: Open Data Base Connectivity

ODMG: Object Data Management Group

propriet√°rios  poder√£o  desaparecer.  Existe  uma necessidade  definitiva  de  incluir  dados  fora  do padr√£o, inserindo imagens e outros dados de multim√≠dia,  como  dados  de  origem  para  minera√ß√£o de dados.

## Resumo

Neste cap√≠tulo, estudamos a disciplina importante da minera√ß√£o de dados, que utiliza a tecnologia de banco de dados para descobrir conhecimento e padr√µes adicionais nos dados. Demos um exemplo ilustrativo da descoberta

de conhecimento nos bancos de dados, que tem um escopo maior do que a minera√ß√£o de dados. Para a minera√ß√£o de dados, entre as diversas t√©cnicas, destacamos os detalhes da minera√ß√£o da regra de associa√ß√£o, classifica√ß√£o e agrupamento. Apresentamos algoritmos em cada uma dessas √°reas e ilustramos com exemplos como eles funcionam.

Diversas outras t√©cnicas, incluindo as redes neurais baseadas  em  IA  e  algoritmos  gen√©ticos,  tamb√©m  foram discutidas  resumidamente.  Existe  pesquisa  ativa  em  minera√ß√£o de dados, e esbo√ßamos algumas de suas dire√ß√µes esperadas. No mercado futuro de produtos de tecnologia de banco de dados, muita atividade de minera√ß√£o de dados √© aguardada. Resumimos 11 das quase cem ferramentas de minera√ß√£o de dados dispon√≠veis; pesquisas futuras dever√£o estender significativamente a quantidade e a funcionalidade.

## Perguntas de revis√£o

- 28.1. Quais s√£o as diferentes fases da descoberta do conhecimento dos bancos de dados? Descreva um cen√°rio de aplica√ß√£o completo em que o  novo  conhecimento  pode  ser  minado  com base  em  um  banco  de  dados  de  transa√ß√µes existente.
- 28.2. Quais s√£o os objetivos ou tarefas que a minera√ß√£o de dados tenta facilitar?
- 28.3. Quais s√£o os cinco tipos de conhecimento produzidos da minera√ß√£o de dados?
- 28.4. O que s√£o regras de associa√ß√£o como um tipo de conhecimento? D√™ uma defini√ß√£o de suporte e confian√ßa e use-os para definir uma regra de associa√ß√£o.
- 28.5. O que √© a propriedade de fechamento para baixo? Como ela auxilia no desenvolvimento de um algoritmo eficiente para encontrar regras de associa√ß√£o, ou seja, com rela√ß√£o √† localiza√ß√£o de itemsets grandes?
- 28.6. Qual foi  o  fator  motivador  para  o  desenvolvimento do algoritmo √°rvore FP para a minera√ß√£o da regra de associa√ß√£o?
- 28.7. Descreva uma regra de associa√ß√£o entre hierarquias com um exemplo.
- 28.8. O que  √©  uma  regra  de  associa√ß√£o  negativa  no contexto da hierarquia da Figura 28.3?
- 28.9. Quais s√£o as dificuldades da minera√ß√£o de regras de associa√ß√£o de bancos de dados grandes?
- 28.10. O que s√£o regras de classifica√ß√£o e como as √°rvores de decis√£o est√£o relacionadas a elas?
- 28.11. O que √© entropia e como ela √© usada na montagem de √°rvores de decis√£o?
- 28.12. Como o agrupamento difere da classifica√ß√£o?
- 28.13. Descreva as redes neurais e os algoritmos gen√©ticos como t√©cnicas para a minera√ß√£o de dados. Quais s√£o as principais dificuldades no uso dessas t√©cnicas?

## Exerc√≠cios

28.14. Aplique o algoritmo Apriori ao seguinte conjunto de dados.

|   Id_Trans | Itens_comprados            |
|------------|----------------------------|
|        101 | leite, p√£o, ovos           |
|        102 | leite, suco                |
|        103 | suco, manteiga             |
|        104 | leite, p√£o, ovos           |
|        105 | caf√©, ovos                 |
|        106 | caf√©                       |
|        107 | caf√©, suco                 |
|        108 | leite, p√£o, biscoito, ovos |
|        109 | biscoito, manteiga         |
|        110 | leite, p√£o                 |

- O itemset √© {leite, p√£o, biscoito, ovos, manteiga, caf√©, suco}. Use 0,2 para o valor de suporte m√≠nimo.
- 28.15. Mostre duas regras que possuem uma confian√ßa de 0,7 ou mais para um itemset que cont√©m tr√™s itens do Exerc√≠cio 28.14.
- 28.16. Para  o  algoritmo  de  Parti√ß√£o,  prove  que  qualquer itemset frequente no banco de dados precisa aparecer como um itemset frequente local em pelo menos uma parti√ß√£o.
- 28.17.

Mostre a √°rvore FP que seria criada para os dados do Exerc√≠cio 28.14.

- 28.18. Aplique o algoritmo de crescimento FP √† √°rvore FP do Exerc√≠cio 28.17 e mostre os itemsets frequentes.
- 28.19. Aplique o algoritmo de classifica√ß√£o ao seguinte conjunto de registros de dados. O atributo de classe √© Cliente\_repetido.

|   RID | Idade   | Cidade   | Sexo   | Educacao            | Cliente_ repetido   |
|-------|---------|----------|--------|---------------------|---------------------|
|   101 | 20...30 | SP       | F      | superior incompleto | SIM                 |
|   102 | 20...30 | BH       | M      | superior completo   | SIM                 |
|   103 | 31...40 | SP       | F      | superior incompleto | SIM                 |
|   104 | 51...60 | SP       | F      | superior incompleto | N√ÉO                 |
|   105 | 31...40 | RJ       | M      | n√≠vel m√©dio         | N√ÉO                 |
|   106 | 41...50 | SP       | F      | superior incompleto | SIM                 |
|   107 | 41...50 | SP       | F      | superior completo   | SIM                 |
|   108 | 20...30 | RJ       | M      | superior incompleto | SIM                 |
|   109 | 20...30 | SP       | F      | n√≠vel m√©dio         | N√ÉO                 |
|   110 | 20...30 | SP       | F      | superior incompleto | SIM                 |

28.20. Considere o seguinte conjunto de registros bidimensionais:

|   RID |   Dimens√£o1 |   Dimens√£o2 |
|-------|-------------|-------------|
|     1 |           8 |           4 |
|     2 |           5 |           4 |
|     3 |           2 |           4 |
|     4 |           2 |           6 |
|     5 |           2 |           8 |
|     6 |           8 |           6 |

Considere  tamb√©m  dois  esquemas  de  agrupamento diferentes: (1) onde Grupo  cont√©m registros 1 {1, 2, 3} e Grupo  cont√©m registros {4, 5, 6} e (2) onde 2 Grupo  cont√©m registros {1, 6} e Grupo  cont√©m re1 2 gistros {2, 3, 4, 5}. Qual esquema √© melhor e por qu√™? 28.21. Use o algoritmo de kmeans para agrupar os dados do Exerc√≠cio 28.20. Podemos usar um valor de 3 para K e  considerar  que  os  registros  com RIDs 1, 3 e 5 s√£o utilizados para os centroides de grupo (m√©dias) iniciais.

28.22. O algoritmo de kmeans utiliza uma m√©trica de similaridade da dist√¢ncia entre um registro e um centroide de cluster. Se os atributos dos registros n√£o forem quantitativos, mas categ√≥ricos por natureza, como Nivel\_de\_renda com valores {baixo, medio, alto} ou Casado com valores {Sim, Nao} ou Estado\_de\_residencia com valores {S√£o Paulo, Rio de Janeiro, ..., Minas Gerais}, ent√£o a m√©trica de dist√¢ncia n√£o √© significativa. Defina uma m√©trica de similaridade mais adequada, que possa ser usada para agrupamento dos registros de dados que cont√™m dados categ√≥ricos.

## Bibliografia selecionada

A literatura sobre minera√ß√£o de dados vem de v√°rios  campos, incluindo estat√≠stica,  otimiza√ß√£o  matem√°tica,  aprendizado  de  m√°quina  e  intelig√™ncia  artificial. Chen et al. (1996) d√£o um bom resumo da perspectiva de banco de dados sobre minera√ß√£o de dados. O livro de Han e Kamber (2001) √© um texto excelente, que descreve com detalhes os diferentes algoritmos e t√©cnicas usadas na √°rea de minera√ß√£o de dados. O trabalho na pesquisa Almaden da IBM produziu um grande n√∫mero de conceitos e algoritmos iniciais, bem como resultados de alguns estudos de desempenho. Agrawal et al. (1993) relatam o primeiro estudo importante sobre regras de associa√ß√£o. Seu algoritmo Apriori para dados de cesta de mercado em Agrawal e Srikant (1994) √© melhorado com o uso de particionamento em Savasere et al. (1995); Toivonen (1996) prop√µe a amostragem como um meio de reduzir o  esfor√ßo  de  processamento.  Cheung  et  al.  (1996)  estendem o particionamento para ambientes distribu√≠dos; Lin e Dunham (1998) prop√µem t√©cnicas para contornar problemas  com  vi√©s  de  dados.  Agrawal  et  al.  (1993b) discutem a perspectiva de desempenho sobre regras de associa√ß√£o. Mannila et al. (1994), Park et al. (1995) e Amir et al. (1997) apresentam outros algoritmos eficientes relacionados a regras de associa√ß√£o. Han et al. (2000) apresentam o algoritmo √°rvore FP discutido neste cap√≠tulo. Srikant e Agrawal (1995) prop√µem regras generalizadas de minera√ß√£o. Savasere et al. (1998) apresentam a primeira t√©cnica de minera√ß√£o de associa√ß√µes negativas. Agrawal et al. (1996) descrevem o sistema Quest na IBM. Sarawagi et al. (1998) descrevem uma implementa√ß√£o em que as regras de associa√ß√£o s√£o integradas a um sistema de gerenciamento de banco de dados relacional. Piatesky-Shapiro e Frawley (1992) contribu√≠ram com artigos  de  diversos  t√≥picos  relacionados  √†  descoberta  de conhecimento. Zhang et al. (1996) apresentam o algoritmo  BIRCH  para  o  agrupamento  de  grandes  bancos de dados. Informa√ß√µes sobre aprendizado de √°rvore de decis√£o e o algoritmo de classifica√ß√£o apresentado neste cap√≠tulo podem ser encontradas em Mitchell (1997).

Adriaans e Zantinge (1996), Fayyad et al. (1997) e Weiss e Indurkhya (1998) s√£o livros dedicados aos diferentes aspectos da minera√ß√£o de dados e seu uso na previs√£o.  A  ideia  de  algoritmos  gen√©ticos  foi  proposta  por Holland (1975); um bom estudo dos algoritmos gen√©ticos aparece em Srinivas e Patnaik (1994). Redes neurais possuem  uma  vasta  literatura;  uma  introdu√ß√£o  abrangente est√° dispon√≠vel em Lippman (1987).

Tan et al. (2006) oferece uma introdu√ß√£o abrangente √† minera√ß√£o de dados e possui um conjunto detalhado de refer√™ncias.  Os  leitores  tamb√©m  s√£o  aconselhados  a consultar os anais das duas principais confer√™ncias anuais  em  minera√ß√£o  de  dados:  a  Knowledge  Discovery  e Data  Mining  Conference  (KDD),  que  √©  realizada  desde 1995, e a SIAM International Conference on Data Mining (SDM), que acontece desde 2001. Os links para as  confer√™ncias  anteriores  podem  ser  encontrados  em &lt;http://dblp.uni-trier.de&gt;.



O crescente poder de processamento e a sofistica√ß√£o das ferramentas e t√©cnicas anal√≠ticas resultaram no desenvolvimento do que s√£o conhecidos como data warehouses . Esses data warehouses oferecem armazenamento, funcionalidade e responsividade √†s consultas al√©m das capacidades dos bancos de  dados  orientados  √†  transa√ß√£o.  Acompanhando esse poder cada vez maior est√° uma grande demanda para melhorar o desempenho de acesso aos dados dos bancos de dados. Como temos visto no decorrer deste livro, os bancos de dados tradicionais equilibram o requisito de acesso a dados com a necessidade de garantir a integridade destes. Em organiza√ß√µes modernas, os usu√°rios dos dados em geral s√£o completamente  retirados  das  fontes  de  dados.  Muitas pessoas s√≥ precisam de acesso de leitura aos dados, mas ainda necessitam de acesso r√°pido a um volume maior de dados do que pode ser convenientemente baixado para o desktop. Com frequ√™ncia, esses dados v√™m de v√°rios bancos de dados. Como muitas das an√°lises realizadas s√£o recorrentes e previs√≠veis, os  vendedores  de  software  e  o  pessoal  de  suporte de  sistemas  projetam  sistemas  para  dar  suporte  a essas  fun√ß√µes.  Atualmente,  existe  uma  grande  necessidade de oferecer aos que tomam decis√µes, da ger√™ncia  intermedi√°ria  para  cima,  informa√ß√µes  no n√≠vel correto de detalhe para dar suporte √† atividade de tomada de decis√£o. Data warehousing , processamento anal√≠tico  on-line (OLAP) e minera√ß√£o de dados oferecem essa funcionalidade. Fizemos uma introdu√ß√£o  √†s  t√©cnicas  de  minera√ß√£o  de  dados  no Cap√≠tulo 28. Neste cap√≠tulo, oferecemos uma vis√£o geral mais ampla das tecnologias de data warehousing e OLAP.

## Vis√£o geral de data warehousing e OLAP

## 29.1 ntrodu√ß√£o, defini√ß√µes e I terminologia

No Cap√≠tulo 1,  definimos  um banco  de  dados como uma cole√ß√£o de dados relacionados e um sistema de banco de dados como um banco de dados e um software de banco de dados juntos. Um data warehouse tamb√©m √© uma cole√ß√£o de informa√ß√µes, bem como um sistema de suporte. Contudo, existe uma distin√ß√£o clara. Os bancos de dados tradicionais s√£o  transacionais  (relacionais,  orientados  a  objeto, em rede ou hier√°rquicos). Os data warehouses t√™m a caracter√≠stica distintiva de servir principalmente para aplica√ß√µes  de  apoio  √†  decis√£o.  Eles  s√£o  otimizados para recupera√ß√£o de dados, e n√£o para processamento de transa√ß√£o de rotina.

Como os data warehouses t√™m sido desenvolvidos em diversas organiza√ß√µes para atender a necessidades particulares, n√£o existe uma √∫nica defini√ß√£o can√¥nica desse termo. Artigos de revista profissional e livros populares elaboraram o significado de diversas maneiras. Os vendedores aproveitaram a popularidade do termo para ajudar a comercializar uma s√©rie de produtos relacionados, e os consultores ofereceram uma grande variedade de servi√ßos, todos sob a bandeira da armazenagem de dados. Contudo, os data warehouses s√£o muito distintos dos bancos de dados tradicionais em sua estrutura, funcionamento, desempenho e finalidade.

W. H. Inmon 1   caracterizou  um data  warehouse como uma  cole√ß√£o  de  dados  orientada  a  assunto, integrada, n√£o vol√°til, vari√°vel no tempo para o suporte  √†s  decis√µes  da  ger√™ncia .  Os  data  warehouses oferecem acesso a dados para an√°lise complexa, des-

coberta de conhecimento e tomada de decis√£o. Eles d√£o suporte a demandas de alto desempenho sobre os dados e informa√ß√µes de uma organiza√ß√£o. V√°rios tipos de aplica√ß√µes - OLAP, DSS e aplica√ß√µes de minera√ß√£o de dados - s√£o aceitos. Definimos cada uma delas a seguir.

OLAP (processamento anal√≠tico on-line) √© um termo usado para descrever a an√°lise de dados complexos do data warehouse. Nas m√£os de trabalhadores do conhecimento habilidosos, as ferramentas OLAP utilizam capacidades de computa√ß√£o distribu√≠da para an√°lises que exigem mais armazenamento e poder de processamento do que pode estar localizado econ√¥mica e eficientemente em um desktop individual.

DSS (sistemas de apoio √† decis√£o) , tamb√©m conhecido como EIS -sistemas  de  informa√ß√µes executivas ;  n√£o  confunda  com  sistemas  de  integra√ß√£o empresarial -, ajudam os principais tomadores de decis√µes  de  uma  organiza√ß√£o  com  dados  de  n√≠vel mais  alto  em  decis√µes  complexas  e  importantes.  A minera√ß√£o de dados (que discutimos no Cap√≠tulo 28) √© usada para descoberta do conhecimento , o processo  de  procurar  novo  conhecimento  imprevisto  nos dados.

Os  bancos  de  dados  tradicionais  t√™m  suporte para o processamento de transa√ß√£o on-line (OLTP) , que inclui inser√ß√µes, atualiza√ß√µes e exclus√µes, enquanto tamb√©m t√™m suporte para requisitos de consulta de informa√ß√£o. Os bancos de dados relacionais tradicionais  s√£o  otimizados  para  processar  consultas que podem tocar em uma pequena parte do banco de dados e transa√ß√µes que lidam com inser√ß√µes ou atualiza√ß√µes no processo de algumas tuplas por rela√ß√£o. Assim, eles n√£o podem ser otimizados para OLAP, DSS ou minera√ß√£o de dados. Ao contr√°rio, os data warehouses  s√£o  projetados  exatamente  para  dar suporte  √†  extra√ß√£o,  processamento  e  apresenta√ß√£o eficientes para fins anal√≠ticos e de tomada de decis√£o. Em compara√ß√£o com os bancos de dados tradicionais, os  data  warehouses  em  geral  cont√™m  quantidades muito grandes de dados de v√°rias fontes, que podem incluir  bancos  de  dados  de  diferentes  modelos  de dados e, √†s vezes, arquivos adquiridos de sistemas e plataformas independentes.

## 29.2 Caracter√≠sticas dos data warehouses

dados multidimensional (explicado com mais detalhes na Se√ß√£o 29.3) √© uma boa escolha para OLAP e  tecnologias de apoio √† decis√£o. Ao contr√°rio dos multibancos de dados, que oferecem acesso a bancos de dados disjuntos e normalmente heterog√™neos, um data warehouse com frequ√™ncia √© um dep√≥sito de dados integrados de m√∫ltiplas fontes, processados para armazenamento em um modelo multidimensional. Diferentemente da maioria dos bancos de dados transacionais,  data  warehouses  costumam  apoiar  a an√°lise de s√©rie temporal e tend√™ncia, ambas exigindo mais dados hist√≥ricos do que geralmente √© mantido nos bancos de dados transacionais.

Em compara√ß√£o com os bancos de dados transacionais, os data warehouses s√£o n√£o vol√°teis. Isso significa que as informa√ß√µes no data warehouse mudam com muito menos frequ√™ncia e podem ser consideradas n√£o de tempo real com atualiza√ß√£o peri√≥dica. Em sistemas transacionais, as transa√ß√µes s√£o a unidade e o agente de mudan√ßa no banco de dados; ao contr√°rio, a informa√ß√£o do data warehouse √© muito menos detalhada e atualizada de acordo com uma escolha cuidadosa  de  pol√≠tica  de  atualiza√ß√£o,  normalmente incremental. As atualiza√ß√µes no armaz√©m s√£o tratadas pelo componente de aquisi√ß√£o do armaz√©m, que oferece todo o pr√©-processamento exigido.

Tamb√©m podemos descrever o data warehousing de forma mais geral como uma cole√ß√£o de tecnologias de apoio √† decis√£o, visando a habilitar o trabalhador do conhecimento (executivo, gerente, analista) a tomar decis√µes melhores e mais r√°pidas . 2 A Figura 29.1 oferece  uma  vis√£o  geral  da  estrutura  conceitual  de um data warehouse. Ela mostra o processo inteiro de data warehousing, que inclui a poss√≠vel limpeza e reformata√ß√£o dos dados antes que sejam carregados no armaz√©m. Esse processo √© tratado por ferramentas conhecidas como ferramentas de ETL (extra√ß√£o, transforma√ß√£o  e  carga).  No  backend  do  processo, OLAP, minera√ß√£o de dados e DSS podem gerar novas informa√ß√µes relevantes, como as regras; essas informa√ß√µes aparecem na figura voltando ao armaz√©m. A figura tamb√©m mostra que as fontes de dados podem incluir arquivos.

Os data warehouses possuem as seguintes caracter√≠sticas diferenciadoras: 3

- ¬Ñ Vis√£o conceitual multidimensional.
- ¬Ñ Dimensionalidade gen√©rica.

Para  discutir  data  warehouses  e  distingui-los dos  bancos  de  dados  transacionais,  √©  preciso  que haja um modelo de dados apropriado. O modelo de

- ¬Ñ Dimens√µes e n√≠veis de agrega√ß√£o ilimitados.
- ¬Ñ Opera√ß√µes irrestritas entre dimens√µes.
- ¬Ñ Tratamento din√¢mico de matriz esparsa.

2 Chaudhuri e Dayal (1997) oferecem um excelente tutorial sobre o assunto, com este sendo uma defini√ß√£o inicial.

3 Codd e Salley (1993) criaram o termo OLAP e mencionaram essas caracter√≠sticas. Apenas reordenamos sua lista original.

Figura 29.1 Exemplo de transa√ß√µes no modelo de cesta de mercado.



- ¬Ñ Arquitetura cliente-servidor.
- ¬Ñ Suporte para m√∫ltiplos usu√°rios.
- ¬Ñ Acessibilidade.
- ¬Ñ Transpar√™ncia.
- ¬Ñ Manipula√ß√£o de dados intuitiva.
- ¬Ñ Desempenho de relat√≥rio consistente.
- ¬Ñ Recurso de relat√≥rio flex√≠vel.

Como abrangem um grande volume de dados, os data warehouses geralmente s√£o uma ordem de magnitude (√†s vezes, duas ordens de magnitude) maiores que os bancos de dados de origem. O imenso volume de dados (provavelmente na faixa dos terabytes ou mesmo petabytes) √© uma quest√£o que tem sido tratada por meio de data warehouses em n√≠vel empresarial, data warehouses virtuais e data marts:

- ¬Ñ Data  warehouses  em  n√≠vel  empresarial s√£o imensos  projetos  que  exigem  investimento maci√ßo de tempo e recursos.
- ¬Ñ Data warehouses virtuais oferecem vis√µes de bancos de dados operacionais que s√£o materializadas para acesso eficiente.
- ¬Ñ Data  marts em  geral  s√£o  voltados  para  um subconjunto  da  organiza√ß√£o,  como  um  departamento, e possuem um foco mais estreito.

## 29.3 Modelagem de dados para data warehouses

Modelos multidimensionais tiram proveito dos relacionamentos inerentes nos dados para preencher os dados em matrizes multidimensionais, chamadas cubos de dados .  (Estes  podem ser chamados de hipercubos ,  se  tiverem  mais  de  tr√™s  dimens√µes.)  Para dados que se prestam √† formata√ß√£o dimensional, o desempenho  da  consulta  nas  matrizes  multidimensionais pode ser muito melhor do que no modelo de dados relacional. Tr√™s exemplos de dimens√µes em um data warehouse corporativo s√£o os per√≠odos fiscais, produtos e regi√µes da empresa.

Uma planilha-padr√£o √© uma matriz bidimensional.  Um exemplo seria uma planilha de vendas regionais por produto para determinado per√≠odo. Os produtos poderiam ser mostrados como linhas, com as receitas de vendas para cada regi√£o compreendendo as colunas. (A Figura 29.2 mostra essa organiza√ß√£o bidimensional.) Ao acrescentar uma dimens√£o de tempo, como os trimestres fiscais de uma organiza√ß√£o, seria produzida uma matriz tridimensional, que poderia ser representada usando um cubo de dados.

A Figura 29.3 mostra um cubo de dados tridimensional que organiza os dados de vendas de produtos por trimestres fiscais e regi√µes de vendas. Cada c√©lula  teria  dados  para  um  produto  espec√≠fico,  trimestre fiscal espec√≠fico e regi√£o espec√≠fica. Ao incluir outras  dimens√µes,  um  hipercubo  de  dados  poderia ser  produzido, embora mais de tr√™s dimens√µes n√£o possam ser facilmente visualizadas ou apresentadas de maneira gr√°fica. Os dados podem ser consultados diretamente em qualquer combina√ß√£o de dimens√µes, evitando  consultas  de  banco  de  dados  complexas. Existem ferramentas para visualizar dados de acordo com a escolha de dimens√µes do usu√°rio.

Mudar  da  hierarquia  (orienta√ß√£o)  unidimensional para outra √© algo feito com facilidade em um cubo  de  dados  com  uma  t√©cnica  chamada  de giro (tamb√©m chamada de rota√ß√£o ). Nessa t√©cnica, o cubo de dados pode ser imaginado girando para mostrar uma  orienta√ß√£o  diferente  dos  eixos.  Por  exemplo, voc√™ poderia girar o cubo de dados para mostrar as receitas de vendas regionais como linhas, os totais de receita por trimestre fiscal como colunas e os produ-

## Regi¬™o

Figura 29.2 Um modelo de matriz bidimensional.



tos da empresa na terceira dimens√£o (Figura 29.4). Logo, essa t√©cnica √© equivalente a ter uma tabela de vendas regionais para cada produto separadamente, onde cada tabela mostra vendas trimestrais para esse produto regi√£o por regi√£o.

Os modelos multidimensionais atendem prontamente a vis√µes hier√°rquicas no que √© conhecido como exibi√ß√£o roll-up  ou  exibi√ß√£o  drill-down.  Uma exibi√ß√£o roll-up sobe na hierarquia, agrupando em unidades maiores ao longo de uma dimens√£o (por exemplo, somando dados semanais por trimestre ou por ano). A Figura 29.5 mostra uma exibi√ß√£o roll-up que move de produtos  individuais  para  uma  categoriza√ß√£o  maior dos  produtos.  Na  Figura  29.6,  uma exibi√ß√£o  drill-

Figura 29.3 Um modelo de cubo de dados tridimensional.



Figura 29.4 Vers√£o girada do cubo de dados da Figura 29.3.



-down oferece a capacidade oposta, fornecendo uma vis√£o mais detalhada, talvez desagregando as vendas do pa√≠s por regi√£o e, depois, as vendas regionais por sub-regi√£o e tamb√©m separando produtos por estilos.

O modelo de armazenamento multidimensional envolve dois tipos de tabelas: tabelas de dimens√£o e tabelas de fatos. Uma tabela de dimens√£o consiste em tuplas de atributos da dimens√£o. Uma tabela de fa- tos pode ser imaginada como tendo tuplas, uma para cada  fato  registrado.  Esse  fato  cont√©m  alguma(s) vari√°vel(is) observada(s) e a(s) identifica com ponteiros  para  tabelas  de  dimens√£o.  A  tabela  de  fatos cont√©m os dados, e as dimens√µes identificam cada tupla nesses dados. A Figura 29.7 cont√©m um exemplo de tabela de fatos que pode ser vista do ponto de vista de m√∫ltiplas tabelas de dimens√£o.

Figura 29.5 A opera√ß√£o roll-up.



|              | Regi¬™o   | Regi¬™o   | Regi¬™o   |
|--------------|----------|----------|----------|
|              | Regi¬™o 1 | Regi¬™o 2 | Regi¬™o 3 |
| Produtos 1XX |          |          |          |
| Produtos 2XX |          |          |          |
| Produtos 3XX |          |          |          |
| Produtos 4XX |          |          |          |



|              |         | Regi¬™o 1   | Regi¬™o 1   | Regi¬™o 1   | Regi¬™o 2   |
|--------------|---------|------------|------------|------------|------------|
|              |         | Sub_reg 2  | Sub_reg 3  | Sub_reg 4  | Sub_reg 1  |
| Estilos P123 | A B C D |            |            |            |            |
| Estilos P124 | A B C   |            |            |            |            |
| Estilos P125 | A B C D |            |            |            |            |

Figura 29.6

A opera√ß√£o drill-down.

Dois  esquemas  multidimensionais  comuns  s√£o o esquema estrela e o esquema floco de neve. O esquema estrela consiste em uma tabela de fatos com uma √∫nica tabela para cada dimens√£o (Figura 29.7). O esquema floco de neve √© uma varia√ß√£o do esquema estrela  em  que  as  tabelas  dimens√µes  de  um  esquema  estrela  s√£o  organizadas  em  uma  hierarquia ao normaliz√°-las (Figura 29.8). Algumas instala√ß√µes est√£o  normalizando  data  warehouses  at√©  a  terceira forma normal, de modo que possam acessar o data warehouse at√© o maior n√≠vel de detalhe. Uma constela√ß√£o de fatos √© um conjunto de tabelas de fatos que compartilham algumas tabelas de dimens√£o. A Figura 29.9 mostra uma constela√ß√£o de fatos com duas tabelas  de  fatos,  regras  de  neg√≥cios  e  previs√£o  de neg√≥cios. Estas compartilham a tabela de dimens√£o chamada produto. As constela√ß√µes de fatos limitam as poss√≠veis consultas para o armaz√©m.

O armazenamento do data warehouse tamb√©m utiliza  t√©cnicas  de  indexa√ß√£o  para  dar  suporte  ao acesso de alto desempenho (ver no Cap√≠tulo 18 uma discuss√£o  sobre  indexa√ß√£o).  Uma  t√©cnica  chamada indexa√ß√£o de bitmap constr√≥i um vetor de bits para cada valor em um dom√≠nio (coluna) que est√° sendo indexado. Ela funciona muito bem para dom√≠nios de baixa cardinalidade. Existe um bit 1 colocado na posi√ß√£o   no vetor se a linha de ordem   tiver o valor senj j do indexado. Por exemplo, imagine um estoque de 100.000 carros com um √≠ndice bitmap sobre o tamanho do carro. Se houver quatro tamanhos de carro econ√¥mico,  compacto,  m√©dio  e  grande  -,  haver√° quatro vetores de bits, cada um contendo 100.000 bits (12,5K), com um tamanho total de 50K. A indexa√ß√£o bitmap pode oferecer vantagens consider√°veis de entrada/sa√≠da e espa√ßo de armazenamento nos dom√≠nios de baixa cardinalidade. Com vetores de bits,



Um esquema de estrela com tabelas de fato e dimens√µes.

## Tabelas de dimens¬™o

Figura 29.8 Um esquema floco de neve.



um √≠ndice bitmap pode oferecer grandes melhorias no desempenho de compara√ß√£o, agrega√ß√£o e jun√ß√£o.

Em um esquema de estrela, dados dimensionais podem ser indexados para tuplas na tabela de fatos pela indexa√ß√£o de jun√ß√£o . Os √≠ndices de jun√ß√£o s√£o √≠ndices  tradicionais  para  manter  relacionamentos entre valores de chave prim√°ria e chave estrangeira. Eles relacionam os valores de uma dimens√£o de um esquema de estrela a linhas na tabela de fatos. Por exemplo, considere uma tabela de fato de vendas que tenha  cidade  e  trimestre  fiscal  como  dimens√µes.  Se houver um √≠ndice de jun√ß√£o sobre cidade, para cada cidade o √≠ndice de jun√ß√£o mant√©m as IDs de tupla das tuplas que cont√™m essa cidade. Os √≠ndices de jun√ß√£o podem envolver v√°rias dimens√µes.

## Tabelas de dimens¬™o

codifica√ß√£o de n√≠vel (por exemplo, semanal, trimestral, anual) em tabelas existentes. Por compara√ß√£o, o trabalho extra da cria√ß√£o e manuten√ß√£o de tais agrega√ß√µes provavelmente seria excessivo em um banco de dados vol√°til, orientado √† transa√ß√£o.

## 29.4 Criando um data warehouse

O armazenamento de data warehouse pode facilitar o acesso a dados de resumo, tirando proveito da n√£o volatilidade dos data warehouses e de um grau de previsibilidade  das  an√°lises  que  ser√£o  realizadas ao utiliz√°-los. Duas t√©cnicas foram usadas: (1) tabelas menores, incluindo dados de resumo como vendas trimestrais ou receita por linha de produto, e (2)

Na constru√ß√£o  de  um  data  warehouse,  os  respons√°veis dever√£o ter uma vis√£o ampla do uso antecipado do armaz√©m. N√£o existe um meio de antecipar todas as consultas ou an√°lises poss√≠veis durante a fase de projeto. Por√©m, o projeto deve aceitar especificamente a consulta ocasional ,  ou seja, acessar dados  com  qualquer  combina√ß√£o  significativa  de valores  para  os  atributos  nas  tabelas  de  dimens√£o ou fatos. Por exemplo, uma empresa de produtos de consumidor com marketing intenso exigiria diferentes maneiras de organizar o data warehouse do que uma empresa de caridade sem fins lucrativos, voltada para angariar fundos. Um esquema apropriado seria escolhido para refletir o uso antecipado.



| Tabela de fatos I Resultados de neg√≥cios   | Tabela de dimens¬™o Produto                           | Tabela de fatos II Previs¬™o de neg√≥cios      |
|--------------------------------------------|------------------------------------------------------|----------------------------------------------|
| Produto Trimestre Regi¬™o Receita           | Num_prod Nome_prod Descr_prod Estilo_prod Linha_prod | Produto Trim_futuro Regi¬™o Receita_projetada |

A aquisi√ß√£o de dados para o armaz√©m envolve as seguintes etapas:

- 1. Os dados precisam ser extra√≠dos de v√°rias fontes heterog√™neas, por exemplo, bancos de dados ou  outras  entradas  de  dados,  como  aquelas que cont√™m dados do mercado financeiro ou dados ambientais.
- 2. Os dados precisam ser formatados por coer√™ncia dentro do armaz√©m. Nomes, significados e dom√≠nios dos dados de fontes n√£o relacionadas precisam ser reconciliados. Por exemplo, empresas  subsidi√°rias  de  uma  grande  corpora√ß√£o  podem  ter  diferentes  calend√°rios fiscais, com trimestres terminando em datas diferentes, tornando dif√≠cil agregar dados financeiros por trimestre. Diversos cart√µes de cr√©dito podem informar suas transa√ß√µes de modos diferentes, tornando dif√≠cil calcular todas as vendas a cr√©dito. Essas inconsist√™ncias de formato devem ser resolvidas.
- 3. Os dados precisam ser limpos para garantir a validade. A limpeza de dados √© um processo complicado e complexo, que tem sido identificado como o componente que mais exige trabalho na constru√ß√£o do data warehouse. Para a entrada de dados, a limpeza precisa ocorrer antes que eles sejam carregados no armaz√©m. N√£o h√° nada sobre limpeza de dados que seja espec√≠fico √† armazenagem de dados e que pudesse ser aplicado a um banco de dados hospedeiro. Por√©m, como os dados de entrada precisam ser examinados e formatados de modo consistente, os criadores de data warehouse devem usar  essa  oportunidade  para  verificar a  validade  e  a  qualidade.  Reconhecer  dados err√¥neos e incompletos √© dif√≠cil de automatizar,  e  a  limpeza  que requer corre√ß√£o de erro autom√°tica pode ser ainda mais complicada. Alguns aspectos, como a verifica√ß√£o de dom√≠nio, s√£o facilmente codificados nas rotinas de limpeza de dados, mas o reconhecimento autom√°tico de outros problemas de dados pode ser mais desafiador. (Por exemplo, pode-se exigir que Cidade = 'Campinas' junto com Estado = 'RJ' seja reconhecida como uma combina√ß√£o incorreta.) Depois que tais problemas tiverem sido  resolvidos,  dados  semelhantes  de  fontes diferentes precisam ser coordenados para carga no armaz√©m. Quando os gerentes de dados na organiza√ß√£o descobrem que seus dados est√£o sendo limpos para entrada no armaz√©m, eles provavelmente desejar√£o uma atualiza√ß√£o com os dados limpos. O processo de retornar
- dados limpos para a origem √© chamado de fluxo reverso (ver Figura 29.1).
- 4. Os dados precisam ser ajustados ao modelo de dados do armaz√©m. Os dados de v√°rias fontes devem ser instalados no modelo de dados do armaz√©m. Eles podem ter que ser convertidos de bancos de dados relacionais, orientados a objeto ou legados (em rede e/ou hier√°rquico) para um modelo multidimensional.
- 5. Os dados precisam ser carregados no armaz√©m. O grande volume de dados no armaz√©m torna a carga dos dados uma tarefa significativa. S√£o necess√°rias ferramentas de monitoramento para cargas, bem como m√©todos para  recupera√ß√£o  de  cargas  incompletas  ou incorretas. Com o imenso volume de dados no armaz√©m, a atualiza√ß√£o incremental normalmente √© a √∫nica t√©cnica vi√°vel. A pol√≠tica de  renova√ß√£o  provavelmente  surgir√°  como um comprometimento que leva em conta as respostas √†s seguintes perguntas:
- ¬Ñ At√© que ponto os dados devem estar atualizados?
- ¬Ñ O armaz√©m pode ficar off-line, e por quanto tempo?
- ¬Ñ Quais s√£o as interdepend√™ncias dos dados?
- ¬Ñ Qual √© a disponibilidade do armazenamento?
- ¬Ñ Quais s√£o os requisitos de distribui√ß√£o (como para replica√ß√£o e particionamento)?
- ¬Ñ Qual √© o tempo de carga (incluindo limpeza, formata√ß√£o,  c√≥pia,  transmiss√£o  e  overhead, como a recria√ß√£o de √≠ndice)?

Como dissemos,  os  bancos  de  dados  precisam lutar  por  um  equil√≠brio  entre  efici√™ncia  no  processamento  de  transa√ß√£o  e  suporte  dos  requisitos  da consulta (consultas ocasionais do  usu√°rio), mas um data warehouse normalmente √© otimizado para acesso  com  base  nas  necessidades  de  um  tomador de decis√£o. O armazenamento de dados em um data warehouse reflete essa especializa√ß√£o e envolve os seguintes processos:

- ¬Ñ Armazenamento dos dados de acordo com o modelo de dados do armaz√©m.
- ¬Ñ Cria√ß√£o e manuten√ß√£o das estruturas de dados exigidas.
- ¬Ñ Cria√ß√£o e manuten√ß√£o dos caminhos de acesso apropriados.
- ¬Ñ Fornecimento de dados vari√°veis no tempo √† medida que novos dados s√£o inclu√≠dos.

- ¬Ñ Suporte √† atualiza√ß√£o dos dados do armaz√©m.
- ¬Ñ Atualiza√ß√£o dos dados.
- ¬Ñ Elimina√ß√£o dos dados.

Embora um tempo adequado possa ser dedicado inicialmente √† constru√ß√£o do armaz√©m, seu imenso volume de dados costuma tornar imposs√≠vel simplesmente recarreg√°-lo em sua totalidade mais adiante. As  alternativas  s√£o  a  atualiza√ß√£o  seletiva  (parcial) dos dados e vers√µes de armaz√©m separadas (exigindo capacidade de armazenamento duplo para o armaz√©m!). Quando o armaz√©m utiliza um mecanismo de atualiza√ß√£o de dados incremental, os dados precisam ser periodicamente eliminados; por exemplo, um armaz√©m que mant√©m dados sobre os doze trimestres comerciais anteriores pode, de maneira peri√≥dica, eliminar seus dados a cada ano.

Os data warehouses tamb√©m devem ser projetados com considera√ß√£o total do ambiente em que residir√£o. Considera√ß√µes de projeto importantes incluem as seguintes:

- ¬Ñ Proje√ß√µes de uso.
- ¬Ñ O ajuste do modelo de dados.
- ¬Ñ Caracter√≠sticas das fontes dispon√≠veis.
- ¬Ñ Projeto do componente de metadados.
- ¬Ñ Projeto de componente modular.
- ¬Ñ Projeto de facilidade de gerenciamento e mudan√ßa.
- ¬Ñ Considera√ß√µes  de  arquitetura  distribu√≠da  e paralela.

Discutimos cada um desses itens por vez. O projeto de  armaz√©m  √©  inicialmente  controlado  por  proje√ß√µes  de  uso;  ou  seja,  por  expectativas  sobre  quem usar√°  o  armaz√©m  e  como  eles  o  usar√£o.  A  escolha de um modelo de dados para dar suporte a esse uso √©  uma  decis√£o  inicial  chave.  Proje√ß√µes  de  uso  e  as caracter√≠sticas das origens de dados do armaz√©m s√£o levadas em considera√ß√£o. O projeto modular √© uma necessidade  pr√°tica  para  permitir  que  o  armaz√©m evolua com a organiza√ß√£o e seu ambiente de informa√ß√£o. Al√©m disso, um data warehouse bem montado deve ser projetado para facilidade de manuten√ß√£o, permitindo que os gerentes de armaz√©m planejem e gerenciem a mudan√ßa com efici√™ncia, enquanto oferecem suporte ideal para os usu√°rios.

Voc√™ pode se lembrar do termo metadados do Cap√≠tulo 1; metadados foram definidos como a descri√ß√£o de um banco de dados que inclui sua defini√ß√£o de esquema. O reposit√≥rio de metadados √©  um componente chave do data warehouse. O reposit√≥rio inclui metadados t√©cnicos e de neg√≥cios. O primeiro, os metadados t√©cnicos , aborda detalhes de processamento de aquisi√ß√£o,  estruturas  de  armazenamento, descri√ß√µes de dados, opera√ß√µes e manuten√ß√£o do armaz√©m, e funcionalidade do suporte de acesso. O segundo, os metadados de neg√≥cios , inclui as regras de neg√≥cios relevantes e os detalhes organizacionais que d√£o suporte ao armaz√©m.

A arquitetura do ambiente de computa√ß√£o distribu√≠da da organiza√ß√£o √© uma importante caracter√≠stica determinante para o projeto do armaz√©m.

Existem duas arquiteturas distribu√≠das b√°sicas: o armaz√©m distribu√≠do e o armaz√©m federado. Para um armaz√©m  distribu√≠do , todos  os  aspectos  dos bancos  de  dados  distribu√≠dos  s√£o  relevantes,  por exemplo,  replica√ß√£o,  particionamento,  comunica√ß√µes  e  quest√µes  de  consist√™ncia.  Uma  arquitetura distribu√≠da pode oferecer benef√≠cios particularmente importantes ao desempenho do armaz√©m, como balanceamento de carga melhorado, escalabilidade de  desempenho  e  maior  disponibilidade.  Um  √∫nico reposit√≥rio de metadados replicado residiria em cada site de distribui√ß√£o. A ideia do armaz√©m federado √© a mesma do banco de dados federado: uma confedera√ß√£o  descentralizada  de  data  warehouses aut√¥nomos, cada um com o pr√≥prio reposit√≥rio de metadados. Dada a magnitude do desafio inerente aos data warehouses, √© prov√°vel que tais federa√ß√µes consistam em componentes de escala menor, como os data marts. Grandes organiza√ß√µes podem decidir confederar data marts em vez de montar data warehouses imensos.

## 29.5 uncionalidade t√≠pica de um F data warehouse

Os data warehouses existem para facilitar as consultas  ocasionais  complexas,  com  uso  intenso de dados e frequentes. Consequentemente, os data warehouses  precisam  oferecer  suporte  a  consulta muito maior e mais eficiente do que √© exigido dos bancos de dados transacionais. O componente de acesso  ao  data  warehouse  tem  suporte  para  funcionalidade  de  planilha  avan√ßada,  processamento  de  consulta  eficiente,  consultas  estruturadas, consultas ocasionais, minera√ß√£o de dados e vis√µes materializadas. Em particular, a funcionalidade de planilha avan√ßada inclui suporte para as mais modernas  aplica√ß√µes  de  planilha  (por  exemplo,  MS Excel),  bem  como  para  programas  de  aplica√ß√µes OLAP. Estes oferecem funcionalidades pr√©-programadas, como as que se seguem:

- ¬Ñ Roll-up. Os dados s√£o resumidos com generaliza√ß√£o  cada  vez  maior  (por  exemplo,  semanal para trimestral para anual).

- ¬Ñ Drill-down. N√≠veis  cada  vez  maiores  de  detalhes s√£o revelados (o complemento de roll-up).
- ¬Ñ Giro. A tabula√ß√£o cruzada (tamb√©m conhecida como rota√ß√£o ) √© realizada.
- ¬Ñ Slice e dice. Opera√ß√µes de proje√ß√£o s√£o realizadas nas dimens√µes.
- ¬Ñ Ordena√ß√£o. Os dados s√£o ordenados por valor ordinal.
- ¬Ñ Sele√ß√£o. Os dados est√£o dispon√≠veis por valor ou intervalo.
- ¬Ñ Atributos  derivados  (calculados). Atributos s√£o  calculados  por  opera√ß√µes  sobre  valores armazenados e derivados.

Como os data warehouses s√£o livres das restri√ß√µes do ambiente transacional, existe uma efici√™ncia  aumentada no processamento da consulta. Entre as ferramentas e t√©cnicas usadas est√£o a transforma√ß√£o de consulta; interse√ß√£o e uni√£o de √≠ndice; fun√ß√µes especiais ROLAP (OLAP relacional) e MOLAP (OLAP multidimensional); extens√µes SQL; m√©todos de jun√ß√£o avan√ßados; e varredura inteligente (como no acr√©scimo de consultas m√∫ltiplas).

O melhor desempenho tamb√©m tem sido obtido  com  o  processamento  paralelo.  As  arquiteturas  de  servidor  paralelas  incluem  multiprocessador  sim√©trico  (SMP),  cluster  e  processamento maci√ßamente  paralelo  (MPP),  al√©m  de  combina√ß√µes destes.

Os trabalhadores do conhecimento e os tomadores  de  decis√£o  utilizam  ferramentas  que  variam desde consultas parametrizadas at√© consultas ocasionais e minera√ß√£o de dados. Assim, o componente de acesso do data warehouse precisa oferecer suporte  para  consultas  estruturadas  (tanto  parametrizadas quanto ocasionais). Juntos, eles comp√µem um ambiente de consulta gerenciado. A pr√≥pria minera√ß√£o de dados usa t√©cnicas da an√°lise estat√≠stica e intelig√™ncia artificial. A an√°lise estat√≠stica pode ser realizada por planilhas avan√ßadas, por software sofisticado de an√°lise estat√≠stica e por programas personalizados. T√©cnicas como lagging , m√©dias m√≥veis e  an√°lise  de  regress√£o  normalmente  tamb√©m  s√£o empregadas. T√©cnicas de intelig√™ncia artificial, que podem incluir algoritmos gen√©ticos e redes neurais, s√£o usadas pra classifica√ß√£o e empregadas para descobrir conhecimento do data warehouse, que pode ser inesperado ou dif√≠cil de especificar em consultas. (Tratamos a minera√ß√£o de dados com detalhes no Cap√≠tulo 28.)

## 29.6 Data warehouses versus vis√µes

Algumas  pessoas  t√™m  considerado  os  data warehouses  uma  extens√£o  das  vis√µes  do  banco de  dados.  J√°  mencionamos  as  vis√µes  materializadas como um modo de atender aos requisitos para acesso melhorado aos dados (veja uma discuss√£o sobre vis√µes na Se√ß√£o 5.3). As vis√µes materializadas t√™m sido exploradas por sua melhoria no desempenho. As vis√µes, no entanto, oferecem apenas um  subconjunto  das  fun√ß√µes  e  capacidades  dos data warehouses. Vis√µes e data warehouses s√£o semelhantes  porque  ambos  t√™m  extratos  apenas  de leitura  dos  bancos  de  dados  e  orienta√ß√£o  por  assunto. Contudo, os data warehouses s√£o diferentes das vis√µes das seguintes maneiras:

- ¬Ñ Os data warehouses existem como armazenamento persistente, em vez de serem materializados por demanda.
- ¬Ñ Os  data  warehouses  normalmente  n√£o  s√£o relacionais,  mas  sim  multidimensionais.  As vis√µes de um banco de dados relacional s√£o relacionais.
- ¬Ñ Os  data  warehouses  podem  ser  indexados para otimizar o desempenho. As vis√µes n√£o podem ser indexadas independentemente dos bancos de dados subjacentes.
- ¬Ñ Os data warehouses caracteristicamente oferecem  suporte  espec√≠fico  de  funcionalidade; as vis√µes, n√£o.
- ¬Ñ Os  data  warehouses  oferecem  uma  grande quantidade  de  dados  integrados  e  normalmente temporais, em geral mais do que est√° contido  em  um  banco  de  dados,  enquanto as  vis√µes  s√£o  uma  s√≠ntese  de  um  banco  de dados.

## 29.7 Dificuldades de implementa√ß√£o de data warehouses

Algumas quest√µes operacionais significativas surgem com o data warehousing: constru√ß√£o, administra√ß√£o  e  controle  de  qualidade.  O  gerenciamento de projeto - desenho, constru√ß√£o e implementa√ß√£o do armaz√©m - √© uma considera√ß√£o importante e desafiadora, que n√£o deve ser subestimada.  A  montagem  de  um  armaz√©m  em  n√≠vel empresarial  em  uma  grande  organiza√ß√£o  √©  uma realiza√ß√£o de import√¢ncia, potencialmente exigindo anos da conceitualiza√ß√£o para implementa√ß√£o.

Devido  √†  dificuldade  e  quantidade  de  tempo  inicial  exigidas  para  tal  empreendimento,  o  desenvolvimento e a implanta√ß√£o generalizada dos data marts  podem  oferecer  uma  alternativa  atraente, especialmente  para  as  organiza√ß√µes  com  necessidades  urgentes  para  suporte  de  OLAP,  DSS  e/ou minera√ß√£o de dados.

A administra√ß√£o de um data warehouse √© um empreendimento  intenso,  proporcional  ao  tamanho e complexidade do armaz√©m. Uma organiza√ß√£o que tenta administrar um data warehouse precisa realisticamente  entender  a  natureza  complexa  de sua administra√ß√£o. Embora projetado para acesso de leitura, um data warehouse n√£o √© uma estrutura mais est√°tica do que qualquer uma de suas fontes de informa√ß√£o. Os bancos de dados de origem podem evoluir. O esquema e o componente de aquisi√ß√£o do armaz√©m devem esperar atualiza√ß√£o para lidar com essas evolu√ß√µes.

Uma quest√£o significativa no data warehousing √© o controle de qualidade dos dados. Tanto a qualidade quanto a consist√™ncia dos dados s√£o quest√µes importantes. Embora os dados passem por uma fun√ß√£o de limpeza durante a aquisi√ß√£o, a qualidade e a consist√™ncia continuam sendo quest√µes significativas para o administrador do banco de dados. Juntar dados de fontes heterog√™neas e distintas √© um desafio s√©rio,  dadas  as  diferen√ßas  na  nomea√ß√£o,  defini√ß√µes de dom√≠nio, n√∫meros de identifica√ß√£o e coisas desse tipo.  Toda  vez  que  um  banco  de  dados  de  origem muda,  o  administrador  do  data  warehouse  precisa considerar  as  poss√≠veis  intera√ß√µes  com  outros  elementos no armaz√©m.

Proje√ß√µes de uso devem ser estimadas conservadoramente antes da constru√ß√£o do data warehouse e  devem  ser  revisadas  de  maneira  cont√≠nua  para refletir  os  requisitos  atuais.  √Ä  medida  que  os  padr√µes de utiliza√ß√£o se tornam claros e mudam com o tempo, o armazenamento e os caminhos de acesso podem ser ajustados para que permane√ßam otimizados  para  o  suporte  do  uso  de  seu  armaz√©m pela  organiza√ß√£o.  Essa  atividade  deve  continuar por toda a vida do armaz√©m para que permane√ßa adiante da demanda. O armaz√©m tamb√©m deve ser projetado  para  acomodar  o  acr√©scimo  e  o  atrito das fontes de dados sem um reprojeto importante. As origens e os dados de origem evoluir√£o, e o armaz√©m precisa acomodar essa mudan√ßa. Ajustar os dados de origem dispon√≠veis ao modelo de dados do armaz√©m ser√° um desafio cont√≠nuo, uma tarefa que √© tanto arte quanto ci√™ncia. Como existe uma mudan√ßa r√°pida  cont√≠nua  nas  tecnologias,  os  requisitos e capacidades do armaz√©m mudar√£o con- sideravelmente com o tempo. Al√©m disso, a pr√≥pria tecnologia  de  armazenagem  continuar√°  a  evoluir por algum tempo, de modo que as estruturas e funcionalidades componentes  ser√£o  continuamente atualizadas. Essa mudan√ßa certa √© uma motiva√ß√£o excelente para que haja um projeto totalmente modular dos componentes.

A  administra√ß√£o  de  um  data  warehouse  exigir√° habilidades muito mais amplas do que as necess√°rias para a administra√ß√£o do banco de dados tradicional.  Provavelmente,  ser√°  necess√°ria  uma equipe de especialistas t√©cnicos altamente habilitados, com √°reas de especializa√ß√£o sobrepostas, em vez de um √∫nico indiv√≠duo. Assim como a administra√ß√£o do banco de dados, a administra√ß√£o do data warehouse  √©  apenas  parcialmente  t√©cnica;  uma grande parte da responsabilidade exige o trabalho eficaz com todos os membros da organiza√ß√£o com um interesse no data warehouse. Por mais dif√≠cil que possa ser √†s vezes para os administradores do banco de dados, isso √© muito mais desafiador para os administradores do data warehouse, pois o escopo de suas responsabilidades √© consideravelmente maior.

O projeto da fun√ß√£o de gerenciamento e a sele√ß√£o da equipe de gerenciamento para um data warehouse s√£o cruciais. Seu gerenciamento em uma organiza√ß√£o grande certamente ser√° uma tarefa importante. Muitas ferramentas comerciais est√£o dispon√≠veis para dar suporte a fun√ß√µes de gerenciamento. O gerenciamento  eficaz  do  data  warehouse  com  certeza  ser√°  uma fun√ß√£o de equipe, que exige um grande conjunto de habilidades t√©cnicas, coordena√ß√£o cuidadosa e lideran√ßa  eficaz.  Assim  como  precisamos  nos  preparar para a evolu√ß√£o do armaz√©m, tamb√©m temos de reconhecer que as habilidades da equipe da ger√™ncia, necessariamente, evoluir√£o com ela.

## Resumo

Neste cap√≠tulo, estudamos o campo conhecido como data warehousing (ou armazenagem de dados). O data warehousing pode ser visto como um processo que requer uma s√©rie de atividades preliminares. Ao contr√°rio, a minera√ß√£o de dados (ver Cap√≠tulo 28) pode ser imaginada  como  uma  atividade  que  retira  conhecimento  de um data warehouse existente. Apresentamos os principais conceitos relacionados ao data warehousing e discutimos a funcionalidade especial associada a uma vis√£o multidimensional  dos  dados.  Tamb√©m  discutimos  as maneiras como os data warehouses d√£o aos tomadores de decis√£o informa√ß√µes no n√≠vel correto de detalhe, com base em organiza√ß√£o e perspectiva apropriadas.

## Perguntas de revis√£o

- 29.1. O que √© um data warehouse? Como ele difere de um banco de dados?
- 29.2. Defina os termos: OLAP (processamento anal√≠tico  on-line),  ROLAP  (OLAP relacional),  MOLAP (OLAP multidimensional) e DSS (sistemas de apoio √† decis√£o).
- 29.3. Descreva as caracter√≠sticas de um data warehouse. Divida-as em funcionalidade de um armaz√©m e vantagens que os usu√°rios tiram dele.
- 29.4. O que √© o modelo de dados multidimensional? Como ele √© usado no data warehousing?
- 29.5. Defina os seguintes termos: esquema estrela, esquema floco de neve, constela√ß√£o de fatos, data marts.
- 29.6. Que  tipos  de  √≠ndices  s√£o  criados  para  um  armaz√©m? Ilustre os usos para cada um com um exemplo.
- 29.7. Descreva as etapas para a cria√ß√£o de um armaz√©m.
- 29.8. Que considera√ß√µes desempenham um papel importante no projeto de um armaz√©m?
- 29.9. Descreva as fun√ß√µes que um usu√°rio pode realizar  em  um  data  warehouse e ilustre  os  resultados  dessas  fun√ß√µes  em  um  exemplo  de  data warehouse multidimensional.
- 29.10. Como o conceito de uma vis√£o relacional est√° relacionado a um data warehouse e a data marts? Em que eles s√£o diferentes?
- 29.11. Liste  as  dificuldades  na  implementa√ß√£o  de  um data warehouse.
- 29.12. Liste as quest√µes abertas e problemas de pesquisa no data warehousing.

## Bibliografia selecionada

Inmon (1992, 2005) tem o cr√©dito por dar aceita√ß√£o geral ao termo. Codd e Salley (1993) popularizaram o termo processamento anal√≠tico on-line (OLAP) e definiram um conjunto de caracter√≠sticas para data warehouses darem suporte a OLAP. Kimball (1996) √© conhecido por sua contribui√ß√£o ao desenvolvimento do campo de data warehousing. Mattison (1996) √© um dos v√°rios livros  sobre  data  warehousing  que  oferece  uma  an√°lise abrangente das t√©cnicas dispon√≠veis nos data warehouses e as estrat√©gias que as empresas devem usar em sua implanta√ß√£o.  Ponniah  (2002)  oferece  uma  vis√£o  geral muito pr√°tica do processo de cria√ß√£o de data warehouse com base na coleta de requisitos at√© a implanta√ß√£o e manuten√ß√£o. Bischoff e Alexander (1997) √© uma compila√ß√£o de conselhos de especialistas. Chaudhuri e Dayal (1997) oferecem um excelente tutorial sobre o assunto, enquanto Widom (1995) aponta uma s√©rie de problemas de pesquisa pendentes.

Tabela 10.1

Algumas das ferramentas de projeto automatizado de banco de dados atualmente dispon√≠veis.

| Empresa                                   | Ferramenta                       | Funcionalidade                                                                                                         |
|-------------------------------------------|----------------------------------|------------------------------------------------------------------------------------------------------------------------|
| Embarcadero                               | ER/Studio DBArtisan              | Modelagem de banco de dados em ER e IDEF1x Administra√ß√£o de banco de dados e gerenciamento de espa√ßo e seguran√ßa       |
| Oracle                                    | Developer 2000 e Designer 2000   | Modelagem de banco de dados, desenvolvimento de aplica√ß√£o                                                              |
| Persistence                               |                                  |                                                                                                                        |
| Inc.                                      | PowerTier Platinum ModelMart,    | Mapeamento de modelo O-O para modelo relacional                                                                        |
| Platinum Technology (Computer Associates) | ERwin, BPwin, Component Modeler  | Modelagem de componentes Modelagem de dados, modelagem de objetos, modelagem de processos, an√°lise/projeto estruturado |
| Popkin Software                           | Telelogic System Architect       |                                                                                                                        |
| Rational (IBM)                            | Rational Rose XDE Developer Plus | Modelagem em UML e gera√ß√£o de aplica√ß√£o em C++ e Java                                                                  |
| Resolution Ltd.                           | XCase                            | Modelagem conceitual at√© manuten√ß√£o de c√≥digo                                                                          |
| Sybase                                    | Enterprise Application Suite     | Modelagem de dados, modelagem de l√≥gica de neg√≥cios                                                                    |
| Visio                                     | Visio Enterprise                 | Modelagem de dados, projeto e reengenharia Visual Basic e Visual C++                                                   |

Fornecemos apenas detalhes ilustrativos, e n√£o a especifica√ß√£o completa. Depois, discutimos uma ferramenta de desenvolvimento de software espec√≠fica - Rational Rose e Rose Data Modeler -, que oferece suporte para as fases  de  projeto  conceitual  e  projeto  l√≥gico  do  banco  de dados. O Rose √© uma ferramenta muito mais ampla para o projeto de sistemas de informa√ß√£o em geral. Por fim, discutimos rapidamente a funcionalidade e os recursos desej√°veis das ferramentas automatizadas comerciais de projeto de banco de dados, que s√£o mais voltadas para o projeto do banco de dados, ao contr√°rio do Rational Rose. Ao final, mostramos um resumo em forma de tabela de recursos.

## Perguntas de revis√£o

- 10.1. Quais s√£o as seis fases do projeto de banco de dados? Discuta cada fase.
- 10.2. Quais das seis fases s√£o consideradas as atividades principais no processo de projeto de banco de dados em si? Por qu√™?
- 10.3. Por que √© importante projetar os esquemas e as aplica√ß√µes em paralelo?
- 10.4. Por que √© importante usar um modelo de dados independente da implementa√ß√£o durante o projeto do esquema conceitual? Que modelos s√£o usados nas ferramentas de projeto atuais? Por qu√™?
- 10.5. Discuta a import√¢ncia do levantamento e an√°lise de requisitos.
- 10.6. Considere a aplica√ß√£o real de um sistema de banco de dados de seu interesse. Defina os requisitos dos diferentes n√≠veis de usu√°rios em mat√©ria de dados necess√°rios, tipos de consulta e transa√ß√µes a serem processadas.
- 10.7. Discuta as caracter√≠sticas que um modelo de dados para o projeto do esquema conceitual deve possuir.
- 10.8. Compare as duas principais t√©cnicas para o projeto do esquema conceitual.
- 10.9. Discuta as estrat√©gias para projetar um √∫nico esquema conceitual com base em seus requisitos.
- 10.10. Quais s√£o as etapas da t√©cnica de integra√ß√£o de vis√£o  para  o  projeto  do  esquema  conceitual? Quais s√£o as dificuldades durante cada etapa?
- 10.11. Como funcionaria  uma  ferramenta  de  integra√ß√£o de vis√£o? Crie uma arquitetura modular de exemplo para tal ferramenta.
- 10.12. Quais s√£o as diferentes estrat√©gias para a integra√ß√£o de vis√£o?
- 10.13. Discuta os fatores que influenciam a escolha de um pacote de SGBD para o sistema de informa√ß√£o de uma organiza√ß√£o.

10.14.

- O que √© o mapeamento do modelo de dados independente do sistema? Como ele se diferencia do mapeamento do modelo de dados dependente do sistema?
- 10.15. Quais  s√£o  os  fatores  importantes  que  influenciam o projeto f√≠sico do banco de dados?

- 10.16. Discuta as decis√µes tomadas durante o projeto f√≠sico do banco de dados.

- 10.17. sistema de informa√ß√£o.

Discuta os ciclos de vida macro e micro de um

- 10.18. Discuta as orienta√ß√µes para o projeto f√≠sico do banco de dados nos SGBDRs.

- 10.19.

Discuta os tipos de modifica√ß√µes que podem ser aplicadas ao projeto l√≥gico de um banco de da- dos relacional.

- 10.20. Quais fun√ß√µes s√£o fornecidas pelas ferramentas t√≠picas de projeto de banco de dados?

- 10.21. Que tipo de funcionalidade  seria  desej√°vel  nas ferramentas automatizadas para dar suporte ao projeto ideal de grandes bancos de dados?

10.22. Quais s√£o os SGBDs relacionais que dominam o mercado atualmente? Escolha um com que voc√™ esteja acostumado e mostre como ele √© avaliado com base nos crit√©rios dispostos na Se√ß√£o 10.2.3.

10.23. Uma DDL poss√≠vel, correspondente √† Figura 3.1, √© a seguinte:

CREATE TABLE ALUNO (

Nome Cpf

VARCHAR(30)

NOT NULL, PRIMARY KEY,

CHAR(9)

Telefone\_residencial

VARCHAR(14),

Endereco

VARCHAR(40),

Telefone\_comercial

VARCHAR(14),

Idade

INT,

Media

DECIMAL(4,3)

);

Discuta as seguintes decis√µes de projeto:

- a. A escolha de exigir que Nome seja NOT NULL.
- b. A sele√ß√£o de Cpf como a PRIMARY KEY.
- c. A escolha de tamanhos e precis√£o dos campos.
- d. Qualquer modifica√ß√£o dos campos definidos neste banco de dados.
- e. Quaisquer restri√ß√µes sobre campos individuais.

Que conven√ß√µes de nomea√ß√£o voc√™ poderia desenvolver para ajudar a identificar as chaves estrangeiras com mais efici√™ncia?

10.24.

10.25.

Que fun√ß√µes s√£o oferecidas pelas ferramentas de projeto de banco de dados t√≠picas?

## Bibliografia selecionada

Existe  muita  literatura  sobre  projeto  de  banco  de dados. Primeiro, listamos alguns dos livros que tratam desse assunto. Batini et al. (1992) fazem um tratamento abrangente do projeto conceitual e l√≥gico do banco de dados. Wiederhold (1987) aborda todas as fases do projeto de banco de dados, com √™nfase no projeto f√≠sico. O'Neil (1994) tem uma discuss√£o detalhada sobre o projeto f√≠sico e as quest√µes de transa√ß√£o em refer√™ncia a SGBDRs comerciais. Um grande acervo de trabalho sobre modelagem e projeto conceitual foi feito na d√©cada de 1980. Brodie et al. (1984) oferecem uma cole√ß√£o de cap√≠tulos  sobre  modelagem  conceitual,  especifica√ß√£o  e an√°lise de restri√ß√£o e projeto de transa√ß√£o. Yao (1985) apresenta uma cole√ß√£o de trabalhos que variam de t√©cnicas de especifica√ß√£o de requisitos √† reestrutura√ß√£o de esquema.  Teorey  (1998)  enfatiza  a  modelagem  EER  e discute diversos aspectos do projeto conceitual e l√≥gico do banco de dados. Hoffer et al. (2009) trazem uma boa introdu√ß√£o √†s quest√µes de aplica√ß√µes de neg√≥cios do gerenciamento de banco de dados.

Navathe e Kerschberg (1986) discutem todas as fases do projeto de banco de dados e apontam o papel de dicion√°rio  de  dados.  Goldfine  e  Konig  (1988)  e  ANSI (1989)  discutem  o  papel  dos  dicion√°rios  de  dados  no projeto de banco de dados. Rozen e Shasha (1991) e Carlis e  March (1984) apresentam diferentes modelos para o problema de projeto f√≠sico de banco de dados. A an√°lise e o projeto orientados a objeto s√£o discutidos em Schlaer e Mellor (1988), Rumbaugh et al. (1991), Martin e Odell (1991) e Jacobson et al. (1992). Livros recentes de Blaha e Rumbaugh (2005) e de Martin e Odell (2008) consolidam as t√©cnicas existentes na an√°lise e projeto orientados a objeto usando UML. Fowler e Scott (2000) fazem uma introdu√ß√£o r√°pida √† UML. Para ver um tratamento abrangente da UML e seu uso no processo de desenvolvimento de software, consulte Jacobson et al. (1999) e Rumbaugh et al. (1999).

O levantamento e an√°lise de requisitos √© um t√≥pico  bastante  pesquisado.  Chatzoglu  et  al.  (1997)  e Lubars et al. (1993) apresentam estudos das pr√°ticas atuais  em  levantamento,  modelagem  e  an√°lise  de  requisitos.  Carroll  (1995)  oferece  um  conjunto  de  leituras  sobre  o  uso  de  cen√°rios  para  levantamento  de requisitos nos est√°gios iniciais do desenvolvimento do sistema. Wood e Silver (1989) oferecem uma boa vis√£o geral do processo oficial de Joint Application Design (JAD). Potter et al. (1991) descrevem a nota√ß√£o Z e a metodologia para a especifica√ß√£o formal do software. Zave (1997) classificou os esfor√ßos de pesquisa na engenharia de requisitos.

Um grande acervo de trabalho tem sido produzido sobre os problemas de integra√ß√£o de esquema e vis√£o, que  est√°  se  tornando  particularmente  relevante  agora por causa da necessidade de integrar uma s√©rie de bancos de dados existentes. Navathe e Gadgil (1982) definiram t√©cnicas para a integra√ß√£o de vis√£o. As metodologias de integra√ß√£o de esquema s√£o comparadas em Batini et al. (1987). O trabalho detalhado sobre integra√ß√£o de vis√£o n -√°ria pode ser encontrado em Navathe et al. (1986), Elmasri et al. (1986) e Larson et al. (1989). Uma ferramenta de integra√ß√£o baseada em Elmasri et al. (1986) √© descrita em Sheth et al. (1988). Outro sistema de integra√ß√£o de vis√£o √© discutido em Hayne e Ram (1990). Casanova et al. (1991) descrevem uma ferramenta para o projeto modular de banco de dados. Motro (1987) discute a integra√ß√£o com rela√ß√£o aos bancos de dados pr√©-existentes. A estrat√©gia balanceada bin√°ria para a integra√ß√£o de vis√£o √© discutida em Teorey e Fry (1982). Uma abordagem

formal para a integra√ß√£o de vis√£o, que usa depend√™ncias de inclus√£o, √© dada em Casanova e Vidal (1982). Ramesh e Ram (1997) descrevem uma metodologia para a integra√ß√£o  de  relacionamentos  nos  esquemas  utilizando  o conhecimento das restri√ß√µes de integridade; isso estende o trabalho anterior de Navathe et al. (1984a). Sheth et al. (1993) descrevem as quest√µes de montagem de esquemas globais  pelo  racioc√≠nio  a  respeito  dos  relacionamentos de atributo e equival√™ncias de entidade. Navathe e Savasere  (1996)  descrevem  uma  abordagem  pr√°tica  para a montagem de esquemas globais com base nos operadores aplicados aos componentes do esquema. Santucci (1998) oferece um tratamento detalhado dos esquemas EER para integra√ß√£o. Castano et al. (1998) apresentam um estudo abrangente das t√©cnicas de an√°lise do esquema conceitual.

O projeto de transa√ß√£o √© um t√≥pico com pesquisa relativamente menos minucioso. Mylopoulos et al. (1980) propuseram a linguagem TAXIS, e Albano et al. (1985)

desenvolveram  o  sistema  GALILEO,  ambos  abrangentes  para  especificar  transa√ß√µes.  A  linguagem  GORDAS para o modelo ECR (Elmasri et al., 1985) cont√©m uma capacidade de especifica√ß√£o de transa√ß√£o. Navathe e Balaraman (1991) e Ngu (1989) discutem a modelagem de transa√ß√£o em geral para modelos de dados sem√¢nticos. Elmagarmid (1992) discute os modelos de transa√ß√£o para aplica√ß√µes avan√ßadas. Batini et al. (1992, cap√≠tulos 8, 9 e 11) discutem o projeto de transa√ß√£o de alto n√≠vel e a an√°lise conjunta de dados e fun√ß√µes. Shasha (1992) √© uma excelente fonte sobre ajuste de banco de dados.

Informa√ß√µes  sobre  algumas  ferramentas  comerciais de banco de dados bem conhecidas podem ser encontradas nos sites dos vendedores (veja o nome das empresas na Tabela 10.1). Os princ√≠pios por tr√°s das ferramentas de projeto automatizadas s√£o discutidos em Batini et al. (1992, Cap√≠tulo 15). A ferramenta SECSI √© descrita em Metais et al. (1998). DKE (1997) √© uma edi√ß√£o especial sobre quest√µes de linguagem natural nos bancos de dados.



Objeto, objeto-relacional e XML: conceitos, modelos, linguagens e padr√µes



## Bancos de dados de objeto e objeto-relacional

N este cap√≠tulo, vamos discutir os recursos dos modelos  de  dados  orientados  a  objeto  e  mostrar como alguns desses recursos foram incorporados nos sistemas de bancos de dados relacionais. Os bancos de dados orientados a objeto agora s√£o conhecidos como bancos de dados de objeto (BDO ) (anteriormente chamados BDOO), e os sistemas de bancos de dados s√£o conhecidos como sistemas de gerenciamento de dados de  objeto (SGDO) (anteriormente conhecidos como SGBDO ou SGBDOO). Sistemas e  modelos  de  dados tradicionais, como relacionais, de rede e hier√°rquicos, t√™m  tido  muito  sucesso  no  desenvolvimento  das tecnologias de banco de dados exigidas para muitas aplica√ß√µes de banco de dados de neg√≥cios tradicionais. Por√©m, eles  t√™m  certas  defici√™ncias  quando  aplica√ß√µes  de  banco  de  dados  mais  complexas  precisam ser  projetadas  e  implementadas  -  por  exemplo, bancos de dados para projeto de engenharia e manufatura (CAD/CAM e CIM 1 ), experimentos cient√≠ficos, telecomunica√ß√µes, sistemas de informa√ß√µes geogr√°ficas e multim√≠dia. 2 Essas aplica√ß√µes mais recentes possuem requisitos e caracter√≠sticas que diferem daqueles das aplica√ß√µes de neg√≥cios tradicionais, como estruturas  mais  complexas  para  objetos  armazenados;  a necessidade  de  novos  tipos  de  dados  para  armazenar imagens, v√≠deos ou itens de texto grandes; transa√ß√µes de maior dura√ß√£o; e a necessidade de definir opera√ß√µes  fora  do  padr√£o  espec√≠ficas  da  aplica√ß√£o. Os bancos de dados de objeto foram propostos para atender a algumas das necessidades dessas aplica√ß√µes mais  complexas.  Um  recurso  chave  dos  bancos  de dados de objeto √© o poder que eles d√£o ao projetista para especificar tanto a estrutura dos objetos comple- xos quanto as opera√ß√µes que podem ser aplicadas a esses objetos.

Outro motivo para a cria√ß√£o de bancos de dados orientados a objeto √© o grande aumento no uso de  linguagens  de  programa√ß√£o  orientadas  a  objeto para  o  desenvolvimento  de  aplica√ß√µes  de  software. Os  bancos  de  dados  s√£o  componentes  fundamentais em muitos sistemas de software, e os bancos de dados tradicionais √†s vezes s√£o dif√≠ceis de usar com aplica√ß√µes  de  software  que  s√£o  desenvolvidas  em uma linguagem de programa√ß√£o orientada a objeto, como C++ ou Java. Os bancos de dados de objeto s√£o projetados de modo que possam ser integrados diretamente - ou transparentemente - ao software desenvolvido  usando  linguagens  de  programa√ß√£o orientadas a objeto.

Vendedores de SGBD relacional (SGBDR) tamb√©m reconheceram a necessidade de incorporar recursos que foram propostos para bancos de dados de objeto, e vers√µes mais novas de sistemas relacionais incorporaram  muitos  desses  recursos.  Isso  levou  a sistemas de banco de dados que s√£o caracterizados como objeto-relacional ou SGBDORs. A vers√£o mais recente do padr√£o SQL (2008) para SGBDRs inclui muitos desses recursos, que eram conhecidos originalmente como SQL/Object e agora t√™m sido incorporados  na  especifica√ß√£o  SQL  principal,  conhecida como SQL/Foundation.

Embora muitos prot√≥tipos experimentais e sistemas  de  banco  de  dados  comerciais  orientados  a objeto tenham sido criados, eles n√£o tiveram uso generalizado por causa da popularidade dos sistemas

1 Computer-Aided Design/Computer-Aided Manufacturing (projeto auxiliado por computador/fabrica√ß√£o auxiliada por computador) e ComputerIntegrated Manufacturing (fabrica√ß√£o integrada ao computador).

2 Bancos de dados de multim√≠dia precisam armazenar v√°rios tipos de objetos de multim√≠dia, como v√≠deo, √°udio, imagens, gr√°ficos e documentos (ver Cap√≠tulo 26).

relacionais e objeto-relacional. Os prot√≥tipos experimentais  inclu√≠ram  o  sistema  Orion,  desenvolvido na  MCC; 3   o  OpenOODB,  na  Texas  Instruments; o sistema Iris, nos laborat√≥rios da Hewlett-Packard; o sistema Ode, na AT&amp;T Bell Labs; 4  e o projeto ENCORE/ObServer, na Brown University. Sistemas dispon√≠veis comercialmente inclu√≠ram GemStone Object Server da GemStone Systems, ONTOS DB da Ontos, Objectivity/DB  da  Objectivity  Inc.,  Versant  Object Database  e  FastObjects  da  Versant  Corporation  (e Poet), ObjectStore da Object Design e Ardent Database da Ardent. 5  Estes representam apenas uma lista parcial  dos  prot√≥tipos  experimentais  e  sistemas  de banco de dados orientados a objeto comerciais que foram criados.

√Ä medida que os SGBDs de objeto comerciais se tornaram dispon√≠veis, reconheceu-se a necessidade de um modelo e de uma linguagem padr√£o. Como o procedimento formal para aprovar padr√µes costuma levar alguns anos, um cons√≥rcio de vendedores e usu√°  rios de SGBD de objeto, chamado ODMG, 6  prop√¥s um padr√£o cuja especifica√ß√£o atual √© conhecida como padr√£o ODMG 3.0.

Os bancos de dados orientados a objeto adotaram muitos dos conceitos que foram desenvolvidos originalmente  para  as  linguagens  de  programa√ß√£o orientadas a objeto. 7  Na Se√ß√£o 11.1, descrevemos os principais conceitos utilizados em muitos sistemas de banco  de  dados  de  objeto  e  que  foram  mais  tarde incorporados em sistemas objeto-relacional e no padr√£o SQL. Estes incluem identidade de objeto , estrutura de objeto e construtores de tipo , encapsulamento de opera√ß√µes e a defini√ß√£o de m√©todos como parte das  declara√ß√µes  de  classe,  mecanismos  para  armazenar objetos em um banco de dados, tornando-os persistentes , e hierarquias e heran√ßa de tipo e classe . Depois, na Se√ß√£o 11.2, vemos como esses conceitos foram incorporados nos padr√µes SQL mais recentes, levando a bancos de dados objeto-relacional. Os recursos  de  objeto  foram  introduzidos  originalmente na SQL:1999, e depois atualizados na vers√£o mais recente (SQL:2008) do padr√£o. Na Se√ß√£o 11.3, voltamos nossa aten√ß√£o para os padr√µes de banco de dados  de  objeto  'puros',  apresentando  recursos  do padr√£o de banco de dados de objeto ODMG 3.0 e a  linguagem  de  defini√ß√£o  de  objeto  ODL.  A  Se√ß√£o 11.4 apresenta uma vis√£o geral do processo de proje-

3 Microelectronics and Computer Technology Corporation, Austin, Texas.

4 Agora chamada Lucent Technologies.

5 Anteriormente, O2 da O2 Technology.

6 Object Data Management Group.

7 Conceitos semelhantes tamb√©m foram desenvolvidos nos campos de modelagem de dados sem√¢ntica e representa√ß√£o do conhecimento.

8 Palo Alto Research Center, Palo Alto, Calif√≥rnia.

9 Os objetos possuem muitas outras caracter√≠sticas, conforme discutiremos adiante neste cap√≠tulo.

to para bancos de dados de objeto. A Se√ß√£o 11.5 discute a linguagem de consulta de objeto (OQL), que faz parte do padr√£o ODMG 3.0. Na Se√ß√£o 11.6, discutimos os bindings da linguagem de programa√ß√£o, que especificam como estender as linguagens de programa√ß√£o orientadas a objeto para incluir recursos do padr√£o de banco de dados de objeto. No final h√° um resumo do cap√≠tulo. As se√ß√µes 11.5 e 11.6 podem ser omitidas se for desejada uma introdu√ß√£o menos completa aos bancos de dados de objeto.

## 11.1 Vis√£o geral dos conceitos de banco de dados de objeto

## 11.1.1 ntrodu√ß√£o aos conceitos e I recursos orientados a objeto

O termo orientado a objeto - abreviado como OO ou O-O - tem suas origens nas linguagens de programa√ß√£o  OO,  ou  LPOO.  Hoje,  os  conceitos de OO s√£o aplicados nas √°reas de bancos de dados, engenharia de software, bases de conhecimento, intelig√™ncia artificial e sistemas de computa√ß√£o em geral. LPOOs t√™m suas ra√≠zes na linguagem SIMULA, que foi proposta no final da d√©cada de 1960. A linguagem de  programa√ß√£o  Smalltalk,  desenvolvida  na  Xerox PARC 8  nos anos 1970, foi uma das primeiras linguagens a incorporar explicitamente conceitos OO adicionais, como passagem de mensagens e heran√ßa. Ela √©  conhecida como uma linguagem de programa√ß√£o OO pura , significando que foi projetada de maneira explicitamente para ser orientada a objeto. Isso √© diferente das linguagens de programa√ß√£o OO h√≠bridas , que incorporam conceitos de OO a uma linguagem j√° existente. Um exemplo desse segundo tipo √© a C++, que incorpora conceitos de OO √† popular linguagem de programa√ß√£o C.

Um objeto normalmente possui dois componentes: estado (valor) e comportamento (opera√ß√µes). Ele pode ter uma estrutura de dados complexa , bem como opera√ß√µes espec√≠ficas definidas pelo programador. 9  Os objetos em uma LPOO existem apenas durante a execu√ß√£o do programa; assim, eles s√£o chamados de objetos transientes . Um banco de dados OO pode estender a exist√™ncia de objetos de modo que eles sejam armazenados permanentemente em um banco de dados, e, portanto,  os  objetos  se  tornam objetos  persistentes ,

que existem al√©m do t√©rmino do programa e podem ser  recuperados  mais  tarde  e  compartilhados  por outros  programas.  Em  outras  palavras,  os  bancos de  dados  OO  armazenam  objetos  persistentes  de maneira  permanente  no  armazenamento  secund√°rio, e permitem o compartilhamento desses objetos entre  v√°rios  programas  e  aplica√ß√µes.  Isso  requer  a incorpora√ß√£o  de  outros  recursos  bem  conhecidos dos sistemas de gerenciamento de banco de dados, como os mecanismos de indexa√ß√£o, para localizar os objetos com efici√™ncia, o controle de concorr√™ncia, para  permitir  o  compartilhamento  de  objeto  entre programas concorrentes, e a recupera√ß√£o de falhas. Um sistema de banco de dados OO costuma interagir com uma ou mais linguagens de programa√ß√£o OO para oferecer capacidades de objeto persistentes e compartilhadas.

A estrutura interna de um objeto na LPOOs inclui a especifica√ß√£o de vari√°veis de inst√¢ncia , as quais mant√™m os valores que definem o estado interno do objeto.  Uma  vari√°vel  de  inst√¢ncia  √©  semelhante  ao conceito de um atributo no modelo relacional, exceto que as vari√°veis de inst√¢ncia podem ser encapsuladas dentro do objeto e, portanto, n√£o s√£o necessariamente vis√≠veis aos usu√°rios externos. As vari√°veis de inst√¢ncia tamb√©m podem ter tipos de dados de qualquer complexidade. Os sistemas orientados a objeto permitem a defini√ß√£o das opera√ß√µes ou fun√ß√µes (comportamentos) que podem ser aplicadas a objetos de determinado tipo. De fato, alguns modelos OO insistem para que todas as opera√ß√µes que um usu√°rio pode aplicar a um objeto sejam predefinidas. Isso for√ßa um encapsulamento completo dos objetos. Essa abordagem r√≠gida tem sido relaxada na maioria dos modelos de dados OO por dois motivos. Primeiro, os usu√°rios do banco de dados normalmente precisam saber os nomes de atributo para poder especificar condi√ß√µes de sele√ß√£o sobre os atributos a fim de recuperar objetos espec√≠ficos. Segundo, o encapsulamento completo implica que qualquer recupera√ß√£o simples exija uma opera√ß√£o  predefinida,  tornando  assim  as  consultas casuais dif√≠ceis de especificar no ato.

Para encorajar o encapsulamento, uma opera√ß√£o √© definida em duas partes. A primeira parte, chamada assinatura ou interface da opera√ß√£o, especifica o nome desta e os argumentos (ou par√¢metros). A segunda parte, chamada de m√©todo ou corpo , especifica  a implementa√ß√£o da opera√ß√£o, com frequ√™ncia escrita em alguma linguagem de programa√ß√£o de uso geral.  As  opera√ß√µes podem ser invocadas passando uma mensagem a um objeto, que inclui o nome da opera√ß√£o e os par√¢metros. O objeto, ent√£o, executa o m√©todo para essa opera√ß√£o. Esse encapsulamento permite a modifica√ß√£o da estrutura interna de um ob- jeto, al√©m da implementa√ß√£o de suas opera√ß√µes, sem a necessidade de interromper os programas externos que chamam essas opera√ß√µes. Logo, o encapsulamento oferece uma forma de independ√™ncia entre dados e opera√ß√£o (ver Cap√≠tulo 2).

Outro conceito fundamental nos sistemas OO √© o de heran√ßa e hierarquias de tipo e classe. Isso permite  a  especifica√ß√£o  de  novos  tipos  ou  classes  que herdam grande parte de sua estrutura e/ou opera√ß√µes de tipos ou classes previamente definidas. Isso torna mais f√°cil desenvolver os tipos de dados de um sistema de forma incremental e reutilizar defini√ß√µes de tipo existentes em novos tipos de objetos.

Um problema nos primeiros sistemas de banco de dados OO envolvia a representa√ß√£o de relacionamentos entre  objetos.  A  insist√™ncia  sobre  encapsulamento completo nos primeiros modelos de dados OO levaram ao argumento de que os relacionamentos n√£o devem ser representados explicitamente, mas, em vez disso, devem ser descritos definindo m√©todos apropriados que localizam objetos relacionados. No entanto,  essa  abordagem  n√£o  funciona  muito  bem para bancos de dados complexos, com diversos relacionamentos, porque √© √∫til identificar esses relacionamentos e torn√°-los vis√≠veis aos usu√°rios. O padr√£o de banco de dados de objeto ODMG reconheceu essa necessidade e representa explicitamente os relacionamentos bin√°rios por meio de um par de refer√™ncias inversas , conforme descreveremos na Se√ß√£o 11.3.

Outro conceito de OO √© a sobrecarga de operador ,  que se refere √† capacidade de uma opera√ß√£o de ser aplicada a diferentes tipos de objetos. Em tal situa  √ß√£o, um nome de opera√ß√£o pode se referir a v√°rias implementa√ß√µes distintas,  dependendo  do  tipo de objeto ao qual √© aplicado. Esse recurso tamb√©m √© chamado polimorfismo de operador . Por exemplo, uma opera√ß√£o para calcular a √°rea de um objeto geom√©trico pode diferir em seu m√©todo (implementa√ß√£o), dependendo de o objeto ser do tipo tri√¢ngulo, c√≠rculo ou ret√¢ngulo. Isso pode exigir o uso da liga√ß√£o tardia do nome da opera√ß√£o ao m√©todo apropriado em tempo de execu√ß√£o, quando o tipo de objeto ao qual a opera√ß√£o √© aplicada se torna conhecido.

Nas pr√≥ximas se√ß√µes, vamos discutir com certos detalhes  as  principais  caracter√≠sticas  dos  bancos  de dados de objeto. A Se√ß√£o 11.1.2 discute a identidade do objeto; a Se√ß√£o 11.1.3 mostra como os tipos para objetos estruturados complexos s√£o especificados por meio de construtores de tipo; a Se√ß√£o 11.1.4 discute o encapsulamento e a persist√™ncia; e a Se√ß√£o 11.1.5 apresenta conceitos de heran√ßa. A Se√ß√£o 11.1.6 discute  alguns  conceitos  adicionais  de  OO,  e  a  Se√ß√£o 11.1.7 oferece um resumo de todos os conceitos de OO que ser√£o apresentados. Na Se√ß√£o 11.2, mostra-

mos como alguns desses conceitos foram incorporados ao padr√£o SQL:2008 para bancos de dados relacionais.  Depois, na Se√ß√£o 11.3, mostramos como esses conceitos s√£o realizados no padr√£o de banco de dados de objeto ODMG 3.0.

## 11.1.2 dentidade de objeto e objetos I versus literais

Um dos objetivos de um SGDO (Sistema de Gerenciamento de Dados de Objeto) √© manter uma correspond√™ncia direta entre objetos do mundo real e do banco de dados, de modo que os objetos n√£o percam sua integridade e identidade e possam facilmente ser identificados e operados. Assim, um SGDO oferece uma identidade √∫nica a cada objeto independente armazenado no banco de dados. Essa identidade √∫nica normalmente √© implementada por meio de um identificador de objeto  OID ( ) √∫nico, gerado pelo sistema. O valor de um OID n√£o √© vis√≠vel ao usu√°rio externo, mas √© utilizado internamente pelo sistema para identificar cada objeto de maneira exclusiva, criar e gerenciar refer√™ncias entre objetos. O OID pode ser atribu√≠do a vari√°veis de programa do tipo apropriado, quando necess√°rio.

A  principal  propriedade  exigida  de  um  OID  √© que ele seja imut√°vel ; ou seja, o valor do OID de um objeto em particular n√£o deve mudar. Isso preserva a identidade do objeto do mundo real que est√° sendo representado. Logo, um SGDO precisa ter algum mecanismo para gerar OIDs e preservar a propriedade de imutabilidade. Tamb√©m √© desej√°vel que cada OID seja usado apenas uma vez; isto √©, mesmo que um objeto seja removido do banco de dados, seu OID n√£o dever√° ser atribu√≠do a outro objeto. Essas duas propriedades implicam que o OID n√£o deve depender de quaisquer valores de atributo do objeto, pois o valor de um atributo pode ser alterado ou corrigido. Podemos comparar isso com o modelo relacional, no qual cada rela√ß√£o precisa ter um atributo de chave prim√°ria cujo valor identifica cada tupla de maneira exclusiva. No modelo relacional, se o valor da chave prim√°ria for alterado, a tupla ter√° uma nova identidade, embora ela ainda possa representar o mesmo objeto do mundo real. Como alternativa, um objeto do mundo real pode ter diferentes nomes para atributos chave em rela√ß√µes distintas, tornando dif√≠cil garantir que as chaves representem o mesmo objeto do mundo real (por exemplo, o identificador de objeto pode ser representado como Emp\_id em uma rela√ß√£o e como Cpf em outra).

N√£o √© apropriado basear o OID no endere√ßo f√≠sico do objeto em seu local de armazenamento, pois esse  endere√ßo  pode  mudar  ap√≥s  uma  reorganiza√ß√£o f√≠sica do banco de dados. Contudo, alguns dos primei- ros SGDOs usaram o endere√ßo f√≠sico como OID, para aumentar a efici√™ncia da recupera√ß√£o do objeto. Se o endere√ßo f√≠sico do objeto muda, um ponteiro indireto pode ser colocado no endere√ßo anterior, dando o novo local f√≠sico do objeto. √â mais comum usar inteiros longos como OIDs e depois usar alguma forma de tabela de hash para mapear o valor do OID ao endere√ßo f√≠sico atual do objeto no local de armazenamento.

Alguns  dos  primeiros  modelos  de  dados  OO exigiam que tudo - desde um simples valor a um objeto complexo - fosse representado como um objeto; logo, cada valor b√°sico, como um inteiro, cadeia ou valor booleano, tem um OID. Isso permite que dois valores b√°sicos id√™nticos tenham OIDs diferentes, o que pode ser √∫til em alguns casos. Por exemplo, o valor inteiro 50 √†s vezes pode ser usado para significar um peso em quilogramas e, em outras ocasi√µes, para significar  a  idade  de  uma  pessoa.  Ent√£o,  dois objetos  b√°sicos  com  OIDs  distintos  poderiam  ser criados,  mas  ambos  representariam  o  valor  inteiro 50. Embora √∫til como um modelo te√≥rico, ele n√£o √© muito pr√°tico, pois leva √† gera√ß√£o de muitos OIDs. Assim,  a  maioria  dos  sistemas  de  banco  de  dados OO permite a representa√ß√£o de objetos e literais (ou valores). Cada objeto precisa ter um OID imut√°vel, enquanto um valor literal n√£o tem OID e seu valor simplesmente corresponde a si mesmo. Dessa forma, um valor literal normalmente √© armazenado dentro de um objeto e n√£o pode ser referenciado de outros objetos. Em muitos sistemas, valores literais estruturados complexos tamb√©m podem ser criados sem ter um OID correspondente, se for preciso.

## 11.1.3 Estruturas de tipo complexas para objetos e literais

Outro recurso de um SGDO (e BDOs em geral) √© que os objetos e literais podem ter uma estrutura de tipo de complexidade arbitr√°ria , a fim de conter todas as informa√ß√µes necess√°rias que descrevem o objeto ou literal. Ao contr√°rio, nos sistemas de banco de dados tradicionais, a informa√ß√£o sobre um objeto complexo com frequ√™ncia √© espalhada por muitas rela√ß√µes ou registros, levando √† perda de correspond√™ncia direta entre um objeto do mundo real e sua representa√ß√£o no banco de dados. Nos BDOs, um tipo complexo pode ser constru√≠do com base em outros tipos pelo aninhamento de construtores  de  tipo .  Os  tr√™s  construtores mais b√°sicos s√£o √°tomo, struct (ou tupla) e cole√ß√£o.

- 1. Um construtor de tipo √© chamado de construtor de √°tomo ,  embora esse termo n√£o seja usado no padr√£o de objeto mais recente. Ele inclui os tipos de dados embutidos b√°sicos do modelo de objeto, que s√£o semelhantes aos tipos b√°sicos em muitas linguagens de programa√ß√£o: inteiros,

- cadeias de caracteres, n√∫meros de ponto flutuante, tipos enumerados, booleanos, e assim por diante. Eles s√£o chamados tipos de valor √∫nico ou at√¥micos , pois cada valor do tipo √© considerado um √∫nico valor at√¥mico (indivis√≠vel).
- 2. Um segundo construtor de tipo √© chamado de construtor struct (ou tuple ).  Ele  pode  criar  tipos  estruturados  padr√£o,  como  tuplas  (tipos de  registro)  no  modelo  relacional  b√°sico.  Um tipo estruturado √© composto de v√°rios componentes,  e  √†s  vezes  tamb√©m  √©  chamado  de  tipo composto . Mais  precisamente, o construtor struct n√£o √© considerado um tipo, mas sim um gerador  de  tipo ,  pois  muitos  tipos  estruturados diferentes podem ser criados. Por exemplo, dois  tipos  estruturados  diferentes  que  podem ser  criados  s√£o:  struct  Nome&lt;PrimeiroNome: string,  InicialMeio:  char,  Sobrenome: string&gt; e struct TituloAcademico&lt;Principal: string, Titulo: string, Ano: date&gt;. Para criar estruturas de tipo aninhado complexas no modelo de objeto, s√£o necess√°rios construtores do tipo de cole√ß√£o , que vamos discutimos a seguir. Observe que os construtores de tipo √°tomo e struct s√£o os √∫nicos dispon√≠veis no modelo relacional original (b√°sico).
- 3. Construtores de tipo de cole√ß√£o (ou multivalorados )  incluem  os  construtores  de  tipo set(T) , list(T)  bag(T)  array(T) , , e dictionary(K,T) . Estes permitem que parte de um objeto ou valor literal inclua uma cole√ß√£o de outros objetos ou valores, quando necess√°rio. Esses construtores tamb√©m s√£o considerados geradores de tipos , pois muitos tipos diferentes podem ser criados. Por exemplo, set( string ), set( integer ) e set( Funcionario ) s√£o tr√™s tipos diferentes que podem ser criados com base no construtor de tipo set . Todos os elementos em um valor de cole√ß√£o em particular precisam ser do mesmo tipo. Por exemplo, todos os valores em uma cole√ß√£o do tipo set( string ) precisam ser valores de string.
- O construtor de √°tomo √© usado para representar todos os valores at√¥micos b√°sicos, como inteiros, n√∫meros reais, cadeias de caracteres, booleanos e qualquer outro tipo de dado b√°sico que o sistema aceite diretamente.  O construtor  tuple pode  criar  valores estruturados  e  objetos  no  formato  &lt; a 1 : i 1 , a 2 : i 2 ,  ..., a n : i n &gt;, onde cada a j √© um nome de atributo 10  e cada i j √© um valor ou um OID.

Os outros construtores bastante usados s√£o conhecidos coletivamente como tipos de cole√ß√£o, mas possuem diferen√ßas individuais entre eles. O construtor set (conjunto) criar√° objetos ou literais que s√£o um conjunto de elementos distintos { i 1 , i 2 , ..., i n }, todos do mesmo tipo. O construtor bag (√†s vezes chamado de multiconjunto ) √© semelhante a um conjunto, exceto que os elementos em uma bag n√£o precisam ser distintos . O construtor list criar√° uma lista ordenada  i [ 1 , i 2 , ..., i n ] de OIDs ou valores do mesmo tipo. Uma lista √© semelhante a uma bag , com exce√ß√£o de os elementos em uma lista serem ordenados , e, portanto, podemos nos referir ao primeiro, segundo ou en√©simo elemento. O construtor array cria um vetor unidimensional de elementos do mesmo tipo. A principal diferen√ßa entre array e lista √© que uma lista pode ter um n√∫mero arbitr√°rio de elementos, enquanto um array normalmente tem um tamanho m√°ximo. Por fim, o constructor dictionary cria uma cole√ß√£o de duas tuplas ( K, V ),  onde o valor de uma chave K pode ser usado para recuperar o valor correspondente V .

A principal caracter√≠stica de um tipo de cole√ß√£o √© que seus objetos ou valores ser√£o uma cole√ß√£o de objetos ou valores do mesmo tipo , que podem ser desordenados (como um set ou uma bag) ou ordenados (como uma list ou um array). O tipo de construtor tuple normalmente √© chamado de um tipo estruturado , pois corresponde √† constru√ß√£o struct nas linguagens de programa√ß√£o C e C++.

Uma linguagem de defini√ß√£o de objeto (ODL -Object  Definition  Language ) 11 que  incorpora  os construtores de tipo anteriores pode ser usada para definir os tipos de objeto para determinada aplica√ß√£o de banco de dados. Na Se√ß√£o 11.3, descreveremos a ODL padr√£o do ODMG, mas primeiro vamos apresentar os conceitos gradualmente nesta se√ß√£o usando uma nota√ß√£o mais simples. Os construtores de tipo podem ser usados para definir as estruturas de dados para um esquema de banco de dados OO. A Figura 11.1 mostra como podemos declarar os tipos FUNCIONARIO e DEPARTAMENTO .

Na Figura 11.1, os atributos que se referem a outros objetos - como Dep de FUNCIONARIO ou Projetos de DEPARTAMENTO - s√£o basicamente OIDs que servem como refer√™ncias para outros objetos ao representar relacionamentos entre  os  objetos.  Por exemplo, o atributo Dep de FUNCIONARIO √© do tipo DEPARTAMENTO e, portanto, √© usado como refer√™ncia a um objeto DEPARTAMENTO espec√≠fico (o objeto DEPARTAMENTO onde o funcion√°rio trabalha). O valor de tal atributo seria um OID para um objeto DEPARTAMENTO espec√≠fico.  Um  relacionamento  bin√°rio pode ser representado em uma dire√ß√£o, ou pode ter uma refer√™ncia inversa . Essa √∫ltima representa√ß√£o facilita a travessia pelo relacionamento nas duas dire√ß√µes. Por exemplo, na Figura 11.1, o atributo Funcionarios de DEPARTAMENTO tem  como  seu  valor

10 Tamb√©m chamado de nome de vari√°vel de inst√¢ncia em terminologia OO.

11 Esta corresponde √† DDL (linguagem de defini√ß√£o de dados) do sistema de banco de dados (ver Cap√≠tulo 2).

## define type FUNCIONARIO

tuple (

Pnome:

string ;

Minicial:

char ;

Unome:

string ;

Cpf:

string ;

Data\_nascimento:

DATE;

Endereco:

string ;

Sexo:

char ;

Salario:

float ;

Supervisor:

FUNCIONARIO;

Dep:

DEPARTAMENTO;

## define type DATA

tuple (

Ano:

integer ;

Mes:

integer ;

Dia:

integer ; );

## define type DEPARTAMENTO

tuple (

Dnome:

string ;

Dnumero:

integer ;

Ger:

tuple (

Gerente: FUNCIONARIO;

Data\_inicio: DATE; );

Localizacoes:

set string ( );

Funcionarios:

set (FUNCIONARIO);

Projetos:

set (PROJETO); );

Figura 11.1

Especificando os tipos de objeto FUNCIONARIO, DATA e DEPARTAMENTO usando construtores de tipo.

um conjunto de refer√™ncias (ou seja, um conjunto de OIDs) para objetos do tipo FUNCIONARIO . Estes s√£o os funcion√°rios que trabalham para o DEPARTAMENTO . O inverso √© o atributo de refer√™ncia Dep de FUNCIONARIO . Veremos, na Se√ß√£o 11.3, como o padr√£o ODMG permite que os inversos sejam declarados explicitamente como atributos de relacionamento para garantir que as refer√™ncias inversas sejam coerentes.

## 11.1.4 Encapsulamento de opera√ß√µes e persist√™ncia de objetos

Encapsulamento de opera√ß√µes . O conceito de encapsulamento √©  uma  das  principais  caracter√≠sticas das linguagens e sistemas de OO. Ele tamb√©m est√° relacionado  aos  conceitos  de tipos  de  dados  abs- tratos e oculta√ß√£o  de  informa√ß√µes nas  linguagens de programa√ß√£o. Em modelos e sistemas de banco de dados tradicionais, esse conceito n√£o foi aplicado, j√° que √© comum tornar a estrutura dos objetos do banco de dados vis√≠vel aos usu√°rios e programas externos. Nesses modelos tradicionais, diversas opera√ß√µes do banco de dados s√£o aplic√°veis a objetos de todos os tipos . Por exemplo, no modelo relacional, as opera√ß√µes para selecionar, inserir, excluir e modificar  tuplas  s√£o  gen√©ricas  e  podem  ser  aplicadas a qualquer  rela√ß√£o no banco de dados. A rela√ß√£o e seus atributos s√£o vis√≠veis para usu√°rios e a programas externos que acessam a rela√ß√£o usando essas opera√ß√µes. Os conceitos de encapsulamento s√£o aplicados a objetos de banco de dados nos BDOs ao definir o comportamento de um tipo de objeto com base nas opera√ß√µes que podem ser aplicadas externamente  a  objetos  desse  tipo.  Algumas  opera√ß√µes podem  ser  usadas  para  criar  (inserir)  ou  destruir (excluir) objetos; outras opera√ß√µes podem atualizar o  estado  do  objeto;  e  outras  podem  ser  utilizadas para recuperar partes do estado do objeto ou para aplicar  alguns  c√°lculos.  Ainda,  outras  opera√ß√µes podem  realizar  uma  combina√ß√£o  de  recupera√ß√£o, c√°lculo  e  atualiza√ß√£o.  Em  geral,  a implementa√ß√£o de uma opera√ß√£o pode ser especificada em uma linguagem de programa√ß√£o de uso geral que  oferece flexibilidade e poder na defini√ß√£o das opera√ß√µes.

Os usu√°rios externos do objeto s√≥ se tornam cientes da interface das opera√ß√µes, que define o nome e os argumentos (par√¢metros) de cada opera√ß√£o. A implementa√ß√£o √© escondida desses usu√°rios - ela inclui a defini√ß√£o  de  quaisquer  estruturas  de  dados  internas ocultas do objeto e a implementa√ß√£o das opera√ß√µes que acessam essas estruturas. A parte de interface de uma opera√ß√£o √†s vezes √© chamada de assinatura , e a implementa√ß√£o da opera√ß√£o pode ser chamada de m√©todo .

Para aplica√ß√µes de banco de dados, o requisito de  que  todos  os  objetos  sejam  completamente  encapsulados √© muito rigoroso. Um modo de relaxar esse requisito √© dividir a estrutura de um objeto em atributos vis√≠veis e ocultos (vari√°veis  de  inst√¢ncia). Os atributos vis√≠veis podem ser vistos e s√£o acess√≠veis diretamente pelos usu√°rios e programadores de banco de dados por meio da linguagem de consulta. Os atributos  ocultos  de  um  objeto  s√£o  completamente encapsulados e s√≥ podem ser acessados por meio de opera√ß√µes predefinidas. A maioria dos SGDOs emprega linguagens de consulta de alto n√≠vel para acessar atributos vis√≠veis. Na Se√ß√£o 11.5, descreveremos a linguagem de consulta OQL, que √© proposta como uma linguagem de consulta padr√£o para BDOs.

- O termo classe √©  frequentemente  utilizado  para se referir a uma defini√ß√£o de tipo, junto com as defi-

ni√ß√µes das opera√ß√µes para esse tipo. 12  A Figura 11.2 mostra como as defini√ß√µes de tipo na Figura 11.1 podem ser estendidas com opera√ß√µes para definir classes. Diversas opera√ß√µes s√£o declaradas para cada classe, e a assinatura (interface) de cada opera√ß√£o √© inclu√≠da na defini√ß√£o da classe. Um m√©todo (implementa√ß√£o) para cada opera√ß√£o deve ser definido em outro lugar usando uma linguagem de programa√ß√£o. As opera√ß√µes t√≠picas incluem a opera√ß√£o de construtor de objeto (normalmente chamada de new ), que √© utilizada para criar um objeto, e a opera√ß√£o de destruidor , que serve para destruir (excluir) um objeto. Diversas opera√ß√µes modificadoras de objeto tamb√©m podem ser declaradas para modificar os estados (valores) de v√°rios atributos de um objeto. Opera√ß√µes adicionais podem recuperar informa√ß√µes sobre o objeto.

Uma opera√ß√£o costuma ser aplicada a um objeto usando a nota√ß√£o de ponto . Por exemplo, se d √© uma refer√™ncia a um objeto de DEPARTAMENTO , podemos chamar uma opera√ß√£o como nr\_funcs escrevendo d.nr\_ funcs . De modo semelhante, ao escrever d.destroi\_dep , o objeto referenciado por d √© destru√≠do (exclu√≠do). A √∫nica exce√ß√£o √© a opera√ß√£o construtora, que retorna uma refer√™ncia  a  um  novo  objeto DEPARTAMENTO . Logo, em alguns modelos OO, √© comum ter um nome padronizado  para  a  opera√ß√£o  construtora,  que  √©  o nome da pr√≥pria classe, embora isso n√£o tenha sido usado na Figura 11.2. 13  A nota√ß√£o de ponto tamb√©m √© utilizada para se referir aos atributos de um objeto por exemplo, ao escrever d.Dnumero ou d.Data\_inicio .

Especificando a persist√™ncia do objeto por meio de nomea√ß√£o e acessibilidade . Um SBDO normalmente est√° bastante ligado a uma linguagem de programa√ß√£o orientada a objeto (LPOO). A LPOO √© usada para especificar as implementa√ß√µes de m√©todo (opera√ß√£o), bem como outro c√≥digo de aplica√ß√£o. Nem todos os objetos visam ser armazenados permanentemente no banco de dados. Objetos transientes existem no programa em execu√ß√£o e desaparecem quando o programa termina. Objetos persistentes s√£o armazenados no banco de dados e persistem ap√≥s o t√©rmino do programa. Os mecanismos t√≠picos para tornar um objeto persistente s√£o a nomea√ß√£o e acessibilidade .

## define class FUNCIONARIO

## type tuple (

Pnome:

string;

Minicial:

char;

Unome:

string;

Cpf:

string;

Data\_nascimento:

DATE;

Endereco:

string;

Sexo:

char;

Salario:

float;

Supervisor:

FUNCIONARIO;

Dep:

DEPARTAMENTO; );

## operations

idade:

integer;

criar\_func:

FUNCIONARIO;

destroi\_func:

boolean;

end FUNCIONARIO;

## define class DEPARTAMENTO

## type tuple (

Dnome:

string;

Dnumero:

integer;

Ger:

tuple (

Gerente: FUNCIONARIO;

Data\_inicio: DATE; );

Localizacoes:

set (string);

Funcionarios:

set (FUNCIONARIO);

Projetos

set (PROJETO); );

## operations

nr\_funcs:

integer;

criar\_dep:

DEPARTAMENTO;

destroi\_dep:

boolean;

aloca\_func

(e: FUNCIONARIO): boolean;

(* acrescenta um funcion√°rio ao departamento *) remove\_func(e: FUNCIONARIO):

## boolean;

- O mecanismo de  nomea√ß√£o envolve  dar  a  um objeto um nome persistente √∫nico dentro de determinado banco de dados. Esse nome de objeto persistente pode receber uma instru√ß√£o ou opera√ß√£o espec√≠fica no programa, como mostra a Figura 11.3. Os objetos

(* remove um funcion√°rio do departamento *)

## end DEPARTAMENTO;

Figura 11.2

Acrescentando opera√ß√µes √†s defini√ß√µes de FUNCIONARIO e DEPARTAMENTO.

12 Essa defini√ß√£o de classe √© semelhante ao modo como √© usada na popular linguagem de programa√ß√£o C++. O padr√£o ODMG usa a palavra interface al√©m de classe (ver Se√ß√£o 11.3). No modelo EER, o termo classe foi usado para se referir a um tipo de objeto, junto com o conjunto de todos os objetos desse tipo (ver Cap√≠tulo 8).

13 Existem nomes padronizados para as opera√ß√µes construtoras e destruidoras na linguagem de programa√ß√£o C++. Por exemplo, para a classe

FUNCIONARIO, o nome do construtor default √© FUNCIONARIO e o nome do destruidor default √© ~FUNCIONARIO. Tamb√©m √© comum usar a opera√ß√£o new para criar novos objetos.

persistentes nomeados s√£o utilizados como pontos de entrada para o banco de dados, por meio dos quais os usu√°rios e as aplica√ß√µes podem iniciar seu acesso ao banco de dados. Obviamente, n√£o √© pr√°tico dar nomes  a  todos  os  objetos  em  um  banco  de  dados grande, que inclui milhares de objetos, de modo que a maioria deles se torna persistente pelo uso do segundo mecanismo, chamado acessibilidade . O mecanismo de acessibilidade funciona tornando o objeto alcan√ß√°vel a partir de algum outro objeto persistente. Um objeto B √© considerado alcan√ß√°vel com base no objeto A se uma sequ√™ncia de refer√™ncias no banco de dados levar do objeto A at√© o objeto B .

Se primeiro criarmos um  objeto  persistente nomeado N ,  cujo  estado  √©  um conjunto (ou  possivelmente uma bag )  de  objetos  de  alguma  classe C , podemos tornar objetos de C persistentes acrescentando-os ao conjunto, tornando-os assim alcan√ß√°veis de N . Logo, N √© um objeto nomeado que define uma cole√ß√£o persistente de objetos de classe C . No padr√£o do modelo de objeto, N √© chamado de extens√£o de C (ver Se√ß√£o 11.3).

Por exemplo, podemos definir uma classe SET\_ DEPARTAMENTO (ver Figura 11.3), cujos objetos s√£o do tipo set ( DEPARTAMENTO ). 14 Podemos criar um objeto  do  tipo SET\_DEPARTAMENTO ,  dando-lhe um  nome  persistente TODOS\_DEPARTAMENTOS , como mostra a Figura 11.3. Qualquer objeto DEPAR- define class SET\_DEPARTAMENTO

type set (DEPARTAMENTO);

operations adiciona\_dep(d: DEPARTAMENTO): boolean

;

(* acrescenta um departamento ao objeto SET\_DEPARTAMENTO *)

remove\_dep(d: DEPARTAMENTO): boolean ;

(* remove um departamento do objeto SET\_DEPARTAMENTO *)

criar\_set\_dep: SET\_DEPARTAMENTO;

destroi\_set\_dep: boolean ;

end SET\_DEPARTAMENTO;

...

persistent name TODOS\_DEPARTAMENTOS: SET\_DEPARTAMENTO; (* TODOS\_DEPARTAMENTOS √© um objeto persistente nomeado do tipo SET\_DEPARTA-MENTO *)

...

d:= cria\_dep;

(* cria um objeto DEPARTAMENTO na vari√°vel d *)

...

b:= TODOS\_DEPARTAMENTOS.adiciona\_dep(d);

(* torna d persistente incluindo-o no conjunto persistente TODOS\_DEPARTAMENTOS *)

Figura 11.3

Criando objetos persistentes por nomea√ß√£o e acessibilidade.

14 Como veremos na Se√ß√£o 11.3, a sintaxe ODL do ODMG usa set &lt;DEPARTAMENTO&gt; em vez de set (DEPARTAMENTO).

15 Alguns sistemas, como POET, criam automaticamente a extens√£o para uma classe.

TAMENTO que seja acrescentado ao conjunto de TO-DOS\_DEPARTAMENTOS usando  a  opera√ß√£o adicio-na\_dep torna-se persistente em virtude de estar sendo alcan√ß√°vel de TODOS\_DEPARTAMENTOS . Conforme veremos na Se√ß√£o 11.3, o padr√£o ODL do ODMG oferece ao projetista de esquema a op√ß√£o de nomear uma extens√£o como parte da defini√ß√£o da classe.

Observe a diferen√ßa entre os modelos de banco de dados tradicionais e os BDOs com rela√ß√£o a isso. Nos modelos de banco de dados tradicionais, como o modelo relacional, todos os objetos s√£o considerados persistentes.  Logo,  quando  uma  tabela  como FUNCIONARIO √© criada em um banco de dados relacional, ela representa tanto a declara√ß√£o de tipo para FUNCIONARIO quanto um conjunto persistente de todos os  registros  (tuplas)  de FUNCIONARIO .  Na  abordagem OO, uma declara√ß√£o de classe de FUNCIONARIO especifica apenas o tipo e as opera√ß√µes para uma classe de objetos. O usu√°rio precisa definir separadamente um objeto persistente do tipo set( FUNCIONARIO ) ou  bag( FUNCIONARIO ),  cujo  valor  √©  a cole√ß√£o  de refer√™ncias (OIDs) a todos os objetos FUNCIONARIO persistentes, se isso for desejado, conforme mostra a Figura 11.3. 15 Isso permite que objetos transientes e persistentes sigam as mesmas declara√ß√µes de tipo e classe da ODL e da LPOO. Em geral, √© poss√≠vel definir v√°rias cole√ß√µes persistentes para a mesma defini√ß√£o de classe, caso seja desejado.

## 11.1.5 Hierarquias de tipo e heran√ßa

Modelo simplificado para heran√ßa . Outra caracter√≠stica principal dos BDOs √© que eles permitem hierarquias de tipo e heran√ßa. Usamos um modelo OO simples nesta se√ß√£o - um modelo em que os atributos e as opera√ß√µes s√£o tratados de maneira uniforme visto  que  tanto  atributos  quanto  opera√ß√µes  podem ser herdadas. Na Se√ß√£o 11.3, discutiremos o modelo de heran√ßa do padr√£o ODMG, que difere do modelo discutido aqui porque distingue entre dois tipos de heran√ßa . A heran√ßa permite a defini√ß√£o de novos tipos  com  base  em  outros  predefinidos,  levando  a uma hierarquia de tipo (ou classe ).

Um tipo  √©  definido  atribuindo-lhe  um  nome  e depois estabelecendo uma s√©rie de atributos (vari√°veis de inst√¢ncia) e opera√ß√µes (m√©todos) para ele. 16 No  modelo  simplificado  que  usamos  nesta  se√ß√£o, os atributos e opera√ß√µes s√£o chamados de fun√ß√µes , pois  os  primeiros  s√£o  semelhantes  a  fun√ß√µes  com zero  argumentos.  Um  nome  de  fun√ß√£o  pode  ser usado  para  se  referir  ao  valor  de  um  atributo  ou para se referir ao valor resultante de uma opera√ß√£o (m√©todo). Usamos o termo fun√ß√£o para nos referirmos a atributos   opera√ß√µes, pois eles s√£o tratados de modo e semelhante em uma introdu√ß√£o b√°sica √† heran√ßa. 17

Um tipo, em sua forma mais simples, tem um nome de tipo e uma lista de fun√ß√µes vis√≠veis ( p√∫blicas ).  Ao  especificar  um  tipo  nesta  se√ß√£o,  usamos  o formato a seguir, que n√£o especifica argumentos de fun√ß√µes, para simplificar a discuss√£o:

NOME\_TIPO: fun√ß√£o, fun√ß√£o, ..., fun√ß√£o

Por exemplo, um tipo que descreve as caracter√≠sticas de uma PESSOA pode ser definido da seguinte forma:

PESSOA: Nome, Endereco, Data\_nascimento, Idade, Cpf

No tipo PESSOA ,  as  fun√ß√µes Nome , Endereco , Cpf e Data\_nascimento podem  ser  implementadas como atributos armazenados, enquanto a fun√ß√£o Idade pode ser implementada como uma opera√ß√£o que calcula a Idade do valor do atributo Data\_nascimento e a data atual.

FUNCIONARIO: Nome, Endereco, Data\_nascimento, Idade, Cpf, Salario, Data\_contratacao, Nivel

ALUNO: Nome, Endereco, Data\_nascimento, Idade, Cpf, Curso, Coeficiente

Visto  que  tanto ALUNO quanto FUNCIONARIO incluem  todas  as  fun√ß√µes  definidas  para PESSOA mais  algumas  fun√ß√µes  adicionais  pr√≥prias,  podemos declar√°-los subtipos de PESSOA . Cada um herdar√° as fun√ß√µes previamente definidas de PESSOA - a saber, Nome , Endereco , Data\_nascimento , Idade e Cpf .  Para ALUNO ,  s√≥ √© necess√°rio definir as novas fun√ß√µes (locais) Curso e Coeficiente , que n√£o s√£o herdadas. Presume-se que Curso possa ser definido como um atributo armazenado,  enquanto Coeficiente pode  ser  implementada como uma opera√ß√£o que calcula a m√©dia de pontos da nota do aluno ao acessar os valores de Nota que  s√£o  armazenados  internamente  (ocultos)  dentro de cada objeto ALUNO como atributos ocultos .  Para FUNCIONARIO ,  as  fun√ß√µes Salario e Data\_contratacao podem ser atributos armazenados, ao passo que Nivel pode ser uma opera√ß√£o que calcula Nivel de experiencia baseando-se no valor de Data\_contratacao .

Portanto,  podemos  declarar FUNCIONARIO e ALUNO da seguinte forma:

FUNCIONARIO subtype-of Data\_contratacao, Nivel

PESSOA: Salario,

ALUNO subtype-of PESSOA: Curso, Coeficiente

Em geral, um subtipo inclui todas as fun√ß√µes que s√£o definidas para seu supertipo mais algumas fun√ß√µes adicionais que s√£o espec√≠ficas apenas ao subtipo. Logo, √© poss√≠vel gerar uma hierarquia de tipos para mostrar os relacionamentos de supertipo/subtipo entre todos os tipos declarados no sistema.

Como  outro  exemplo,  considere  um  tipo  que descreve  objetos  na  geometria  plana,  e  que  podem ser definidos da seguinte forma:

GEOMETRIA\_OBJETO: Formato, Area, Ponto\_ referencia

O conceito de subtipo √© √∫til quando o projetista ou usu√°rio precisa criar um tipo que √© semelhante, mas n√£o id√™ntico, a um tipo j√° definido. O subtipo, ent√£o,  herda  todas  as  fun√ß√µes  do  tipo  predefinido, que √© conhecido como supertipo . Por exemplo, suponha que queiramos definir dois novos tipos FUNCIONARIO e ALUNO da seguinte forma:

Para  o  tipo GEOMETRIA\_OBJETO , Formato √© implementado como um atributo (seu dom√≠nio pode ser um tipo enumerado com valores 'triangulo', 'retangulo', 'circulo', e assim por diante), e Area √© um m√©todo aplicado para calcular a √°rea. Ponto\_referen-cia especifica as coordenadas de um ponto que determina a localiza√ß√£o do objeto. Agora, suponha que queiramos definir uma s√©rie de subtipos para o tipo GEOMETRIA\_OBJETO , da seguinte forma:

16 Nesta se√ß√£o, usaremos os termos tipo e classe para indicar a mesma coisa - a saber, os atributos e opera√ß√µes de algum tipo de objeto.

17 Veremos, na Se√ß√£o 11.3, que os tipos com fun√ß√µes s√£o semelhantes ao conceito de interfaces usado na ODL do ODMG.

RETANGULO subtype-of GEOMETRIA\_OBJETO: Largura, Altura

TRIANGULO subtype-of Lado1, Lado2, Angulo

GEOMETRIA\_OBJETO:

CIRCULO subtype-of GEOMETRIA\_OBJETO: Raio

Observe  que  a  opera√ß√£o Area pode  ser  implementada por um m√©todo diferente para cada subtipo, pois  o  procedimento  para  c√°lculo  de  √°rea  √©  distinto  para  ret√¢ngulos,  tri√¢ngulos  e  c√≠rculos.  De  modo semelhante, o atributo Ponto\_referencia pode ter um significado diferente para cada subtipo; ele poderia ser o ponto central para objetos RETANGULO e CIRCULO , e o ponto de v√©rtice entre os dois lados dados para um objeto TRIANGULO .

Observe que as defini√ß√µes de tipo descrevem objetos, mas n√£o geram objetos por si s√≥s. Quando um objeto √© criado, em geral ele pertence a um ou mais desses tipos que foram declarados. Por exemplo, um objeto c√≠rculo √© do tipo CIRCULO e GEOMETRIA\_OB-JETO (por  heran√ßa).  Cada  objeto  tamb√©m se torna um membro de uma ou mais cole√ß√µes persistentes de objetos (ou extens√µes), que s√£o usadas para agrupar cole√ß√µes de objetos que s√£o armazenadas persistentemente no banco de dados.

Restri√ß√µes  sobre  extens√µes  correspondentes  a  uma hierarquia  de  tipos . Na  maioria  dos  BDOs,  uma extens√£o √© definida para armazenar a cole√ß√£o de objetos persistentes para cada tipo ou subtipo. Nesse caso, a restri√ß√£o √© que todo objeto em uma extens√£o que corresponda a um subtipo tamb√©m deve ser um membro da extens√£o que  corresponde a seu supertipo. Alguns sistemas de banco de dados OO t√™m um tipo de sistema predefinido (chamado de classe ROOT ou classe OBJETO ), cuja extens√£o cont√©m todos os objetos do sistema. 18

A classifica√ß√£o, ent√£o, prossegue atribuindo objetos  a  subtipos  adicionais  que  s√£o  significativos  √† aplica√ß√£o, criando uma hierarquia de tipos (ou hierarquia de classes )  para o sistema. Todas as extens√µes para classes definidas pelo sistema e pelo usu√°rio s√£o subconjuntos da extens√£o correspondente √† classe OBJETO , direta ou indiretamente. No modelo ODMG (ver Se√ß√£o 11.3), o usu√°rio pode ou n√£o especificar  uma  extens√£o  para  cada  classe  (tipo),  dependendo da aplica√ß√£o.

Uma extens√£o √© um objeto persistente  nomeado  cujo  valor  √©  uma cole√ß√£o  persistente que  mant√©m uma cole√ß√£o de objetos do mesmo tipo que, por sua vez, s√£o armazenados permanentemente no banco de dados. Os objetos podem ser acessados e com- partilhados por v√°rios programas. Tamb√©m √© poss√≠vel criar uma cole√ß√£o transiente , que existe por certo tempo durante a execu√ß√£o de um programa, mas n√£o √©  mantida quando este termina. Por exemplo, uma cole√ß√£o transiente pode ser criada em um programa para manter o resultado de uma consulta que seleciona alguns objetos de uma cole√ß√£o persistente e os copia para a cole√ß√£o transiente. O programa pode, ent√£o, manipular os objetos na cole√ß√£o transiente e, quando  o  programa  terminar,  a  cole√ß√£o  transiente deixa de existir. Em geral, diversas cole√ß√µes - transientes  ou  persistentes  -  podem  conter  objetos  do mesmo tipo.

O  modelo  de  heran√ßa  discutido  nesta  se√ß√£o  √© muito simples. Conforme veremos na Se√ß√£o 11.3, o modelo ODMG distingue a heran√ßa de tipo - chamada de heran√ßa de interface e indicada por um sinal de dois pontos (:) - da restri√ß√£o de heran√ßa de extens√£o , indicada pela palavra-chave EXTEND .

## 11.1.6 Outros conceitos de orienta√ß√£o a objeto

## Polimorfismo de opera√ß√µes (sobrecarga de operador) .

Outra caracter√≠stica dos sistemas OO em geral √© que eles oferecem o polimorfismo de opera√ß√µes, conhecido tamb√©m como sobrecarga de operador . Esse conceito permite que o mesmo nome de operador ou s√≠mbolo esteja ligado a duas ou mais implementa√ß√µes diferentes do operador, dependendo do tipo de objetos aos quais o operador √© aplicado. Um exemplo simples das linguagens de programa√ß√£o pode ilustrar esse conceito. Em algumas linguagens, o s√≠mbolo de operador '+' pode significar coisas distintas quando aplicado a operandos (objetos) de tipos diferentes. Se os operandos de '+' forem do tipo inteiro , a opera√ß√£o chamada √© a adi√ß√£o de inteiros; se forem do tipo ponto flutuante , a opera√ß√£o chamada √© a adi√ß√£o de ponto flutuante; e se forem do tipo set , a opera√ß√£o chamada √© a uni√£o de conjunto. O compilador pode determinar qual opera√ß√£o executar com base nos tipos dos operandos fornecidos.

Em bancos de dados OO, pode ocorrer uma situa√ß√£o semelhante. Podemos usar o exemplo GEO-METRIA\_OBJETO da Se√ß√£o 11.1.5 para ilustrar o polimorfismo de opera√ß√µes 19  no BDO.

Nesse exemplo, a fun√ß√£o Area √© declarada para todos os objetos do tipo GEOMETRIA\_OBJETO .  No entanto, a implementa√ß√£o do m√©todo para Area pode ser diferente para cada subtipo de GEOMETRIA\_OBJE-TO . Uma possibilidade √© ter uma implementa√ß√£o geral

18 Isso √© chamado de OBJETO no modelo ODMG (ver Se√ß√£o 11.3).

19 Em linguagens de programa√ß√£o h√° diversos tipos de polimorfismo. O leitor interessado deve consultar a bibliografia selecionada ao final deste cap√≠tulo, os trabalhos que incluem uma discuss√£o mais aprofundada.

para calcular a √°rea de GEOMETRIA\_OBJETO generalizado (por exemplo, ao escrever um algoritmo geral para calcular a √°rea de um pol√≠gono) e depois para reescrever algoritmos mais eficientes para calcular as √°reas de tipos espec√≠ficos de objetos geom√©tricos, como um c√≠rculo, um ret√¢ngulo, um tri√¢n  gulo, e assim por diante. Nesse caso, a fun√ß√£o Area √© sobrecarregada por diferentes implementa√ß√µes.

O SGDO agora precisa selecionar o m√©todo apropriado para a fun√ß√£o Area com base no tipo de objeto geom√©trico ao qual ele √© aplicado. Em sistemas fortemente tipados, isso pode ser feito em tempo √† compila√ß√£o, pois os tipos de objeto precisam ser conhecidos. Isso  √©  chamado de v√≠nculo antecipado (ou est√°tico ). Por√©m, em sistemas com tipagem fraca ou sem tipagem (como Smalltalk e LISP), o tipo do objeto ao qual uma fun√ß√£o √© aplicada pode n√£o ser conhecido antes da execu√ß√£o. Nesse caso, a fun√ß√£o precisa verificar o tipo  do  objeto  durante  a  execu√ß√£o  e  depois  chamar o m√©todo apropriado. Isso normalmente √© conhecido como v√≠nculo tardio (ou din√¢mico ).

Heran√ßa m√∫ltipla e heran√ßa seletiva . A heran√ßa m√∫ltipla ocorre quando certo subtipo T √© um subtipo de dois  (ou  mais)  tipos  e,  portanto,  herda  as  fun√ß√µes (atributos e m√©todos) dos dois supertipos. Por exemplo, podemos criar um subtipo GERENTE\_ENGENHEI-RO, que √© um subtipo tanto de GERENTE quanto de ENGENHEIRO . Isso leva √† cria√ß√£o de um reticulado de tipos , em vez de uma hierarquia deles. Um problema que pode ocorrer com a heran√ßa m√∫ltipla √© que os supertipos dos quais o subtipo herda podem ter fun√ß√µes distintas do mesmo nome, criando uma ambiguidade. Por exemplo, tanto GERENTE quanto ENGENHEIRO podem ter uma fun√ß√£o chamada Salario . Se a fun√ß√£o Salario for implementada por diferentes m√©todos nos supertipos GERENTE e ENGENHEIRO , existe uma ambiguidade quanto a qual dos dois √© herdado pelo subtipo GERENTE\_ENGENHEIRO. Contudo, √© poss√≠vel que tanto ENGENHEIRO quanto GERENTE herdem Salario do mesmo supertipo (como FUNCIONARIO) mais acima no reticulado. A regra geral √© que, se uma fun√ß√£o √© herdada de algum supertipo comum , ent√£o ela √© herdada apenas uma vez. Nesse caso, n√£o existe ambiguidade; o problema s√≥ aparece se as fun√ß√µes forem distintas nos dois supertipos.

permitir a heran√ßa m√∫ltipla completamente se houver ambiguidade de nomes, em vez de for√ßar o usu√°rio a mudar o nome de uma das fun√ß√µes em um dos supertipos.  Na  realidade,  alguns  sistemas  OO  n√£o permitem  heran√ßa  m√∫ltipla  alguma.  No  padr√£o  de banco de dados de objeto (ver Se√ß√£o 11.3), a heran√ßa m√∫ltipla √© permitida para a opera√ß√£o das interfaces, mas n√£o para a heran√ßa EXTENDS de classes.

A heran√ßa  seletiva ocorre  quando  um  subtipo herda apenas algumas das fun√ß√µes de um supertipo. Outras  fun√ß√µes  n√£o  s√£o  herdadas.  Nesse  caso,  uma cl√°usula EXCEPT pode ser usada para listar as fun√ß√µes em um supertipo que n√£o devem ser  herdadas  pelo subtipo. O mecanismo de heran√ßa seletiva n√£o costuma ser fornecido nos BDOs, mas √© usado com mais frequ√™ncia nas aplica√ß√µes de intelig√™ncia artificial. 20

## 11.1.7 Resumo dos conceitos de banco de dados de objeto

Para concluir esta se√ß√£o, oferecemos um resumo dos principais conceitos usados nos BDOs e sistemas objeto-relacional:

- ¬Ñ Identidade  de  objeto. Os  objetos  possuem identidades  √∫nicas,  que  s√£o  independentes de  seus  valores  de  atributo  e  geradas  pelo SGDO.
- ¬Ñ Construtores  de  tipos. Estruturas  de  objeto complexas  podem  ser  constru√≠das  ao  aplicar  de  uma  maneira aninhada um conjunto de construtores b√°sicos, como tuple, set, list, array e bag.
- ¬Ñ Encapsulamento de opera√ß√µes. Tanto a estrutura do objeto quanto as opera√ß√µes que podem ser aplicadas aos objetos individuais s√£o inclu√≠das nas defini√ß√µes de tipo.
- ¬Ñ Compatibilidade  da  linguagem  de  programa√ß√£o. Objetos persistentes e transientes s√£o tratados de maneira transparente. Os objetos se  tornam  persistentes  ao  serem  alcan√ß√°veis de uma cole√ß√£o persistente (extens√£o) ou pela nomea√ß√£o expl√≠cita.

Existem v√°rias t√©cnicas para lidar com a ambiguidade  na  heran√ßa  m√∫ltipla.  Uma  solu√ß√£o  √©  fazer que  o  sistema  verifique  a  ambiguidade  quando  o subtipo  for  criado,  e  deixar  que  o  usu√°rio  escolha explicitamente  qual  fun√ß√£o  deve  ser  herdada  nesse momento. Uma segunda solu√ß√£o √© usar alguma padroniza√ß√£o do sistema. Uma terceira solu√ß√£o √© n√£o

- ¬Ñ Hierarquias de tipos e heran√ßa. Os tipos de objetos podem ser especificados usando uma hierarquia  de  tipos,  que  permite  a  heran√ßa de atributos e m√©todos (opera√ß√µes) de tipos previamente definidos. A heran√ßa m√∫ltipla √© permitida em alguns modelos.
- ¬Ñ Extens√µes. Todos  os  objetos  persistentes  de determinado tipo podem ser armazenados em

20 No modelo ODMG, a heran√ßa de tipos refere-se apenas √† heran√ßa de opera√ß√µes, e n√£o de atributos (ver Se√ß√£o 11.3).

- uma extens√£o. As extens√µes correspondentes a uma hierarquia de tipo possuem restri√ß√µes de conjunto/subconjunto em suas cole√ß√µes de objetos persistentes.
- ¬Ñ Polimorfismo  e  sobrecarga  de  operador. As opera√ß√µes  e  nomes  de  m√©todo  podem  ser sobrecarregadas para que se apliquem a diferentes tipos de objeto com diversas implementa√ß√µes.

Nas se√ß√µes a seguir, mostramos como esses conceitos s√£o realizados no padr√£o SQL (Se√ß√£o 11.2) e no padr√£o ODMG (Se√ß√£o 11.3).

## 11.2 Recursos objeto-relacional: extens√µes do banco de dados de objeto para SQL

Apresentamos a SQL como a linguagem-padr√£o para SGBDRs nos cap√≠tulos 4 e 5. Conforme discutimos, a SQL foi especificada inicialmente por Chamberlin e Boyce (1974) e passou por melhorias e padroniza√ß√£o em 1989 e 1992. A linguagem continuou sua  evolu√ß√£o  com  um  novo  padr√£o,  inicialmente chamado SQL3 enquanto estava sendo desenvolvido, e mais tarde ficou conhecido como SQL:99 para as partes da SQL3 que foram aprovadas no padr√£o. Come√ßando com a vers√£o da SQL conhecida como SQL3, recursos dos bancos de dados de objeto foram incorporados ao padr√£o SQL. A princ√≠pio, essas extens√µes foram conhecidas como SQL/Object, mas depois foram incorporadas na parte principal da SQL, conhecida como SQL/Foundation. Usaremos esse padr√£o mais recente, SQL:2008, em nossa apresenta√ß√£o dos recursos de objeto da SQL, embora isso possa ainda n√£o ter sido realizado nos SGBDs comerciais que seguem a SQL. Tamb√©m discutiremos como os recursos de objeto da SQL evolu√≠ram at√© sua manifesta√ß√£o mais recente na SQL:2008.

O modelo relacional com melhorias de banco de dados de objeto √†s vezes √© conhecido como modelo objeto-relacional . Revis√µes adicionais foram feitas √† SQL em 2003 e 2006 para acrescentar recursos relacionados √† XML (ver Cap√≠tulo 12).

A seguir est√£o alguns dos recursos do banco de dados de objeto que foram inclu√≠dos na SQL:

- ¬Ñ Alguns construtores de tipo foram acrescentados para especificar objetos complexos. Estes incluem o tipo de linha , que corresponde ao construtor de tupla (ou struct). Um tipo de array para especificar cole√ß√µes tamb√©m √© fornecido. Outros construtores de tipo de cole√ß√£o, como set , list e bag , n√£o fizeram parte
- das especifica√ß√µes SQL/Object originais, mas foram inclu√≠dos mais tarde ao padr√£o.
- ¬Ñ Foi inclu√≠do um mecanismo para especificar a identidade de objeto por meio do uso de tipo de refer√™ncia .
- ¬Ñ O encapsulamento de opera√ß√µes √© fornecido por  meio  do  mecanismo  de tipos  definidos pelo usu√°rio ( UDTs -User-Defined Types ), que podem incluir opera√ß√µes como parte de sua  declara√ß√£o.  Estes  s√£o  um  pouco  semelhantes ao conceito de tipos de dados abstratos , que foram desenvolvidos nas linguagens de  programa√ß√£o. Al√©m disso, o conceito de rotinas definidas pelo usu√°rio ( UDRs -User-Defined  Routines )  permite  a  defini√ß√£o de m√©todos (opera√ß√µes) gerais.
- ¬Ñ Mecanismos de heran√ßa s√£o fornecidos usando a palavra-chave UNDER.

Agora, vamos discutir cada um desses conceitos com mais detalhes. Em nossa discuss√£o, vamos nos referir ao exemplo da Figura 11.4.

## 11.2.1 Tipos definidos pelo usu√°rio e estruturas complexas para objetos

Para permitir a cria√ß√£o de objetos estruturados complexos, e para separar a declara√ß√£o de um tipo da cria√ß√£o de uma tabela, a SQL agora oferece tipos definidos  pelo  usu√°rio ( UDTs ).  Al√©m  disso,  quatro tipos de cole√ß√£o foram inclu√≠dos para permitir tipos e atributos multivalorados, a fim de especificar objetos com estruturas complexas, em vez de apenas registros simples (planos). O usu√°rio criar√° os UDTs para determinada  aplica√ß√£o  como  parte  do  esquema  do banco de dados. Um UDT pode ser especificado em sua forma mais simples usando a seguinte sintaxe:

## CREATE TYPE NOME\_TIPO AS

(&lt;declara√ß√µes de componentes&gt;);

A Figura 11.4 ilustra alguns dos conceitos de objeto na SQL. Explicaremos os exemplos dessa figura gradualmente, √† medida que explicarmos os conceitos.  Primeiro,  um  UDT  pode  ser  usado  como  tipo para um atributo ou como tipo para uma tabela. Ao usar um UDT como tipo para um atributo dentro de outro UDT, podemos criar uma estrutura complexa para  objetos  (tuplas)  em  uma  tabela,  como  aquela obtida  pelo  aninhamento  de  construtores  de  tipos. Isso √© semelhante a usar o construtor de tipo struct da Se√ß√£o 11.1.3. Por exemplo, na Figura 11.4(a), o UDT TIPO\_END\_RUA √©  utilizado  como  tipo  para o atributo END\_RUA no UDT TIPO\_END\_BRASIL. De modo  semelhante,  o  UDT TIPO\_END\_BRASIL, por sua vez, √© usado como tipo para o atributo END no

## (a)  CREATE TYPE TIPO\_END\_RUA AS (

NUMERO

VARCHAR (5),

NOME\_RUA

VARCHAR (25),

NR\_APTO

VARCHAR (5),

NR\_BLOCO

VARCHAR (5)

);

## CREATE TYPE TIPO\_END\_BRASIL AS (

END\_RUA

TIPO\_END\_RUA,

CIDADE

VARCHAR (25),

CEP

VARCHAR (10)

);

## CREATE TYPE TIPO\_TELEFONE\_BRASIL AS (

TIPO\_TELEFONE

VARCHAR (5),

CODIGO\_AREA

CHAR (3),

NUM\_TELEFONE

CHAR (7)

);

## (b)  CREATE TYPE TIPO\_PESSOA AS (

NOME

VARCHAR (35),

SEXO

CHAR,

DATA\_NASCIMENTO

DATE,

TELEFONES

TIPO\_TELEFONE\_BRASIL ARRAY [4],

END

TIPO\_END\_BRASIL

## INSTANTIABLE

NOT FINAL

## REF IS SYSTEM GENERATED

INSTANCE METHOD IDADE( ) RETURNS INTEGER;

## CREATE INSTANCE METHOD IDADE( ) RETURNS INTEGER

FOR TIPO\_PESSOA

BEGIN

RETURN /* C√ìDIGO PARA CALCULAR A IDADE DE UMA PESSOA COM BASE NA DATA DE HOJE E SUA DATA\_NASCIMENTO */

END ;

);

## (c)  CREATE TYPE TIPO\_NOTA AS (

DISCIPLINA

CHAR (8),

SEMESTRE

ANO

NOTA

VARCHAR (8),

CHAR (4),

CHAR

);

## CREATE TYPE TIPO\_ALUNO UNDER TIPO\_PESSOA AS (

CODIGO\_CURSO

CHAR (4),

COD\_ALUNO

CHAR (12),

GRAU

VARCHAR (5),

HISTORICO\_ESCOLAR

TIPO\_NOTA ARRAY [100]

## Figura 11.4

( continua )

INSTANTIABLE

NOT FINAL

INSTANCE METHOD COEFICIENTE( ) RETURNS FLOAT;

CREATE INSTANCE METHOD COEFICIENTE( ) RETURNS FLOAT

FOR TIPO\_ALUNO

BEGIN

RETURN /* C√ìDIGO PARA CALCULAR COEFICIENTE MEDIO DE UM ALUNO COM BASE EM SEU HISTORICO ESCOLAR */

END ;

);

CREATE TYPE TIPO\_FUNCIONARIO UNDER TIPO\_PESSOA AS (

CODIGO\_EMPREGO

CHAR (4),

SALARIO

FLOAT,

CPF

CHAR (11)

INSTANTIABLE

NOT FINAL

);

CREATE TYPE TIPO\_GERENTE UNDER TIPO\_FUNCIONARIO AS (

DEP\_GERENCIADO

CHAR (20)

INSTANTIABLE

);

## (d)  CREATE TABLE PESSOA OF TIPO\_PESSOA

REF IS ID\_PESSOA SYSTEM GENERATED;

CREATE TABLE FUNCIONARIO OF TIPO\_FUNCIONARIO

UNDER PESSOA;

CREATE TABLE GERENTE OF TIPO\_GERENTE

UNDER FUNCIONARIO;

CREATE TABLE ALUNO OF TIPO\_ALUNO

UNDER PESSOA;

## (e)  CREATE TYPE TIPO\_EMPRESA AS (

NOME\_EMP

VARCHAR (20),

LOCALIZACAO

VARCHAR (20));

CREATE TYPE TIPO\_EMPREGO AS (

Funcionario REF (TIPO\_FUNCIONARIO) SCOPE (FUNCIONARIO),

Empresa REF (TIPO\_EMPRESA) SCOPE (EMPRESA) );

CREATE TABLE EMPRESA OF TIPO\_EMPRESA (

REF IS COD\_EMP SYSTEM GENERATED,

PRIMARY KEY (NOME\_EMP) );

CREATE TABLE EMPREGO OF TIPO\_EMPREGO;

## Figura 11.4 (continua√ß√£o)

Ilustrando alguns dos recursos de objeto da SQL. (c) (continua√ß√£o) Especificando UDTs para TIPO\_ALUNO e TIPO\_ FUNCIONARIO como dois subtipos de TIPO\_PESSOA. (d) Criando tabelas com base em alguns dos UDTs, e ilustrando a heran√ßa de tabela. (e) Especificando relacionamentos com REF e SCOPE.

UDT TIPO\_PESSOA da Figura 11.4(b). Se um UDT n√£o tiver nenhuma opera√ß√£o, como nos exemplos da Figura 11.4(a),  √©  poss√≠vel  usar  o  conceito  de ROW TYPE para criar diretamente um atributo estruturado usando a palavra-chave ROW . Por exemplo, poder√≠amos usar o seguinte em vez de declarar TIPO\_ END\_RUA como um tipo separado, como na Figura 11.4(a):

| CREATE TYPE END_RUA   | TIPO_END_BRASIL ROW ( NUMERO   | AS ( VARCHAR (5),   |
|-----------------------|--------------------------------|---------------------|
| CIDADE                | VARCHAR (25), VARCHAR (10)     |                     |
| CEP                   |                                |                     |

Para permitir tipos de cole√ß√£o a fim de criar objetos  estruturados  complexos,  quatro  construtores agora  est√£o  inclu√≠dos  na  SQL: ARRAY, MULTISET, LIST   SET. e Estes s√£o semelhantes aos construtores de tipo discutidos na Se√ß√£o 11.1.3. Na especifica√ß√£o inicial da SQL/Object, apenas o tipo ARRAY foi estabelecido, pois ele pode ser usado para simular os outros tipos, mas os tr√™s tipos de cole√ß√£o adicionais foram inclu√≠dos na vers√£o mais recente do padr√£o SQL. Na Figura 11.4(b), o atributo TELEFONES de TIPO\_PES-SOA tem como tipo um array cujos elementos s√£o do UDT  previamente  definido TIPO\_TELEFONE\_BRA-SIL. Esse  array  tem um m√°ximo de quatro elementos, significando que podemos armazenar at√© quatro n√∫meros de telefone por pessoa. Um array tamb√©m pode n√£o ter um n√∫mero m√°ximo de elementos, se isso for desejado.

Um tipo de array pode ter seus elementos referenciados  usando  a  nota√ß√£o  comum  dos  colchetes. Por  exemplo, TELEFONES[1] refere-se  ao  valor  do primeiro local em um atributo TELEFONES (ver  Figura 11.4(b)). Uma fun√ß√£o embutida CARDINALITY pode retornar o n√∫mero atual de elementos em um array (ou qualquer outro tipo de cole√ß√£o). Por exemplo, TELEFONES[ CARDINALITY ( TELEFONES) ]  refere-se ao √∫ltimo elemento no array.

A nota√ß√£o de ponto comumente utilizada serve para se  referir  aos  componentes de um ROW TYPE ou um UDT. Por exemplo, END.CIDADE refere-se  ao  componente CIDADE de um atributo END (ver Figura 11.4(b)).

## 11.2.2 dentificadores de objeto usando I tipos de refer√™ncia

Identificadores  de  objeto  gerados  pelo  sistema podem ser criados por meio do tipo de refer√™ncia na vers√£o mais recente da SQL. Por exemplo, na Figura 11.4(b), a frase:

## REF IS SYSTEM GENERATED

indica que, sempre que um objeto TIPO\_PESSOA for criado, o sistema lhe atribuir√° um identificador √∫nico, gerado pelo sistema. Tamb√©m √© poss√≠vel n√£o ter um identificador de objeto gerado pelo sistema e usar as chaves tradicionais do modelo relacional b√°sico, se isso for desejado.

Em geral, o usu√°rio pode especificar que devem ser criados  identificadores  de  objeto  gerados  pelo  sistema para linhas individuais em uma tabela. Ao usar a sintaxe:

<!-- formula-not-decoded -->

o usu√°rio declara que o atributo chamado &lt;OID\_ATRI-BUTO&gt; ser√° usado para identificar tuplas individuais na tabela. As op√ß√µes para &lt;METODO\_GERACAO\_VA-LOR&gt; s√£o SYSTEM  GENERATED ou DERIVED. No primeiro caso, o sistema gerar√° automaticamente um identificador √∫nico (exclusivo) para cada tupla. No segundo caso, √© aplicado o m√©todo tradicional de uso do valor  de  chave  prim√°ria  fornecido  pelo  usu√°rio para identificar as tuplas.

## 11.2.3 Criando tabelas baseadas nos UDTs

Para  cada  UDT  especificado  para  ser  instanci√°vel  por  meio  da  frase INSTANTIABLE (ver  Figura 11.4(b)),  uma  ou  mais  tabelas  podem  ser  criadas. Isso √© ilustrado na Figura 11.4(d), onde criamos uma tabela PESSOA com  base  no  UDT TIPO\_PESSOA . Observe que os UDTs da Figura 11.4(a) s√£o n√£o instanci√°veis e, portanto, s√≥ podem ser usados como tipos para atributos, e n√£o como base para a cria√ß√£o de tabela. Na Figura 11.4(d), o atributo ID\_PESSOA manter√° o identificador de objeto gerado pelo sistema sempre que um novo registro (objeto) PESSOA for criado e inserido na tabela.

## 11.2.4 Encapsulamento de opera√ß√µes

Em SQL, um tipo definido pelo usu√°rio pode ter a  pr√≥pria  especifica√ß√£o  comportamental  ao  definir m√©todos (ou opera√ß√µes) al√©m dos atributos. A forma geral  de  uma  especifica√ß√£o  UDT  com  m√©todos  √©  a seguinte:

CREATE TYPE &lt;NOME-TIPO&gt; (

&lt;LISTA DE ATRIBUTOS DE COMPONENTE E SEUS TIPOS&gt;

&lt;DECLARACAO DE FUNCOES (METODOS)&gt;

Por exemplo, na Figura 11.4(b), declaramos um m√©todo Idade( ) que calcula a idade de um objeto individual do tipo TIPO\_PESSOA.

O c√≥digo para implementar o m√©todo ainda precisa ser escrito. Podemos nos referir √† implementa√ß√£o do m√©todo especificando o arquivo que cont√©m o c√≥digo para o m√©todo, ou podemos escrever o c√≥digo real na pr√≥pria declara√ß√£o de tipo (ver Figura 11.4(b)).

A SQL oferece certas fun√ß√µes embutidas para os tipos definidos pelo usu√°rio. Para um UDT chamado TYPE\_T, a fun√ß√£o construtora TYPE\_T( ) retorna um novo objeto desse tipo. No novo objeto UDT, cada atributo √© inicializado para seu valor default.  Uma fun√ß√£o observadora A √©  criada  implicitamente para cada atributo A a fim de ler seu valor. Logo, A X ( ) ou X.A retorna o valor do atributo A de TYPE\_T se X √© do tipo TYPE\_T. Uma fun√ß√£o  alteradora  (mutator  function) para  atualizar um atributo define um novo valor para o atributo. A SQL permite que essas fun√ß√µes sejam bloqueadas contra uso p√∫blico. Um privil√©gio EXECUTE √© necess√°rio para se ter acesso a essas fun√ß√µes.

Em geral, um UDT pode ter uma s√©rie de fun√ß√µes  definidas  pelo  usu√°rio  associadas  a  ele.  A sintaxe √©

INSTANCE METHOD &lt;NOME&gt; (&lt;LISTA\_ARGUMENTOS&gt;) RETURNS

&lt;TIPO\_RETORNO&gt;;

Dois tipos de fun√ß√µes podem ser definidos: SQL interna  e  externa.  Fun√ß√µes  internas  s√£o  escritas  na linguagem PSM estendida de SQL (ver Cap√≠tulo 13). Fun√ß√µes  externas  s√£o  escritas  em  uma  linguagem hospedeira (host), com apenas sua assinatura (interface) aparecendo na defini√ß√£o do UDT. Uma defini√ß√£o de fun√ß√£o externa pode ser declarada da seguinte maneira:

DECLARE EXTERNAL &lt;NOME\_FUNCAO&gt; &lt;ASSINATURA&gt; LANGUAGE &lt;NOME\_ LINGUAGEM&gt;;

Atributos e fun√ß√µes nos UDTs s√£o divididos em tr√™s categorias:

- ¬Ñ PUBLIC (vis√≠veis na interface do UDT).
- ¬Ñ PRIVATE (n√£o vis√≠veis na interface do UDT).
- ¬Ñ PROTECTED (vis√≠veis apenas aos subtipos).

Tamb√©m  √©  poss√≠vel  definir  atributos  virtuais como parte dos UDTs, que s√£o calculados e atualizados usando fun√ß√µes.

## 11.2.5 Especificando heran√ßa e sobrecarga de fun√ß√µes

Lembre-se de que j√° discutimos muitos dos princ√≠pios  de  heran√ßa  na  Se√ß√£o  11.1.5.  A  SQL  tem  regras para lidar com heran√ßa de tipo (especificada por meio da palavra-chave UNDER ). Em geral, atributos e m√©todos (opera√ß√µes) de inst√¢ncia s√£o herdados. A frase NOT FINAL precisa ser inclu√≠da em um UDT se os subtipos puderem ser criados sob esse UDT (ver Figura 11.4(b) e (c), onde TIPO\_PESSOA, TIPO\_ALU-NO e TIPO\_FUNCIONARIO s√£o declarados como NOT FINAL) . Associadas √† heran√ßa de tipo est√£o as regras para  a  sobrecarga  de  implementa√ß√µes  de  fun√ß√£o e  para  resolu√ß√£o  de  nomes de fun√ß√£o. Essas regras de heran√ßa podem ser resumidas da seguinte forma:

- ¬Ñ Todos os atributos s√£o herdados.
- ¬Ñ A ordem dos supertipos na cl√°usula UNDER determina a hierarquia de heran√ßa.
- ¬Ñ Uma inst√¢ncia de um subtipo pode ser usada em cada contexto em que uma inst√¢ncia do supertipo √© utilizada.
- ¬Ñ Um subtipo pode redefinir qualquer fun√ß√£o que √© definida em seu supertipo, com a restri√ß√£o de que a assinatura seja a mesma.
- ¬Ñ Quando  uma  fun√ß√£o  √©  chamada,  a  melhor combina√ß√£o √© selecionada com base nos tipos de todos os argumentos.
- ¬Ñ Para a liga√ß√£o din√¢mica, a execu√ß√£o dos tipos de par√¢metros s√£o considerados.

Considere os seguintes exemplos para ilustrar a heran√ßa de tipo, que s√£o ilustrados na Figura 11.4(c). Suponha que queiramos criar dois subtipos de TIPO\_PES-SOA: TIPO\_FUNCIONARIO e TIPO\_ALUNO. Al√©m disso, tamb√©m criamos um subtipo TIPO\_GERENTE que herda todos os atributos (e m√©todos) de TIPO\_FUNCIONARIO , mas tem um atributo adicional DEP\_GERENCIADO. Esses subtipos s√£o mostrados na Figura 11.4(c).

Em  geral,  especificamos  os  atributos  locais  e quaisquer  m√©todos  espec√≠ficos  para  o  subtipo,  que herda os atributos e opera√ß√µes de seu supertipo.

Outra facilidade em SQL √© a heran√ßa de tabela por meio da facilidade de supertabela/subtabela. Isso tamb√©m √© especificado usando a palavra-chave UNDER (ver Figura 11.4(d)). Aqui, um novo registro que √© inserido em uma subtabela, digamos, a tabela GERENTE ,  tamb√©m √© inserido em suas supertabelas FUNCIONARIO e PESSOA. Observe que, quando um registro √© inserido em GERENTE ,  temos de oferecer valores para todos os seus atributos herdados. Opera√ß√µes INSERT, DELETE e UPDATE s√£o  propagadas corretamente.

## 11.2.6 Especificando relacionamentos por refer√™ncia

Um atributo componente de uma tupla pode ser uma refer√™ncia (especificada usando a palavra-chave REF ) a uma tupla de outra tabela (ou possivelmente a mesma). Um exemplo √© mostrado na Figura 11.4(e).

A  palavra-chave SCOPE especifica  o  nome  da tabela cujas tuplas podem ser referenciadas pelo atributo de refer√™ncia. Observe que isso √© semelhante a uma  chave  estrangeira,  exceto  que  o  valor  gerado pelo sistema √© usado, em vez do valor da chave prim√°ria.

A SQL usa uma nota√ß√£o de ponto para montar express√µes de caminho que  se  referem  aos  atributos componentes de tuplas e tipos de linha. Por√©m, para um atributo cujo tipo √© REF, o s√≠mbolo de desrefer√™ncia -&gt; √© utilizado. Por exemplo, a consulta a seguir recupera os funcion√°rios que trabalham na empresa chamada 'ABCXYZ' consultando a tabela EMPREGO :

SELECT F. Funcionario-&gt;NOME

FROM EMPREGO AS E

WHERE E. Empresa-&gt;NOME\_EMP = 'ABCXYZ';

Em SQL, -&gt; √© usado para desreferenciar e tem o mesmo significado atribu√≠do a ele na linguagem de programa√ß√£o C. Assim, se   √© uma refer√™ncia a uma r tupla e a √© um atributo componente nela, ent√£o r -&gt; a √© o valor do atributo a nessa tupla.

Se existirem v√°rias rela√ß√µes do mesmo tipo, a SQL oferece a palavra-chave SCOPE, pela qual um atributo de  refer√™ncia  pode  ser  feito  para  apontar  para  uma tupla dentro de uma tabela espec√≠fica daquele tipo.

## 11.3 O modelo de objeto ODMG e a Object Definition Language (ODL)

partes, incluindo o modelo de objeto , a Object Definition  Language ( ODL ),  a Object Query Language ( OQL ) e os bindings com as linguagens de programa√ß√£o orientadas a objeto.

Nesta se√ß√£o, vamos descrever o modelo de objeto ODMG e a ODL. Na Se√ß√£o 11.4, discutimos como projetar um BDO com base em um esquema conceitual EER. Mostraremos uma vis√£o geral da OQL na Se√ß√£o 11.5 e o v√≠nculo da linguagem C++ na Se√ß√£o 11.6. Alguns exemplos de como usar ODL, OQL e o binding da linguagem C++ utilizar√£o o exemplo de banco de dados UNIVERSIDADE introduzido  no  Cap√≠tulo  8.  Em  nossa descri√ß√£o, seguiremos o modelo de objeto ODMG 3.0, conforme descrito em Cattell et al. (2000). 21 √â importante observar que muitas das ideias incorporadas no modelo de objeto ODMG s√£o baseadas em duas d√©cadas de pesquisa em modelagem conceitual e bancos de dados de objeto por muitos pesquisadores.

A incorpora√ß√£o de conceitos de objeto no padr√£o de banco de dados relacional SQL, levando √† tecnologia objeto-relacional, foi apresentada na Se√ß√£o 11.2.

## 11.3.1 Vis√£o geral do modelo de objeto do ODMG

O modelo de objeto ODMG √© o modelo de dados no qual a linguagem de defini√ß√£o de objeto (ODL) e a linguagem de consulta de objeto (OQL) s√£o baseadas.  Ele  serve  para  oferecer  um  modelo  de  dados padr√£o para os bancos de dados de objeto, assim como a  SQL  descreve  um  modelo  de  dados  padr√£o  para bancos  de  dados  relacionais.  Ele  tamb√©m  oferece uma  terminologia  padr√£o  em  um  campo  onde  os mesmos termos √†s vezes eram usados para descrever diferentes conceitos. Tentaremos aderir √† terminologia ODMG neste cap√≠tulo. Muitos dos conceitos no modelo ODMG j√° foram discutidos na Se√ß√£o 11.1, e consideramos que o leitor leu essa se√ß√£o. Faremos a  indica√ß√£o  sempre  que  a  terminologia  do  ODMG diferir daquela usada na Se√ß√£o 11.1.

Conforme discutimos na introdu√ß√£o ao Cap√≠tulo 4, um dos motivos para o sucesso dos SGBDs relacionais √© o padr√£o SQL. A falta de um padr√£o para os SGDOs por v√°rios anos pode ter evitado que alguns usu√°rios em potencial convertessem para a nova tecnologia. Subsequentemente, um cons√≥rcio de vendedores e usu√°rios de SGDO, chamado ODMG ( Object  Data  Management Group ),  prop√¥s  um padr√£o conhecido como padr√£o ODMG-93 ou ODMG 1.0. Este foi revisado para o ODMG 2.0 e, mais tarde, para o ODMG 3.0. O padr√£o √© composto de v√°rias

Objetos e literais . Objetos e literais s√£o os blocos b√°sicos de montagem do modelo de objeto. A principal diferen√ßa entre os dois √© que um objeto tem um identificador de objeto e um estado (ou valor atual), enquanto um literal tem um valor (estado), mas nenhum identificador de objeto . 22 Nos dois casos, o valor pode ter uma estrutura complexa. O estado do objeto pode mudar com o tempo, modificando seu valor. Um literal √© basicamente um valor constante, com possibilidade de ter uma estrutura complexa, no entanto ele n√£o muda.

Um objeto tem  cinco  aspectos:  identificador, nome, tempo de vida, estrutura e cria√ß√£o.

21 As vers√µes mais antigas do modelo de objeto foram publicadas em 1993 e 1997.

22 Usaremos os termos valor e estado para indicar a mesma coisa aqui.

- 1. O identificador do objeto √©  um  identificador √∫nico de todo o sistema (ou Object\_id ). 23 Todo objeto precisa ter um identificador de objeto.
- 2. Alguns objetos podem opcionalmente receber um nome √∫nico dentro de um SGDO em particular - esse nome pode ser usado para localizar o objeto, e o sistema deve retornar o objeto que recebeu tal nome. 24 Obviamente, nem todos os objetos individuais possuem nomes exclusivos. Com frequ√™ncia, alguns objetos, principalmente aqueles que mant√™m cole√ß√µes de objetos de um tipo de objeto em particular - como extens√µes -, ter√£o um nome. Esses nomes s√£o utilizados como pontos de entrada para o banco de dados; ou seja, ao localizar esses objetos por seu nome √∫nico, o usu√°rio pode ent√£o localizar outros objetos que s√£o referenciados com base nesses.  Outros  objetos  importantes  na  aplica√ß√£o tamb√©m podem ter nomes exclusivos, e √© poss√≠vel  dar  mais  de  um  nome  a  um  objeto. Todos os nomes em um SGDO em particular precisam ser exclusivos.
- 3. O tempo de vida de um objeto especifica se ele √© um objeto persistente (ou seja, um objeto do banco de dados) ou um objeto transiente (ou seja, um objeto em um programa em execu√ß√£o, que desaparece ap√≥s o t√©rmino do programa). Os tempos de vida s√£o independentes dos tipos - ou seja, alguns objetos de um tipo em particular podem ser transientes, enquanto outros podem ser persistentes.
- 4. A estrutura de um objeto especifica como ele √© moldado usando os construtores de tipo. A estrutura  especifica  se  um  objeto  √© at√¥mico ou  n√£o.  Um objeto  at√¥mico refere-se  a  um √∫nico objeto que segue um tipo definido pelo usu√°rio, como Funcionario ou Departamento. Se um objeto n√£o √© at√¥mico, ent√£o ele ser√° composto  de  outros  objetos.  Por  exemplo, um objeto de cole√ß√£o n√£o √© um objeto at√¥mico,  pois  seu  estado  ser√°  uma  cole√ß√£o  de outros  objetos. 25 O  termo objeto  at√¥mico √© diferente de como definimos o construtor de √°tomo na Se√ß√£o 11.1.3, que se referia a todos os valores de tipos de dados embutidos. No modelo ODMG, um objeto at√¥mico √© qualquer objeto individual definido pelo usu√°rio .
- Todos os valores dos tipos de dados embutidos b√°sicos s√£o considerados literais .
- 5. A cria√ß√£o do objeto refere-se √† maneira como ele  pode ser criado. Isso normalmente √© realizado  por  meio  de  uma  opera√ß√£o new para uma interface. Vamos descrever isso com detalhes mais adiante nesta se√ß√£o.

No modelo de objeto, uma literal √© um valor que n√£o tem um identificador de objeto. Por√©m, o valor pode ter uma estrutura simples ou complexa. Existem tr√™s tipos de literais: at√¥micas, estruturadas e de cole√ß√£o.

- 1. Literais at√¥micas 26 correspondem aos valores dos tipos de dados b√°sicos e s√£o predefinidas. Os tipos de dados b√°sicos do modelo de objeto incluem long, short e n√∫meros inteiros sem sinal  (estes  s√£o  especificados  pelas  palavras-chave long , short , unsigned long e unsigned short em ODL), n√∫meros de ponto flutuante de precis√£o normal e dupla ( float , double ), valores booleanos ( boolean ), caracteres isolados ( char ), cadeias de caracteres ( string ) e tipos de enumera√ß√£o ( enum ), entre outros.
- 2. Literais  estruturadas correspondem  aproximadamente aos valores que s√£o constru√≠dos usando o construtor de tupla descrito na Se√ß√£o 11.1.3. As literais estruturadas embutidas incluem Date, Interval, Time e Timestamp (ver Figura 11.5(b)). Outras literais estruturadas definidas pelo usu√°rio podem ser estabelecidas conforme a necessidade de cada aplica√ß√£o. 27 As  estruturas  definidas  pelo  usu√°rio s√£o criadas usando a palavra-chave STRUCT em ODL, assim como nas linguagens de programa√ß√£o C e C++.
- 3. Literais de cole√ß√£o especificam um valor literal que √© uma cole√ß√£o de objetos ou valores, mas a cole√ß√£o em si n√£o tem um OID. As cole√ß√µes no modelo de objeto podem ser definidas pelos geradores de tipo set &lt; T &gt;, bag &lt; T &gt;, list &lt; T &gt; e array &lt; T&gt; ,  onde T √©  o  tipo  dos  objetos  ou valores na cole√ß√£o. 28 Outro tipo de cole√ß√£o √© dictionary &lt; K V , &gt;, que √© uma cole√ß√£o de associa√ß√µes &lt; K V , &gt;, onde K √© uma chave (um valor de pesquisa exclusivo) associada a um valor V . Este pode ser usado para criar um √≠ndice sobre uma cole√ß√£o de valores V .

23 Isso corresponde ao OID da Se√ß√£o 11.1.2.

24 Isso corresponde ao mecanismo de nomea√ß√£o para persist√™ncia, descrito na Se√ß√£o 11.1.4.

25 No modelo ODMG, objetos at√¥micos n√£o correspondem a objetos cujos valores s√£o tipos de dados b√°sicos. Todos os valores b√°sicos (inteiros, reais etc.) s√£o considerados literais .

26 O uso da palavra at√¥mica em literal at√¥mica corresponde ao modo como usamos o construtor de √°tomo na Se√ß√£o 11.1.3.

27 As estruturas para Date, Interval, Time e Timestamp podem ser usadas para criar valores literais ou objetos com identificadores.

28 Estes s√£o semelhantes aos construtores de tipo correspondentes na Se√ß√£o 11.1.3.

(a) interface Object {

... boolean same\_as(in object other\_object); object copy( ); void delete( ); }; Class Date : Object { enum Weekday { Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday }; enum Month { January, February, March, April, May, June, July, August, September, October, November, December }; unsigned short year( ); unsigned short month( ); unsigned short day( ); ... boolean is\_equal(in Date other\_date); boolean is\_greater(in Date other\_date); ...    }; Class Time : Object { ... unsigned short hour( ); unsigned short minute( ); unsigned short second( ); unsigned short milisecond( ); ... boolean is\_equal(in Time a\_time); boolean is\_greater(in Time a\_time); ... Time add\_interval(in Interval an\_interval); Time subtract\_interval(in Interval an\_interval); Interval subtract\_time(in Time other\_time);    }; class Timestamp : Object { ... unsigned short year( ); unsigned short month( ); unsigned short day( ); unsigned short hour( ); unsigned short minute( ); unsigned short second( ); unsigned short milisecond( ); ... Timestamp plus(in Interval an\_interval);

(b)

( continua )

## Figura 11.5

Vis√£o geral das defini√ß√µes de interface para parte do modelo de objeto ODMG. (a) A interface object, herdada por todos os objetos. (b) Algumas interfaces-padr√£o para literais estruturadas.

Timestamp

minus(in Interval an\_interval);

boolean

is\_equal(in Timestamp a\_timestamp);

boolean

is\_greater(in Timestamp a\_timestamp);

...    };

class Interval :

Object {

unsigned short

day( );

unsigned short

hour( );

unsigned short

minute( );

unsigned short

second( );

unsigned short

milisecond( );

...

Interval

plus(in Interval an\_interval); minus(in Interval an\_interval); product(in long a\_value); quotient(in long a\_value); is\_equal(in interval an\_interval);

Interval

Interval

Interval

boolean

boolean

is\_greater(in interval an\_interval);

... };

## (c) interface Collection : Object {

...

exception

ElementNotFound{ Object element; };

unsigned long

cardinality( );

boolean

is\_empty( );

...

boolean

contains\_element(in Object element); insert\_element(in Object element); remove\_element(in Object element) raises(ElementNotFound); create\_iterator(in boolean stable);

void

void

iterator

... };

interface Iterator {

exception

NoMoreElements( );

...

boolean

at\_end( );

void

reset( );

Object

get\_element( ) raises(NoMoreElements);

void

next\_position( ) raises(NoMoreElements);

... };

interface set : Collection {

set

create\_union(in set other\_set);

...

boolean

is\_subset\_of(in set other\_set);

... };

( continua )

## Figura 11.5 (continua√ß√£o)

Vis√£o geral das defini√ß√µes de interface para parte do modelo de objeto ODMG. (b) (continua√ß√£o) Algumas interfaces-padr√£o para literais estruturadas. (c) Interfaces para cole√ß√µes e objetos de itera√ß√£o.

interface bag : Collection {

unsigned long

occurrences\_of(in Object element); create\_union(in Bag other\_bag);

bag

... };

interface list : Collection {

exception

Invalid\_lndex{unsigned\_long index; ); remove\_element\_at(in unsigned long index) raises(lnvalidlndex); retrieve\_element\_at(in unsigned long index) raises(lnvalidlndex); replace\_element\_at(in Object element, in unsiged long index)

void

Object

void

raises(lnvalidlndex);

void

insert\_element\_after(in Object element, in unsigned long index) raises(lnvalidlndex);

...

void

insert\_element\_first(in Object element);

...

void

remove\_first\_element( ) raises(ElementNotFound);

...

Object

retrieve\_first\_element( ) raises(ElementNotFound);

...

list

concat(in list other\_list); append(in list other\_list);

void

};

interface array : Collection {

exception

Invalid\_lndex{unsigned\_long index; };

exception

Invalid\_Size{unsigned\_long size; };

void

remove\_element\_at(in unsigned long index)

raises(InvalidIndex);

Object

retrieve\_element\_at(in unsigned long index)

raises(InvalidIndex);

void

replace\_element\_at(in unsigned long index, in Object element)

raises(InvalidIndex);

void

resize(in unsigned long new\_size)

raises(InvalidSize);

};

struct association { Object key; Object value; };

interface dictionary : Collection {

exception

DuplicateName{string key; };

exception

KeyNotFound{Object key; };

void

bind(in Object key, in Object value)

raises(DuplicateName);

void

unbind(in Object key) raises(KeyNotFound);

Object

lookup(in Object key) raises(KeyNotFound);

boolean

contains\_key(in Object key);

};

A  Figura  11.5  mostra  uma  vis√£o  simplificada dos tipos b√°sicos e geradores de tipo do modelo de objeto.  A  nota√ß√£o  do  ODMG  usa  tr√™s  conceitos: interface, literal e class. Seguindo  a  terminologia  do ODMB, usamos a palavra comportamento para nos referirmos √†s opera√ß√µes e estado para nos referirmos √†s propriedades (atributos e relacionamentos). Uma interface especifica apenas o comportamento de um tipo de objeto e normalmente √© n√£o instanci√°vel (ou seja, nenhum objeto √© criado correspondente a uma interface). Embora uma interface possa ter propriedades de estado (atributos e relacionamentos) como parte de suas especifica√ß√µes, estas n√£o podem ser herdadas da interface. Logo, uma interface serve para definir  opera√ß√µes  que  podem  ser herdadas por  outras interfaces, assim como por classes que definem os objetos definidos pelos usu√°rios para determinada aplica√ß√£o. Uma class especifica tanto o estado (atributos) quanto o comportamento (opera√ß√µes) de um tipo  de  objeto,  e  √© instanci√°vel .  Assim,  objetos  de banco de dados e aplica√ß√£o normalmente s√£o criados com base nas declara√ß√µes de classe especificadas pelo usu√°rio que formam um esquema de banco de dados. Finalmente, uma declara√ß√£o literal especifica o estado, mas n√£o o comportamento. Dessa forma, uma inst√¢ncia literal mant√©m um valor estruturado simples ou complexo, mas n√£o tem um identificador de objeto nem opera√ß√µes encapsuladas.

A Figura 11.5 √© uma vers√£o simplificada do modelo  de  objeto.  Para  especifica√ß√µes  completas,  consulte  Cattell  et  al.  (2000).  Descreveremos  algumas das constru√ß√µes mostradas na Figura 11.5 √† medida que descrevermos o modelo de objeto. Em um modelo  de  objeto,  todos  os  objetos  herdam  as  opera√ß√µes  de  interface  b√°sicas  de Object, mostradas  na Figura 11.5(a); estas incluem opera√ß√µes como copy (cria uma c√≥pia do objeto), delete (exclui o objeto) e same\_as (compara a identidade do objeto com outro objeto). 29 Em geral, as opera√ß√µes s√£o aplicadas aos objetos  usando  a nota√ß√£o  de  ponto .  Por  exemplo, dado um objeto O , para compar√°-lo com outro objeto P , escrevemos

O .same\_as( P )

O resultado retornado por essa opera√ß√£o √© booleano e seria verdadeiro se a identidade de P fosse a mesma de O , e falso em caso contr√°rio. De modo semelhante, para criar uma c√≥pia P do objeto O , escrevemos

P = O .copy( )

Uma alternativa √† nota√ß√£o de ponto √© a nota√ß√£o de seta: O -&gt;same\_as ( P ) ou O -&gt;copy ( ).

## 11.3.2 Heran√ßa no modelo de objeto de ODMG

No modelo de objeto ODMG, existem dois tipos de relacionamento de heran√ßa: heran√ßa apenas de  comportamento e heran√ßa de estado mais comportamento. A heran√ßa de comportamento tamb√©m √© conhecida como heran√ßa ISA ou de interface ,  e  √© especificada pela nota√ß√£o de dois pontos (:). 30  Logo, no modelo de objeto ODMG, a heran√ßa de comportamento requer que um supertipo seja uma interface, enquanto o subtipo poderia ser uma classe ou outra interface.

O outro  relacionamento  de  heran√ßa,  chamado heran√ßa ESTENDIDA ,  √©  especificado  pela  palavra-chave extends .  Ele  √©  usado  para  herdar  estado  e comportamento estritamente entre classes, de modo que o supertipo e o subtipo devem ser classes. A heran√ßa m√∫ltipla por extends n√£o √© permitida. Por√©m, a  heran√ßa  m√∫ltipla  √©  permitida  para  a  heran√ßa  de comportamento por meio da nota√ß√£o de dois pontos (:). Logo, uma interface pode herdar comportamento de v√°rias outras interfaces. Uma classe tamb√©m herda comportamento de diversas interfaces por meio da nota√ß√£o de dois  pontos  (:),  al√©m  de  herdar  o  comportamento e o estado de no m√°ximo uma classe por meio de extends. Na Se√ß√£o 11.3.4, daremos exemplos de como esses dois relacionamentos de heran√ßa - ':' e extends - podem ser usados.

## 11.3.3 nterfaces e classes embutidas no I modelo de objeto

A Figura 11.5 mostra as interfaces e classes embutidas do modelo de objeto. Todas as interfaces, como Collection, Date e Time, herdam a interface Object b√°sica. No modelo de objeto, existe uma distin√ß√£o entre objetos de cole√ß√£o, cujo estado cont√©m m√∫ltiplos objetos ou literais, versus objetos at√¥micos (e estruturados), cujo estado √© um objeto ou literal individual. Objetos de cole√ß√£o herdam a interface Collection b√°sica,  mostrada  na  Figura  11.5(c),  que  mostra  as opera√ß√µes de todos os objetos de cole√ß√£o. Dado um objeto de cole√ß√£o O , a opera√ß√£o O .cardinality( ) retorna o n√∫mero de elementos na cole√ß√£o. A opera√ß√£o O . is\_empty( ) retorna verdadeira se a cole√ß√£o O for vazia, e retorna falsa em caso contr√°rio. As opera√ß√µes O . insert\_element(E) e O .remove\_element ( E ) inserem e

29 Opera√ß√µes adicionais s√£o definidas sobre objetos para fins de bloqueio , mas n√£o aparecem na Figura 11.5. Discutiremos os conceitos de bloqueio para bancos de dados no Cap√≠tulo 22.

30 O relat√≥rio do ODMG tamb√©m chama a heran√ßa de interface de relacionamentos tipo/subtipo, '√©-um' e generaliza√ß√£o/especializa√ß√£o, embora, na literatura, esses termos tenham sido usados para descrever a heran√ßa tanto de estado quanto de opera√ß√µes (ver Cap√≠tulo 8 e Se√ß√£o 11.1).

removem um elemento E da cole√ß√£o O ,  respectivamente.  Por  fim,  a  opera√ß√£o O .contains\_element ( E ) retorna verdadeira se a cole√ß√£o O incluir o elemento E , e retorna falsa em caso contr√°rio. A opera√ß√£o   = I O . create\_iterator( ) cria um objeto de itera√ß√£o I para o objeto de cole√ß√£o O , que pode percorrer cada elemento na cole√ß√£o. A interface para os objetos de itera√ß√£o tamb√©m aparece na Figura 11.5(c). A opera√ß√£o I . reset( ) define o objeto de itera√ß√£o para o primeiro elemento em uma cole√ß√£o (para uma cole√ß√£o desordenada, esse seria um elemento qualquer), e I .next\_ position( ) define o objeto de itera√ß√£o para o pr√≥ximo elemento. I .get\_element( ) recupera o elemento atual , que √© o elemento em que o objeto de itera√ß√£o est√° posicionado atualmente.

O modelo de objeto ODMG usa exce√ß√µes para informar erros ou condi√ß√µes particulares. Por exemplo, a exce√ß√£o ElementNotFound (elemento n√£o encontrado) na interface Collection seria lan√ßada pela opera√ß√£o O .remove\_element( E ) se E n√£o fosse um elemento na cole√ß√£o O . A exce√ß√£o NoMoreElements (sem mais elementos) na  interface  do  objeto  de  itera√ß√£o  seria lan√ßada pela opera√ß√£o I .next\_position( ) se tal objeto estivesse atualmente posicionado no √∫ltimo elemento da cole√ß√£o, e, portanto, n√£o houvesse mais elementos a serem apontados por ele.

Objetos Collection s√£o especializados ainda mais em set, list, bag, array e dictionary, que  herdam  as opera√ß√µes da interface Collection. Um gerador de tipo set&lt; T &gt; pode ser usado para criar objetos de modo que o valor do objeto O seja um conjunto cujos elementos s√£o do tipo T .  A  interface Set inclui a opera√ß√£o adicional P = O .create\_union( S ) (ver  Figura  11.5(c)), que retorna um novo objeto P do tipo set&lt; T &gt; que √© a uni√£o dos dois conjuntos O e S . Outras opera√ß√µes semelhantes a create\_union (n√£o mostradas na Figura 11.5(c)) s√£o create\_intersection( S ) e create\_difference( S ) . Opera√ß√µes para compara√ß√£o de conjunto incluem a opera√ß√£o O .is\_subset\_of( S ) , que retorna verdadeira se o objeto set O for  um  subconjunto de algum outro objeto set S , e retorna falsa em caso contr√°rio. Opera√ß√µes semelhantes (n√£o mostradas na Figura 11.5(c)) s√£o is\_proper\_subset\_of( S ) , is\_superset\_of( S ) e is\_pro-per\_superset\_of( S ) . O gerador de tipo bag&lt; T &gt; permite elementos duplicados na cole√ß√£o e tamb√©m herda a interface Collection. Ele tem tr√™s opera√ß√µes -create\_ union(b) , create\_intersection(b) e create\_difference(b) -, que retornam um novo objeto do tipo bag&lt; T &gt; .

Um tipo de objeto list &lt; T &gt; herda as opera√ß√µes de Collection e pode ser usado para criar cole√ß√µes onde a ordem dos elementos √© importante. O valor de cada objeto O desse tipo √© uma lista ordenada cujos elementos s√£o do tipo T . Logo, podemos nos referir ao primeiro, √∫ltimo e  -√©simo elemento na lista. Al√©m disso, quando i acrescentamos um elemento √† lista, temos de especificar a posi√ß√£o em que o elemento √© inserido. Algumas das opera√ß√µes de list s√£o exibidas na Figura 11.5(c). Se O √©  um objeto do tipo list &lt; T &gt;,  a  opera√ß√£o O .insert\_ele-ment\_first ( E ) insere o elemento E antes do primeiro elemento na lista O , de modo que E se torna o primeiro elemento na lista. Uma opera√ß√£o semelhante (n√£o mostrada) √© O .insert\_element\_last( E ) . A opera√ß√£o O .insert\_ element\_after ( E  I , ), na Figura 11.5(c), insere o elemento E ap√≥s o  -√©simo elemento na lista i O e lan√ßar√° a exce√ß√£o InvalidIndex se n√£o houver um  -√©simo elemento em i O . Uma outra opera√ß√£o semelhante (n√£o mostrada) √© O .insert\_element\_before ( E  I , ). Para remover elementos da lista, as opera√ß√µes s√£o E = O .remove\_first\_element ( ), E = O .remove\_last\_element ( ) e E = O .remove\_element \_ at ( I ); essas opera√ß√µes removem o elemento indicado da lista e retornam o elemento como o resultado da opera√ß√£o. Outras opera√ß√µes recuperam um elemento sem remov√™-lo da lista. Estas s√£o E = O .retrieve\_first\_element ( ), E = O .retrieve\_last\_element (  )  e E = O .retrieve\_ele-ment\_at ( I ). Al√©m disso, duas opera√ß√µes para manipular listas s√£o definidas. S√£o elas P = O .concat ( I ), a qual cria uma nova lista P que √© a concatena√ß√£o das listas O e I (os elementos da lista O seguidos por aqueles da lista I ), e O .append ( I ), que anexa os elementos da lista I ao final da lista O (sem criar um novo objeto de lista).

O tipo de objeto array &lt; T &gt; tamb√©m herda as opera√ß√µes de Collection, e √© semelhante √† lista. Opera√ß√µes espec√≠ficas para um objeto de array O s√£o O .replace\_ element\_at ( I , E ), que substitui o elemento de array na posi√ß√£o I pelo  elemento E ; E = O .remove\_element\_ at ( I ),  que  recupera  o i√©simo  elemento  e  o  substitui por um valor NULL ; e E = O .retrieve\_element\_at ( I ), que simplesmente recupera o  -√©simo elemento do array. i Qualquer uma dessas opera√ß√µes pode lan√ßar a exce√ß√£o InvalidIndex se I for maior do que o tamanho do array.  A  opera√ß√£o O .resize ( N )  muda  o  n√∫mero  dos elementos do array para N .

O √∫ltimo tipo de objetos de cole√ß√£o s√£o do tipo dictionary &lt; K V , &gt;, que permite a cria√ß√£o de uma cole√ß√£o de pares associados &lt; K V , &gt;, em que todos os valores K (chave) s√£o √∫nicos. Isso, por sua vez,  permite a recupera√ß√£o associativa de determinado par dado seu valor de chave (semelhante a um √≠ndice). Se O √© um objeto de cole√ß√£o do tipo dictionary &lt; K V , &gt;, ent√£o O .bind ( K,V ) vincula  o  valor V √†  chave K como  uma  associa√ß√£o &lt; K V , &gt; na cole√ß√£o, enquanto O . unbind ( K ) remove a associa√ß√£o com chave K de O , e V = O .lookup ( K ) retorna o valor V associado √† chave K em O . As duas √∫ltimas opera√ß√µes podem lan√ßar a exce√ß√£o KeyNotFound. Por fim, O .contains\_key ( K ) retorna verdadeiro se a chave K existir em O , e retorna falso em caso contr√°rio.

A Figura 11.6 √© um diagrama que ilustra a hierarquia de heran√ßa das constru√ß√µes embutidas do mo-

Figura 11.6



Hierarquia de heran√ßa para as interfaces embutidas do modelo de objeto.

delo de objeto. As opera√ß√µes s√£o herdadas do supertipo para o subtipo. As interfaces de cole√ß√£o descritas anteriormente n√£o s√£o diretamente instanci√°veis ;  ou seja, n√£o se pode criar diretamente objetos com base nessas interfaces. Em vez disso, as interfaces podem ser usadas para gerar tipos de cole√ß√£o definidos pelo usu√°rio - do tipo set, bag, list, array ou dictionary -para uma aplica√ß√£o de banco de dados em particular. Se um atributo ou classe tem um tipo de cole√ß√£o, digamos, um set, ent√£o ele herdar√° as opera√ß√µes da interface set . Por exemplo, em uma aplica√ß√£o de banco de dados UNIVERSIDADE , o usu√°  rio pode especificar um tipo para set&lt;ALUNO&gt; , cujo estado seria conjuntos de objetos ALUNO . O programador pode, ent√£o, usar as opera√ß√µes para set &lt; T &gt; para manipular uma inst√¢ncia do tipo set&lt;ALUNO&gt; . A cria√ß√£o de classes de aplica√ß√£o normalmente √© feita utilizando a linguagem de defini√ß√£o de objeto - ODL (ver Se√ß√£o 11.3.6).

√â  importante  observar  que  todos  os  objetos  em uma cole√ß√£o em particular precisam ser do mesmo tipo . Logo, embora a palavra-chave any apare√ßa nas especifica√ß√µes das interfaces de cole√ß√£o na Figura 11.5(c), isso n√£o significa que os objetos de qualquer tipo podem ser mesclados dentro da mesma cole√ß√£o. Ao contr√°rio, isso significa que qualquer tipo pode ser usado quando se especifica o tipo dos elementos para determinada cole√ß√£o (incluindo outros tipos de cole√ß√£o!)

Por  exemplo,  em  uma  aplica√ß√£o  de  banco  de dados UNIVERSIDADE ,  o  usu√°rio pode especificar o tipo de objeto (class) para objetos ALUNO . A maior parte desses objetos ser√° de objetos estruturados . Por exemplo, um ALUNO ter√° uma estrutura complexa, com muitos atributos, relacionamentos e opera√ß√µes, mas ainda √© considerado at√¥mico porque n√£o √© uma cole√ß√£o.  Esse  tipo  de  objeto  at√¥mico  definido  pelo usu√°rio √© estabelecido como uma classe ao especificar suas propriedades e opera√ß√µes . As propriedades definem o estado do objeto e s√£o distinguidas ainda mais em atributos e relacionamentos . Nesta subse√ß√£o, detalhamos os tr√™s tipos de componentes - atributos, relacionamentos e opera√ß√µes - que um tipo de objeto definido pelo usu√°rio para objetos at√¥micos (estruturados) pode incluir. Ilustramos nossa discuss√£o com as duas classes, FUNCIONARIO e DEPARTAMENTO , mostradas na Figura 11.7.

## 11.3.4 Objetos at√¥micos (definidos pelo usu√°rio)

A se√ß√£o anterior descreveu os tipos de cole√ß√£o embutidos do modelo de objeto. Agora, vamos discutir como os tipos de objeto para objetos at√¥micos podem ser constru√≠dos. Estes s√£o especificados usando a palavra-chave class na ODL. No modelo de objeto, qualquer objeto definido pelo usu√°rio, que n√£o √© um objeto de cole√ß√£o, √© chamado de objeto at√¥mico . 31

Um atributo √© uma propriedade que descreve algum aspecto  de  um  objeto.  Atributos  possuem  valores  (os quais normalmente s√£o literais com uma estrutura simples ou complexa) que s√£o armazenados dentro do objeto. Por√©m, os valores de atributo tamb√©m podem ser OIDs de outros objetos. Os valores de atributo podem at√© mesmo ser especificados por meio de m√©todos que s√£o utilizados para calcular o valor do atributo. Na Figura 11.7, 32 os atributos para FUNCIONARIO s√£o Nome, Cpf, Data\_nascimento, Sexo e Idade, e para DEPARTAMENTO s√£o Dnome, Dnumero, Ger, Localizacoes e Projs. Os atributos Ger e Projs de DEPARTAMENTO possuem  estrutura complexa e s√£o definidos por meio de struct , que corresponde  ao construtor  de  tuplas da  Se√ß√£o  11.1.3. Logo, o valor de Ger em cada objeto DEPARTAMENTO ter√°  dois  componentes: Gerente, cujo  valor  √©  um OID que referencia o objeto FUNCIONARIO ,  que gerencia o DEPARTAMENTO   Data\_inicio, e cujo  valor  √©  uma date.

31 Como dissemos anteriormente, essa defini√ß√£o de objeto at√¥mico no modelo de objeto ODMG √© diferente da defini√ß√£o do construtor de √°tomo da Se√ß√£o 11.1.3, que √© a defini√ß√£o usada em grande parte da literatura de banco de dados orientada a objeto.

32 Estamos usando a nota√ß√£o da Object Definition Language (ODL) na Figura 11.7, que ser√° discutida com mais detalhes na Se√ß√£o 11.3.6.

O atributo localizacoes de DEPARTAMENTO √©  definido por meio do construtor set , pois cada objeto DEPARTAMENTO pode ter um conjunto de locais.

Um relationship √© uma propriedade que especifica que  dois  objetos  no  banco  de  dados  est√£o  relacionados.  No  modelo  de  objeto  do  ODMG,  somente relacionamentos  bin√°rios  (ver  Se√ß√£o  7.4)  s√£o  representados  explicitamente,  e  cada  relacionamento bin√°rio  √©  representado  por  um par  de  refer√™ncias inversas especificadas  por  meio  do  relationship  de palavra-chave.  Na  Figura  11.7,  existe  um  relacionamento que relaciona cada FUNCIONARIO ao DEPARTAMENTO em que trabalha - o relacionamento Trabalha\_para de FUNCIONARIO. Na dire√ß√£o inversa, cada DEPARTAMENTO est√° relacionado ao conjunto de FUNCIONARIOS que trabalha no DEPARTAMENTO -o relacionamento Tem\_funcs de DEPARTAMENTO. A palavra-chave inverse especifica que essas duas propriedades definem um √∫nico relacionamento conceitual nas dire√ß√µes inversas. 33

class FUNCIONARIO

};

Figura 11.7 Os atributos, relacionamentos e opera√ß√µes em uma defini√ß√£o de classe.

| extent                       | TODOS_FUNCIONARIOS                                          |                                                             |
|------------------------------|-------------------------------------------------------------|-------------------------------------------------------------|
| key                          | Cpf )                                                       |                                                             |
| attribute                    | string                                                      | Nome;                                                       |
| attribute                    | string                                                      | Cpf;                                                        |
| attribute                    | date                                                        | Data_nascimento;                                            |
| attribute                    | enum Genero{M, F}                                           | Sexo;                                                       |
| attribute                    | short                                                       | Idade;                                                      |
| relationship                 | DEPARTAMENTO                                                | Trabalha_para                                               |
|                              | inverse DEPARTAMENTO::Tem_funcs;                            | inverse DEPARTAMENTO::Tem_funcs;                            |
| void                         | realoca_func(in string Novo_dnome)                          | realoca_func(in string Novo_dnome)                          |
| DEPARTAMENTO                 |                                                             |                                                             |
| extent                       | TODOS_DEPARTAMENTOS                                         |                                                             |
| key                          |                                                             | Dnome, Dnumero)                                             |
| attribute                    | string                                                      | Dnome;                                                      |
| attribute                    | short                                                       | Dnumero;                                                    |
| attribute                    | struct Ger_proj {FUNCIONARIO date Data_inicio} Ger;         | Gerente,                                                    |
| attribute                    | set<string>                                                 | Localizacoes;                                               |
| attribute                    | struct Projs {string Proj_nome, time Horas_semana) Projs;   |                                                             |
| relationship                 | set<FUNCIONARIO>                                            | Tem_funcs inverse FUNCIONARIO::Trabalha_para;               |
| void                         | adiciona_func(in string Novo_fnome) raises(fnome_invalido); | adiciona_func(in string Novo_fnome) raises(fnome_invalido); |
| void troca_gerente(in string | Novo_ger_nome; in date                                      | Novo_ger_nome; in date                                      |
|                              | Data_inicio);                                               |                                                             |

33 A Se√ß√£o 7.4 discute como um relacionamento pode ser representado por dois atributos em dire√ß√µes inversas.

Ao  especificar  inversos,  o  sistema  de  banco de dados pode manter a integridade referencial do relacionamento  automaticamente.  Ou  seja,  se  o valor de Trabalha\_para para determinado FUNCIONARIO F refere-se  ao DEPARTAMENTO D ,  ent√£o o  valor  de Tem\_funcs para  o DEPARTAMENTO D precisa incluir uma refer√™ncia a F em seu conjunto de refer√™ncias de FUNCIONARIO . Se o projetista de banco de dados quiser ter um relacionamento para ser representado em apenas uma dire√ß√£o , ent√£o ele precisa ser modelado como um atributo (ou opera√ß√£o). Um exemplo √© o componente Gerente do atributo Ger em DEPARTAMENTO.

Al√©m dos atributos e relacionamentos, o projetista pode incluir opera√ß√µes nas especifica√ß√µes de tipo de objeto (class). Cada tipo de objeto pode ter uma s√©rie de assinaturas de opera√ß√£o , que especificam o nome da opera√ß√£o, seus tipos de argumento e seu valor retornado, se for o caso. Os nomes de opera√ß√£o s√£o exclusivos dentro de cada tipo de objeto, mas eles podem ser sobrecarregados, fazendo que o mesmo nome de opera√ß√£o apare√ßa em tipos de objeto distintos. A assinatura da opera√ß√£o tamb√©m pode especificar os nomes das exce√ß√µes sujeitas a ocorrer durante a execu√ß√£o da opera√ß√£o. A implementa√ß√£o da opera√ß√£o incluir√° o c√≥digo para lan√ßar  essas  exce√ß√µes.  Na  Figura  11.7,  a  classe FUNCIONARIO tem uma opera√ß√£o: realoca\_func, e a classe DEPARTAMENTO tem duas opera√ß√µes: adi-ciona\_func e troca\_gerente .

## 11.3.5 Extens√µes, chaves e f√°brica de objetos

No  modelo  de  objeto  ODMG,  o  projetista de  banco  de  dados  pode  declarar  uma extens√£o (usando  a  palavra-chave extent ) para  qualquer tipo de objeto que seja definido por meio de uma declara√ß√£o class . A extent recebe um nome e ter√° todos  os  objetos  persistentes  dessa  classe.  Logo, a extent comporta-se como um objeto de conjunto que  mant√©m  todos  os  objetos  persistentes  da classe.  Na  Figura  11.7,  as  classes FUNCIONARIO e DEPARTAMENTO possuem  extens√µes  chamadas TODOS\_FUNCIONARIOS e TODOS\_DEPARTAMEN-TOS ,  respectivamente.  Isso  √©  semelhante  a  criar dois objetos - um do tipo set&lt;FUNCIONARIO&gt; e outro do tipo set&lt;DEPARTAMENTO&gt; - e torn√°-los persistentes  chamando-os  de TODOS\_FUNCIONA-

34 Uma chave composta √© chamada de compound key no relat√≥rio do ODMG.

RIOS e TODOS\_DEPARTAMENTOS. As  extens√µes tamb√©m s√£o usadas para impor automaticamente o  relacionamento  de  conjunto/subconjunto  entre as  extens√µes  de  um  supertipo  e  seu  subtipo.  Se duas classes A e B possuem extens√µes TODOS\_A e TODOS\_B, e a classe B √© um subtipo da classe A (ou seja, a classe B extends class A ), ent√£o a cole√ß√£o de objetos em TODOS\_B precisa ser um subconjunto daqueles  em TODOS\_A em  qualquer  ponto.  Essa restri√ß√£o √© imposta automaticamente pelo sistema de banco de dados.

Uma classe com uma extens√£o pode ter uma ou mais chaves. Uma chave consiste em uma ou mais propriedades (atributos ou relacionamentos), cujos valores s√£o restritos a serem √∫nicos para cada objeto  na  extens√£o.  Por  exemplo,  na  Figura  11.7,  a classe FUNCIONARIO tem o atributo Cpf como chave (cada objeto FUNCIONARIO na extens√£o precisa ter um valor de Cpf √∫nico),  e  a  classe DEPARTAMENTO tem  duas  chaves  distintas: Dnome e Dnumero (cada DEPARTAMENTO deve  ter  um Dnome √∫nico e um Dnumero √∫nico). Para uma chave composta 34 que √© feita de v√°rias propriedades, as propriedades que formam a chave est√£o contidas em par√™nteses. Por exemplo,  se  uma  classe VEICULO com uma extent TODOS\_VEICULOS tem  uma  chave  composta  por uma combina√ß√£o de dois atributos Estado e Placa, eles poderiam ser colocados entre par√™nteses, como em ( Estado, Placa ) na declara√ß√£o de chave.

Em seguida, apresentamos o conceito de f√°brica  de  objeto -  um  objeto  que  pode  ser  usado  para  gerar  ou  criar  objetos  individuais  por meio  de  suas  opera√ß√µes.  Algumas  das  interfaces da f√°brica de objetos que fazem parte do modelo de objeto ODMG aparecem na Figura 11.8. A interface ObjectFactory tem uma √∫nica opera√ß√£o, new( ) , que retorna um novo objeto com um OID. Ao herdar essa interface, os usu√°rios podem criar as pr√≥prias interfaces de f√°brica para cada tipo de objeto definido pelo usu√°rio (at√¥mico), e o programador pode implementar a opera√ß√£o new de forma diferente para cada tipo de objeto. A Figura  11.8  tamb√©m  mostra  uma  interface DateFactory , que tem opera√ß√µes adicionais para a cria√ß√£o de um novo calendar\_date, e para criar um objeto cujo valor √© o current\_date, entre outras opera√ß√µes (n√£o mostradas na Figura 11.8). Como podemos ver, uma f√°brica de objeto basicamente oferece as opera√ß√µes construtoras para novos objetos.

interface ObjectFactory {

Object new( ); }; interface SetFactory : ObjectFactory { Set new\_of\_size(in long size); }; interface ListFactory : ObjectFactory { List new\_of\_size(in long size); }; interface ArrayFactory : ObjectFactory { Array new\_of\_size(in long size); }; interface DictionaryFactory : ObjectFactory { Dictionary new\_of\_size(in long size); }; interface DateFactory : ObjectFactory { exception InvalidDate{}; ... Date calendar\_date( in unsigned short year, in unsigned short month, in unsigned short day) raises(InvalidDate); ... Date current( ); }; interface DatabaseFactory { Database new( ); }; interface Database { ... void open(in string database\_name) raises(DatabaseNotFound, DatabaseOpen); void close( ) raises(DatabaseClosed, ...); void bind(in Object an\_object, in string name) raises(DatabaseClosed, ObjectNameNotUnique, ...); Object unbind(in string name) raises(DatabaseClosed, ObjectNameNotFound, ...); Object lookup(in string object\_name) raises(DatabaseClosed, ObjectNameNotFound, ...);

... };

Figura 11.8

Interfaces para ilustrar f√°brica de objetos e objetos de banco de dados.

Finalmente,  discutimos  o  conceito  de  um banco de dados. Como um SGBDO pode criar muitos bancos de dados diferentes, cada um com o pr√≥prio esquema, o modelo de objeto ODMG tem interfaces para objetos DatabaseFactory e Database , como mostra a Figura 11.8. Cada banco de dados tem o pr√≥prio nome de banco de dados , e a opera√ß√£o bind pode ser  usada  para  atribuir  nomes  √∫nicos  individuais  a objetos persistentes em um banco de dados em particular. A opera√ß√£o lookup retorna um objeto do banco de dados que tem o object\_name especificado, e a opera√ß√£o unbind remove o nome de um objeto dito persistente do banco de dados.

## 11.3.6 A linguagem de defini√ß√£o de objeto ODL

Depois de nossa vis√£o geral do modelo de objeto ODMG na se√ß√£o anterior, agora vamos mostrar como esses conceitos podem ser utilizados para criar um esquema de banco de dados de objeto usando a linguagem de defini√ß√£o de objeto ODL. 35

A ODL √© projetada para dar suporte  √†s  constru√ß√µes sem√¢nticas do modelo de objeto ODMG e √© independente de qualquer linguagem de programa√ß√£o em particular. Seu uso principal √© para criar especifica√ß√µes de objeto - ou seja, classes e interfaces. Logo, a ODL n√£o √© uma linguagem de programa√ß√£o completa. Um usu√°rio pode especificar um esquema de banco de dados na ODL independentemente de qualquer linguagem de programa√ß√£o, e depois usar os  bindings  da  linguagem  espec√≠fica  para  indicar como as constru√ß√µes ODL podem ser mapeadas em constru√ß√µes nas linguagens de programa√ß√£o espec√≠ficas, como C++, Smalltalk e Java. Daremos uma vis√£o geral do binding com a C++ na Se√ß√£o 11.6.

A Figura 11.9(b) mostra um esquema de objeto poss√≠vel para parte do banco de dados UNIVERSIDADE , que foi apresentado no Cap√≠tulo 8. Descreveremos os conceitos da ODL usando esse exemplo, e aquele da Figura 11.11. A nota√ß√£o gr√°fica para a Figura 11.9(b) √©  mostrada  na  Figura  11.9(a)  e  pode  ser  considerada uma varia√ß√£o dos diagramas EER (ver Cap√≠tulo 8) com o conceito adicionado de heran√ßa de interface, mas sem v√°rios conceitos de EER, como categorias (tipos de uni√£o) e atributos de relacionamentos.

esquema de objeto (ou diagrama de esquema EER) para classes ODL. Discutiremos melhor sobre essas op√ß√µes na Se√ß√£o 11.4.

A Figura 11.10 mostra o modo direto de mapear parte do banco de dados UNIVERSIDADE do Cap√≠tulo 8. Os tipos de entidade s√£o mapeados para classes ODL, e a heran√ßa √© feita usando extends . Por√©m, n√£o existe um modo direto de mapear categorias (tipos de uni√£o) ou realizar a heran√ßa m√∫ltipla. Na Figura 11.10, as classes PESSOA , DOCENTE , ALUNO e ALUNO\_POSGRADUA-CAO t√™m as extens√µes PESSOAS, DOCENTE , ALUNOS e ALUNO\_POSGRADUACAO , respectivamente.  Tanto DOCENTE quanto ALUNO extends PESSOA e ALUNO\_ POSGRADUACAO extends ALUNO. Logo, a cole√ß√£o de ALUNOS (e a cole√ß√£o de DOCENTE ) ser√° restrita a um subconjunto da cole√ß√£o de PESSOA a qualquer momento. De modo semelhante, a cole√ß√£o de ALUNO\_POSGRA-DUACAO ser√°  um subconjunto de ALUNO .  Ao mesmo tempo, objetos ALUNO e DOCENTE individuais herdar√£o as propriedades (atributos e relacionamentos) e opera√ß√µes  de PESSOA, e  objetos ALUNO\_POSGRADUACAO individuais herdar√£o aquelas de ALUNO.

As classes DEPARTAMENTO DISCIPLINA , , TURMA e TURMA\_ATUAL da Figura 11.10 s√£o mapeamentos diretos dos tipos de entidade correspondentes da Figura 11.9(b). Por√©m, a classe NOTA requer alguma explica√ß√£o. A classe NOTA corresponde ao relacionamento M:N entre ALUNO e TURMA na Figura 11.9(b). O motivo para isso ter sido feito em uma classe separada (em vez de em um par de relacionamentos inversos) √© porque inclui o atributo de relacionamento Nota. 36

Assim,  o  relacionamento  M:N  √©  mapeado  para  a classe NOTA, e um par de relacionamentos 1:N, um entre ALUNO e NOTA e o outro entre TURMA e NOTA. 37 Esses relacionamentos  s√£o  representados  pelas  seguintes  propriedades de relacionamento: Turma\_concluida de ALUNO; Turma e Aluno de NOTA; e Alunos de TURMA (ver Figura 11.10).  Por  fim,  a  classe TITULO\_ACADEMICO √©  usada para representar os graus de atributo compostos, multivalorados, de ALUNO\_POSGRADUACAO (ver Figura 8.10).

A  Figura  11.10  mostra  um  conjunto  poss√≠vel de  defini√ß√µes  de  classes  ODL  para  o  banco  de  dados UNIVERSIDADE .  Em  geral,  pode  haver  diversos mapeamentos poss√≠veis a partir de um diagrama de

Como o exemplo anterior n√£o inclui quaisquer interfaces, apenas classes, agora utilizamos um exemplo diferente para ilustrar interfaces e heran√ßa de interface (comportamento). A Figura 11.11(a) faz parte de um esquema de banco de dados para armazenar objetos geom√©tricos. Uma interface GeometriaObjeto √© especificada, com opera√ß√µes para calcular o perimetro e a area de um objeto geom√©trico, mais opera√ß√µes para translacao (mover) e rotacao (girar) um objeto.

35 A sintaxe e os tipos de dados ODL t√™m como prop√≥sito serem compat√≠veis com a IDL -Linguagem de Defini√ß√£o de Interface ( Interface Definition Language ) de CORBA (Common Object Request Broker Architecture), com extens√µes para relacionamentos e outros conceitos de banco de dados.

36 Discutiremos mapeamentos alternativos para atributos de relacionamentos na Se√ß√£o 11.4.

37 Isso √© semelhante ao modo como um relacionamento M:N √© mapeado no modelo relacional (ver Se√ß√£o 9.1) e no modelo de rede legado (ver Ap√™ndice E).



Aluno\_matriculado

## Figura 11.9

Exemplo de um esquema de banco de dados. (a) Nota√ß√£o gr√°fica para representar esquemas ODL. (b) Um esquema gr√°fico de banco de dados de objeto para parte do banco de dados UNIVERSIDADE (as classes NOTA e TITULO\_ACADEMICO n√£o aparecem).

V√°rias  classes  ( RETANGULO, TRIANGULO, CIRCULO, ...)  herdam  a  interface GeometriaObjeto. Como GeometriaObjeto √© uma interface, ela √© n√£o instanci√°vel - ou seja, nenhum objeto pode ser criado com base nessa interface diretamente. No entanto, objetos do tipo RETANGULO, TRIANGULO, CIRCULO, ... podem ser criados, e esses objetos herdam todas as opera√ß√µes  da  interface GeometriaObjeto .  Observe  que, com a heran√ßa de interface, somente opera√ß√µes s√£o herdadas, e n√£o propriedades (atributos, relacionamentos). Logo, se uma propriedade for necess√°ria na classe de heran√ßa, ela precisa ser repetida na defini-

√ß√£o da classe, como no atributo Ponto\_referencia da Figura 11.11(b). Observe que as opera√ß√µes herdadas podem ter diferentes implementa√ß√µes em cada caso. Por exemplo, as implementa√ß√µes das opera√ß√µes area e perimetro podem ser diferentes para RETANGULO, TRIANGULO e CIRCULO.

A heran√ßa m√∫ltipla das interfaces por uma classe √© permitida, assim como a heran√ßa m√∫ltipla de interfaces por outra interface. Contudo, com a heran√ßa extends (classe), a heran√ßa m√∫ltipla n√£o √© permitida . Logo, uma classe pode  herdar por extends at√© no  m√°ximo uma classe (al√©m de herdar de zero ou mais interfaces).

| class                      | PESSOA                     |                                                                                                                                       |                                                                                                                                       |                                                                                                                                       |                                                                                                                                       |
|----------------------------|----------------------------|---------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------|
| (                          | extent                     | PESSOAS                                                                                                                               |                                                                                                                                       |                                                                                                                                       |                                                                                                                                       |
| {                          | attribute                  | struct Projnome {                                                                                                                     | string                                                                                                                                | Pnome,                                                                                                                                |                                                                                                                                       |
|                            |                            |                                                                                                                                       | string                                                                                                                                | Mnome,                                                                                                                                |                                                                                                                                       |
|                            |                            |                                                                                                                                       | string                                                                                                                                | Unome }                                                                                                                               | Nome;                                                                                                                                 |
|                            | attribute                  | string                                                                                                                                |                                                                                                                                       |                                                                                                                                       | Cpf;                                                                                                                                  |
|                            | attribute                  | date                                                                                                                                  |                                                                                                                                       |                                                                                                                                       | Data_nascimento;                                                                                                                      |
|                            | attribute                  | enum Genero{M, F}                                                                                                                     |                                                                                                                                       |                                                                                                                                       | Sexo;                                                                                                                                 |
|                            | attribute                  | struct Endereco {                                                                                                                     | short                                                                                                                                 | Nr,                                                                                                                                   |                                                                                                                                       |
|                            |                            |                                                                                                                                       | string                                                                                                                                | Rua,                                                                                                                                  |                                                                                                                                       |
|                            |                            |                                                                                                                                       | short                                                                                                                                 | Nr_apto,                                                                                                                              |                                                                                                                                       |
|                            |                            |                                                                                                                                       | string                                                                                                                                | Cidade,                                                                                                                               |                                                                                                                                       |
|                            |                            |                                                                                                                                       | string                                                                                                                                | Estado,                                                                                                                               |                                                                                                                                       |
|                            |                            |                                                                                                                                       | short                                                                                                                                 | Cep }                                                                                                                                 | Endereco;                                                                                                                             |
|                            | short                      | Idade( ); };                                                                                                                          |                                                                                                                                       |                                                                                                                                       |                                                                                                                                       |
| class                      | DOCENTE extends PESSOA     | DOCENTE extends PESSOA                                                                                                                |                                                                                                                                       |                                                                                                                                       |                                                                                                                                       |
| (                          | extent                     | DOCENTE )                                                                                                                             |                                                                                                                                       |                                                                                                                                       |                                                                                                                                       |
| {                          | attribute                  | string                                                                                                                                | N√≠vel;                                                                                                                                |                                                                                                                                       |                                                                                                                                       |
|                            | attribute                  | float                                                                                                                                 | Salario;                                                                                                                              |                                                                                                                                       |                                                                                                                                       |
|                            | attribute                  | string                                                                                                                                | Escritorio;                                                                                                                           |                                                                                                                                       |                                                                                                                                       |
|                            | attribute                  | string                                                                                                                                | Telefone;                                                                                                                             |                                                                                                                                       |                                                                                                                                       |
|                            | relationship               | DEPARTAMENTO                                                                                                                          | Trabalha_em                                                                                                                           | DEPARTAMENTO::Tem_docente;                                                                                                            |                                                                                                                                       |
|                            | relationship               | set<ALUNO_POSGRADUACAO> Orientados inverse ALUNO_ POSGRADUACAO::Orientador;                                                           | set<ALUNO_POSGRADUACAO> Orientados inverse ALUNO_ POSGRADUACAO::Orientador;                                                           | set<ALUNO_POSGRADUACAO> Orientados inverse ALUNO_ POSGRADUACAO::Orientador;                                                           | set<ALUNO_POSGRADUACAO> Orientados inverse ALUNO_ POSGRADUACAO::Orientador;                                                           |
|                            | relationship               | set<ALUNO_POSGRADUACAO> POSGRADUACAO::Banca;                                                                                          | set<ALUNO_POSGRADUACAO> POSGRADUACAO::Banca;                                                                                          | Membro_de_banca inverse ALUNO_                                                                                                        |                                                                                                                                       |
|                            | void                       | dar_aumento(in float aumento);                                                                                                        | dar_aumento(in float aumento);                                                                                                        |                                                                                                                                       |                                                                                                                                       |
|                            | void                       | promocao(in string novo_nivel);                                                                                                       | };                                                                                                                                    |                                                                                                                                       |                                                                                                                                       |
| class NOTA                 | class NOTA                 |                                                                                                                                       |                                                                                                                                       |                                                                                                                                       |                                                                                                                                       |
| (                          | extent                     | NOTAS )                                                                                                                               |                                                                                                                                       |                                                                                                                                       |                                                                                                                                       |
| {                          | attribute                  | enum Valores Nota{A,B,C,D,F,I,P} Nota;                                                                                                | enum Valores Nota{A,B,C,D,F,I,P} Nota;                                                                                                |                                                                                                                                       |                                                                                                                                       |
|                            | relationship               | TURMA Turma inverse TURMA::Alunos;                                                                                                    | TURMA Turma inverse TURMA::Alunos;                                                                                                    | TURMA Turma inverse TURMA::Alunos;                                                                                                    |                                                                                                                                       |
|                            | relationship               | ALUNO Aluno inverse ALUNO::Turma_concluida;};                                                                                         | ALUNO Aluno inverse ALUNO::Turma_concluida;};                                                                                         |                                                                                                                                       |                                                                                                                                       |
| class ALUNO extends PESSOA | class ALUNO extends PESSOA | class ALUNO extends PESSOA                                                                                                            |                                                                                                                                       |                                                                                                                                       |                                                                                                                                       |
| (                          | extent                     | ALUNOS )                                                                                                                              |                                                                                                                                       |                                                                                                                                       |                                                                                                                                       |
| {                          | attribute string           | Tipo_aluno;                                                                                                                           |                                                                                                                                       |                                                                                                                                       |                                                                                                                                       |
|                            | attribute                  | DEPARTAMENTO                                                                                                                          | Dep_secund;                                                                                                                           |                                                                                                                                       |                                                                                                                                       |
|                            | relationship               | DEPARTAMENTO Dep_princ inverse DEPARTAMENTO::Tem_aluno; set<NOTA> Turma_concluida inverse NOTA::Aluno;                                | DEPARTAMENTO Dep_princ inverse DEPARTAMENTO::Tem_aluno; set<NOTA> Turma_concluida inverse NOTA::Aluno;                                | DEPARTAMENTO Dep_princ inverse DEPARTAMENTO::Tem_aluno; set<NOTA> Turma_concluida inverse NOTA::Aluno;                                | DEPARTAMENTO Dep_princ inverse DEPARTAMENTO::Tem_aluno; set<NOTA> Turma_concluida inverse NOTA::Aluno;                                |
|                            | relationship               |                                                                                                                                       |                                                                                                                                       |                                                                                                                                       |                                                                                                                                       |
|                            | relationship               | set<TURMA_ATUAL> Matricula_em inverse TURMA_ATUAL::Aluno_matriculado; troca_dep_princ(in string dnome) raises(departamento_invalido); | set<TURMA_ATUAL> Matricula_em inverse TURMA_ATUAL::Aluno_matriculado; troca_dep_princ(in string dnome) raises(departamento_invalido); | set<TURMA_ATUAL> Matricula_em inverse TURMA_ATUAL::Aluno_matriculado; troca_dep_princ(in string dnome) raises(departamento_invalido); | set<TURMA_ATUAL> Matricula_em inverse TURMA_ATUAL::Aluno_matriculado; troca_dep_princ(in string dnome) raises(departamento_invalido); |
|                            | float                      | coeficiente( );                                                                                                                       | coeficiente( );                                                                                                                       | coeficiente( );                                                                                                                       | coeficiente( );                                                                                                                       |
|                            | void                       | matricula(in short nr_turma) raises(turma_invalida);                                                                                  | matricula(in short nr_turma) raises(turma_invalida);                                                                                  | matricula(in short nr_turma) raises(turma_invalida);                                                                                  | matricula(in short nr_turma) raises(turma_invalida);                                                                                  |
|                            | void                       |                                                                                                                                       |                                                                                                                                       |                                                                                                                                       |                                                                                                                                       |
|                            |                            | aloca_nota(in short nr_turma; IN ValorNota nota) raises(turma_invalida,nota_invalida); };                                             | aloca_nota(in short nr_turma; IN ValorNota nota) raises(turma_invalida,nota_invalida); };                                             | aloca_nota(in short nr_turma; IN ValorNota nota) raises(turma_invalida,nota_invalida); };                                             | aloca_nota(in short nr_turma; IN ValorNota nota) raises(turma_invalida,nota_invalida); };                                             |

## class TITULO\_ACADEMICO

Figura 11.10

Esquema ODL poss√≠vel para o banco de dados UNIVERSIDADE da Figura 11.8(b).

{

attribute

string

Faculdade;

attribute

string

Titulo;

attribute

string

Ano; };

## class ALUNO\_POSGRADUACAO

extends

ALUNO

(

extent

DEPARTAMENTOS

{ attribute

set&lt;TITULO\_ACADEMICO&gt;

Titulos;

relationship

DOCENTE Orientador inverse DOCENTE::Orientados;

relationship

set&lt;DOCENTE&gt; Banca inverse DOCENTE::Membro\_de\_banca;

void

aloca\_orientador (in string Unome; in string Pnome)

raises(docente\_invalido);

void

aloca\_membro\_banca (in string Unome; in string Pnome)

raises(docente\_invalido); };

## class DEPARTAMENTO

(

extent

DEPARTAMENTOS

key

Dnome )

{

attribute

string

Dnome;

attribute

string

Dtelefone;

attribute

string

Descritorio;

attribute

string

Faculdade;

attribute

DOCENTE

Diretor;

relationship

set&lt;DOCENTE&gt; Tem\_docente inverse DOCENTE::Trabalha\_em;

relationship

set&lt;ALUNO&gt; Tem\_aluno inverse ALUNO::Dep\_princ;

relationship

set&lt;DISCIPLINA&gt; Oferece inverse DISCIPLINA::Oferecida\_por; };

## class DISCIPLINA

(

extent

DISCIPLINAS

key

Dnr )

{ attribute

string

Dnome;

attribute

string

Dnr;

attribute

string

Descri√ß√£o;

relationship

set&lt;TURMA&gt; Tem\_turma inverse TURMA::Da\_disciplina;

relationship

&lt;DEPARTAMENTO&gt; Oferecido\_por inverse DEPARTAMENTO::Oferece; };

## class TURMA

(

extent

TURMAS )

{ attribute

short

Num\_turma

attribute

string

Ano;

attribute

enum Periodo {Primeiro, Segundo}

Semestre;

relationship

set&lt;NOTA&gt; Alunos inverse Nota::Turma;

relationship

DISCIPLINA Da\_disciplina inverse DISCIPLINA::Tem\_turma; };

class TURMA\_ATUAL extends TURMA

( extent

TURMAS\_ATUAIS )

{ relationship

set&lt;ALUNO&gt; Aluno\_matriculado

inverse ALUNO::Matricula\_em

void

matricular\_aluno(in string Cpf)

raises(aluno\_invalido, turma\_cheia); };

Figura 11.11



|                                   | attribute                         | enum                              | {                                                         |
|-----------------------------------|-----------------------------------|-----------------------------------|-----------------------------------------------------------|
|                                   | attribute                         | struct                            | Ponto {short x, short y} Ponto_referencia;                |
|                                   | float                             | perimetro( );                     | Ponto {short x, short y} Ponto_referencia;                |
|                                   | float                             | area( );                          | Ponto {short x, short y} Ponto_referencia;                |
|                                   | void                              | translacao(in short translacao_x; | Ponto {short x, short y} Ponto_referencia;                |
|                                   | void                              | rotacao(in float angulo_rotacao); | Ponto {short x, short y} Ponto_referencia;                |
| class RECTANGLE : GeometriaObjeto | class RECTANGLE : GeometriaObjeto | class RECTANGLE : GeometriaObjeto | class RECTANGLE : GeometriaObjeto                         |
| ( {                               | extent                            | RETANGULOS                        | ) Ponto {short x, short y} Ponto_referencia; Comprimento; |
|                                   | attribute                         | struct                            | ) Ponto {short x, short y} Ponto_referencia; Comprimento; |
|                                   | attribute                         | short                             | ) Ponto {short x, short y} Ponto_referencia; Comprimento; |
|                                   | attribute                         | short                             | ) Ponto {short x, short y} Ponto_referencia; Comprimento; |
|                                   | attribute                         | float                             | ) Ponto {short x, short y} Ponto_referencia; Comprimento; |
| class TRIANGULO : GeometriaObjeto | class TRIANGULO : GeometriaObjeto | class TRIANGULO : GeometriaObjeto | class TRIANGULO : GeometriaObjeto                         |
| (                                 | extent                            | TRIANGULOS                        | Ponto {short x, short y} Ponto_referencia;                |
| { class                           | attribute                         | struct                            | Ponto {short x, short y} Ponto_referencia;                |
| { class                           | attribute                         | short                             | Ponto {short x, short y} Ponto_referencia;                |
| { class                           | attribute                         | short                             | Ponto {short x, short y} Ponto_referencia;                |
| { class                           | attribute                         | float                             | Ponto {short x, short y} Ponto_referencia;                |
| { class                           | attribute                         | float                             | Ponto {short x, short y} Ponto_referencia;                |
| CIRCULO : GeometriaObjeto         | CIRCULO : GeometriaObjeto         | CIRCULO : GeometriaObjeto         | CIRCULO : GeometriaObjeto                                 |
| (                                 | extent                            | CIRCULOS )                        | Ponto {short x, short y} Ponto_referencia;                |
| {                                 | attribute                         | struct                            | Ponto {short x, short y} Ponto_referencia;                |
| {                                 | attribute                         | short                             | Ponto {short x, short y} Ponto_referencia;                |

Uma ilustra√ß√£o da heran√ßa de interface por meio de  : ' ' . (a) Representa√ß√£o de esquema gr√°fico. (b) Defini√ß√µes de interface e classe correspondentes em ODL.

## 11.4 Projeto conceitual de banco de dados de objeto

## 11.4.1 Diferen√ßas entre o projeto conceitual do BDO e do BDR

A Se√ß√£o 11.4.1 discute como o projeto de banco  de  dados  de  objeto  (BDO)  difere  do  projeto  de banco  de  dados  relacional  (BDR).  A  Se√ß√£o  11.4.2 esbo√ßa um algoritmo de mapeamento que pode ser usado para criar um esquema de BDO, feito de defini√ß√µes de classe ODL do ODMG, com base em um esquema EER conceitual.

Uma das principais diferen√ßas entre o projeto de BDO e BDR √© o modo como os relacionamentos s√£o tratados.  No  BDO,  eles  normalmente  s√£o  tratados como tendo propriedades de relacionamento ou atributos de refer√™ncia que incluem OID(s) dos objetos relacionados. Estes podem ser considerados refer√™ncias  de  OID aos  objetos  relacionados.  Tanto  refe-

r√™ncias  isoladas  quanto  cole√ß√µes  de  refer√™ncias  s√£o permitidas.  As  refer√™ncias  para  um  relacionamento bin√°rio podem ser declaradas em uma √∫nica dire√ß√£o, ou nas duas dire√ß√µes, dependendo dos tipos de acesso esperados. Se declaradas nas duas dire√ß√µes, elas podem ser especificadas como inversas uma da outra, impondo assim o equivalente BDO da restri√ß√£o de integridade referencial do modelo relacional.

No BDR, os relacionamentos entre tuplas (registros) s√£o especificados por atributos com valores que combinam. Estes podem ser considerados refer√™ncias de valor e  s√£o especificados por meio de chaves estrangeiras , que s√£o valores de atributos de chave prim√°ria repetidos em tuplas da rela√ß√£o que referencia. S√£o limitados a serem de √∫nico valor em cada registro, pois atributos multivalorados n√£o s√£o permitidos no modelo relacional b√°sico. Assim, relacionamentos M:N devem ser representados n√£o diretamente, mas como uma rela√ß√£o (tabela) separada, conforme discutimos na Se√ß√£o 9.1.

O  mapeamento  de  relacionamentos  bin√°rios que cont√©m atributos n√£o √© direto nos BDOs, pois o projetista precisa escolher em que dire√ß√£o os atributos devem ser inclu√≠dos. Se eles forem inclu√≠dos nas duas  dire√ß√µes,  ent√£o  haver√°  redund√¢ncia  no  armazenamento, podendo ocasionar dados inconsistentes. Logo, √†s vezes √© prefer√≠vel usar a t√©cnica relacional de cria√ß√£o de uma tabela separada ao criar uma classe separada para representar o relacionamento. Essa t√©cnica tamb√©m pode ser usada para relacionamentos n -√°rios, com grau n &gt; 2.

Outra  √°rea  importante  da  diferen√ßa  entre  o projeto de BDO e BDR √© o modo como a heran√ßa √© tratada. No BDO, essas estruturas s√£o embutidas no modelo, de modo que o mapeamento √© alcan√ßado usando as constru√ß√µes de heran√ßa, como derived (:) e extends . No projeto relacional, conforme discutimos na Se√ß√£o 9.2, existem v√°rias op√ß√µes para escolher, pois n√£o existe uma constru√ß√£o embutida para a heran√ßa no modelo relacional b√°sico. √â importante observar,  por√©m,  que  os  sistemas  objeto-relacional e  relacional estendido est√£o acrescentando recursos para  modelar  essas  constru√ß√µes  diretamente,  bem como para incluir especifica√ß√µes de opera√ß√£o nos tipos de dados abstratos (ver  Se√ß√£o 11.2).

ficar opera√ß√µes durante a fase de projeto para todos os tipos de bancos de dados, isso pode ser adiado no projeto do BDR, pois n√£o √© estritamente exigido at√© a fase de implementa√ß√£o.

Existe  uma  diferen√ßa  filos√≥fica  entre  o  modelo  relacional  e  o  modelo  de  objeto  dos  dados  em rela√ß√£o √† especifica√ß√£o comportamental. O modelo relacional n√£o exige que os projetistas de banco de dados predefinam um conjunto de comportamentos ou opera√ß√µes v√°lidas, enquanto esse √© um requisito impl√≠cito no modelo de objeto. Uma das vantagens alegadas do modelo relacional √© o suporte de consultas e transa√ß√µes ocasionais, ao passo que s√£o contra o princ√≠pio de encapsulamento.

Na pr√°tica, est√° se tornando comum ter equipes de projeto de banco de dados aplicando metodologias  baseadas  em  objeto  nos  est√°gios  iniciais do projeto conceitual, de modo que tanto a estrutura  quanto  o  uso  ou  opera√ß√µes  dos  dados  sejam considerados,  e  uma  especifica√ß√£o  completa  seja desenvolvida  durante  o  projeto  conceitual.  Essas especifica√ß√µes  s√£o  ent√£o  mapeadas  para  esquemas relacionais, restri√ß√µes e artefatos comportamentais, como triggers ou procedimentos armazenados (ver se√ß√µes 5.2 e 13.4).

## 11.4.2 Mapeando um esquema EER para um esquema BDO

√â relativamente simples projetar as declara√ß√µes de tipo das classes de objeto para um SGBDO com base em um esquema EER que n√£o cont√©m nem categorias nem relacionamentos n -√°rios com n &gt; 2. Por√©m, as opera√ß√µes das classes n√£o s√£o especificadas no diagrama EER e devem ser acrescentadas √†s declara√ß√µes de classe ap√≥s o t√©rmino do mapeamento estrutural. Um esbo√ßo do mapeamento de EER para ODL √© o seguinte:

A terceira diferen√ßa importante √© que, no projeto do BDO, √© necess√°rio especificar as opera√ß√µes desde cedo no projeto, pois elas fazem parte das especifica√ß√µes de classe. Embora seja essencial especi-

Etapa 1. Crie uma classe ODL para cada tipo de entidade ou subclasse EER. O tipo da classe ODL deve incluir todos os atributos da classe EER. 38 Atributos multivalorados normalmente s√£o declarados usando os construtores set, bag ou list. 39  Se os valores do atributo multivalorado para um objeto tiverem de ser ordenados, o construtor list √© escolhido; se  duplicatas  forem  permitidas,  o  construtor  bag dever√°  ser  escolhido;  caso  contr√°rio,  o  construtor set √© escolhido. Atributos compostos s√£o mapeados para um construtor de tupla (usando uma declara√ß√£o struct em ODL).

38 Isso implicitamente usa um construtor de tupla no n√≠vel superior da declara√ß√£o de tipo, mas, em geral, o construtor de tupla n√£o √© mostrado de maneira expl√≠cita nas declara√ß√µes de classe ODL.

39 √â preciso haver uma an√°lise melhor do dom√≠nio da aplica√ß√£o para decidir qual construtor usar, pois essa informa√ß√£o n√£o est√° dispon√≠vel no esquema EER.

Declare uma extens√£o para cada classe e especifique quaisquer atributos de chave como chaves da extens√£o. (Isso s√≥ √© poss√≠vel se uma facilidade de extens√£o e declara√ß√µes de restri√ß√£o de chave estiverem dispon√≠veis no SGBDO.)

Etapa 2. Inclua propriedades de relacionamento  ou  atributos  de  refer√™ncia  para  cada relacionamento bin√°rio nas classes ODL que participam do relacionamento.  Estas  podem  ser  criadas  em  uma ou nas duas dire√ß√µes. Se um relacionamento bin√°rio for representado por refer√™ncias nas duas dire√ß√µes, declare as refer√™ncias √†s propriedades de relacionamento que s√£o inversas uma da outra, se tal facilidade existir. 40 Se um relacionamento bin√°rio for representado por uma refer√™ncia em apenas uma dire√ß√£o, declare  a  refer√™ncia  para  que  seja  um  atributo  na classe que referencia, cujo tipo √© o nome da classe referenciada.

Dependendo da raz√£o de cardinalidade do relacionamento  bin√°rio,  as  propriedades  de  relacionamento ou atributos de refer√™ncia podem ser tipos de √∫nico valor ou de cole√ß√£o. Eles ser√£o de √∫nico valor  para  relacionamentos  bin√°rios  nas  dire√ß√µes  1:1 ou N:1; e s√£o tipos de cole√ß√£o (valor de conjunto ou valor de lista 41 ) para relacionamentos na dire√ß√£o 1:N ou M:N. Um modo alternativo de mapear os relacionamentos bin√°rios M:N √© discutido na etapa 7.

Se  houver  atributos  de  relacionamento,  um construtor  de  tupla  ( struct )  pode  ser  usado  para criar uma estrutura na forma &lt; refer√™ncia, atributos de relacionamento&gt; , que pode ser inclu√≠da no lugar do atributo de refer√™ncia. Contudo, isso n√£o permite o uso da restri√ß√£o inversa. Al√©m disso, se essa escolha for representada nas duas dire√ß√µes , os valores de atributo ser√£o representados duas vezes, criando redund√¢ncia.

Etapa 3. Inclua opera√ß√µes apropriadas para cada classe. Estas n√£o est√£o dispon√≠veis no esquema EER e  precisam  ser  acrescentadas  ao  projeto  do  banco de  dados  referenciando  os  requisitos  originais.  Um m√©todo construtor dever√° incluir  o  c√≥digo  de  programa que verifica quaisquer restri√ß√µes que dever√£o existir quando um novo objeto for criado. Um m√©todo destruidor deve verificar quaisquer restri√ß√µes que possam ser violadas quando um objeto for exclu√≠do. Outros m√©todos dever√£o incluir quaisquer outras verifica√ß√µes de restri√ß√£o que sejam relevantes.

o tipo e os m√©todos de sua superclasse no esquema ODL. Seus atributos espec√≠ficos (n√£o herdados), refer√™ncias de relacionamento e opera√ß√µes s√£o especificados, conforme discutimos nas etapas 1, 2 e 3.

Etapa 5. Tipos de entidade fraca podem ser mapeados  da  mesma  maneira  que  os  tipos  de  entidade regulares. Um mapeamento alternativo √© poss√≠vel para tipos de entidade fraca que n√£o participam de quaisquer  relacionamentos,  exceto  seu  relacionamento de identifica√ß√£o.  Estes  podem  ser  mapeados como se fossem atributos multivalorados compostos do tipo de entidade propriet√°rio, usando os construtores set &lt; struct &lt; ... &gt;&gt;  ou list &lt; struct &lt; ... &gt;&gt;.  Os  atributos da entidade fraca s√£o inclu√≠dos na constru√ß√£o struct &lt; ... &gt;, que corresponde a um construtor de tupla. Os atributos s√£o mapeados conforme discutimos nas etapas 1 e 2.

Etapa 6. As categorias (tipos de uni√£o) em um esquema EER s√£o dif√≠ceis de mapear para ODL. √â poss√≠vel criar um mapeamento semelhante ao EER-para-relacional  (ver  Se√ß√£o  9.2),  declarando  uma classe para representar a categoria e definindo relacionamentos 1:1 entre a categoria e cada uma de suas superclasses. Outra op√ß√£o √© usar um tipo de uni√£o , se estiver dispon√≠vel.

Etapa  7. Um  relacionamento n -√°rio  com  grau n &gt; 2 pode ser mapeado para uma classe separada, com refer√™ncias apropriadas a cada classe participante. Essas refer√™ncias s√£o baseadas no mapeamento de um relacionamento 1:N de cada classe que representa um tipo de entidade participante para a classe que representa  o  relacionamento n -√°rio.  Um  relacionamento bin√°rio M:N, especialmente se tiver atributos de relacionamento, tamb√©m pode usar essa op√ß√£o de mapeamento, se for desejado.

Na  Figura  8.10,  o  mapeamento  foi  aplicado a um subconjunto do esquema de banco de dados UNIVERSIDADE no contexto do padr√£o de banco de dados de objeto ODMG. O esquema de objeto mapeado usando a nota√ß√£o ODL √© mostrado na Figura 11.10.

## 11.5 A linguagem de consulta de objeto (OQL - Object Query Language)

Etapa  4. Uma  classe  ODL  que  corresponde  a uma subclasse no esquema EER herda (por extends )

A linguagem de consulta de objeto OQL √© a linguagem proposta para o modelo de objeto ODMG.

40 O padr√£o ODL prov√™ a defini√ß√£o expl√≠cita dos relacionamentos inversos. Alguns produtos de SGBDO podem n√£o oferecer esse suporte; nesses casos, os programadores precisam manter cada relacionamento explicitamente, codificando os m√©todos que atualizam os objetos de forma apropriada.

41 A decis√£o sobre usar set ou list n√£o est√° dispon√≠vel no esquema EER, e precisa ser determinada com base nos requisitos.

Ela foi projetada para trabalhar de perto com as linguagens de programa√ß√£o para as quais um binding ODMG  √©  definido,  como  C++,  Smalltalk  e  Java. Logo, uma consulta OQL embutida em uma dessas linguagens  de  programa√ß√£o  pode  retornar  objetos que combinam com o sistema de tipos dessa linguagem. Al√©m disso, as implementa√ß√µes de opera√ß√µes de classe em um esquema ODMG podem ter seu c√≥digo escrito nessas linguagens de programa√ß√£o. A sintaxe OQL para consultas √© semelhante √† sintaxe da linguagem de consulta do padr√£o relacional, SQL, com recursos adicionais para os conceitos ODMG, como identidade de objeto, objetos complexos, opera√ß√µes, heran√ßa, polimorfismo e relacionamentos.

Na  Se√ß√£o  11.5.1,  discutiremos  a  sintaxe  das consultas OQL simples e o conceito de usar objetos nomeados ou extens√µes como pontos de entrada do banco de dados. Depois, na Se√ß√£o 11.5.2, discutiremos a estrutura dos resultados de consulta e o uso de express√µes de caminho para atravessar relacionamentos  entre  objetos.  Outras  caracter√≠sticas  da OQL para tratamento de identidade de objeto, heran√ßa, polimorfismo e outros conceitos orientados a objeto s√£o discutidos na Se√ß√£o 11.5.3. Os exemplos para ilustrar consultas OQL s√£o baseados no esquema  de  banco  de  dados UNIVERSIDADE dado na Figura 11.10.

## 11.5.1 Consultas em OQL simples, pontos de entrada do banco de dados e vari√°veis de itera√ß√£o

A sintaxe OQL b√°sica √© uma estrutura select ... from ... where ... , assim como para a SQL. Por exemplo, a consulta para recuperar os nomes de todos os departamentos  na  faculdade  de  'Engenharia'  pode ser escrita da seguinte forma:

C0: select

D. Dnome

from D in DEPARTAMENTOS

where D. Faculdade = 'Engenharia';

TAMENTOS √©  do  tipo set&lt;DEPARTAMENTO&gt; ; PESSOAS √© do tipo set&lt;PESSOA&gt; ; DOCENTE √© do tipo set&lt;DOCENTE&gt; ; e assim por diante.

O uso de um nome de extens√£o DEPARTAMENTOS em C0 - como um ponto de entrada refere-se a uma cole√ß√£o persistente de objetos. Sempre que uma cole√ß√£o √© referenciada em uma consulta OQL, devemos definir uma vari√°vel de itera√ß√£o 42 -D em C0 - que percorre cada objeto na cole√ß√£o. Em muitos casos, como em C0, a consulta selecionar√° certos objetos da cole√ß√£o, com base nas condi√ß√µes especificadas na cl√°usula where .  Em C0, somente objetos persistentes D na cole√ß√£o de DEPARTAMENTOS que satisfa√ßam  a  condi√ß√£o D . Faculdade =  'Engenharia' s√£o selecionados para o resultado da consulta. Para cada  objeto  selecionado D ,  o  valor  de D . Dnome √© recuperado no resultado da consulta. Assim, o tipo do resultado para C0 √© bag&lt;string&gt; porque o tipo de cada valor Dnome √© string (embora o resultado real seja  um  set,  pois Dnome √©  um atributo-chave). Em geral, o resultado de uma consulta seria do tipo bag para select ... from ... e do tipo set para select distinct ... from ... , como na SQL (a inclus√£o da palavra-chave distinct elimina duplicatas).

Usando o exemplo em C0, existem tr√™s op√ß√µes sint√°ticas para especificar vari√°veis de itera√ß√£o:

D in DEPARTAMENTOS DEPARTAMENTOS D DEPARTAMENTOS AS

D

Usaremos  a  primeira  constru√ß√£o  em  nossos exemplos. 43

Os  objetos  nomeados  usados  como  pontos  de entrada de banco de dados para consultas OQL n√£o s√£o limitados aos nomes das extens√µes. Qualquer objeto persistente nomeado, n√£o importa se ele se refere a um objeto at√¥mico (√∫nico) ou a um objeto de cole√ß√£o, pode ser usado como um ponto de entrada do banco de dados.

Em geral, um ponto de entrada para o banco de dados √© necess√°rio para cada consulta, que pode ser qualquer objeto  persistente  nomeado .  Para  muitas consultas, o ponto de entrada √© o nome da extent de uma classe. Lembre-se de que o nome da extens√£o √© considerado  o  nome  de  um  objeto  persistente  cujo tipo √© uma cole√ß√£o (na maioria dos casos, um set ) de objetos da classe. Ao examinar os nomes de extens√£o na Figura 11.10, o objeto nomeado DEPAR-

## 11.5.2 Resultados de consulta e express√µes de caminho

Em  geral,  o  resultado  de  uma  consulta  pode ser de qualquer tipo expresso no modelo de objeto ODMG. Uma consulta n√£o precisa seguir a estrutura select ... from ... where ... ; no caso mais simples, qualquer nome persistente por si s√≥ √© uma consulta, cujo resultado √© uma refer√™ncia a esse objeto persistente. Por exemplo, a consulta

42 Isso √© semelhante √†s vari√°veis de tupla que percorrem as tuplas nas consultas SQL.

43 Observe que as duas √∫ltimas op√ß√µes s√£o semelhantes √† sintaxe para especificar vari√°veis de tupla nas consultas SQL.

## C1: DEPARTAMENTOS;

retorna  uma  refer√™ncia  √†  cole√ß√£o  de  todos  os  objetos  persistentes  de DEPARTAMENTO ,  cujo  tipo  √© set&lt;DEPARTAMENTO&gt; .  De modo semelhante, suponha que tenhamos dado (pela opera√ß√£o de v√≠nculo do banco de dados, ver Figura 11.8) um nome persistente CC\_DEPARTAMENTO a um √∫nico objeto DEPARTAMENTO (o departamento de Ci√™ncia da Computa√ß√£o); ent√£o, a consulta

## C1A: CC\_DEPARTAMENTO;

retorna  uma  refer√™ncia  a  esse  objeto  individual  do tipo DEPARTAMENTO. Quando um ponto de entrada for especificado, o conceito de uma express√£o de caminho poder√° ser usado para especificar um caminho aos atributos e objetos relacionados. Uma express√£o de  caminho normalmente come√ßa em um nome de objeto  persistente ,  ou  na  vari√°vel  de  itera√ß√£o  que percorre os objetos individuais em uma cole√ß√£o. Esse nome ser√° seguido por zero ou mais nomes de relacionamento ou nomes de atributo conectados que usam a nota√ß√£o de ponto . Por exemplo, referindo-se ao banco de dados UNIVERSIDADE da Figura 11.10, a seguir est√£o exemplos de express√µes de caminho, que tamb√©m s√£o consultas v√°lidas em OQL:

C2: CC\_DEPARTAMENTO.Diretor;

C2A: CC\_DEPARTAMENTO.Diretor.Nivel;

C2B: CC\_DEPARTAMENTO.Tem\_docente;

A primeira express√£o C2 retorna um objeto do tipo DOCENTE , pois esse √© o tipo do atributo Diretor da classe DEPARTAMENTO . Esta ser√° uma refer√™ncia ao objeto DOCENTE que est√° relacionado ao objeto DEPARTAMENTO, cujo  nome  persistente  √© CC\_DE-PARTAMENTO por meio do atributo Diretor ; ou seja, uma refer√™ncia ao objeto DOCENTE que √© diretor do departamento de Ci√™ncia da Computa√ß√£o. A segunda express√£o C2A √©  semelhante,  exceto  que  retorna  o Nivel desse objeto DOCENTE (a cadeira de Ci√™ncia da Computa√ß√£o) em vez da refer√™ncia ao objeto; logo, o tipo retornado por C2A √© string, que √© o tipo de dado para o atributo Nivel da classe DOCENTE.

As express√µes de caminho C2 e C2A retornam valores isolados porque os atributos Diretor (de DEPARTAMENTO) e Nivel (de DOCENTE) s√£o ambos valores isolados e aplicados a um √∫nico objeto. A terceira express√£o, C2B, √©  diferente;  ela  retorna  um  objeto do  tipo set&lt;DOCENTE&gt; mesmo  quando  aplicada  a um √∫nico objeto, pois esse √© o tipo do relacionamento Tem\_docente da classe DEPARTAMENTO .  A  cole√ß√£o retornada incluir√° refer√™ncias a todos os objetos DOCENTE que est√£o relacionados ao objeto DEPARTAMENTO, cujo  nome  persistente  √© CC\_DEPARTA-MENTO por  meio  do  relacionamento Tem\_docente;

ou seja, as refer√™ncias a todos os objetos DOCENTE que est√£o trabalhando no departamento de Ci√™ncia da Computa√ß√£o. Agora, para retornar as pontua√ß√µes do corpo docente de Ci√™ncia da Computa√ß√£o, n√£o podemos escrever

## C3': CC\_DEPARTAMENTO.Tem\_docente.Nivel;

porque n√£o est√° claro se o objeto retornado seria do tipo set&lt;string&gt; ou bag&lt;string&gt; (sendo o √∫ltimo mais prov√°vel, pois v√°rios membros do corpo docente podem compartilhar o mesmo n√≠vel). Devido a esse tipo de  problema  de  ambiguidade,  a  OQL  n√£o  permite express√µes como a C3 '. Em vez disso, √© preciso usar uma vari√°vel de itera√ß√£o  sobre  quaisquer  cole√ß√µes, como em C3A ou C3B , a seguir:

C3A:

select D .Nivel

from

D

in

CC\_DEPARTAMENTO.Tem\_

docente;

C3B: select distinct F .Nivel from D in docente;

CC\_DEPARTAMENTO.Tem\_

Aqui, C3A retorna bag&lt;string&gt; (valores de n√≠veis duplicados aparecem no resultado), enquanto C3B retorna set&lt;string&gt; (duplicatas s√£o eliminadas por meio da palavra-chave distinct) . Tanto C3A quanto C3B ilustram como uma vari√°vel de itera√ß√£o pode ser definida na cl√°usula from para percorrer uma cole√ß√£o restrita especificada na consulta. A vari√°vel D em C3A e C3B varia  sobre  os  elementos  da  cole√ß√£o CC\_DEPARTA-MENTO.Tem\_docente, que √© do tipo set&lt;DOCENTE&gt; e inclui apenas corpo docente, e o qual √© membro do departamento de Ci√™ncia da Computa√ß√£o.

Em geral, uma consulta OQL pode retornar um resultado com uma estrutura complexa especificada na pr√≥pria consulta e utilizar a palavra-chave struct . Considere os seguintes exemplos:

## C4: CC\_DEPARTAMENTO.Diretor.Orientados;

C4A: select struct ( nome: struct (ultimo\_nome:

A .nome.Unome, primeiro\_nome: A .nome.Pnome),

titulo:( select struct (tit:

T.Titulo, ano: T .Ano,

faculdade:

T .faculdade)

from T in A .Titulos ))

from S in CC\_DEPARTAMENTO.Diretor. Orientados;

Aqui,  a C4 √©  direta,  retornando  um  objeto  do tipo set&lt;ALUNO\_POSGRADUACAO&gt; como seu resultado. Essa √© a cole√ß√£o de alunos formados que s√£o orientados pelo diretor do departamento de Ci√™ncia

da Computa√ß√£o. Agora, suponha que seja necess√°ria uma consulta para recuperar o nome e sobrenome desses alunos de p√≥s-gradua√ß√£o, mais a lista de t√≠tulos anteriores de cada um. Isso pode ser escrito como na C4A, em que a vari√°vel A percorre a cole√ß√£o de alunos de p√≥s-gradua√ß√£o orientados pelo diretor, e a vari√°vel T percorre os t√≠tulos de cada aluno A . O tipo do resultado de C4A √© uma cole√ß√£o de struct s (de primeiro n√≠vel) onde cada struct tem dois componentes: nome e titulo. 44

- O componente nome √©  um outro struct composto  de ultimo\_nome e primeiro\_nome ,  cada  um sendo uma √∫nica cadeia. O componente de t√≠tulos √© definido por uma consulta embutida e por si s√≥ √© uma  cole√ß√£o  de  outros  structs  (segundo  n√≠vel), cada um com tr√™s componentes de string: tit , ano e faculdade .

Observe que OQL √© ortogonal com rela√ß√£o √† especifica√ß√£o de express√µes de caminho. Ou seja, atributos, relacionamentos e nomes de opera√ß√£o (m√©todos) podem ser usados um no lugar do outro dentro das express√µes de caminho, desde que o sistema de tipo da OQL n√£o seja comprometido. Por exemplo, pode-se escrever as seguintes consultas para recuperar a m√©dia de notas de todos os alunos s√™nior que est√£o se formando em Ci√™ncia da Computa√ß√£o, com o resultado ordenado por coeficiente, e dentro disso por sobrenome e primeiro nome.

C5A: select struct

( ultimo\_nome: A primeiro\_nome: A

.nome.Unome, .nome.Pnome,

coef: A .coeficiente )

from

S in CC\_DEPARTAMENTO.

Tem\_aluno

where order by

A .Tipo\_aluno = 'senior'

media desc , ultimo\_nome asc , primeiro\_nome asc ;

Q5B:  select struct

( ultimo\_nome: A .nome.Unome, primeiro\_nome: A .nome.Pnome, coef: A .coeficiente )

from

A in ALUNOS

where

A .Dep\_princ.Dnome = 'Ciencia da Computacao' and

A .Tipo\_aluno = 'senior' coef desc , ultimo\_nome asc , primeiro\_nome asc ;

order by

os alunos por meio do relacionamento Tem\_aluno, ao passo que C5B procura a extens√£o ALUNOS para localizar todos os alunos que est√£o se formando nesse departamento. Observe como os nomes de atributo, nomes de relacionamento e nomes de opera√ß√£o (m√©todo) s√£o todos usados de maneira intercambi√°vel (ortogonal) nas express√µes de caminho: coeficiente √© uma opera√ß√£o; Dep\_princ e Tem\_aluno s√£o relacionamentos; e Tipo\_aluno, Nome, Dnome, Unome e Pnome s√£o atributos. A implementa√ß√£o da opera√ß√£o coeficiente calcula a coeficiente de pontos e retorna seu valor como um tipo de ponto flutuante para cada ALUNO selecionado.

A cl√°usula order  by √©  semelhante  √†  constru√ß√£o SQL correspondente, e especifica em que ordem o resultado da consulta deve ser exibido. Logo, a cole√ß√£o retornada por uma consulta com uma cl√°usula order by √© do tipo list .

## 11.5.3 Outros recursos da OQL

Especificando vis√µes como consultas nomeadas . O mecanismo de vis√£o (ou view ) em OQL utiliza o conceito de consulta nomeada . A palavra-chave define √© usada para especificar um identificador da consulta nomeada, que precisa ser um nome exclusivo entre todos os objetos nomeados, nomes de classe, nomes de m√©todo e nomes de fun√ß√£o no esquema. Se o identificador tem o mesmo nome de uma consulta nomeada existente, ent√£o a nova defini√ß√£o substitui a anterior. Uma vez definida, a consulta √© persistente at√© que seja redefinida ou exclu√≠da. Uma vis√£o tamb√©m pode ter par√¢metros (argumentos) em sua defini√ß√£o.

Por exemplo, a vis√£o V1 a seguir define uma consulta  nomeada Tem\_dep\_secund para  recuperar  o conjunto de objetos para alunos que tenham departamento secund√°rio:

V1: define Tem\_dep\_secund(Nome\_dep) as select A from A in ALUNOS where A .Dep\_secund.Dnome = Nome\_dep;

A C5A usou o ponto de entrada nomeado CC\_DE-PARTAMENTO para localizar diretamente a refer√™ncia ao departamento de Ci√™ncia da Computa√ß√£o e depois

Como o esquema ODL na Figura 11.10 s√≥ forneceu  um  atributo Minors\_in unidirecional  para  um ALUNO, podemos usar a vis√£o acima para representar seu inverso sem ter de definir um relacionamento explicitamente. Esse tipo de vis√£o pode ser utilizado para representar relacionamentos inversos que n√£o dever√£o ser usados com frequ√™ncia. O usu√°rio agora pode utilizar a vis√£o citada para escrever consultas como

Tem\_dep\_secund ('Ciencia da Computacao');

44 Como dissemos anteriormente, struct corresponde ao construtor de tupla discutido na Se√ß√£o 11.1.3.

que retornariam uma bag de alunos que tenham departamento secund√°rio de Ci√™ncia da Computa√ß√£o. Observe  que,  na  Figura  11.10,  definimos Tem\_dep\_princ como um relacionamento expl√≠cito, possivelmente porque se espera que seja usado com mais frequ√™ncia.

Extraindo elementos isolados de cole√ß√µes singulares . Uma  consulta  OQL,  em  geral,  retorna  uma cole√ß√£o como seu resultado, tal como uma bag, set (se distinct for especificado) ou list (se a cl√°usula order by for usada).  Se  o  usu√°rio  solicitar  que  uma  consulta  retorne apenas um √∫nico elemento, existe um operador element na OQL que garante o retorno de um √∫nico elemento E de uma cole√ß√£o singular C , que cont√©m apenas um elemento. Se C tiver mais de um elemento ou se for vazia, ent√£o o operador de elemento lan√ßa uma exce√ß√£o . Por exemplo, C6 retorna a √∫nica refer√™ncia de objeto ao departamento de Ci√™ncia da Computa√ß√£o:

DEPARTAMENTOS .Dnome = 'Ciencia da

C6: element ( select D from D in where D Computacao' );

Como um nome de departamento √© √∫nico entre todos os departamentos, o resultado deve ser um departamento. O tipo do resultado √© D : DEPARTAMENTO.

Operadores  de  cole√ß√£o  (fun√ß√µes  de  agrega√ß√£o, quantificadores) . Como  muitas  express√µes  de  consulta especificam cole√ß√µes como seu resultado, diversos operadores foram definidos para serem aplicados a tais cole√ß√µes. Estes incluem operadores de agrega√ß√£o, bem como condi√ß√£o de membro e quantifica√ß√£o (universal e existencial) sobre uma cole√ß√£o.

Os  operadores  de  agrega√ß√£o  ( min, max, count, sum, avg ) operam sobre uma cole√ß√£o. 45  O operador count retorna um tipo inteiro. Os demais operadores de agrega√ß√£o ( min, max, sum, avg ) retornam o mesmo tipo do tipo do operando da cole√ß√£o. Vejamos dois exemplos. A consulta C7 retorna o n√∫mero de alunos quem tenham departamento secund√°rio em Ci√™ncia da Computa√ß√£o e C8 retorna o coeficiente m√©dio de todos os formandos em Ci√™ncia da Computa√ß√£o.

C7: count ( A in T em\_dep\_princ('Ciencia da Computa cao'));

C8: avg ( select

A .Coeficiente

from

A in ALUNOS

where

A .Dep\_princ.Dnome = 'Ciencia da

Computacao' and

A .Tipo\_aluno = 'Senior');

Observe que as opera√ß√µes de agrega√ß√£o podem ser aplicadas a qualquer cole√ß√£o do tipo apropriado e usa-

45 Estes correspondem √†s fun√ß√µes de agrega√ß√£o em SQL.

das em qualquer parte de uma consulta. Por exemplo, a consulta para recuperar todos os nomes de departamento que possuem mais de cem alunos como departamento principal pode ser escrita como em C9:

<!-- formula-not-decoded -->

As express√µes de condi√ß√£o de membro e quantifica√ß√£o retornam um tipo booleano - ou seja, verdadeiro ou falso. Considere que V seja uma vari√°vel; C, uma express√£o de cole√ß√£o; B, uma express√£o do tipo Boolean (ou seja, uma condi√ß√£o booleana); e E, um elemento do tipo dos elementos na cole√ß√£o C . Ent√£o:

- ( E in C ) retorna verdadeiro se o elemento E √© um membro da cole√ß√£o C .

( for all V in C : B ) retorna verdadeiro se todos os elementos da cole√ß√£o C satisfizerem B .

( exists V in C : B )  retorna verdadeiro se houver pelo menos um elemento em C satisfazendo B .

Para ilustrar a condi√ß√£o de membro, suponha que queiramos recuperar os nomes de todos os alunos que completaram a disciplina chamada 'Sistemas de Bancos de Dados I'. Isso pode ser escrito como em C10 , em que a consulta aninhada retorna a cole√ß√£o de nomes de disciplina que cada ALUNO A completou, e a condi√ß√£o de membro retorna verdadeira se 'Sistemas de Bancos de Dados I' estiver na cole√ß√£o para determinado ALUNO A :

C10: select A.nome.Unome, A.nome.Pnome from A in ALUNOS where 'Sistemas de Bancos de Dados I' in ( select C.Da\_disciplina. from C in A.Turma\_concluida);

C10 tamb√©m ilustra um modo mais simples de especificar a cl√°usula select das consultas que retornam uma cole√ß√£o de structs. O tipo retornado por C10 √© bag &lt; struct(string, string) &gt;.

Tamb√©m √© poss√≠vel escrever consultas que retornam resultados verdadeiro/falso.  Como exemplo, vamos  supor  que  haja  um  objeto  nomeado,  chamado JEREMIAS , do tipo ALUNO. Ent√£o, a consulta C11 responde √† seguinte pergunta: Jeremias tem departamento secund√°rio em Ci√™ncia da Computa√ß√£o? De modo semelhante, C12 responde √† pergunta: Todos os alunos formados em Ci√™ncia da Computa√ß√£o s√£o orientados pelo corpo docente de Ci√™ncia da Computa√ß√£o? Tanto C11 quanto C12 retornam verdadeira ou falsa, que s√£o interpretadas como respostas sim ou n√£o para as perguntas acima:

C11: JEREMIAS in Tem\_dep\_secund('Ciencia da Computacao');

C12: for all G in

( select A

from A in ALUNOS\_POSGRADUA- CAO

where A .Dep\_princ.Dnome = 'Ciencia da Computacao' )

: G .Orientador in CC\_DEPARTA- Tem\_docente;

MENTO.

Observe  que  a  consulta C12 tamb√©m  ilustra como a heran√ßa de atributo, relacionamento e opera√ß√£o se aplica √†s consultas. Embora A seja um objeto de itera√ß√£o que percorre a extent ALUNOS\_POSGRA-DUACAO , podemos escrever A .Dep\_princ porque o relacionamento dep\_princ √© herdado por ALUNO\_POS-GRADUACAO de ALUNO por  meio  de extends (ver Figura 11.10). Por fim, para ilustrar o quantificador exists , a consulta C13 responde √† seguinte pergunta: Algum formado em Ci√™ncia da Computa√ß√£o tem um COEFICIENTE 4,0? Aqui, novamente, a opera√ß√£o coeficiente √© herdada por ALUNO\_POSGRADUACAO de ALUNO por meio de extends.

C13:

exists

G

in

( select A

from

A in ALUNOS\_POSGRADUACAO

where

A.

Dep\_princ.Dnome

= 'Ciencia da

Computacao' )

: G. Coeficiente = 4;

Express√µes de cole√ß√£o ordenada (indexada). Conforme discutimos na Se√ß√£o 11.3.3, as cole√ß√µes que s√£o  listas  e  arrays  possuem  opera√ß√µes  adicionais, tais como recuperar o  -√©simo, primeiro e √∫ltimo elei mentos. Al√©m disso, existem opera√ß√µes para extrair uma subcole√ß√£o e  concatenar  duas  listas.  Logo,  as express√µes de consulta que envolvem listas ou arrays podem  invocar  essas  opera√ß√µes.  Ilustraremos  algumas dessas opera√ß√µes usando exemplos de consulta. A C14 recupera o sobrenome do membro do corpo docente que ganha o maior sal√°rio:

C14: first ( select

struct (docnome: D.nome.

Unome, salario: D.Salario)

from

D in DOCENTE

order by

salario desc );

C14 ilustra o uso do operador first sobre uma cole√ß√£o de lista que cont√©m os sal√°rios dos membros do corpo docente classificados em ordem decrescente. Portanto, o primeiro elemento nessa lista classificada cont√©m o membro do corpo docente com o sal√°rio mais alto. Essa consulta considera que apenas um membro do corpo docente ganha o sal√°rio m√°ximo. A pr√≥xima consulta, C15 , recupera os tr√™s melhores coeficientes do departamento de Ci√™ncia da Computa√ß√£o.

C15: ( select

struct ( ultimo\_nome: A. nome. Unome primeiro\_nome: , A. nome. Pnome , coeficiente: A. Coeficiente

)

from

A in CC\_DEPARTAMENTO.Tem\_alunos

order by

coef desc ) [0:2] ;

A consulta select-from-order-by retorna uma lista de alunos de Ci√™ncia da Computa√ß√£o ordenados pelo COEFICIENTE em ordem decrescente. O primeiro elemento de uma cole√ß√£o ordenada tem uma posi√ß√£o de √≠ndice 0, de modo que a express√£o [0:2] retorna uma lista com o primeiro, o segundo e o terceiro elementos do resultado de select ... from ... order by ... .

- O operador de agrupamento . A  cl√°usula group by em OQL, embora semelhante √† cl√°usula correspondente em SQL, oferece refer√™ncia expl√≠cita √† cole√ß√£o de objetos dentro de cada grupo ou parti√ß√£o . Primeiro, vamos dar um exemplo e, depois, descrever a forma geral dessas consultas.

C16 recupere o n√∫mero de alunos em cada departamento. Nessa consulta, os alunos s√£o agrupados na mesma parti√ß√£o (grupo) se tiverem o mesmo nome do departamento; ou seja, o mesmo valor para A .Dep\_princ.Dnome :

C16: ( select

struct ( Nome\_dep, numero\_de\_

alunos: count partition ( ) )

from

A in ALUNOS

group by

Nome\_dep: A

.Dep\_princ.Dnome;

- O  resultado  da  especifica√ß√£o  de  agrupamento  √©  do  tipo set&lt;struct(Nome\_dep:  string, partition: bag&lt;struct ( S :ALUNO&gt; )&gt;), que  cont√©m  uma  struct para cada grupo ( partition ), o qual tem dois componentes: o valor do atributo de agrupamento ( Nome\_ dep ) e a bag dos objetos ALUNO no grupo ( partition ). A cl√°usula select retorna o atributo de agrupamento (nome do departamento) e uma contagem do n√∫mero de elementos em cada parti√ß√£o (ou seja, o n√∫mero de alunos  em  cada  departamento),  em  que partition √© a palavra-chave usada para se referir a cada parti√ß√£o.  O  tipo  de  resultado  da  cl√°usula select √© set&lt;struct(Nome\_dep:  string, numero\_de\_aluno:  integer )&gt;. Em geral, a sintaxe para a cl√°usula group by √©

<!-- formula-not-decoded -->

onde F 1 : E 1 , F 2 : E 2 , ..., F k : E k √© uma lista de atributos de particionamento (agrupamento) e cada especifica√ß√£o de atributo de particionamento F i : E i define  um nome de atributo (campo) F i e  uma express√£o E i .  O resultado da aplica√ß√£o do agrupamento (especificado na cl√°usula group by ) √© um conjunto de estruturas:

set&lt;struct( F 1 : T 1 , F 2 : T 2 , ..., F k : T k , partition: bag&lt; B &gt;)&gt;

onde T i √© o tipo retornado pela express√£o E i , partition √© um nome de campo distinto (uma palavra-chave) e B √© uma estrutura cujos campos s√£o as vari√°veis de itera√ß√£o ( A em C16 ) declaradas na cl√°usula from que tem o tipo apropriado.

Assim como em SQL, uma cl√°usula having pode ser utilizada para filtrar os conjuntos particionados (ou  seja,  selecionar  apenas  alguns  dos  grupos  com base nas condi√ß√µes do grupo). Em C17 ,  a  consulta anterior √© modificada para ilustrar a cl√°usula having (e tamb√©m mostra a sintaxe simplificada para a cl√°usula select ). C17 recupera, para cada departamento com mais de cem alunos, o coeficiente de seus formandos. A cl√°usula having em C17 seleciona apenas as parti√ß√µes (grupos) que possuem mais de cem elementos  (ou  seja,  departamentos  com  mais  de  cem alunos).

C17:

select

nome\_dep, media\_coef: avg ( select P .coeficiente from P in partition )

from

A in ALUNOS

group by

nome\_dep: A. Dep\_princ.Dnome count partition ( ) &gt; 100;

having

Observe que a cl√°usula select de C17 retorna o coeficiente m√©dio dos alunos na parti√ß√£o. A express√£o

## select P. Coeficiente from P in partition

retorna uma bag de coeficientes de aluno para essa parti√ß√£o. A cl√°usula from declara uma vari√°vel de itera√ß√£o P sobre a cole√ß√£o da parti√ß√£o, que √© do tipo bag&lt;struct( A : ALUNO )&gt;.  Ent√£o,  a  express√£o  de  caminho P .media √© usada para acessar o coeficiente de cada aluno na parti√ß√£o.

## 11.6 Vis√£o geral de binding da linguagem C++ no padr√£o ODMG

O binding da linguagem C++ especifica como as constru√ß√µes  ODL  s√£o  mapeadas  para  constru√ß√µes C++. Isso √© feito por meio de uma biblioteca de classes  C++  que  oferece  classes  e  opera√ß√µes  que  implementam  as  constru√ß√µes  da  ODL.  Uma  linguagem de manipula√ß√£o de objeto (OML) √© necess√°ria para especificar  como  os  objetos  de  banco  de  dados  s√£o recuperados e manipulados em um programa C++, e isso est√° baseado na sintaxe e sem√¢ntica da linguagem

Bancos de dados de objeto e objeto-relacional de  programa√ß√£o  C++.  Al√©m  dos  bindings  da  ODL/ OML, um conjunto de constru√ß√µes, chamado pragmas f√≠sicas , √© definido para permitir que o programador tenha algum controle sobre aspectos de armazenamento f√≠sico,  como  o  agrupamento  de  objetos,  a utiliza√ß√£o de √≠ndices e o gerenciamento de mem√≥ria.

A biblioteca de classes acrescentada √† C++ para o padr√£o ODMG usa o prefixo d\_ para declara√ß√µes de classe que lidam com conceitos de banco de dados. 46 O objetivo √© que o programador pense que apenas uma linguagem est√° sendo usada, e n√£o duas linguagens  separadas.  Para  o  programador  se  referir  aos objetos  do  banco  de  dados  em  um  programa,  uma classe D\_Ref&lt; T &gt; √© definida para cada classe de banco de  dados T no  esquema.  Logo,  vari√°veis  de  programa  do tipo D\_Ref&lt; T &gt; podem se referir tanto a objetos persistentes quanto a transientes de classe T .

Para utilizar os v√°rios tipos embutidos no modelo de objeto do ODMG, como tipos de cole√ß√£o, v√°rias  classes  gen√©ricas  (template  class)  s√£o  especificadas na biblioteca. Por exemplo, uma classe abstrata D\_Objeto&lt; T &gt;  especifica  as  opera√ß√µes  a  serem herdadas por todos os objetos. De modo semelhante, uma classe abstrata D\_Collection&lt; T &gt; especifica as opera√ß√µes das cole√ß√µes. Essas classes n√£o s√£o instanci√°veis,  mas  somente  especificam  as  opera√ß√µes  que podem ser herdadas por todos os objetos e por objetos de cole√ß√£o, respectivamente. Uma classe gen√©rica (template class) √© especificada para cada tipo de cole√ß√£o; estas incluem D\_Set &lt; T &gt;, D\_List &lt; T &gt;, D\_Bag &lt; T &gt;, D\_Varray &lt; T &gt; e D\_Dictionary &lt; T &gt;, e correspondem aos tipos de cole√ß√£o no modelo de objeto (ver Se√ß√£o 11.3.1). Assim, o programador pode criar classes de tipos como D\_Set&lt;D\_Ref&lt;ALUNO&gt;&gt; , cujas inst√¢ncias seriam conjuntos de refer√™ncias a objetos ALUNO , ou D\_Set&lt;string&gt; ,  cujas  inst√¢ncias  seriam  conjuntos  de strings. Al√©m disso, uma classe d\_Iterator corresponde √† classe Iterator do modelo de objeto.

A ODL C++ permite que um usu√°rio especifique as classes de um esquema de banco de dados usando as constru√ß√µes da C++, bem como as constru√ß√µes oferecidas pela biblioteca de banco de dados do objeto. Para especificar os tipos de dados dos atributos, 47 tipos b√°sicos como d\_Short (inteiro curto), d\_Ushort (inteiro  curto  sem  sinal), d\_Long (inteiro  longo)  e d\_Float (n√∫mero de ponto flutuante) s√£o fornecidos. Al√©m dos tipos de dados b√°sicos, v√°rios tipos literais estruturados  s√£o  fornecidos  para  corresponderem aos tipos literais estruturados do modelo de objeto ODMG. Estes  incluem d\_String, d\_Interval, d\_Date, d\_Time e d\_Timestamp (ver Figura 11.5(b)).

46 Presume-se que d\_ indique classes de database (banco de dados).

47 Ou seja, vari√°veis membro na terminologia da programa√ß√£o orientada a objeto.

Para especificar relacionamentos, a palavra-chave rel\_ √©  usada  no  prefixo  dos  nomes  de  tipo;  por exemplo, ao escrever

- d\_Rel\_Ref&lt;DEPARTAMENTO, Tem\_aluno&gt; Dep\_ princ;

na classe ALUNO, e

- d\_Rel\_Set&lt;ALUNO, Dep\_princ&gt; Tem\_aluno;

na classe DEPARTAMENTO , estamos declarando que Dep\_princ e Tem\_aluno s√£o propriedades de relacionamento inversas uma √† outra e, portanto, representam um relacionamento bin√°rio 1:N entre DEPARTAMENTO e ALUNO .

Para a OML, o binding sobrecarrega a opera√ß√£o new de modo que pode ser usado para criar objetos persistentes ou transientes. Para criar objetos persistentes, deve-se fornecer o nome do banco de dados e o nome persistente do objeto. Por exemplo, ao escrever

<!-- formula-not-decoded -->

o programador cria um objeto persistente nomeado, do tipo ALUNO , no banco de dados BD1 , com nome persistente Jo√£o\_Silva .  Outra  opera√ß√£o, delete\_ob-ject ( ), pode ser utilizada para excluir objetos. A modifica√ß√£o de objeto √© feita pelas opera√ß√µes (m√©todos) definidas em cada classe pelo programador.

O binding C++ tamb√©m permite a cria√ß√£o de extens√µes usando a classe de biblioteca d\_Extent. Por exemplo, ao escrever

## D\_Extent&lt;PESSOA&gt; TODAS\_PESSOAS(BD1);

o  programador  criaria  um  objeto  de  cole√ß√£o  nomeado TODAS\_PESSOAS -  cujo  tipo  seria D\_ Set&lt;PESSOA &gt; - no banco de dados BD1, que manteria objetos persistentes do tipo PESSOA. Por√©m, as restri√ß√µes de chave n√£o s√£o aceitas no binding C++, e quaisquer verifica√ß√µes de chave devem ser programadas nos m√©todos da classe. 48  Al√©m disso, o v√≠nculo com C++ n√£o admite persist√™ncia por meio da acessibilidade. O objeto precisa ser declarado estaticamente para ser persistente no momento em que √© criado.

## Resumo

Neste cap√≠tulo, come√ßamos na Se√ß√£o 11.1 com uma vis√£o geral dos conceitos utilizados nos bancos de dados de objeto, e discutimos como esses conceitos foram derivados dos princ√≠pios gerais da orienta√ß√£o a objeto. Os conceitos principais que discutimos foram: identidade e identificadores de objeto; encapsulamento de opera√ß√µes; heran√ßa; estrutura complexa de objetos por meio de ani- nhamento de construtores de tipo; e como os objetos se tornam persistentes. Depois, na Se√ß√£o 11.2, mostramos como  muitos  desses  conceitos  foram  incorporados  ao modelo relacional e ao padr√£o SQL, levando √† funcionalidade expandida do banco de dados relacional. Esses sistemas eram chamados de bancos de dados objeto-relacional.

Depois, discutimos o padr√£o ODMG 3.0 para bancos de dados de objeto. Come√ßamos descrevendo as diversas constru√ß√µes do modelo de objeto na Se√ß√£o 11.3. Os v√°rios tipos embutidos, como Object, Collection, Iterator, set, list, e  assim  por  diante,  foram  descritos  por suas interfaces, que especificam as opera√ß√µes embutidas de cada tipo. Esses tipos embutidos s√£o o alicerce sobre o qual a linguagem de defini√ß√£o de objeto (ODL) e a linguagem de consulta de objeto (OQL) s√£o baseadas. Tamb√©m descrevemos a diferen√ßa entre objetos, que possuem um identificador de objeto, e literais, que s√£o valores sem OID. Os usu√°rios podem declarar classes para sua aplica√ß√£o  que  herdam  opera√ß√µes  das  interfaces  embutidas apropriadas. Dois tipos de propriedades podem ser especificados em uma classe definida pelo usu√°rio - atributos e relacionamentos - al√©m das opera√ß√µes que podem ser  aplicadas  a  objetos  da  classe.  A  ODL  permite  que os usu√°rios especifiquem interfaces e classes, e dois tipos diferentes de heran√ßa - heran√ßa de interface atrav√©s de ':'  e  heran√ßa  de  classe  atrav√©s  de extends . Uma  classe pode ter uma extens√£o e chaves. Uma descri√ß√£o da ODL foi vista em seguida, e um exemplo de esquema para o banco de dados UNIVERSIDADE foi usado para ilustrar as constru√ß√µes da ODL.

Ap√≥s  a  descri√ß√£o  do  modelo  de  objeto  ODMG, abordamos  uma  t√©cnica  geral  para  projetar  esquemas de banco de dados de objeto na Se√ß√£o 11.4. Discutimos como os bancos de dados de objeto diferem dos bancos de dados relacionais em tr√™s √°reas principais: refer√™ncias para representar relacionamentos, inclus√£o de opera√ß√µes e heran√ßa. Por fim, mostramos como mapear um projeto de banco de dados conceitual no modelo EER para as constru√ß√µes dos bancos de dados de objeto.

Na Se√ß√£o  11.5,  apresentamos  uma  vis√£o  geral  da linguagem de consulta de objeto (OQL). A OQL segue o conceito de ortogonalidade na constru√ß√£o de consultas, significando que uma opera√ß√£o pode ser aplicada ao resultado de outra opera√ß√£o, desde que o tipo do resultado seja do tipo de entrada correto para a opera√ß√£o. A sintaxe da OQL segue muitas das constru√ß√µes da SQL, mas inclui conceitos adicionais, como express√µes de caminho, heran√ßa, m√©todos, relacionamentos e cole√ß√µes. Mostramos alguns exemplos de como usar a OQL no banco de dados UNIVERSIDADE.

Em seguida, na Se√ß√£o 11.6, fizemos um r√°pido apanhado do binding da linguagem C++, que estende as declara√ß√µes de sua classe com os construtores de tipo ODL, mas  permite  a  integra√ß√£o  transparente  da  C++  com  o SGBDO.

48 S√≥ fornecemos uma breve vis√£o geral do binding C++. Para mais detalhes, consulte Cattell e Barry, eds. (2000), Cap. 5.

Em 1997, a Sun aprovou o API ODMG ( API -Application Program Interface ODMG) . A O2 Technologies foi a primeira empresa a oferecer um SGBD compat√≠vel com ODMG. Muitos fornecedores de SGBDO, incluindo a Object Design (agora eXcelon), a Gemstone Systems, a POET Software e a Versant Object Technology, aprovaram o padr√£o ODMG.

## Perguntas de revis√£o

- 11.1. Quais s√£o as origens da abordagem orientada a objeto?
- 11.2. Quais  caracter√≠sticas  principais  um  OID  deve possuir?
- 11.3. Discuta sobre os diversos construtores de tipo. Como eles s√£o usados para criar estruturas de objeto complexas?
- 11.4. Discuta  o  conceito  de  encapsulamento  e  diga como ele √© utilizado  para  criar  tipos  de  dados abstratos.
- 11.5. Explique  o  que  significam  os  seguintes  termos na terminologia de banco de dados orientado a objeto: m√©todo , assinatura , mensagem , cole√ß√£o , extens√£o .
- 11.6. Qual √© o relacionamento entre um tipo e seu subtipo em uma hierarquia de tipos? Qual √© a restri√ß√£o imposta sobre as extens√µes correspondentes aos tipos na hierarquia de tipos?
- 11.7. Qual  √©  a  diferen√ßa  entre  objetos  persistentes  e transientes?  Como  a  persist√™ncia  √©  tratada  nos sistemas t√≠picos de banco de dados OO?
- 11.8. Qual √© a diferen√ßa entre a heran√ßa normal, a heran√ßa m√∫ltipla e a heran√ßa seletiva?
- 11.9. Discuta o conceito de polimorfismo/sobrecarga de operador.
- 11.10. Discuta como cada um dos seguintes recursos √© realizado na SQL 2008: identificador de objeto, heran√ßa de tipo, encapsulamento de opera√ß√µes e estruturas de objeto complexas .
- 11.11. No modelo relacional tradicional, a cria√ß√£o de uma tabela definia tanto o tipo de tabela (esquema  ou  atributos)  quanto  a  pr√≥pria  tabela (extens√£o ou conjunto de tuplas atuais). Como esses  conceitos  podem  ser  separados  na  SQL 2008?
- 11.12. Descreva as regras de heran√ßa na SQL 2008.
- 11.13. Quais s√£o as diferen√ßas e semelhan√ßas entre os objetos e literais no modelo de objeto ODMG?
- 11.14. Liste  as  opera√ß√µes  b√°sicas  das  seguintes  interfaces  embutidas  do  modelo  de  objeto  ODMG: Object, Collection, Iterator, Set, List, Bag, Array e Dictionary.
- 11.15. Descreva as literais estruturadas embutidas do modelo  de  objeto  ODMG  e  as  opera√ß√µes  de cada uma.
- 11.16. Quais s√£o as diferen√ßas e semelhan√ßas das propriedades de atributo e relacionamento de uma classe (at√¥mica) definida pelo usu√°rio?
- 11.17. Quais s√£o as diferen√ßas e semelhan√ßas da heran√ßa de classe por extends e a heran√ßa de interface por ':' no modelo de objeto ODMG?
- 11.18. Discuta  como  a  persist√™ncia  √©  especificada  no modelo de objeto ODMG no binding C++.
- 11.19. Por que os conceitos de extens√µes e chaves s√£o importantes nas aplica√ß√µes de banco de dados?
- 11.20. Descreva os seguintes conceitos de OQL: pontos de entrada de banco de dados , express√µes de caminho , vari√°veis de itera√ß√£o , consultas nomeadas ( vis√µes ), fun√ß√µes de agrega√ß√£o , agrupamento e quantificadores .
- 11.21. O  que  significa  a  ortogonalidade  de  tipo  da OQL?
- 11.22. Discuta os princ√≠pios gerais por tr√°s do binding C++ do padr√£o ODMG.
- 11.23. Quais s√£o as principais diferen√ßas entre projetar um banco de dados relacional e um banco de dados de objeto?
- 11.24. Descreva as etapas do algoritmo para o projeto de banco de dados de objeto pelo mapeamento EER para OO.

## Exerc√≠cios

- 11.25. Converta  o  exemplo  de GEOMETRIA\_OBJE-TO dado na Se√ß√£o 11.1.5 da nota√ß√£o funcional para a nota√ß√£o dada na Figura 11.2, que distingue atributos e opera√ß√µes. Use a palavra-chave INHERIT para mostrar que uma classe herda de outra classe.
- 11.26. Compare a heran√ßa no modelo EER (ver Cap√≠tulo 8) com a heran√ßa no modelo OO, descrito na Se√ß√£o 11.1.5.
- 11.27. Considere  o  esquema  EER UNIVERSIDADE da Figura 8.10. Pense em quais opera√ß√µes s√£o necess√°rias para os tipos de entidade/classes no esquema. N√£o considere opera√ß√µes construtoras e destruidoras.
- 11.28. Considere o esquema ER EMPRESA da Figura 7.2.  Pense  em  quais  opera√ß√µes  s√£o  necess√°rias para  os  tipos  de  entidade/classes  no  esquema. N√£o considere opera√ß√µes construtoras e destruidoras.
- 11.29. Projete um esquema OO para uma aplica√ß√£o de banco de dados em que voc√™ esteja interessado. Construa um esquema EER para a aplica√ß√£o e depois crie as classes correspondentes em  ODL.  Especifique  uma  s√©rie  de  m√©todos para cada classe, e depois especifique consultas  em  OQL para sua aplica√ß√£o de banco de dados.

11.30. Considere o banco de dados AEROPORTO descrito no Exerc√≠cio 8.21. Especifique uma s√©rie de opera√ß√µes/m√©todos que voc√™ acredita que deveriam ser adequados √† aplica√ß√£o. Especifique as classes e m√©todos ODL para o banco de dados.

- 11.31. Mapeie  o  esquema  ER EMPRESA da  Figura 7.2 para classes ODL.  Inclua m√©todos apropriados para cada classe.
- 11.32. Especifique em OQL as consultas dos exerc√≠cios dos cap√≠tulos 7 e 8 que se aplicam ao banco de dados EMPRESA.

11.33. Usando  mecanismos  de  busca  e  outras  fontes, determine  at√©  que  ponto  os  diversos  produtos comerciais  de  SGBDO  s√£o  compat√≠veis  com  o padr√£o ODMG 3.0.

## Bibliografia selecionada

Os conceitos de banco de dados orientado a objeto s√£o uma combina√ß√£o de conceitos das linguagens de programa√ß√£o OO e dos sistemas de banco de dados e modelos de dados conceituais. Diversos livros-texto descrevem as linguagens de programa√ß√£o OO - por exemplo, Stroustrup (1997) para C++, e Goldberg e Robson (1989) para Smalltalk. Livros de Cattell (1994) e Lausen e Vossen (1997) descrevem os conceitos de banco de dados  OO.  Outros  livros  sobre  modelos  OO  incluem uma descri√ß√£o detalhada do SGBDOO desenvolvido na Microelectronic Computer Corporation, chamado Orion,  e  relacionados  aos  t√≥picos  de  OO  por  Kim  e Lochovsky (1989). Bancilhon et al. (1992) descrevem a hist√≥ria da cria√ß√£o do SGBDOO O2 com uma discuss√£o detalhada das decis√µes de projeto e implementa√ß√£o de linguagem. Dogac et al. (1994) oferecem uma discuss√£o profunda sobre t√≥picos de banco de dados OO por especialistas em um workshop da OTAN.

H√° uma vasta bibliografia sobre bancos de dados OO, de  modo  que  s√≥  podemos  oferecer  uma  amostra representativa  aqui.  A  edi√ß√£o  de  outubro  de  1991  da CACM e a edi√ß√£o de dezembro de 1990 da IEEE Computer descrevem os conceitos e sistemas de banco de dados OO. Dittrich (1986) e Zaniolo et al. (1986) analisam os conceitos b√°sicos dos modelos de dados OO. Um artigo inicial sobre a implementa√ß√£o de sistema de banco de  dados  OO  √©  o  de  Baroody  e  DeWitt  (1981).  Su  et al. (1988) apresentam um modelo de dados OO que foi usado em aplica√ß√µes de CAD/CAM. Gupta e Horowitz (1992) discutem aplica√ß√µes de OO para CAD, Gerenciamento de Redes e outras √°reas. Mitschang (1989) esten- de  a  √°lgebra  relacional  para  abranger  objetos  complexos. Linguagens de consulta e interfaces gr√°ficas com o usu√°rio para OO s√£o descritas em Gyssens et al. (1990), Kim (1989), Alashqur et al. (1989), Bertino et al. (1992), Agrawal et al. (1990) e Cruz (1992).

O Object-Oriented  Manifesto de  Atkinson  et  al. (1990) √© um artigo interessante que relata sobre a posi√ß√£o de um painel de especialistas com rela√ß√£o aos recursos obrigat√≥rios e opcionais do gerenciamento de banco de  dados  OO.  O  polimorfismo  nos  bancos  de  dados  e nas  linguagens  de  programa√ß√£o  OO  s√£o  discutidos  em Osborn (1989), Atkinson e Buneman (1987) e Danforth e Tomlinson (1988). A identidade de objeto √© discutida em Abiteboul e Kanellakis (1989). Linguagens de programa√ß√£o OO para bancos de dados s√£o discutidas em Kent (1991). Restri√ß√µes de objeto s√£o discutidas em Delcambre et al. (1991) e Elmasri, James e Kouramajian (1993). Autoriza√ß√£o e seguran√ßa em bancos de dados OO s√£o examinados em Rabitti et al. (1991) e Bertino (1992).

Cattell e Barry (2000) descrevem o padr√£o ODMG 3.0, que √© descrito neste cap√≠tulo. Cattell et al. (1993) e Cattell et al. (1997) descrevem as vers√µes anteriores do padr√£o. Bancilhon e Ferrari (1995) oferecem uma apresenta√ß√£o  tutorial  dos  aspectos  importantes  do  padr√£o ODMG. V√°rios livros descrevem a arquitetura Corba por exemplo, Baker (1996).

O sistema O2 √© descrito em Deux et al. (1991), e Bancilhon et al. (1992) incluem uma lista de refer√™ncias a outras publica√ß√µes que descrevem v√°rios aspectos do O2. O modelo O2 foi formalizado em Velez et al. (1989). O sistema ObjectStore √© descrito em Lamb et al. (1991). Fishman et al. (1987) e Wilkinson et al. (1990) discutem o  Iris,  um  SGBD  orientado  a  objeto  desenvolvido  nos laborat√≥rios da Hewlett-Packard.

Maier et al. (1986) e Butterworth et al. (1991) descrevem o projeto do GEM-STONE. O sistema ODE, desenvolvido na AT&amp;T Bell Labs, √© descrito em Agrawal e  Gehani  (1989).  O  sistema  ORION  desenvolvido  no MCC √© descrito em Kim et al. (1990). Morsi et al. (1992) descrevem um ambiente de testes OO.

Cattell (1991) analisa conceitos de bancos de dados relacional e de objeto, e discute v√°rios prot√≥tipos de sistemas de banco de dados baseados em objeto e relacional estendido. Alagic (1997) indica discrep√¢ncias entre o modelo de dados ODMG e seus bindings de linguagem, propondo algumas solu√ß√µes. Bertino e Guerrini (1998) prop√µem uma extens√£o do modelo ODMG para dar suporte a objetos compostos. Alagic (1999) apresenta v√°rios modelos de dados pertencentes √† fam√≠lia ODMG.



## XML: Extensible Markup Language

M uitas aplica√ß√µes de com√©rcio eletr√¥nico (e-commerce) e outras da Internet oferecem interfaces Web para acessar informa√ß√µes armazenadas em um ou mais bancos de dados. Esses bancos de dados normalmente s√£o conhecidos como fontes de dados . √â comum usar arquiteturas cliente/servidor de duas e tr√™s camadas para aplica√ß√µes da Internet (ver Se√ß√£o 2.5). Em alguns casos, outras varia√ß√µes do modelo cliente/ servidor s√£o usadas. O e-commerce e outras aplica√ß√µes de banco de dados da Internet s√£o projetadas para interagir com o usu√°rio por meio de interfaces Web que exibem p√°ginas Web. O m√©todo comum de especificar o conte√∫do e a formata√ß√£o das p√°ginas Web √© com o  uso  de documentos  de  hipertexto .  Existem  v√°rias linguagens para escrever esses documentos, sendo que a mais comum √© a HTML ( Hypertext Markup Language ). Embora seja bastante usada para formata√ß√£o e estrutura de documentos da Web, ela n√£o √© adequada para especificar dados estruturados que s√£o extra√≠dos de bancos de dados. Uma nova linguagem - a saber, XML ( Extensible Markup Language ) - surgiu como padr√£o para estrutura√ß√£o e troca de dados pela Web. A XML pode ser usada para oferecer informa√ß√µes sobre a estrutura e o significado dos dados nas p√°ginas Web, em vez de apenas especificar como elas s√£o formatadas para exibi√ß√£o na tela. Os aspectos de formata√ß√£o  s√£o  especificados  separadamente  -  por exemplo, usando uma linguagem de formata√ß√£o como a XSL ( Extensible Stylesheet Language )  ou uma linguagem de transforma√ß√£o como a XSLT ( Extensible Stylesheet Language for Transformations , ou simplesmente XSL Transformations ). Recentemente, a XML tamb√©m foi proposta como um poss√≠vel modelo para armazenamento e recupera√ß√£o de dados, embora apenas alguns sistemas de banco de dados experimentais, baseados em XML nessa linguagem, tenham sido desenvolvidos at√© o momento.

A HTML b√°sica √© √∫til para gerar p√°ginas Web est√°ticas ,  com  texto  fixo  e  outros  objetos,  mas  a maioria das aplica√ß√µes de e-commerce exige p√°ginas Web que oferecem recursos interativos com o usu√°rio. Por exemplo, considere o caso de um cliente de companhia a√©rea que deseja verificar a informa√ß√£o de hora de chegada e port√£o de determinado voo. O usu√°rio pode inserir informa√ß√µes como uma data e n√∫mero de voo em certos campos de formul√°rio da p√°gina Web. O programa da Web precisa, primeiro, submeter uma consulta ao banco de dados da companhia a√©rea para recuperar essa informa√ß√£o, e depois exibi-la. Essas p√°ginas Web, onde parte da informa√ß√£o √© extra√≠da de bancos de dados e outras fontes de dados, s√£o chamadas p√°ginas Web din√¢micas ,  pois os dados extra√≠dos e exibidos a cada vez ser√£o para diferentes voos e datas.

Neste  cap√≠tulo,  vamos  nos  concentrar  na  descri√ß√£o do modelo de dados XML e suas linguagens associadas,  e  como  os  dados  extra√≠dos  dos  bancos de  dados  relacionais  podem  ser  formatados  como documentos XML para serem trocados pela Web. A Se√ß√£o 12.1 discute a diferen√ßa entre dados estruturados, semiestruturados e n√£o estruturados. A Se√ß√£o 12.2 apresenta o modelo de dados da XML, que √© baseado em estruturas de √°rvore (hier√°rquicas), em compara√ß√£o com as estruturas planas do modelo de dados  relacional.  Na  Se√ß√£o  12.3,  verificamos  a  estrutura dos documentos XML e as linguagens para especificar  a  estrutura  desses  documentos,  como DTD ( Document Type Definition )  e  XML Schema. A Se√ß√£o 12.4 mostra o relacionamento entre a XML e os bancos de dados relacionais. A Se√ß√£o 12.5 descreve  algumas  das  linguagens  associadas  √†  XML, como XPath e XQuery. A Se√ß√£o 12.6 discute como os dados extra√≠dos dos bancos de dados relacionais

podem ser formatados como documentos XML. Por fim, apresentamos um resumo do cap√≠tulo.

## 12.1 Dados estruturados, semiestruturados e n√£o estruturados

A informa√ß√£o armazenada nos bancos de dados √© conhecida como dados estruturados porque √© representada em um formato estrito. Por exemplo, cada registro em uma tabela de banco de dados relacional como cada uma das tabelas no banco de dados EMPRESA da Figura 3.6 - segue o mesmo formato dos outros registros nessa tabela. Para dados estruturados,  √©  comum  projetar  cuidadosamente  o  esquema de banco de dados usando t√©cnicas como as descritas  nos  cap√≠tulos 7 e 8 a fim de definir a estrutura do banco de dados. O SGBD ent√£o verifica para ter certeza de que todos os dados seguem as estruturas e restri√ß√µes especificadas no esquema.

No entanto, nem todos os dados s√£o coletados e inseridos em bancos de dados estruturados projetados cuidadosamente. Em algumas aplica√ß√µes, os dados s√£o coletados de uma maneira casual antes que se saiba como ser√£o armazenados e gerenciados. Esses dados podem ter uma estrutura, mas nem toda a informa√ß√£o coletada ter√° a estrutura id√™ntica. Alguns atributos podem ser compartilhados entre as diversas entidades, mas outros podem existir apenas em algumas entidades. Al√©m disso, atributos adicionais podem ser introduzidos em alguns dos itens de dados mais novos a qualquer momento, e n√£o existe esquema predefinido. Esse tipo de dados √© conhecido como dados semiestruturados . Diversos modelos de dados foram  introduzidos  para  representar  dados  semiestruturados, geralmente com base no uso de estruturas de dados de √°rvore ou grafo, em vez das estruturas do modelo relacional plano.

A principal  diferen√ßa  entre  dados  estruturados e  semiestruturados diz respeito a como as constru√ß√µes do esquema (como os nomes de atributos, relacionamentos e tipos de entidade) s√£o tratadas. Nos dados  semiestruturados,  a  informa√ß√£o  do  esquema √© misturada com os valores dos dados, j√° que cada objeto de dado pode ter atributos diferentes que n√£o s√£o conhecidos antecipadamente. Logo, esse tipo de dados √†s vezes √© chamado de dados autodescritivos . Considere o exemplo a seguir. Queremos coletar uma lista de refer√™ncias bibliogr√°ficas relacionadas a certo projeto de pesquisa. Algumas delas podem ser livros ou relat√≥rios t√©cnicos, outras podem ser artigos de pesquisa em jornais ou eventos de confer√™ncia, e ainda  outras  podem  se  referir  a  edi√ß√µes  completas de jornal ou atas de confer√™ncia. Nitidamente, cada uma pode ter diferentes atributos e diversos tipos de informa√ß√£o. At√© para o mesmo tipo de refer√™ncia digamos, artigos de confer√™ncia -, podemos ter diferentes informa√ß√µes. Por exemplo, uma cita√ß√£o de artigo pode ser bastante completa, com todas as informa√ß√µes sobre nomes de autor, t√≠tulo, eventos, n√∫meros de p√°gina, e assim por diante, enquanto outra cita√ß√£o pode n√£o ter toda a informa√ß√£o dispon√≠vel. Novos tipos de fontes bibliogr√°ficas podem aparecer no futuro - por exemplo, refer√™ncias a p√°ginas Web ou tutoriais da confer√™ncia -, e estes podem ter novos atributos que os descrevem.

Os dados semiestruturados podem ser exibidos como um grafo direcionado, como mostra a Figura

Figura 12.1



Representando dados semiestruturados como um grafo.

12.1.  A  informa√ß√£o  exibida  corresponde  a  alguns dos  dados  estruturados  mostrados  na  Figura  3.6. Como podemos ver, esse modelo √© um pouco semelhante ao modelo de objeto (ver Se√ß√£o 11.1.3) em sua capacidade de representar objetos complexos e estruturas aninhadas. Na Figura 12.1, os r√≥tulos ou marcas (labels ou tags) nas arestas direcionadas representam os nomes de esquema: os nomes de atributos , tipos de objeto (ou tipos de entidade ou classes ) e relacionamentos . Os n√≥s internos representam objetos individuais ou atributos compostos. Os n√≥s de folha representam valores de dados reais de atributos simples (at√¥micos).

Existem duas diferen√ßas principais entre o modelo semiestruturado e o modelo de objeto que discutimos no Cap√≠tulo 11:

- 1. A informa√ß√£o do esquema - nomes de atributos, relacionamentos e classes (tipos de objeto) no modelo semiestruturado √© misturado com  os  objetos  e  seus  valores  de  dados  na mesma estrutura de dados.
- 2. No  modelo  semiestruturado,  n√£o  existe  requisito para um esquema predefinido ao qual os objetos de dados precisam se adequar, embora seja poss√≠vel definir um esquema, se necess√°rio.

Al√©m de dados estruturados e semiestruturados, existe uma terceira categoria, conhecida como dados n√£o estruturados porque existe indica√ß√£o muito limitada sobre o tipo de dados. Um exemplo t√≠pico √© um documento de texto que cont√©m informa√ß√µes incorporadas a ele. As p√°ginas Web em HTML que  cont√™m  alguns  dados  s√£o  consideradas  dados n√£o  estruturados.  Considere  parte  de  um  arquivo HTML, mostrado na Figura 12.2. O texto que aparece entre os sinais &lt; ... &gt; √© uma tag HTML . Uma tag com uma barra, &lt;/...&gt;, indica uma tag de fim , que  representa  o  encerramento  do  efeito  de  uma tag de in√≠cio correspondente. As tags marcam o documento 1  a fim de instruir um processador HTML sobre como exibir o texto entre uma tag de in√≠cio e uma tag de fim correspondente. Portanto, as tags especificam  a  formata√ß√£o  do  documento,  e  n√£o  o significado dos diversos elementos de dados no documento. As tags HTML especificam informa√ß√µes, como tamanho de fonte e estilo (negrito, it√°lico, e assim por diante), cores, n√≠veis de cabe√ßalho nos documentos etc. Algumas tags oferecem estrutura√ß√£o de texto nos documentos, como na especifica√ß√£o de lista numerada ou n√£o numerada, ou de tabela. At√©

mesmo essas tags de estrutura√ß√£o especificam que os dados textuais embutidos devem ser exibidos de certa maneira, em vez de indicar o tipo de dado representado na tabela.

A HTML usa um grande n√∫mero de tags predefinidas, que servem para especificar uma s√©rie de comandos  para  formata√ß√£o  de  documentos  Web para exibi√ß√£o. As tags de in√≠cio e fim especificam o intervalo de texto a ser formatado por cada comando. Estes s√£o alguns exemplos das tags mostradas na Figura 12.2:

- ¬Ñ As tags &lt; HTML &gt; ...  &lt; /HTML &gt; especificam os limites do documento.
- ¬Ñ A informa√ß√£o de cabe√ßalho do documento -dentro das tags &lt; HEAD &gt; ... &lt; /HEAD &gt; - especifica diversos comandos que ser√£o usados em outra parte do documento. Por exemplo, ela pode especificar diversas fun√ß√µes de script em uma linguagem como JavaScript ou PERL, ou certos estilos de formata√ß√£o (fontes, estilos de par√°grafo,  estilos  de  cabe√ßalho,  e  assim  por diante) que podem ser utilizados no documento. Ela tamb√©m pode especificar um t√≠tulo para indicar para que serve o arquivo HTML, e outras  informa√ß√µes  semelhantes  que  n√£o  ser√£o exibidas como parte do documento.
- ¬Ñ O corpo do documento - especificado dentro das tags &lt; BODY &gt; ... &lt; /BODY &gt; - inclui o texto  do  documento  e  as  tags  de  marca√ß√£o que especificam como o texto deve ser formatado e exibido. Tamb√©m pode incluir refer√™ncias a outros objetos, como imagens, v√≠deos, mensagens de voz e outros documentos.
- ¬Ñ As tags &lt; H1 &gt; ... &lt; /H1 &gt; especificam que o texto  deve  ser  exibido  como  um  cabe√ßalho  de n√≠vel 1. Existem muitos n√≠veis de cabe√ßalho (&lt; H2 &gt;,  &lt; H3 &gt;,  e  assim  por  diante),  cada  um exibindo texto em um formato de cabe√ßalho proeminente.
- ¬Ñ As  tags  &lt; TABLE &gt;  ...  &lt; /TABLE &gt;  especificam que o texto seguinte deve ser exibido como uma tabela. Cada linha de tabela √© delimitada por tags &lt; TR &gt; ... &lt; /TR &gt;, e os elementos de dados individuais da tabela, dentro de uma linha, s√£o exibidos dentro de tags &lt; TD &gt; ... &lt; / TD &gt;. 2
- ¬Ñ Algumas tags podem ter atributos , que aparecem dentro da tag de in√≠cio e descrevem propriedades adicionais da tag. 3

1 √â por isso que ela √© conhecida como linguagem de marca√ß√£o de hipertexto

2 &lt;TR&gt; significa table row (linha da tabela) e &lt;TD&gt; significa table data (dado da tabela).

3 √â assim que o termo atributo √© usado em linguagens de marca√ß√£o de documento, que diferem do modo como √© usado nos modelos de banco de dados.

```
<HTML> <HEAD> ... </HEAD> <BODY> <H1>Listta de projetos da empresa e os funcion√°rios em cada projeto</H1> <H2>O projeto ProdutoX:</H2> <TABLE width='100%' border=0 cellpadding=0 cellspacing=0> <TR> <TD width='50%'><FONT size='2' face='Arial'>Jo√£o Silva:</FONT></TD> <TD>32,5 horas por semana</TD> </TR> <TR> <TD width='50%'><FONT size='2' face='Arial'>Joice Leite:</FONT></TD> <TD>20,0 horas por semana</TD> </TR> </TABLE> <H2>O projeto ProdutoY:</H2> <TABLE width='100%' border=0 cellpadding=0 cellspacing=0> <TR> <TD width='50%'><FONT size='2' face='Arial'>Jo√£o Silva:</FONT></TD> <TD>7,5 horas por semana</TD> </TR> <TR> <TD width='50%'><FONT size='2' face='Arial'>Joice Leite:</FONT></TD> <TD>20,0 horas por semana</TD> </TR> <TR> <TD width= '50%'><FONT size='2' face='Arial'>Fernando Wong:</FONT></TD> <TD>10,0 horas por semana</TD> </TR> </TABLE> ... </BODY> </HTML>
```

Figura 12.2

Parte de um documento HTML representando dados n√£o estruturados.

Na  Figura  12.2,  a  tag  de  in√≠cio  &lt; TABLE &gt;  tem quatro atributos que descrevem diversas caracter√≠sticas da tabela. As tags de in√≠cio &lt; TD &gt; e &lt; FONT &gt; seguintes t√™m um e dois atributos, respectivamente.

A HTML tem um n√∫mero muito grande de tags predefinidas,  e  livros  inteiros  s√£o  dedicados  a  descrever como us√°-las. Se projetados corretamente, os documentos HTML podem ser formatados de modo que  os  humanos  consigam  entender  facilmente  seu conte√∫do,  e  sejam  capazes  de  navegar  pelos  docu- mentos Web resultantes. Por√©m, os documentos de texto HTML fonte s√£o muito dif√≠ceis de interpretar automaticamente  por programas  de  computador , pois  eles  n√£o  incluem  informa√ß√µes  de  esquema  sobre o tipo de dado nos documentos. √Ä medida que o com√©rcio eletr√¥nico e outras aplica√ß√µes da Internet se tornam cada vez mais automatizadas, est√° se tornando essencial a capacidade de trocar documentos Web entre diversos sites de computador e interpretar seu  conte√∫do de maneira autom√°tica. Essa necessi-

dade foi um dos motivos que levaram ao desenvolvimento da XML. Al√©m disso, uma vers√£o extens√≠vel da HTML, chamada XHTML, foi desenvolvida para permitir que os usu√°rios estendessem as tags da HTML para  diferentes  aplica√ß√µes,  permitindo  que um arquivo XHTML seja interpretado pelos programas de processamento XML padr√£o. Nossa discuss√£o focalizar√° apenas a XML.

O exemplo da Figura 12.2 ilustra uma p√°gina HTML est√°tica , pois toda a informa√ß√£o a ser exibida est√° escrita explicitamente como um texto fixo no arquivo  HTML.  Em  muitos  casos,  algumas  informa√ß√µes a serem exibidas podem ser extra√≠das de um banco de dados. Por exemplo, os nomes de projeto e os funcion√°rios que trabalham em cada um deles podem ser extra√≠dos do banco de dados da Figura 3.6 por meio da consulta SQL apropriada. Podemos querer  usar  as  mesmas  tags  de  formata√ß√£o  HTML para exibir cada projeto e os funcion√°rios que trabalham nele, mas podemos querer mudar os projetos em particular (e funcion√°rios) que est√£o sendo exibidos. Por exemplo, podemos querer ver uma p√°gina Web exibindo a informa√ß√£o para ProjetoX e,  mais tarde, uma p√°gina exibindo a informa√ß√£o para o ProjetoY . Embora as duas p√°ginas sejam exibidas usando as mesmas tags de formata√ß√£o HTML, os itens de dados reais exibidos ser√£o diferentes. Essas p√°ginas Web s√£o chamadas de din√¢micas porque as partes dos dados da p√°gina podem ser diferentes toda vez que ela √© exibida, embora a apar√™ncia da tela seja a mesma.

## 12.2 Modelo de dados hier√°rquico (em √°rvore) da XML

Agora,  vamos  apresentar  o  modelo  de  dados usado em XML. O objeto b√°sico em XML √© o documento XML. Dois conceitos de estrutura√ß√£o principais s√£o usados para construir um documento XML: elementos e atributos . √â importante observar que o termo atributo em XML n√£o √© usado da mesma maneira que na terminologia de banco de dados, mas sim como √© usado em linguagens de descri√ß√£o de documento  como  HTML e  SGML. 4   Os  atributos  em XML oferecem informa√ß√µes  adicionais  que  descrevem elementos, conforme veremos. Existem conceitos adicionais na XML, como entidades, identificadores e refer√™ncias, mas primeiro vamos nos concentrar na descri√ß√£o de elementos e atributos para mostrar a ess√™ncia do modelo XML.

&lt;?xml version= '1.0' standalone='yes'?&gt;

&lt;Projetos&gt;

&lt;Projeto&gt;

&lt;Nome&gt;ProdutoX&lt;/Nome&gt;

&lt;Numero&gt;1&lt;/Numero&gt;

&lt;Localizacao&gt;Santo\_Andre&lt;/Localizacao&gt;

&lt;Dept\_nr&gt;5&lt;/Dept\_nr&gt;

&lt;Trabalhador&gt;

&lt;Cpf&gt;12345678966&lt;/Cpf&gt;

&lt;Ultimo\_nome&gt;Silva&lt;/Ultimo\_nome&gt;

&lt;Horas&gt;32,5&lt;/Horas&gt;

&lt;/Trabalhador&gt;

&lt;Trabalhador&gt;

&lt;Cpf&gt;45345345376&lt;/Cpf&gt; &lt;Horas&gt;20,0&lt;/Horas&gt;

&lt;Primeiro\_nome&gt;Joice&lt;/Primeiro\_nome&gt;

&lt;/Trabalhador&gt;

&lt;/Projeto&gt;

&lt;Projeto&gt;

&lt;Nome&gt;ProdutoY&lt;/Nome&gt;

&lt;Numero&gt;2&lt;/Numero&gt;

&lt;Localizacao&gt;Itu&lt;/Localizacao&gt;

&lt;Dept\_nr&gt;5&lt;/Dept\_nr&gt;

&lt;Trabalhador&gt;

&lt;Cpf&gt;12345678966&lt;/Cpf&gt;

&lt;Horas&gt;7,5&lt;/Horas&gt;

&lt;/Trabalhador&gt;

&lt;Trabalhador&gt;

&lt;Cpf&gt;45345345376&lt;/Cpf&gt; &lt;Horas&gt;20,0&lt;/Horas&gt;

&lt;/Trabalhador&gt;

&lt;Trabalhador&gt;

&lt;Cpf&gt;33344555587&lt;/Cpf&gt;

&lt;Horas&gt;10,0&lt;/Horas&gt;

&lt;/Trabalhador&gt;

&lt;/Projeto&gt;

...

&lt;/Projetos&gt;

Figura 12.3

Um elemento XML complexo, chamado &lt;Projeto&gt;.

A Figura 12.3 mostra um exemplo de elemento XML chamado &lt; Projeto &gt;. Assim como na HTML, os elementos  s√£o  identificados  em  um  documento  por sua tag de in√≠cio e tag de fim. Os nomes de tag s√£o delimitados por sinais &lt; ... &gt;, e as tags de fim s√£o identificadas ainda por uma barra, &lt;/ ... &gt;. 5

4 A SGML ( standard generalized markup language ) √© uma linguagem mais geral para descrever documentos e oferece capacidades para especificar novas tags. Por√©m, ela √© mais complexa do que a HTML e a XML.

5 Os caracteres &lt; e &gt; s√£o caracteres reservados, assim como o &amp;, o ap√≥strofo (') e a aspa simples ('). Para inclu√≠-los no texto de um documento, eles precisam ser codificados com escapes, como &amp;lt;, &amp;gt;, &amp;amp;, &amp;apos;, e &amp;quot;, respectivamente.

Elementos complexos s√£o constru√≠dos com base em  outros  elementos  hierarquicamente,  enquanto elementos  simples cont√™m  valores  de  dados.  Uma diferen√ßa importante entre XML e HTML √© que os nomes de tag XML s√£o definidos para descrever o significado  dos  elementos  de  dados  no  documento, em vez de descrever como o texto deve ser exibido. Isso possibilita processar os elementos de dados no documento XML de maneira autom√°tica pelos programas de computador. Al√©m disso, os nomes de tag (elemento) XML podem ser definidos em outro documento, conhecido como documento de esquema , para dar um significado sem√¢ntico aos nomes de tag que  podem  ser  trocados  entre  v√°rios  usu√°rios.  Em HTML, todos os nomes de tag s√£o predefinidos e fixos; e por isso eles n√£o s√£o extens√≠veis.

√â f√°cil ver a correspond√™ncia entre a representa√ß√£o textual da XML mostrada na Figura 12.3 e a estrutura de √°rvore mostrada na Figura 12.1. Na representa√ß√£o de √°rvore, os n√≥s internos representam elementos complexos, enquanto os n√≥s de folha representam elementos simples. √â por isso que o modelo XML √© conhecido como um modelo de √°rvore ou um modelo hier√°rquico . Na Figura 12.3, os elementos simples s√£o aqueles com nomes de tag &lt;Nome&gt;, &lt;Numero&gt;, &lt;Localizacao&gt;, &lt;Dept\_nr&gt;, &lt;Cpf&gt;, &lt;Ulti-mo\_nome&gt;, &lt;Primeiro\_nome&gt; e &lt;Horas&gt;. Os elementos complexos s√£o aqueles com nomes de tag &lt;Projetos&gt;, &lt;Projeto&gt; e &lt;Trabalhador&gt;. Em geral, n√£o existe limite sobre os n√≠veis de aninhamento dos elementos.

√â  poss√≠vel  caracterizar  tr√™s  tipos  principais  de documentos XML:

- ¬Ñ Documentos XML centrados em dados. Esses documentos  possuem  muitos  itens  de dados  pequenos  que  seguem  uma  estrutura espec√≠fica  e,  portanto,  podem  ser  extra√≠dos de um banco de dados estruturado. Eles s√£o formatados como documentos XML a fim de troc√°-los  pela  Web  ou  exibi-los  nela.  Estes normalmente seguem um esquema predefinido , que define os nomes de tag.
- ¬Ñ Documentos XML centrados no documento. Estes  s√£o  documentos  com  grande  quantidade  de  texto,  como  artigos  de  not√≠cias  ou livros.  H√°  poucos  ou  nenhum  elemento  de dado estruturado nesses documentos.
- ¬Ñ Documentos XML h√≠bridos. Esses documentos  podem  ter  partes  que  cont√™m  dados  estruturados e outras partes que s√£o predominantemente  textuais  ou  n√£o  estruturadas.  E podem ou n√£o ter um esquema predefinido.

Documentos XML que n√£o seguem um esquema predefinido de nomes de elemento e estrutura de √°rvo- re correspondente s√£o conhecidos como documentos XML sem esquema . √â importante observar que os documentos XML centrados nos dados podem ser considerados dados semiestruturados ou estruturados, conforme definido na Se√ß√£o 12.1. Se um documento XML obedece a um esquema XML predefinido ou DTD (ver Se√ß√£o 12.3), ent√£o o documento pode ser considerado dados estruturados .  Al√©m disso, a XML permite documentos que n√£o obedecem a qualquer esquema. Estes  seriam  considerados dados  semiestruturados e s√£o documentos XML sem esquema . Quando o valor do atributo standalone em um documento XML √© yes , como na primeira linha da Figura 12.3, o documento √© independente e sem esquema.

Os atributos XML geralmente s√£o usados de uma maneira  semelhante  √†  da  HTML  (ver  Figura  12.2), a saber, para descrever propriedades e caracter√≠sticas dos elementos (tags) nas quais eles aparecem. Tamb√©m √© poss√≠vel usar atributos XML para manter os valores  de  elementos  de  dados  simples;  por√©m,  isso n√£o costuma ser recomendado. Uma exce√ß√£o a essa regra se d√° em casos que precisam referenciar outro elemento em outra parte do documento XML. Para fazer isso, √© comum usar valores de atributo em um elemento  como  refer√™ncias.  Isso  √©  semelhante  ao conceito de chaves estrangeiras nos bancos de dados relacionais, e √© um modo de contornar o modelo hier√°rquico  estrito  que  o  modelo  de  √°rvore  XML  implica. Discutiremos mais sobre os atributos XML na Se√ß√£o  12.3  quando  falarmos  sobre  esquema  XML e DTD.

## 12.3 Documentos XML, DTD e esquema XML

## 12.3.1 Documentos XML bem formados e v√°lidos e XML DTD

Na  Figura  12.3,  vimos  como  um  documento XML simples  poderia  se  parecer.  Um  documento  XML √© bem  formado se  seguir  algumas  condi√ß√µes.  Em particular, ele precisa come√ßar com uma declara√ß√£o XML para  indicar  a  vers√£o  da  linguagem  que  est√° sendo usada, bem como quaisquer outros atributos relevantes,  com  mostra  a  primeira  linha  da  Figura 12.3. Ele tamb√©m precisa seguir as diretrizes sint√°ticas do modelo de dados de √°rvore. Isso significa que deve haver um √∫nico elemento raiz , e cada elemento precisa incluir um par correspondente de tags de in√≠cio e de fim dentro das tags de in√≠cio e de fim do elemento pai . Isso garante que os elementos aninhados especificam uma estrutura de √°rvore bem formada.

Um documento XML bem formado √© sintaticamente  correto.  Isso  permite  que  ele  seja  processado por processadores gen√©ricos, que percorrem o docu-

mento e criam uma representa√ß√£o de √°rvore interna. Um modelo-padr√£o com um conjunto associado  de fun√ß√µes de API ( Application Programming Interface ), chamado DOM ( Document  Object  Model )  permite  que  os  programas  manipulem a representa√ß√£o de √°rvore  resultante  correspondente  a  um  documento XML bem formado.  No  entanto,  o  documento  inteiro precisa ser analisado de antem√£o quando se usa DOM, para converter o documento para a representa√ß√£o  na  estrutura  de  dados  interna  DOM  padr√£o. Outra API, chamada SAX ( Simple API for XML ) permite o processamento de documentos XML no ato ao notificar o programa de processamento por meio de chamadas de eventos sempre que uma tag de in√≠cio ou fim for encontrada. Isso facilita o processamento de grandes documentos e permite o dos chamados documentos XML de streaming , em que o programa de processamento pode processar as tags √† medida que forem  encontradas.  Isso  tamb√©m  √©  conhecido  como processamento baseado em evento .

Um  documento  XML  bem  formado  pode  n√£o ter esquema; ou seja, ele pode ter quaisquer nomes de tag para os elementos do documento. Nesse caso, n√£o existe um conjunto predefinido de elementos (nomes de tag) que um programa processando o documento saiba esperar. Isso d√° ao criador do documento a liberdade de especificar novos elementos, mas limita as possibilidades para interpretar automaticamente o significado ou a sem√¢ntica dos elementos do documento.

formado e seguir um esquema espec√≠fico. Ou seja,  os nomes de elemento usados nos pares de tag de in√≠cio e de fim devem seguir a estrutura especificada em um arquivo XML DTD ( Document Type Definition ) separado, ou arquivo de esquema XML. Primeiro, vamos discutir aqui a XML DTD, e depois daremos uma vis√£o geral do esquema XML na Se√ß√£o 12.3.2. A Figura 12.4 mostra um arquivo XML DTD simples, que especifica os elementos (nomes de tag) e suas estruturas aninhadas. Quaisquer documentos v√°lidos em conformidade com essa DTD devem seguir a estrutura especificada. Existe  uma  sintaxe  especial  para  especificar  arquivos DTD, conforme ilustrado na Figura 12.4. Primeiro, um nome √© dado √† tag raiz do documento, que √© chamada de Projetos na primeira linha da Figura 12.4. Depois, os elementos e sua estrutura aninhada s√£o especificados.

Ao especificar elementos, a nota√ß√£o a seguir √© usada:

- ¬Ñ Um   ap√≥s o nome do elemento significa que * ele pode ser repetido zero ou mais vezes no documento. Esse tipo de elemento √© conhecido como um elemento multivalorado (repetitivo) opcional .
- ¬Ñ Um + ap√≥s o nome do elemento significa que ele pode ser repetido uma ou mais vezes no documento. Esse tipo de elemento √© conhecido como um elemento multivalorado (repetitivo) obrigat√≥rio.

Um crit√©rio mais forte √© que um documento XML seja v√°lido .  Nesse caso, o documento dever√° ser bem

- ¬Ñ Um ? ap√≥s o nome do elemento significa que ele pode ser repetido zero ou uma vez. Esse

```
<!DOCTYPE Projects [ <!ELEMENT Projetos (Projeto+)> <!ELEMENT Projeto (Nome, Numero, Localizacao, Dept_nr?, Trabalhadores) <!ATTLIST Projeto ProjId ID #REQUIRED> > <!ELEMENT Nome (#PCDATA)> <!ELEMENT Numero (#PCDATA) <!ELEMENT Localizacao (#PCDATA)> <!ELEMENT Dept_nr (#PCDATA)> <!ELEMENT Trabalhadores (Trabalhador*)> <!ELEMENT Trabalhador (Cpf, Ultimo_nome?, Primeiro_nome?, Horas)> <!ELEMENT Cpf (#PCDATA)> <!ELEMENT Ultimo_nome (#PCDATA)> <!ELEMENT Primeiro_nome (#PCDATA)> <!ELEMENT Horas (#PCDATA)>
```

] &gt;

Figura 12.4

Um arquivo XML DTD chamado Projetos .

tipo √© um elemento de √∫nico valor (n√£o repetitivo) opcional .

- ¬Ñ Um elemento sem qualquer um dos tr√™s s√≠mbolos anteriores precisa aparecer exatamente uma vez no documento. Esse tipo √© um elemento de √∫nico valor (n√£o repetitivo) obrigat√≥rio .
- ¬Ñ O tipo do elemento √© especificado por par√™nteses ap√≥s ele mesmo. Se os par√™nteses inclu√≠rem nomes de outros elementos, estes s√£o os filhos do elemento na estrutura de √°rvore. Se os par√™nteses inclu√≠rem a palavra-chave #PCDATA ou um dos outros tipos de dados dispon√≠veis em  XML  DTD,  o  elemento  √©  um  n√≥  folha. PCDATA significa Parsed Character Data (dados de caractere analisados), que √© mais ou menos equivalente a um tipo de dados de string.
- ¬Ñ A lista de atributos que podem aparecem em um elemento tamb√©m pode ser especificada por meio da palavra-chave !ATTLIST. Na Figura 12.3, o elemento Projeto tem um atributo  ProjId.  Se  o  tipo  de  um  atributo  √©  ID, ent√£o ele pode ser referenciado com base em outro atributo cujo tipo √© IDREF dentro de outro elemento. Observe que os atributos tamb√©m podem ser usados para manter os valores de elementos de dados simples do tipo #PCDATA.
- ¬Ñ Os par√™nteses podem ser aninhados quando se especifica elementos.
- ¬Ñ Um s√≠mbolo de barra ( e 1 | e 2 ) especifica que e 1 ou e 2 podem aparecer no documento.

Podemos ver que a estrutura de √°rvore na Figura 12.1 e o documento XML na Figura 12.3 est√£o em conformidade com a XML DTD da Figura 12.4. Para exigir  que  um  documento  XML  seja  verificado  por conformidade  com  uma  DTD,  temos  de  especificar isso na declara√ß√£o do documento. Por exemplo, poder√≠amos mudar a primeira linha da Figura 12.3 para:

&lt;?xml version='1.0' standalone='no'?&gt; &lt;!DOCTYPE Projetos SYSTEM 'proj.dtd'&gt;

Quando o valor do atributo standalone em um documento  XML  √© 'no' ,  o  documento  precisa  ser verificado  contra  um  documento  DTD  ou  um  documento de esquema XML separado (ver a seguir). O arquivo DTD mostrado na Figura 12.4 deve ser armazenado no mesmo sistema de arquivos do documento  XML,  e  receber  o  nome  de  arquivo proj. dtd. Como  alternativa,  poder√≠amos  incluir  o  texto do documento DTD no in√≠cio do pr√≥prio documento XML, para permitir a verifica√ß√£o.

Embora  a  XML  DTD  seja  bastante  adequada para  especificar  estruturas  de  √°rvore  com  elementos  obrigat√≥rios,  opcionais  e  repetitivos,  e  com  v√°- rios  tipos  de  atributos,  ela  tem  diversas  limita√ß√µes. Primeiro, os tipos de dados na DTD n√£o s√£o muito gen√©ricos. Em segundo lugar, a DTD tem a pr√≥pria sintaxe especial e, portanto, requer processadores especializados. Seria vantajoso especificar documentos de esquema XML usando as regras de sintaxe da pr√≥pria XML, de modo que os mesmos processadores usados para documentos XML pudessem processar descri√ß√µes de esquema XML. Em terceiro lugar, todos os elementos DTD s√£o sempre for√ßados a seguir a  ordena√ß√£o  especificada  do  documento,  de  modo que  elementos  n√£o  ordenados  n√£o  s√£o  permitidos. Essas desvantagens levaram ao desenvolvimento do esquema XML, uma linguagem mais gen√©rica, mas tamb√©m mais complexa, para especificar a estrutura e os elementos dos documentos XML.

## 12.3.2 Esquema XML

A linguagem  de  esquema  XML √©  um  padr√£o para  especificar  a  estrutura  de  documentos  XML. Ela usa as mesmas regras de sintaxe dos documentos XML normais, de modo que os mesmos processadores  podem ser utilizados  em  ambos.  Para  distinguir os dois tipos de documentos, usaremos o termo documento de inst√¢ncia XML ou documento XML para um documento XML normal, e documento de esquema  XML para  um  documento  que  especifica um esquema XML. A Figura 12.5 mostra um documento de esquema XML correspondente ao banco de  dados EMPRESA exibido  nas  figuras  3.5  e  7.2. Embora seja improv√°vel que queiramos exibir o banco de dados inteiro como um √∫nico documento, h√° propostas para armazenar dados em formato XML nativo como uma alternativa ao armazenamento dos dados em bancos de dados relacionais. O esquema da Figura 12.5 atenderia √† finalidade de especificar a estrutura do banco de dados EMPRESA se ela fosse armazenada em um sistema XML nativo. Vamos discutir melhor esse assunto na Se√ß√£o 12.4.

Assim como a XML DTD, o esquema XML √© baseado no modelo de dados de √°rvore, com elementos e atributos como os conceitos de estrutura√ß√£o principais. Contudo, ele utiliza conceitos adicionais dos modelos de banco de dados e objeto, como chaves, refer√™ncias e identificadores. Aqui, descrevemos os recursos do esquema XML de uma maneira passo a passo, referindo-nos a um documento de esquema XML de exemplo na Figura 12.5 para fins de ilustra√ß√£o. Apresentamos e descrevemos alguns dos conceitos de esquema na ordem em que eles s√£o usados na Figura 12.5.

- 1. Descri√ß√µes de esquema e namespaces XML. √â necess√°rio identificar o conjunto espec√≠fico de elementos da linguagem de esquema XML (tags)  sendo  usado  ao  especificar  um  arqui-

&lt;?xml version='1.0' encoding='UTF-8' ?&gt;

&lt;xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'&gt;

&lt;xsd:annotation&gt;

&lt;xsd  :documentation  xml:lang='en'&gt;Esquema  Empresa  (Defini√ß√£o  Elemento)  -  Criado  por  Babak Hojabri&lt;/xsd:documentation&gt;

&lt;/xsd:annotation&gt;

&lt;xsd:element name='empresa'&gt;

&lt;xsd:complexType&gt;

&lt;xsd:sequence&gt;

&lt;xsd:element name='departamento' type='Departamento' minOccurs='0' maxOccurs= 'unbounded' /&gt; &lt;xsd:element name='funcionario' type='Funcionario' minOccurs='0' maxOccurs= 'unbounded'&gt; &lt;xsd:unique name='UnicoNomedependente'&gt;

&lt;xsd:selector xpath='dependenteFuncionario' /&gt; &lt;xsd:field xpath='nomeDepartamento' /&gt;

&lt;/xsd:unique&gt;

&lt;/xsd:element&gt;

&lt;xsd:element name='projeto' type='Projeto' minOccurs='0' maxOccurs='unbounded' /&gt; &lt;/xsd:sequence&gt;

## &lt;/xsd:complexType&gt;

&lt;xsd:unique name='unicoNomeDepartamento'&gt;

&lt;xsd:selector xpath='departamento' /&gt;

&lt;xsd:field xpath='nomeDepartmento' /&gt;

&lt;/xsd:unique&gt;

&lt;xsd:unique name='unicoNomeProjeto'&gt;

&lt;xsd:selector xpath='projeto' /&gt;

&lt;xsd:field xpath='nomeProjeto' /&gt;

## &lt;/xsd:unique&gt;

&lt;xsd:key name='chaveNumeroProjeto'&gt;

&lt;xsd:selector xpath='projeto' /&gt;

&lt;xsd:field xpath='numeroProjeto' /&gt;

## &lt;/xsd:key&gt;

&lt;xsd:key name='chaveNumeroDepartamento'&gt;

&lt;xsd:selector xpath='departamento' /&gt;

&lt;xsd:field xpath='numeroDepartamento' /&gt;

## &lt;/xsd:key&gt;

&lt;xsd:key name='chaveCPFFuncionario'&gt;

&lt;xsd:selector xpath='funcionario' /&gt;

&lt;xsd:field xpath='CPFfuncionario' /&gt;

## &lt;/xsd:key&gt;

&lt;xsd:keyref name='chaveCPFGerenteDepartamento' refer='chaveCPFFuncionario'&gt;

&lt;xsd:selector xpath='departamento' /&gt;

&lt;xsd:field xpath='CPFGerenteDepartamento' /&gt;

&lt;/xsd:keyref&gt;

&lt;xsd:keyref name='refChaveNumeroDepartamentoFuncionario'

Um arquivo de esquema XML chamado empresa .

/&gt;

refer='chaveNumeroDepartamento'&gt;

&lt;xsd:selector xpath='funcionario' /&gt;

&lt;xsd:field xpath='numeroDepartamentoFuncionario' /&gt;

## &lt;/xsd:keyref&gt;

&lt;xsd:keyref name='refChaveCPFGerenteFuncionario' refer='ChaveCPFFuncionario'&gt; &lt;xsd:selector xpath='funcionario' /&gt; &lt;xsd:field xpath='CPFGerenteFuncionario' /&gt;

&lt;/xsd:keyref&gt;

&lt;xsd:keyref name='refChaveNumeroDepartamentoProjeto' refer='ChaveNumeroDepartamento'&gt; &lt;xsd:selector xpath='projeto' /&gt;

&lt;xsd:field xpath='numeroDepartamentoProjeto' /&gt;

&lt;/xsd:keyref&gt;

&lt;xsd:keyref name='refChaveCPFTrabalhadorProjeto refer='chaveCPFFuncionario'&gt; &lt;xsd:selector xpath='projeto/trabalhadorProjeto' /&gt; &lt;xsd:field xpath='CPF' /&gt;

&lt;/xsd:keyref&gt;

&lt;xsd:keyref name='refChaveNumeroProjetoTrabalhaemFuncionario' refer='chaveNumeroP'&gt; &lt;xsd:selector xpath='funcionario/trabalhaemFuncionario' /&gt; &lt;xsd:field xpath='numeroProjeto' /&gt;

## &lt;/xsd:keyref&gt;

&lt;/xsd:element&gt;

&lt;xsd:complexType name='Departamento'&gt;

&lt;xsd:sequence&gt;

&lt;xsd:element name='nomeDepartamento' type='xsd:string' /&gt;

&lt;xsd:element name='numeroDepartamento' type='xsd:string' /&gt;

&lt;xsd:element name='CPFGerenteDepartamento' type='xsd:string' /&gt;

&lt;xsd:element name='dataInicioGerenteDepartamento' type='xsd:date' /&gt;

&lt;xsd:element name='localizacaoDepartamento' type='xsd:string' minOccurs='0'  maxOccurs='unbounded'

&lt;/xsd:sequence&gt;

&lt;/xsd:complexType&gt;

&lt;xsd:complexType name='Funcionario'&gt;

&lt;xsd:sequence&gt;

&lt;xsd:element name='nomeFuncionario' type='Nome' /&gt;

&lt;xsd:element name='CPFFuncionario' type='xsd:string' /&gt;

&lt;xsd:element name='sexoFuncionario' type='xsd:string' /&gt;

&lt;xsd:element name='salarioFuncionario' type='xsd:unsignedInt' /&gt;

&lt;xsd:element name='dataNascimentoFuncionario' type='xsd:date' /&gt;

&lt;xsd:element name='numeroDepartamentoFuncionario' type='xsd:string' /&gt;

&lt;xsd:element name='CPFGerenteFuncionario' type='xsd:string' /&gt;

&lt;xsd:element name='enderecoFuncionario' type='Address' /&gt;

&lt;xsd:element name='trabalhaemFuncionario' type='T rabalhaEm' minOccurs='1' maxOccurs='unbounded' /&gt;

&lt;xsd:element name='dependenteFuncionario' type='Dependente' minOccurs='0' maxOccurs='unbounded' /&gt;

&lt;/xsd:sequence&gt;

&lt;/xsd:complexType&gt;

Figura 12.5 (continua√ß√£o)

Um arquivo de esquema XML chamado empresa.

&lt;xsd:complexType name='Projeto'&gt;

&lt;xsd:sequence&gt;

&lt;xsd:element name='nomeProjeto' type='xsd:string' /&gt;

&lt;xsd:element name='numeroProjeto' type='xsd:string' /&gt;

&lt;xsd:element name='localizacaoProjeto' type='xsd:string' /&gt;

&lt;xsd:element name='numeroDepartamentoProjeto' type='xsd:string' /&gt;

&lt;xsd:element name='trabalhadorProjeto' type='Worker' minOccurs='1' maxOccurs='unbounded' /&gt;

&lt;/xsd:sequence&gt;

&lt;/xsd:complexType&gt;

&lt;xsd:complexType name='Dependente'&gt;

&lt;xsd:sequence&gt;

&lt;xsd:element name='nomeDependente' type='xsd:string' /&gt; &lt;xsd:element name='sexoDependente' type='xsd:string' /&gt; &lt;xsd:element name='dataNascimentoDependente' type='xsd:date' /&gt; &lt;xsd:element name='parentescoDependente' type='xsd:string' /&gt;

&lt;/xsd:sequence&gt;

&lt;/xsd:complexType&gt;

&lt;xsd:complexType name='Endereco'&gt;

&lt;xsd:sequence&gt;

&lt;xsd:element name='numero' type='xsd:string' /&gt;

&lt;xsd:element name='rua' type='xsd:string' /&gt; &lt;xsd:element name='cidade' type='xsd:string' /&gt; &lt;xsd:element name='estado' type='xsd:string' /&gt;

&lt;/xsd:sequence&gt;

&lt;/xsd:complexType&gt;

&lt;xsd:complexType name='Nome'&gt;

&lt;xsd:sequence&gt;

&lt;xsd:element name='primeiroNome' type='xsd:string' /&gt; &lt;xsd:element name='nomeMeio' type='xsd:string' /&gt; &lt;xsd:element name='ultimoNome' type='xsd:string' /&gt;

&lt;/xsd:sequence&gt;

&lt;/xsd:complexType&gt;

&lt;xsd:complexType name='Trabalhador'&gt;

&lt;xsd:sequence&gt;

&lt;xsd:element name='CPF' type='xsd:string' /&gt; &lt;xsd:element name='horas' type='xsd:float' /&gt;

&lt;/xsd:sequence&gt;

&lt;/xsd:complexType&gt;

&lt;xsd:complexType name='TrabalhaEm'&gt;

&lt;xsd:sequence&gt;

&lt;xsd:element name='numeroProjeto' type='xsd:string' /&gt; &lt;xsd:element name='horas' type='xsd:float' /&gt;

&lt;/xsd:sequence&gt;

&lt;/xsd:complexType&gt;

&lt;/xsd:schema&gt;

Figura 12.5 (continua√ß√£o)

Um arquivo de esquema XML chamado empresa.

- vo armazenado em um local de Website. A segunda linha da Figura 12.5 especifica o arquivo utilizado neste exemplo, que √© &lt; http:// www.w3.org/2001/XMLSchema&gt;. Esse  √©  um padr√£o  normalmente  usado  para  comandos de esquema XML. Cada defini√ß√£o desse tipo √©  chamada de namespace XML ,  pois  define o conjunto de comandos (nomes) que podem ser usados. O nome de arquivo √© atribu√≠do √† vari√°vel xsd (descri√ß√£o de esquema XML, ou XML Schema Description ) usando o atributo xmlns (XML namespace), e essa vari√°vel √©  utilizada  como  um  prefixo  para  todos  os comandos (nomes de tag) de esquema XML. Por exemplo, na Figura 12.5, quando escrevemos xsd:element ou xsd:sequence, estamos nos referindo √†s defini√ß√µes das tags element e sequence conforme  definidas  no  arquivo &lt; http://www.w3.org/2001/XMLSchema&gt;.
- 2. Anota√ß√µes, documenta√ß√£o e linguagem usada. As duas linhas seguintes da Figura 12.5 ilustram  os  elementos  (tags)  do  esquema XML xsd:annotation e xsd:documentation, que s√£o  usadas  para  oferecer  coment√°rios  e  outras descri√ß√µes no documento XML. O atributo xml:lang do elemento xsd:documentation especifica o idioma ( language )  sendo usado, no qual en significa english (ingl√™s).
- 3. Elementos  e  tipos. Em  seguida,  especificamos o elemento raiz de nosso esquema XML. No esquema XML, o atributo name da tag xsd:element especifica  o  nome  do  elemento, que se chama empresa para o elemento raiz em  nosso  exemplo  (ver  Figura  12.5).  A  estrutura  do  elemento  raiz empresa pode  ent√£o  ser  especificada,  que  em  nosso  exemplo √© xsd:complexType. Isso √© especificado ainda mais como uma sequ√™ncia de departamentos, funcion√°rios  e  projetos  usando  a  estrutura xsd:sequence do esquema XML. √â importante observar aqui que essa n√£o √© a √∫nica maneira de especificar um esquema XML para o  banco  de  dados EMPRESA .  Discutiremos outras op√ß√µes na Se√ß√£o 12.6.
- 4. Elementos de primeiro n√≠vel no banco de dados EMPRESA . Em seguida, especificamos os tr√™s elementos de primeiro n√≠vel sob o elemento raiz empresa da Figura 12.5. Esses elementos  s√£o  chamados funcionarios, departamento e projeto ,  e  cada  um  √©  especificado  em  uma tag xsd:element . Observe que, se uma tag tem apenas atributos e n√£o mais subelementos ou dados dentro dela, ela pode ser encerrada com o  s√≠mbolo  de  contrabarra  ( /&gt; )  diretamente, em vez de ter uma tag de fim correspondente.
- Estes s√£o chamados elementos vazios . Alguns exemplos s√£o os elementos de xsd:element chamados departamento e projeto na Figura 12.5.
- 5. Especificando tipo de elemento e ocorr√™ncias m√≠nima  e  m√°xima. No  esquema  XML,  os atributos type, minOccurs e maxOccurs na tag xsd:element especificam o tipo e a multiplicidade de cada elemento em qualquer documento que esteja em conformidade com as especifica√ß√µes  de  esquema.  Se  especificarmos  um atributo type em  uma  estrutura xsd:element, a  estrutura  do  elemento  precisa  ser  descrita separadamente,  em  geral  usando  o  elemento xsd:complexType do esquema XML. Isso √© ilustrado  pelos  elementos funcionario, departamento e projeto na Figura 12.5. Mas, se nenhum atributo type for especificado, a estrutura de elementos pode ser definida diretamente ap√≥s a tag, conforme ilustrado pelo elemento raiz empresa da Figura 12.5. As tags minOccurs e maxOccurs s√£o usadas para especificar os limites inferior e superior sobre o n√∫mero de ocorr√™ncias de um elemento em qualquer documento XML que esteja em conformidade com as especifica√ß√µes do esquema. Se eles n√£o forem  especificados,  o  padr√£o  √©  exatamente uma  ocorr√™ncia.  Estes  t√™m  um  papel  semelhante aos s√≠mbolos  , + e ? da XML DTD. *
- 6. Especificando  chaves. No  esquema  XML,  √© poss√≠vel especificar restri√ß√µes que correspondem a restri√ß√µes √∫nicas e de chave prim√°ria em um banco de dados relacional (ver Se√ß√£o 3.2.2), bem como restri√ß√µes de chaves estrangeiras (ou integridade referencial) (ver Se√ß√£o 3.2.4).  A  tag xsd:unique especifica  elementos que correspondem a atributos √∫nicos em um banco de dados relacional. Podemos dar um nome a cada restri√ß√£o √∫nica, e devemos especificar  tags xsd:selector e xsd:field para ela,  a  fim  de  identificar  o  tipo  de  elemento que cont√©m o elemento √∫nico e o nome do elemento dentro dela que √© √∫nico por meio do atributo xpath .  Isso √© ilustrado pelos elementos unicoNomeDepartamento e unicoNomeProjeto da  Figura  12.5.  Para  especificar chaves  prim√°rias ,  a  tag xsd:key √©  usada  no lugar de xsd:unique, conforme ilustrado pelos elementos chaveNumeroProjeto, chaveNu -meroDepartamento e chaveCPFFuncionario da Figura  12.5.  Para  especificar chaves  estrangeiras ,  a  tag xsd:keyref √©  usada,  conforme ilustrado  pelos  seis  elementos xsd:keyref da Figura 12.5. Ao especificar uma chave estrangeira, o atributo refer da tag xsd:keyref especifica a chave prim√°ria referenciada, enquanto

- as  tags xsd:selector e xsd:field especificam  o tipo de elemento referenciando e a chave estrangeira (ver Figura 12.5).
- 7. Especificando as estruturas de elementos complexos por meio de tipos complexos. A pr√≥xima parte de nosso exemplo especifica as estruturas dos elementos complexos Departamento, Funcionario, Projeto e Dependente, usando  a tag xsd:complexType (ver  Figura  12.5).  Especificamos cada um deles como uma sequ√™ncia de subelementos correspondentes aos atributos de  banco  de  dados  de  cada  tipo  de  entidade (ver Figura 3.7) ao usar as tags xsd:sequence e xsd:element do esquema XML. Cada elemento recebe um nome e tipo por meio dos atributos name e type de xsd:element. Tamb√©m podemos especificar os atributos minOccurs e maxOccurs se precisarmos mudar o padr√£o de exatamente uma ocorr√™ncia. Para atributos de banco de dados (opcionais) em que o nulo √© permitido, precisamos especificar minOccurs = 0, ao passo que, para atributos de banco de dados multivalorados, precisamos especificar maxOccurs = 'unbounded' no elemento correspondente. Observe que, se n√£o f√¥ssemos especificar quaisquer restri√ß√µes de chave, poder√≠amos ter embutido os subelementos nas defini√ß√µes do elemento pai diretamente sem ter de especificar tipos complexos. Contudo, quando restri√ß√µes √∫nicas, de chave prim√°ria e de chave estrangeira precisam ser especificadas, temos de definir tipos complexos para especificar as estruturas de elemento.
- 8. Atributos compostos. Os  atributos  compostos da Figura 7.2 tamb√©m s√£o especificados como tipos complexos na Figura 12.7, conforme ilustrado pelos tipos complexos Endereco, Nome, Trabalhador e Trabalha em .  Estes poderiam ter sido embutidos diretamente em seus elementos pai.

Este exemplo ilustra alguns dos principais recursos do esquema XML. Existem outros recursos, mas eles est√£o al√©m do escopo de nossa apresenta√ß√£o. Na pr√≥xima se√ß√£o, vamos discutir as diferentes t√©cnicas para criar documentos XML baseando-se em bancos de dados relacionais e armazenar documentos XML.

## 12.4 Armazenando e extraindo documentos XML de bancos de dados

V√°rias t√©cnicas de organiza√ß√£o do conte√∫do de documentos  XML,  para  facilitar  sua  subsequente consulta  e  recupera√ß√£o,  foram  propostas.  A  seguir est√£o as mais comuns:

- 1. Usar  um  SGBD  para  armazenar  os  documentos como texto. Um SGBD relacional ou de objeto pode ser utilizado para armazenar os  documentos  XML  inteiros  como  campos de  texto  nos  registros  ou  objetos  do  SGBD. Essa t√©cnica pode ser usada se o SGBD tiver um  m√≥dulo  especial  para  processamento  de documento, e funcionaria para armazenar documentos XML sem esquema e centrados no pr√≥prio documento.
- 2. Usar um SGBD para armazenar conte√∫dos de documento como elementos de dados. Essa t√©cnica funcionaria para armazenar uma cole√ß√£o  de  documentos  que  segue  uma  XML DTD espec√≠fica ou um esquema XML. Como todos os documentos t√™m a mesma estrutura, pode-se projetar um banco de dados relacional (ou de objeto) para armazenar os elementos de dados em n√≠vel de folha nos documentos XML. Essa t√©cnica exigiria algoritmos de mapeamento para projetar um esquema de banco de dados compat√≠vel com a estrutura do documento XML, conforme especificada no esquema XML ou DTD, para recriar os documentos XML com base nos dados armazenados. Esses algoritmos podem ser implementados como um m√≥dulo de SGBD interno ou como middleware separado, que n√£o faz parte do SGBD.
- 3. Projetar um sistema especializado para armazenar dados XML nativos. Um novo tipo de sistema de banco de dados, baseado no modelo hier√°rquico (de √°rvore) poderia ser projetado e implementado. Esses sistemas est√£o sendo chamados de SGBDs XML nativos . O sistema incluiria t√©cnicas especializadas para indexa√ß√£o e consulta, e funcionaria para todos os tipos de documentos XML. Ele tamb√©m poderia incluir t√©cnicas de compacta√ß√£o de dados, para reduzir o tamanho dos documentos para armazenamento. O Tamino, da Software AG, e a Dynamic Application Platform, da eXcelon, s√£o dois produtos populares que oferecem capacidade de SGBD XML. A Oracle tamb√©m oferece uma op√ß√£o de armazenamento XML nativo.
- 4. Criar  ou  publicar  documentos  XML  personalizados de bancos de dados relacionais pr√©-existentes. Como h√° grande quantidade de dados  j√°  armazenados  em  bancos  de  dados relacionais, partes desses dados podem ter de ser formatadas como documentos para a troca ou exibi√ß√£o pela Web. Essa t√©cnica usaria uma camada separada de software  de  mid-

dleware para tratar das convers√µes necess√°rias entre os documentos XML e o banco de dados relacional.  A  Se√ß√£o  12.6  discute  essa t√©cnica,  em  que  os  documentos  XML  centrados  nos  dados  s√£o  extra√≠dos  dos  bancos de dados existentes, com mais detalhes. Em particular, mostramos como os documentos estruturados em √°rvore podem ser criados a partir  de  bancos  de  dados  estruturados  em grafo. A Se√ß√£o 12.6.2 discute o problema de ciclos e como lidar com ele.

Todas  essas  t√©cnicas  receberam  bastante  aten√ß√£o.  Focalizamos  a  quarta  t√©cnica  na  Se√ß√£o  12.6, pois  ela  oferece  um  bom  entendimento  conceitual das diferen√ßas entre o modelo de dados em √°rvore da XML e os modelos de banco de dados tradicionais baseados em arquivos planos (modelo relacional) e representa√ß√µes gr√°ficas (modelo ER). Mas, primeiro, vamos dar uma vis√£o geral das linguagens de consulta XML na Se√ß√£o 12.5.

## 12.5 Linguagens XML

Houve v√°rias propostas para linguagens de consulta XML, e dois padr√µes de linguagens de consulta se  destacaram.  O  primeiro  √©  o XPath ,  que  oferece constru√ß√µes da linguagem para especificar express√µes de caminho a fim de identificar certos n√≥s (elementos) ou atributos em um documento XML que combina padr√µes espec√≠ficos. O segundo √© o XQuery , que √© uma linguagem de consulta mais geral. A XQuery usa express√µes XPath, mas tem constru√ß√µes adicionais. Vamos apresentar uma vis√£o geral de cada uma dessas linguagens nesta se√ß√£o. Depois, discutiremos algumas linguagens adicionais relacionadas √† HTML na Se√ß√£o 12.5.3.

## 12.5.1 XPath: especificando express√µes de caminho em XML

Uma express√£o XPath geralmente retorna uma sequ√™ncia  de  itens  que  satisfazem  certo  padr√£o, conforme  especificado  pela  express√£o.  Esses  itens podem ser valores (ou n√≥s de folha), elementos ou

- 1. /empresa
- 2. /empresa/departamento
- 3. //funcionario [salarioFuncionario gt 70.000]/nomeFuncionario
- 4. /empresa/funcionario [salarioFuncionario gt 70.000]/nomeFuncionario
- 5. /empresa/projeto/trabalhadorProjeto [horas ge 20,0]

## Figura 12.6

Alguns exemplos de express√µes XPath em documentos XML que seguem o arquivo de esquema XML empresa na Figura 12.5.

atributos. O tipo mais comum de express√£o XPath retorna uma cole√ß√£o de n√≥s de elemento ou atributo que satisfaz certos padr√µes especificados na express√£o. Os nomes na express√£o XPath s√£o nomes de n√≥ na √°rvore de documentos XML que s√£o tamb√©m nomes de tag (elemento) ou de atributo, possivelmente com condi√ß√µes qualificadoras adicionais, para restringir ainda mais os n√≥s que satisfazem o padr√£o. Dois separadores principais s√£o usados ao se especificar um caminho: barra simples (/) e barra dupla (//). Uma barra simples antes de uma tag especifica que esta precisa aparecer como um filho direto da tag anterior (pai), enquanto uma barra dupla especifica que a tag pode aparecer como um descendente da tag anterior, em qualquer n√≠vel . Vamos examinar alguns exemplos da XPath conforme mostrados na Figura 12.6.

A primeira express√£o XPath da Figura 12.6 retorna o n√≥ raiz empresa e todos os n√≥s descendentes, o que significa que retorna o documento XML inteiro. Devemos notar que √© comum incluir o nome do arquivo na consulta XPath . Isso nos permite especificar qualquer nome de arquivo local ou mesmo qualquer nome de caminho que determine um arquivo na Web. Por exemplo, se o documento XML EMPRESA est√° armazenado no local www.empresa.com/info.XML

ent√£o  a  primeira  express√£o  XPath  da  Figura  12.6 pode ser escrita como doc(www.empresa.com/info.XML)/empresa

Esse  prefixo  tamb√©m  seria  inclu√≠do  nos  outros exemplos de express√µes XPath.

- O  segundo  exemplo  da  Figura  12.6  retorna todos  os  n√≥s  (elementos)  de  departamento  e  suas sub√°rvores  descendentes.  Observe  que  os  n√≥s  (elementos) em um documento XML s√£o ordenados, de modo que o resultado XPath que retorna v√°rios n√≥s far√° isso na mesma ordem em que os n√≥s s√£o ordenados na √°rvore do documento.

A terceira express√£o XPath da Figura 12.6 ilustra o uso de //, que √© conveniente se n√£o soubermos o nome do caminho completo que estamos procuran-

do, mas sabemos o nome de algumas tags de interesse no documento XML. Isso √© √∫til particularmente para documentos XML sem esquema ou para documentos com muitos n√≠veis de n√≥s aninhados. 6

A express√£o retorna todos os n√≥s nomeFuncionario que s√£o filhos diretos de um n√≥ funcionario , de modo que o n√≥ funcionario tem outro elemento filho salarioFuncionario cujo valor √© maior que 70000. Isso ilustra o uso de condi√ß√µes qualificadoras, que restringem os n√≥s selecionados pela express√£o XPath √†queles que satisfazem a condi√ß√£o. A XPath tem  uma  s√©rie  de  opera√ß√µes  de  compara√ß√£o  para uso nas condi√ß√µes qualificadoras, incluindo opera√ß√µes de compara√ß√£o aritm√©tica padr√£o, de string e de conjunto.

A quarta express√£o XPath da Figura 12.6 deve retornar o mesmo resultado da anterior, exceto que especificamos o nome do caminho completo nesse exemplo. A quinta express√£o da Figura 12.6 retorna todos os n√≥s trabalhadorProjeto e seus n√≥s descendentes, que s√£o filhos sob um caminho /trabalhador/projeto e t√™m um n√≥ filho horas com um valor maior que 20,0 horas.

Quando  precisamos  incluir  atributos  em  uma express√£o XPath , o nome do atributo √© iniciado pelo s√≠mbolo @ para distingui-lo dos nomes de elemento (tag). √â poss√≠vel usar o s√≠mbolo curinga * , que representa qualquer elemento, como no exemplo a seguir, que recupera todos os elementos que s√£o elementos filho da raiz, independentemente de seu tipo de elemento.  Quando  s√£o  usados  curingas,  o  resultado pode ser uma sequ√™ncia de diferentes tipos de itens.

/empresa/*

Os exemplos anteriores ilustram express√µes XPath simples, nas quais s√≥ podemos descer na estrutura da √°rvore de determinado n√≥. Um modelo mais geral para express√µes de caminho j√° foi proposto. Nesse modelo, √© poss√≠vel mover em v√°rias dire√ß√µes a partir do n√≥ atual na express√£o de caminho. Estes s√£o conhecidos como eixos de uma express√£o XPath . Nossos exemplos usaram apenas tr√™s desses eixos : filho do n√≥ atual (/), descendente ou ele mesmo em qualquer n√≠vel do n√≥ atual (//) e atributo do n√≥ atual (@). Outros eixos incluem pai, ancestral (em qualquer n√≠vel), irm√£o anterior (qualquer n√≥ no mesmo n√≠vel √† esquerda na √°rvore) e irm√£o seguinte (qualquer n√≥ no mesmo n√≠vel √† direita na √°rvore). Esses eixos permitem express√µes de caminho mais complexas.

A principal  restri√ß√£o  de  express√µes  de XPath √© que o caminho que especifica o padr√£o tamb√©m especifica os itens a serem recuperados. Logo, √© dif√≠cil especificar certas condi√ß√µes sobre o padr√£o enquanto

6 Usamos os termos n√≥, tag e elemento para indicar a mesma coisa aqui.

se especifica separadamente quais itens do resultado devem ser recuperados. A linguagem XQuery separa esses dois problemas, e oferece constru√ß√µes mais poderosas para especificar consultas.

## 12.5.2 XQuery: especificando consultas em XML

A XPath nos permite escrever express√µes que selecionam itens de um documento XML estruturado em  √°rvore.  A XQuery possibilita  a  especifica√ß√£o  de consultas  mais  gerais  sobre  um  ou  mais  documentos XML. O formul√°rio t√≠pico de uma consulta em XQuery √© conhecido como express√£o FLWR , que indica as quatro cl√°usulas principais da XQuery e tem a seguinte forma:

FOR   &lt;v√≠nculos de vari√°vel para n√≥s (elementos) in -dividuais&gt;

LET   &lt;v√≠nculos  de  vari√°vel  para  cole√ß√µes  de  n√≥s (elementos)&gt;

WHERE &lt;condi√ß√µes qualificadoras&gt;

RETURN &lt;especifica√ß√£o de resultado da consulta&gt;

Pode  haver  zero  ou  mais  inst√¢ncias  da  cl√°usula FOR , bem como da cl√°usula LET , em uma √∫nica XQuery. A cl√°usula WHERE √© opcional, mas pode aparecer no m√°ximo uma vez, e a cl√°usula RETURN deve aparecer exatamente  uma  vez.  Vamos  ilustrar  essas  cl√°usulas com o seguinte exemplo simples de uma XQuery.

LET $d := doc(www.empresa.com/info.xml)

FOR   $x IN $d/empresa/projeto[NumeroProjeto = 5]/ trabalhadorProjeto,  $y  IN  $d/empresa/funcio - nario WHERE $x/horas gt 20.0 AND $y.cpf = $x.cpf RETURN &lt;res&gt;   $y/nomeFuncionario/primeiroNome, $y/nomeFuncionario/ultimoNome, $x/horas &lt;/res&gt;

- 1. As vari√°veis s√£o iniciadas com o sinal $. No exemplo, $d, $x e $y s√£o vari√°veis.
- 2. A cl√°usula LET atribui uma vari√°vel a uma express√£o em particular para o restante da consulta. Neste exemplo, $d √© atribu√≠da ao nome do arquivo de documento. √â poss√≠vel ter uma consulta que se refere a v√°rios documentos ao atribuir diversas vari√°veis dessa forma.
- 3. A cl√°usula FOR atribui  uma  vari√°vel  ao  intervalo  sobre  cada  um  dos  itens  individuais em  uma  sequ√™ncia.  Em  nosso  exemplo,  as sequ√™ncias  s√£o  especificadas  por  express√µes de  caminho.  A  vari√°vel $x percorre  os  ele-

mentos que satisfazem a express√£o de caminho $d/empresa/projeto[NumeroProjeto  =  5]/ trabalhadorPro  jeto. A vari√°vel $y percorre os  elementos que satisfazem a express√£o de caminho $d/empresa/funcionario. Logo, $x percorre os elementos trabalhadorProjeto , enquanto $y percorre os elementos funcionario .

- 4. A cl√°usula WHERE especifica  condi√ß√µes  adicionais sobre a sele√ß√£o de itens. Nesse exemplo, a primeira condi√ß√£o seleciona apenas os elementos trabalhadorProjeto que satisfazem a condi√ß√£o (horas gt 20,0). A segunda condi√ß√£o especifica uma condi√ß√£o de jun√ß√£o que combina um funcionario com um trabalhadorProjeto somente se eles tiverem o mesmo valor de cpf.
- 5. Finalmente,  a  cl√°usula RETURN especifica quais  elementos  ou  atributos  devem  ser  recuperados dos itens que satisfazem as condi√ß√µes  de  consulta.  Neste  exemplo,  ela  retornar√° uma sequ√™ncia de elementos, cada um contendo &lt;primeiroNome, ultimoNome, horas&gt; para funcion√°rios que trabalham mais de 20 horas por semana no projeto n√∫mero 5.

A Figura 12.7 inclui alguns exemplos adicionais de consultas em XQuery , as quais podem ser especificadas nos documentos de inst√¢ncia XML que seguem o  documento de esquema XML na Figura 12.5. A primeira consulta recupera os nomes e sobrenomes dos funcion√°rios que ganham mais de R$70.000. A vari√°vel $x est√° ligada a cada elemento nomeFuncionario, que √© um filho de um elemento funcionario , mas somente para elementos de funcionario que satisfazem o  qualificador  de  que  seu  valor  de salarioFuncionario √© maior do que R$70.000. O resultado recupera os elementos filhos primeiroNome e ultimoNome dos elementos nomeFuncionario selecionados. A segunda consulta √© um modo alternativo de recuperar os mesmos elementos recuperados pela primeira consulta.

A terceira consulta ilustra como uma opera√ß√£o de jun√ß√£o pode ser realizada usando mais de uma vari√°vel. Aqui, a vari√°vel $x est√° ligada a cada elemento trabalhadorProjeto, que √© um filho do projeto n√∫mero 5, enquanto a vari√°vel $y est√° ligada a cada elemento funcionario .  A  condi√ß√£o  de  jun√ß√£o  combina  valores cpf a fim de recuperar os nomes de funcion√°rio. Observe que esse √© um modo alternativo de especificar a mesma consulta em nosso exemplo anterior, mas sem a cl√°usula LET.

A  XQuery possui  constru√ß√µes  muito  poderosas para  especificar  consultas  complexas.  Em  particular, ela pode especificar quantificadores universais e existenciais nas condi√ß√µes de uma consulta, fun√ß√µes de agrega√ß√£o, ordena√ß√£o dos resultados da consulta, sele√ß√£o baseada na posi√ß√£o em uma sequ√™ncia, e at√© mesmo desvio condicional. Portanto, de algumas maneiras,  ela  se  qualifica  como  uma  linguagem  de programa√ß√£o completa.

Isso conclui nossa breve introdu√ß√£o √† XQuery. O leitor  interessado  dever√°  consultar  &lt;www.w3.org&gt;, que  cont√©m  documentos  descrevendo  os  padr√µes mais recentes relacionados a XML e XQuery. A pr√≥xima se√ß√£o vai discutir rapidamente algumas linguagens e protocolos adicionais relacionados √† XML.

## 1. FOR $x IN

doc(www.empresa.com/info.xml) //funcionario [salarioFuncionario gt 70.000]/nomeFuncionario

RETURN &lt;res&gt; $x/primeiroNome, $x/ultimoNome &lt;/res&gt;

## 2. FOR $x IN

doc(www.empresa.com/info.xml)/empresa/funcionario

WHERE $x/salarioFuncionario gt 70.000

RETURN &lt;res&gt; $x/nomeFuncionario/primeiroNome, $x/nomeFuncionario/ultimoNome &lt;/res&gt;

## 3. FOR $x IN

doc(www.empresa.com/info.xml)/empresa/projeto[numeroProjeto = 5]/trabalhadorProjeto, $y IN doc(www.empresa.com/info.xml)/empresa/funcionario

WHERE $x/horas gt 20,0 AND $y.cpf = $x.cpf

RETURN &lt;res&gt; $y/nome\_funcionario/primeiroNome, $y/nomeFuncionario/ultimoNome, $x/horas&lt;/res&gt;

## Figura 12.7

Alguns exemplos de consultas XQuery em documentos XML que seguem o arquivo de esquema XML company da Figura 12.5.

## 12.5.3 Outras linguagens e protocolos relacionados a XML

Existem  v√°rias  outras  linguagens  e  protocolos relacionados √† tecnologia XML. O objetivo em longo prazo destas e de outras linguagens e protocolos √© oferecer a tecnologia para a realiza√ß√£o da Web sem√¢ntica, na qual toda informa√ß√£o na Web possa ser inteligentemente localizada e processada.

- ¬Ñ A Extensible Stylesheet Language (XSL) pode ser usada para definir como um documento deve  ser  renderizado  para  exibi√ß√£o  por  um navegador Web.
- ¬Ñ A Extensible Stylesheet Language for Transformations (XSLT) pode ser usada para transformar uma estrutura em outra. Logo, ela pode converter documentos de uma forma para outra.
- ¬Ñ A Web Services Description Language (WSDL) permite a descri√ß√£o de Web Services em XML. Isso torna o Web Service dispon√≠vel para usu√°rios e programas pela Web.
- ¬Ñ O Simple Object Access Protocol (SOAP) √© um  protocolo  independente  de  plataforma e de linguagem de programa√ß√£o para transmiss√£o de mensagens e chamadas de procedimento remoto.
- ¬Ñ O Resource  Description  Framework (RDF) oferece linguagens e ferramentas para trocar e processar descri√ß√µes de metadados (esquema) e especifica√ß√µes pela Web.

## 12.6 Extraindo documentos XML de bancos de dados relacionais

## 12.6.1 Criando vis√µes XML hier√°rquicas sobre dados planos ou baseados em grafos

Esta se√ß√£o aborda as quest√µes de representa√ß√£o que surgem quando se converte dados de um sistema de banco de dados para documentos XML. Conforme discutimos, a XML usa um modelo hier√°rquico (em √°rvore) para representar documentos. Os sistemas de banco de dados com uso mais difundido seguem o modelo de dados relacional plano. Quando acrescentamos  restri√ß√µes  de  integridade  referencial, um  esquema  relacional  pode  ser  considerado  uma estrutura gr√°fica (por exemplo, ver Figura 3.7). De modo  semelhante,  o  modelo  ER  representa  dados que usam estruturas tipo grafo (por exemplo, ver Figura 7.2). Vimos no Cap√≠tulo 9 que existem mapea- mentos diretos entre os modelos ER e relacional, de modo que podemos conceitualmente representar um esquema de banco de dados relacional usando o esquema ER correspondente. Embora usemos o modelo ER em nossa discuss√£o e exemplos para esclarecer as diferen√ßas conceituais entre os modelos de √°rvore e grafo, as mesmas quest√µes se aplicam √† convers√£o de dados relacionais para XML.

Usaremos o esquema ER UNIVERSIDADE simplificado mostrado na Figura 12.8 para ilustrar nossa discuss√£o. Suponha que uma aplica√ß√£o precise extrair documentos  XML  para  informa√ß√µes  sobre  aluno, disciplina e nota do banco de dados UNIVERSIDADE . Os dados necess√°rios para esses documentos est√£o contidos nos atributos do banco de dados dos tipos de entidade DISCIPLINA, TURMA e ALUNO da Figura 12.8, e nos relacionamentos T-A e D-T entre eles. Em geral,  a  maioria  dos  documentos  extra√≠dos  de  um banco de dados s√≥ usar√° um subconjunto dos atributos, tipos de entidade e relacionamentos no banco de dados. Neste exemplo, o subconjunto do banco de dados que √© necess√°rio aparece na Figura 12.9.

Pelo menos tr√™s hierarquias de documento poss√≠veis podem ser extra√≠das do subconjunto do banco de dados da Figura 12.9. Primeiro, podemos escolher DISCIPLINA como a raiz, conforme ilustramos na Figura 12.10. Aqui, cada entidade de disciplina tem o conjunto de suas turmas como subelementos, e cada turma tem seus alunos como subelementos. Podemos ver uma consequ√™ncia da modelagem da informa√ß√£o em uma estrutura de √°rvore hier√°rquica.  Se  um  aluno  tiver  realizado  diversas  turmas,  a informa√ß√£o  desse  aluno  aparecer√°  v√°rias  vezes  no documento - uma vez sob cada turma. Um esquema  XML  simplificado  poss√≠vel  para  essa  vis√£o  √© mostrado na Figura 12.11. O atributo de banco de dados Nota no relacionamento T-A √© migrado para o elemento ALUNO. Isso  porque ALUNO torna-se um filho de TURMA nessa hierarquia, de modo que cada elemento ALUNO sob um elemento TURMA espec√≠fico pode ter uma nota espec√≠fica nessa turma. Nessa hierarquia de documentos, um aluno que est√° em mais de uma turma ter√° v√°rias r√©plicas, uma sob cada turma, e cada r√©plica ter√° a nota espec√≠fica dada nessa turma em particular.

Na  segunda  vis√£o  de  documento  hier√°rquico, podemos escolher ALUNO como raiz (Figura 12.12). Nessa  vis√£o  hier√°rquica,  cada  aluno  tem  um  conjunto de turmas como seus elementos filhos, e cada turma  est√°  relacionada  a  uma  disciplina  como  seu filho,  pois  o  relacionamento  entre TURMA e DISCI -PLINA √©  N:1.  Assim,  podemos  mesclar  os  elementos DISCIPLINA e TURMA nesta vis√£o, como mostra a Figura 12.12. Al√©m disso, o atributo de banco de

Figura 12.8 Um diagrama de esquema ER para um banco de dados UNIVERSIDADE simplificado.



dados NOTA pode ser migrado para o elemento TURMA .  Nessa  hierarquia,  a  informa√ß√£o  combinada  de DISCIPLINA/TURMA √©  replicada sob cada aluno que concluir  a  turma.  Um  esquema  XML  simplificado poss√≠vel para essa vis√£o aparece na Figura 12.13.

vis√µes de documento hier√°rquicas, cada uma correspondendo a uma raiz diferente e uma estrutura de documento XML diferente.

A  terceira  maneira  poss√≠vel  √©  escolher TURMA como a raiz, conforme mostra a Figura 12.14. Semelhante √† segunda vis√£o hier√°rquica, a informa√ß√£o de DISCIPLINA pode ser mesclada no elemento TURMA . O atributo de banco de dados NOTA pode ser migrado para o elemento ALUNO . Como podemos ver, at√© mesmo nesse exemplo simples pode haver diversas

## 12.6.2 Quebrando ciclos para converter grafos em √°rvores

Nos exemplos anteriores, o subconjunto do banco de dados de interesse n√£o tinha ciclos. √â poss√≠vel ter um subconjunto mais complexo com um ou mais ciclos,  indicando m√∫ltiplos relacionamentos entre as entidades. Nesse caso, √© mais dif√≠cil decidir como criar as hierarquias de documento. Uma duplica√ß√£o adicio-

Figura 12.9



Subconjunto do esquema de banco de dados UNIVERSIDADE necess√°rio para a extra√ß√£o de documento XML.

Figura 12.10 Vis√£o hier√°rquica (em √°rvore) com DISCIPLINA como a raiz.



&lt;xsd:element name='root'&gt;

&lt;xsd:sequence&gt;

&lt;xsd:element name='disciplina' minOccurs='0' maxOccurs='unbounded'&gt;

&lt;xsd:sequence&gt;

&lt;xsd:element name='dnome' type='xsd:string' /&gt; &lt;xsd:element name='numdiscip' type='xsd:unsignedInt' /&gt; &lt;xsd:element name='turma' minOccurs='0' maxOccurs='unbounded'&gt;

&lt;xsd:sequence&gt;

&lt;xsd:element name='numturma' type='xsd:unsignedInt' /&gt;

&lt;xsd:element name='ano' type='xsd:string' /&gt;

&lt;xsd:element name='semestre' type='xsd:string' /&gt;

&lt;xsd:element name='aluno' minOccurs='0' maxOccurs='unbounded'&gt; &lt;xsd:sequence&gt;

&lt;xsd:element name='cpf' type='xsd:string' /&gt;

&lt;xsd:element name='anome' type='xsd:string' /&gt; &lt;xsd:element name='tipoaluno' type='xsd:string' /&gt; &lt;xsd:element name='nota' type='xsd:string' /&gt;

&lt;/xsd:sequence&gt;

&lt;/xsd:element&gt;

&lt;/xsd:sequence&gt;

&lt;/xsd:element&gt;

&lt;/xsd:sequence&gt;

&lt;/xsd:element&gt;

&lt;/xsd:sequence&gt;

&lt;/xsd:element&gt;

## Figura 12.11

Documento de esquema XML com disciplina como a raiz.

Figura 12.12



Vis√£o hier√°rquica (em √°rvore) com ALUNO como a raiz.

&lt;xsd:element name='root'&gt;

&lt;xsd:sequence&gt;

&lt;xsd:element name='aluno' minOccurs='0' maxOccurs='unbounded'&gt;

&lt;xsd:sequence&gt;

&lt;xsd:element name='cpf' type='xsd:string' /&gt;

&lt;xsd:element name='anome' type='xsd:string' /&gt;

&lt;xsd:element name='tipoaluno' type='xsd:string' /&gt;

&lt;xsd:element name='turma' minOccurs='0' maxOccurs='unbounded'&gt;

&lt;xsd:sequence&gt;

&lt;xsd:element name='numturma' type='xsd:unsignedInt' /&gt; &lt;xsd:element name='ano' type='xsd:string' /&gt; &lt;xsd:element name='semestre' type='xsd:string' /&gt; &lt;xsd:element name='numdiscip' type='xsd:unsignedInt' /&gt; &lt;xsd:element name='dnome' type='xsd:string' /&gt;

&lt;xsd:element name='nota' type='xsd:string' /&gt;

&lt;/xsd:sequence&gt;

&lt;/xsd:element&gt;

&lt;/xsd:sequence&gt;

&lt;/xsd:element&gt;

&lt;/xsd:sequence&gt;

&lt;/xsd:element&gt;

## Figura 12.13

Documento de esquema XML com aluno como a raiz.

Figura 12.14 Vis√£o hier√°rquica (em √°rvore) com TURMA como a raiz.



nal de entidades pode ser necess√°ria para representar os m√∫ltiplos relacionamentos. Ilustraremos isso com um exemplo que usa o esquema ER da Figura 12.8.

Suponha que precisemos da informa√ß√£o em todos os tipos de entidade e relacionamentos da Figura 12.8 para um documento XML em particular, com ALUNO como elemento raiz. A Figura 12.15 ilustra como uma poss√≠vel estrutura em √°rvore hier√°rquica pode ser criada para esse documento. Primeiro, obtemos um reticulado com ALUNO como raiz, conforme mostra a Figura 12.15(a). Essa n√£o √© uma estrutura em √°rvore verdadeira por causa dos ciclos. Um modo de quebrar os ciclos √© replicar os tipos de entidade nele envolvidos. Primeiro, replicamos PROFESSOR, como mostra a Figura 12.15(b), chamando a r√©plica para o PROFESSOR1 √† direita. A r√©plica de PROFESSOR √†  esquerda  representa  o  relacionamento  entre professores e as turmas que eles lecionam, enquanto a r√©plica PROFESSOR1 √† direita representa o relacionamento entre professores e o departamento em que cada um trabalha. Depois disso, ainda temos o ciclo envolvendo DISCIPLINA, de modo que podemos replicar DISCIPLINA de uma maneira semelhante, levando √† hierarquia mostrada na Figura 12.15(c). A r√©plica DISCIPLINA1 √† esquerda representa o relacionamento entre disciplinas e suas turmas, ao passo que a r√©plica de DISCIPLINA √† direita representa o relacionamento entre disciplinas e o departamento que oferece cada uma delas.

Na Figura 12.15(c), convertemos o grafo inicial em uma hierarquia. Podemos fazer outra mesclagem, se  for  desejado  (como  em  nosso  exemplo  anterior) antes de criar a hierarquia final e a estrutura do esquema XML correspondente.

## 12.6.3 Outras etapas para extrair documentos XML de bancos de dados

Al√©m de criar a hierarquia XML apropriada e o documento de esquema XML correspondente, v√°rias

Figura 12.15



Convertendo um grafo com c√≠rculos em uma estrutura hier√°rquica (em √°rvore).

outras etapas s√£o necess√°rias para extrair um documento XML em particular de um banco de dados:

- 1. √â necess√°rio criar a consulta correta em SQL para  extrair  a  informa√ß√£o  desejada  para  o documento XML.
- 2. Quando a consulta √© executada, seu resultado deve ser reestruturado da forma relacional para a estrutura em √°rvore da XML.
- 3. A  consulta  pode  ser  personalizada  para  selecionar tanto um √∫nico objeto como v√°rios objetos no documento. Por exemplo, na vis√£o da Figura 12.13, a consulta pode selecionar uma √∫nica entidade de aluno e criar um documento correspondente a esse √∫nico aluno, ou pode selecionar v√°rios - ou mesmo todos os alunos - e criar um documento com m√∫ltiplos alunos.

## Resumo

Este cap√≠tulo forneceu uma vis√£o geral do padr√£o XML para representa√ß√£o e troca de dados pela Internet. Primeiro, discutimos algumas das diferen√ßas entre diversos tipos de dados, classificando tr√™s tipos principais: estruturados, semiestruturados e n√£o estruturados. Os dados estruturados s√£o armazenados em bancos de dados tradicionais.  Os  dados  semiestruturados  misturam  nomes de tipos de dados e valores de dados, mas nem todos eles precisam seguir uma estrutura predefinida fixa. Os dados n√£o estruturados referem-se √† informa√ß√£o exibida na Web, especificada pela HTML, em que a informa√ß√£o sobre os tipos dos itens de dados n√£o existe. Descrevemos o padr√£o XML e seu modelo de dados estruturado em  √°rvore  (hier√°rquico),  e  discutimos  os  documentos XML e as linguagens para especificar a estrutura desses documentos, a saber, XML DTD ( Document Type Definition )  e  esquema  XML. Demos uma vis√£o geral das diversas t√©cnicas para armazenar documentos XML, seja no formato nativo (texto), no formato compactado ou nos bancos de dados relacionais e de outros tipos. Por fim, oferecemos uma vis√£o geral das linguagens XPath e XQuery, propostas para a consulta de dados XML, e discutimos as quest√µes de mapeamento que surgem quando √© necess√°rio converter dados armazenados nos bancos de dados relacionais tradicionais para documentos XML.

## Perguntas de revis√£o

- 12.1. Quais  s√£o  as  diferen√ßas  entre  dados  estruturados, semiestruturados e n√£o estruturados?
- 12.2. Sob qual das categorias em 12.1 os documentos XML se encontram? E os dados autodescritivos?
- 12.3. Quais s√£o as diferen√ßas entre o uso de tags em XML versus HTML?
- 12.4. Qual √© a diferen√ßa entre documentos XML centrados nos dados e centrados nos documentos?
- 12.5. Qual √© a diferen√ßa  entre  os  atributos  e  os  elementos na XML? Liste alguns dos atributos importantes usados para especificar elementos no esquema XML.
- 12.6. Qual √© a diferen√ßa entre esquema XML e XML DTD?

## Exerc√≠cios

- 12.7. Crie parte de um documento de inst√¢ncia XML para  corresponder  aos  dados  armazenados  no banco de dados relacional mostrado na Figura 3.6, tal que o documento XML corresponda ao documento de esquema XML da Figura 12.5.
- 12.8. Crie  documentos  de  esquema  XML  e  XML DTDs para corresponderem √†s hierarquias mostradas nas figuras 12.14 e 12.15(c).
- 12.9. Considere o esquema de banco de dados relacional BIBLIOTECA da Figura 4.6. Crie um documento de esquema XML que corresponda a esse esquema de banco de dados.
- 12.10. Especifique as vis√µes a seguir como consultas em XQuery sobre o esquema XML empresa mostrado na Figura 12.5.
- a. Uma vis√£o que tem nome de departamento, nome  de  gerente  e  sal√°rio  de  gerente  para cada departamento.
- b. Uma vis√£o que tem o nome do funcion√°rio, nome do supervisor e sal√°rio de cada funcion√°rio que trabalha no departamento Pesquisa.
- c. Uma vis√£o que tem o nome do projeto, nome do  departamento  de  controle,  n√∫mero  de funcion√°rios e total de horas trabalhadas por semana para cada projeto.
- d. Uma vis√£o que tem o nome do projeto, nome do  departamento  de  controle,  n√∫mero  de funcion√°rios e total de horas trabalhadas por semana para cada projeto com mais de um funcion√°rio trabalhando nele.

## Bibliografia selecionada

Existem tantos artigos e livros sobre v√°rios aspectos da XML que seria imposs√≠vel fazer at√© mesmo uma lista modesta. Mencionaremos um livro: Chaudhri, Rashid e Zicari (eds.), de 2003. Esse livro discute diversos aspectos da XML e cont√©m uma lista de algumas refer√™ncias a pesquisa e pr√°tica em XML.



T√©cnicas de programa√ß√£o de banco de dados



## Introdu√ß√£o √†s t√©cnicas de programa√ß√£o SQL

N os cap√≠tulos 4 e 5, descrevemos v√°rios aspectos da linguagem SQL, que √© o padr√£o para bancos de dados relacionais. Descrevemos as instru√ß√µes SQL para  defini√ß√£o  de  dados,  modifica√ß√£o  de  esquema, consultas,  vis√µes  e  atualiza√ß√µes.  Tamb√©m  descrevemos como s√£o especificadas diversas restri√ß√µes sobre o conte√∫do do banco de dados, como restri√ß√µes de chave e integridade referencial.

quisa, algumas linguagens de programa√ß√£o de banco de dados not√°veis possuem uso generalizado, como a PL/SQL (Programming Language/SQL) da Oracle.

Neste  cap√≠tulo  e  no  pr√≥ximo,  vamos  discutir alguns dos m√©todos que foram desambolvidos para acessar bancos de dados de programas. A maior parte do acesso ao banco de dados em aplica√ß√µes pr√°ticas √© realizada por meio de programas de software que  implementam aplica√ß√µes  de  banco  de  dados . Esse software normalmente √© desambolvido em uma linguagem de programa√ß√£o de uso geral, como Java, C/C++/C#,  COBOL  ou  alguma  outra  linguagem de programa√ß√£o. Al√©m disso, muitas linguagens de scripting, como PHP e JavaScript, tamb√©m est√£o sendo usadas para programa√ß√£o de acesso do banco de dados em aplica√ß√µes Web. Neste cap√≠tulo, focalizamos como os bancos de dados podem ser acessados das linguagens de programa√ß√£o tradicionais C/C++ e Java, enquanto o pr√≥ximo cap√≠tulo vai mostrar como os  bancos  de  dados  s√£o  acessados  com  linguagens de scripting, como PHP e JavaScript. Lembre-se, da Se√ß√£o 2.3.1, que quando as instru√ß√µes do banco de dados s√£o inclu√≠das em um programa, a linguagem de programa√ß√£o de uso geral √© chamada de linguagem hospedeira , ao passo que a linguagem de banco de dados - SQL, em nosso caso - √© chamada de sublinguagem  de  dados .  Em  alguns  casos, linguagens  de  programa√ß√£o  de  banco  de  dados especiais s√£o desambolvidas especificamente para a escrita de aplica√ß√µes de banco de dados. Embora muitas delas tenham sido desambolvidas como prot√≥tipos de pes-

√â importante observar que a programa√ß√£o de banco de dados √© um assunto muito amplo. Existem  livros-texto  inteiros  dedicados  a  cada  t√©cnica de  programa√ß√£o  de  banco  de  dados  e  como  essa t√©cnica  √©  realizada  em  um  sistema  espec√≠fico.  Novas t√©cnicas s√£o desambolvidas o tempo todo, e as mudan√ßas nas t√©cnicas existentes s√£o incorporadas a vers√µes de sistema e linguagens mais novas. Uma dificuldade adicional na apresenta√ß√£o desse t√≥pico √© que, embora existam padr√µes de SQL, eles mesmos est√£o continuamente evoluindo, e cada vendedor de SGBD pode ter algumas varia√ß√µes do padr√£o. Por causa disso, escolhemos fazer uma introdu√ß√£o a alguns dos principais tipos de t√©cnicas de programa√ß√£o  de  banco  de  dados  e  compar√°-las,  em  vez  de estudar um m√©todo ou sistema em particular com detalhes. Os exemplos que damos servem para ilustrar  as  principais  diferen√ßas  que  um  programador enfrentaria ao usar cada uma dessas t√©cnicas de programa√ß√£o de banco de dados. Tentaremos usar os padr√µes  de  SQL  em  nossos  exemplos  no  lugar  de descrever um sistema espec√≠fico. Ao usar um sistema espec√≠fico, os materiais neste cap√≠tulo podem servir como uma introdu√ß√£o, mas devem ser expandidos com os manuais do sistema e com livros que descrevem o sistema espec√≠fico.

Iniciamos  nossa  apresenta√ß√£o  da  programa√ß√£o de banco de dados na Se√ß√£o 13.1 com uma vis√£o geral das diferentes t√©cnicas desambolvidas para acessar  um  banco  de  dados  de  programas.  Depois,  na Se√ß√£o 13.2, discutimos as regras para embutir instru√ß√µes SQL em uma linguagem de programa√ß√£o de uso geral,  comumente  conhecida  como SQL embutida .

Esta se√ß√£o tamb√©m discute rapidamente a SQL din√¢mica , em que as consultas podem ser constru√≠das dinamicamente em tempo de execu√ß√£o, e apresenta os fundamentos da variante SQLJ da SQL embutida, que foi desambolvida especificamente para a linguagem de programa√ß√£o Java. Na Se√ß√£o 13.3, discutimos a t√©cnica conhecida como SQL/CLI ( Call Level Interface ), em que uma biblioteca de procedimentos e  fun√ß√µes  √©  fornecida  para  acessar  o  banco  de  dados. Diversos conjuntos de fun√ß√µes de biblioteca foram propostos. O conjunto de fun√ß√µes da SQL/CLI √© aquele dado no padr√£o SQL. Outra biblioteca de fun√ß√µes  √© ODBC ( Open  Data  Base  Connectivity ). N√£o descrevemos a ODBC porque ela √© considerada predecessora  da  SQL/CLI.  Uma  terceira  biblioteca de  fun√ß√µes  -  que  descrevemos  -  √©  a JDBC ;  esta foi desambolvida especificamente para acessar bancos de dados baseados na linguagem Java. Na Se√ß√£o 13.4, vamos discutir sobre SQL/PSM Persistent Sto-( red Modules ), que √© uma parte do padr√£o SQL que permite que m√≥dulos de programa - procedimentos e fun√ß√µes - sejam armazenados pelo SGBD e acessados  pela  SQL.  Comparamos  rapidamente  as  tr√™s t√©cnicas de programa√ß√£o de banco de dados na Se√ß√£o 13.5, e oferecemos um resumo do cap√≠tulo no final.

## 13.1 Programa√ß√£o de banco de dados: t√©cnicas e problemas

Agora, vamos voltar nossa aten√ß√£o para as t√©cnicas que foram desambolvidas para acessar bancos de dados de programas e, em particular, para a quest√£o de  como  acessar  bancos  de  dados  SQL  de  programas de aplica√ß√£o. Nossa apresenta√ß√£o da SQL nos cap√≠tulos 4 e 5 focalizou as constru√ß√µes da linguagem para diversas opera√ß√µes do banco de dados - da defini√ß√£o  do  esquema  e  especifica√ß√£o  de  restri√ß√£o  at√© a consulta, atualiza√ß√£o e especifica√ß√£o de vis√µes. A maioria dos sistemas de banco de dados possui uma interface interativa na qual esses comandos SQL podem ser digitados diretamente em um monitor para execu√ß√£o pelo sistema de banco de dados. Por exemplo, em um sistema de computador em que o SGBD Oracle √© instalado, o comando SQLPLUS inicia a interface interativa. O usu√°rio pode digitar comandos ou consultas SQL diretamente em v√°rias linhas, terminadas com um ponto e v√≠rgula e uma tecla Enter (ou seja, '; &lt;cr&gt;' ). Como alternativa, um arquivo de comandos pode ser criado e executado por meio da interface  interativa  ao  digitar  @&lt; nomearquivo &gt;.  O sistema executar√° os comandos escritos no arquivo e exibir√° os resultados, se houver.

1 Outros prefixos √†s vezes s√£o usados, mas este √© o mais comum.

A interface interativa √© muito conveniente para a  cria√ß√£o  de  esquema  e  restri√ß√£o  ou  para  consultas ad hoc ocasionais. Por√©m, na pr√°tica, a maioria das  intera√ß√µes  de  banco  de  dados  √©  executada  por programas que foram cuidadosamente projetados e testados. Esses programas costumam ser conhecidos como programas de aplica√ß√£o ou aplica√ß√µes de banco de dados , e s√£o usados como transa√ß√µes programadas pelos usu√°rios finais, conforme discutimos na Se√ß√£o 1.4.3. Outro uso comum da programa√ß√£o de banco de dados √© para acessar um banco de dados por meio de um programa de aplica√ß√£o que implementa uma interface Web , por exemplo, quando se faz  reservas  ou  compras  de  uma  companhia  a√©rea. De fato, a grande maioria das aplica√ß√µes de com√©rcio eletr√¥nico na Web inclui alguns comandos de acesso a banco de dados. O Cap√≠tulo 14 nos dar√° uma vis√£o geral da programa√ß√£o de banco de dados Web usando PHP, uma linguagem de scripting que recentemente se tornou bastante utilizada.

Nesta  se√ß√£o,  primeiro  damos  uma  vis√£o  geral das principais t√©cnicas de programa√ß√£o de banco de dados. Depois, discutimos alguns dos problemas que ocorrem quando se tenta acessar um banco de dados com base em uma linguagem de programa√ß√£o de uso geral,  e  a  sequ√™ncia  t√≠pica  de  comandos  para  interagir com um banco de dados de um programa de software.

## 13.1.1 √©cnicas para a programa√ß√£o de T banco de dados

Existem  v√°rias  t√©cnicas  para  incluir  intera√ß√µes do banco de dados nos programas de aplica√ß√£o. As principais  t√©cnicas  para  programa√ß√£o  de  banco  de dados s√£o as seguintes:

- 1. Embutir  comandos  do  banco  de  dados  em uma  linguagem  de  programa√ß√£o  de  uso  geral. Nessa t√©cnica, os comandos do banco de dados  s√£o embutidos na  linguagem  de  programa√ß√£o hospedeira, mas eles s√£o identificadas por um prefixo especial. Por exemplo, o prefixo para a SQL embutida √© a string EXEC SQL, que precede todos os comandos SQL em um programa de linguagem hospedeira. 1  Um pr√©-compilador ou pr√©-processador varre  o c√≥digo do programa fonte para identificar os comandos de banco de dados e extra√≠-los para processamento pelo SGBD. Eles s√£o substitu√≠dos no programa por chamadas de fun√ß√£o ao c√≥digo gerado pelo SGBD. Essa t√©cnica geralmente √© conhecida como SQL embutida .

- 2. Usar uma biblioteca de fun√ß√µes de banco de dados. Uma biblioteca  de  fun√ß√µes se  torna dispon√≠vel √† linguagem de programa√ß√£o hospedeira  para  chamadas  de  banco  de  dados. Por  exemplo,  poderia  haver  fun√ß√µes  para conectar com um banco de dados, executar uma atualiza√ß√£o, e assim por diante. Os comandos  reais  de  consulta  e  atualiza√ß√£o  do banco de dados e quaisquer outras informa√ß√µes necess√°rias s√£o inclu√≠dos como par√¢metros  nas  chamadas  de  fun√ß√£o.  Essa  t√©cnica oferece o que √© conhecido como interface de programa√ß√£o de aplica√ß√£o  API ( -Application Programming Interface ) para acessar um banco de dados de programas de aplica√ß√£o.
- 3. Projetar  uma  linguagem  totalmente  nova. Uma linguagem de programa√ß√£o de banco de dados √©  projetada  do  zero  para  ser  compat√≠vel  com  o  modelo  de  banco  de  dados  e  a linguagem de consulta. Estruturas de programa√ß√£o  adicionais,  como  loops  e  instru√ß√µes condicionais, s√£o acrescentadas √† linguagem de banco de dados para convert√™-la em uma linguagem  de  programa√ß√£o  completa.  Um exemplo dessa t√©cnica √© a PL/SQL da Oracle.

Na pr√°tica, as duas primeiras t√©cnicas s√£o mais comuns, pois muitas aplica√ß√µes j√° s√£o escritas em linguagens de programa√ß√£o de uso geral, mas exigem algum acesso ao banco de dados. A terceira t√©cnica √© mais apropriada para aplica√ß√µes que possuem intensa intera√ß√£o com o banco de dados. Um dos principais problemas com as duas primeiras t√©cnicas √© a diverg√™ncia de imped√¢ncia , que n√£o ocorre na terceira t√©cnica.

## 13.1.2 Diverg√™ncia de imped√¢ncia

Diverg√™ncia  de  imped√¢ncia √©  o  termo  usado para se referir aos problemas que ocorrem devido √†s diferen√ßas entre o modelo de banco de dados e o modelo da linguagem de programa√ß√£o. Por exemplo, o modelo relacional pr√°tico tem tr√™s constru√ß√µes principais: colunas (atributos) e seus tipos de dados, linhas (tamb√©m chamadas de tuplas ou registros)  e  tabelas  (conjuntos  ou  multiconjuntos de registros).  O  primeiro  problema que pode ocorrer √©  que  os tipos  de  dados  da  linguagem  de  programa√ß√£o diferem dos tipos de dados de atributo que est√£o dispon√≠veis no modelo de dados. Logo, √© necess√°rio ter um v√≠nculo para cada linguagem de programa√ß√£o hospedeira que especifica, para cada tipo de atributo, os tipos de linguagem de programa√ß√£o compat√≠veis. Um v√≠nculo diferente √© necess√°rio para cada  linguagem  de  programa√ß√£o , pois  diferentes linguagens  possuem  diversos  tipos  de  dados.  Por exemplo, os tipos de dados dispon√≠veis em C/C++ e Java s√£o diferentes, e ambos diferem dos tipos de dados SQL, que s√£o os tipos de dados padr√£o para bancos de dados relacionais.

Outro problema ocorre porque os resultados da maioria  das  consultas  s√£o  conjuntos  ou  multiconjuntos de tuplas (linhas), e cada tupla √© formada por uma sequ√™ncia de valores de atributo. No programa, normalmente √© necess√°rio acessar os valores de dados individuais nas tuplas individuais para impress√£o ou processamento. Logo, √© preciso que haja um v√≠nculo para mapear a estrutura de dados do resultado da consulta , que √© uma tabela, para uma estrutura de dados apropriada na linguagem de programa√ß√£o. √â necess√°rio que haja um mecanismo para percorrer  as  tuplas  em  um resultado  de  consulta a fim de acessar uma √∫nica tupla de cada vez e extrair valores individuais dela. Os valores de atributo extra√≠dos costumam ser copiados para as vari√°veis de programa apropriadas para que o programa continue processando. Um cursor ou vari√°vel de itera√ß√£o normalmente √© usado para percorrer as tuplas em um resultado de consulta. Os valores individuais dentro de cada tupla s√£o ent√£o extra√≠dos para vari√°veis de programa distintas do tipo apropriado.

A  diverg√™ncia  de  imped√¢ncia  √©  um  problema menor quando uma linguagem de programa√ß√£o de banco de dados especial √© projetada para usar o mesmo modelo e tipos de dados do banco de dados. Um exemplo dessa linguagem √© a PL/SQL da Oracle. O padr√£o SQL tamb√©m tem uma proposta para tal linguagem de programa√ß√£o de banco de dados, conhecida como SQL/PSM . Para bancos de dados de objeto, o modelo de dados de objeto (ver Cap√≠tulo 11) √© muito semelhante ao modelo de dados da linguagem de programa√ß√£o Java, de modo que a diverg√™ncia de imped√¢ncia √© bastante reduzida quando Java √© usada como linguagem hospedeira para acessar um banco de dados de objeto compat√≠vel com ela. Diversas linguagens de programa√ß√£o de banco de dados foram implementadas como prot√≥tipos de pesquisa (ver a bibliografia selecionada).

## 13.1.3 Sequ√™ncia de intera√ß√£o t√≠pica na programa√ß√£o de banco de dados

Quando um programador ou engenheiro de software escreve um programa que exige acesso a um banco de dados, √© muito comum que o programa esteja rodando em um sistema de computador enquanto o banco de dados √© instalado em outro. Lembre-se, da Se√ß√£o 2.5, de que uma arquitetura comum para o acesso ao banco de dados √© o modelo cliente/servidor,

no qual um programa cliente trata da l√≥gica de uma aplica√ß√£o de software, mas inclui algumas chamadas para um ou mais servidores de banco de dados para acessar ou atualizar os dados. 2 Ao escrever tal programa, uma sequ√™ncia comum de intera√ß√£o √© a seguinte:

- 1. Quando o programa cliente requer acesso a determinado  banco  de  dados,  o  programa precisa  primeiro estabelecer ou abrir uma conex√£o com o servidor de banco de dados. Normalmente, isso ambolve especificar o endere√ßo da Internet (URL) da m√°quina onde o servidor de banco de dados est√° localizado, al√©m de fornecer um nome de conta de login e senha para o acesso ao banco de dados.
- 2. Quando  a  conex√£o  √©  estabelecida,  o  programa pode interagir com o banco de dados submetendo consultas, atualiza√ß√µes e outros comandos  do  banco  de  dados.  Em  geral,  a maioria dos tipos de instru√ß√µes SQL pode ser inclu√≠da em um programa de aplica√ß√£o.
- 3. Quando o programa n√£o precisar mais acessar determinado banco de dados, ele dever√° terminar ou fechar essa conex√£o.

Um programa pode acessar v√°rios bancos de dados, se for preciso. Em algumas t√©cnicas de programa√ß√£o de banco de dados, somente uma conex√£o pode estar ativa de uma s√≥ vez, enquanto em outras, v√°rias conex√µes podem ser estabelecidas simultaneamente.

Nas pr√≥ximas tr√™s se√ß√µes, vamos discutir exemplos de cada uma das tr√™s principais t√©cnicas de programa√ß√£o de banco de dados. A Se√ß√£o 13.2 descreve como a SQL √© embutida em uma linguagem de programa√ß√£o. A Se√ß√£o 13.3 discute como as chamadas de fun√ß√£o s√£o usadas para acessar o banco de dados, e a Se√ß√£o 13.4 discute uma extens√£o √† SQL chamada SQL/PSM, que permite constru√ß√µes de programa√ß√£o de uso geral para definir m√≥dulos (procedimentos e fun√ß√µes) que s√£o armazenados no sistema de banco de dados. 3  A Se√ß√£o 13.5 compara essas t√©cnicas.

## 13.2 SQL embutida, SQL din√¢mica e SQLJ

Nesta se√ß√£o, fornecemos uma vis√£o geral da t√©cnica que demonstra como as instru√ß√µes SQL podem ser  embutidas  em  uma  linguagem  de  programa√ß√£o de uso geral. Focalizamos duas linguagens: C e Java.

Os exemplos usados com a linguagem C, conhecida como SQL  embutida ,  s√£o  apresentados  nas  se√ß√µes 13.2.1  a  13.2.3,  e  podem  ser  adaptados  a  outras linguagens de programa√ß√£o. Os exemplos que usam Java, conhecidos como SQLJ ,  s√£o apresentados nas se√ß√µes  13.2.4  e  13.2.5.  Nesta  t√©cnica  embutida,  a linguagem de programa√ß√£o √© chamada de linguagem hospedeira (ou host ). A maioria das instru√ß√µes SQL incluindo defini√ß√µes de dados ou restri√ß√µes, consultas, atualiza√ß√µes ou defini√ß√µes de vis√£o - pode ser embutida em um programa na linguagem hospedeira.

## 13.2.1 Recuperando tuplas isoladas com SQL embutida

Para  ilustrar  os  conceitos  da  SQL  embutida, usaremos C como linguagem de programa√ß√£o hospedeira. 4 Ao  usar  C  dessa  maneira,  uma  instru√ß√£o SQL embutida  √©  distinguida  das  instru√ß√µes  da  linguagem  de  programa√ß√£o  pelas  palavras-chave  de prefixo EXEC SQL , de modo que um pr√©-processador (ou pr√©-compilador ) possa separar as instru√ß√µes SQL embutidas  do  c√≥digo  da  linguagem  hospedeira.  As instru√ß√µes SQL em um programa terminam com um END-EXEC correspondente ou com um ponto e v√≠rgula (;). Regras semelhantes se aplicam √† SQL embutida em outras linguagens de programa√ß√£o.

Em um comando SQL embutido, podemos nos referir a vari√°veis de programa√ß√£o C especialmente declaradas.  Estas  s√£o  chamadas  de vari√°veis  compartilhadas porque s√£o usadas tanto no programa C quanto nas instru√ß√µes SQL embutidas. As vari√°veis compartilhadas s√£o iniciadas com um sinal de dois pontos (:) quando aparecem em uma instru√ß√£o SQL . Isso  distingue  os  nomes  de  vari√°vel  do  programa dos nomes das constru√ß√µes do esquema de banco de dados, como atributos (nomes de coluna) e rela√ß√µes (nomes de tabela). Isso tamb√©m permite que as vari√°veis do programa tenham os mesmos nomes que os atributos, pois podem ser distinguidos pelo sinal de dois pontos de prefixo na instru√ß√£o SQL. Os nomes de constru√ß√µes do esquema de banco de dados como atributos  e  rela√ß√µes  -  s√≥  podem  ser  usados nos comandos SQL, mas as vari√°veis de programa compartilhadas podem ser usadas em qualquer lugar no programa C sem o prefixo de dois pontos.

Suponha que queiramos escrever programas C para processar o banco de dados FUNCRESA da Figura 3.5. Precisamos declarar vari√°veis de programa

2 Conforme discutimos na Se√ß√£o 2.5, existem arquiteturas de duas e tr√™s camadas; para simplificar nossa discuss√£o, vamos considerar aqui uma arquitetura cliente/servidor de duas camadas.

3 A SQL/PSM ilustra como as constru√ß√µes t√≠picas da linguagem de programa√ß√£o de uso geral - como loops e estruturas condicionais - podem ser incorporadas √† SQL.

4 Nossa discuss√£o aqui tamb√©m se aplica √† linguagem de programa√ß√£o C++, pois n√£o usamos nenhum dos recursos orientados a objeto, mas focalizamos o mecanismo de programa√ß√£o de banco de dados.

que correspondam aos tipos dos atributos do banco de dados que o programa processar√°. O programador pode escolher os nomes das vari√°veis de programa, que podem ou n√£o ter nomes id√™nticos a seus atributos correspondentes no banco de dados. Usaremos as vari√°veis de programa C declaradas na Figura 13.1 para todos os nossos exemplos, mostrando os segmentos de programa C sem declara√ß√µes de vari√°vel. As vari√°veis compartilhadas s√£o declaradas em uma se√ß√£o de declara√ß√£o no programa, como mostra a  Figura  13.1  (linhas  1  a  7).   Alguns  dos  v√≠nculos 5 comuns dos tipos C com os tipos SQL s√£o os seguintes: os tipos SQL INTEGER, SMALLINT, REAL e DOUBLE s√£o mapeados para os tipos C long, short, float e double, respectivamente.  Strings  de  tamanho  fixo e de tamanho vari√°vel ( CHAR[ ] i , VARCHAR[] i ) em SQL podem ser mapeados para vetores de caracteres ( char [i+1], varchar [i+1]) em C, que possuem um caractere a mais que o tipo SQL, pois as strings em C terminam com um caractere NULL ( \0) ,  que  n√£o  faz  parte  da string de caracteres em si. 6 Embora varchar n√£o seja um tipo de dado C padr√£o, ele √© permitido quando C √© usada para a programa√ß√£o de banco de dados SQL.

Observe que os √∫nicos comandos SQL embutidos na Figura 13.1 s√£o as linhas 1 e 7, que dizem ao pr√©-compilador para atentar para os nomes de vari√°vel C entre BEGIN DECLARE e END DECLARE , pois podem ser inclu√≠dos em instru√ß√µes SQL embutidas - desde que precedidas por um sinal de dois pontos (:). As linhas 2 a 5 s√£o declara√ß√µes normais de programa C. As vari√°veis de programa C declaradas nas linhas 2 a 5 correspondem aos atributos das tabelas FUNCIONARIO e DEPARTAMENTO do banco de dados EMPRESA da Figura 3.5, que foi declarado pela SQL DDL na Figura 4.1. As vari√°veis declaradas na linha 6 SQLCODE e SQLSTATE - s√£o usadas para comunicar erros e condi√ß√µes de exce√ß√£o entre o sistema de banco

- 0) int loop ;
- 1) EXEC SQL BEGIN DECLARE SECTION ;
- 2) varchar dnrme [16], pnome [16], unome [16], endereco [31] ;
- 3) char cpf [10], datanasc [11], sex [2], minicial [2] ;
- 4) float salario, aumento ;
- 5) int dnr, dnumero ;
- 6) int SQLCODE ; char SQLSTATE [6] ;
- 7) EXEC SQL END DECLARE SECTION ;

## Figura 13.1

Vari√°veis do programa C utilizadas nos exemplos E1 e E2 da SQL embutida.

de dados e o programa em execu√ß√£o. A linha 0 mostra uma vari√°vel de programa loop que  n√£o  ser√°  usada em qualquer instru√ß√£o SQL embutida, de modo que √© declarada fora da se√ß√£o de declara√ß√£o da SQL.

Conectando ao banco de dados. O comando SQL para estabelecer uma conex√£o com um banco de dados tem a seguinte forma:

CONNECT TO &lt;nome do servidor&gt; AS &lt;nome da conex√£o&gt; AUTHORIZATION &lt;nome de conta do usu√°rio e senha&gt; ;

Em geral, como um usu√°rio ou programa podem acessar v√°rios servidores de banco de dados, diversas conex√µes podem ser estabelecidas, mas somente uma pode estar ativa em qualquer ponto no tempo. O programador ou usu√°rio podem usar o &lt;nome da conex√£o&gt; para mudar da conex√£o atualmente ativa para uma diferente utilizando o comando a seguir:

## SET CONNECTION &lt;nome da conex√£o&gt; ;

Quando uma conex√£o n√£o √© mais necess√°ria, ela pode ser terminada pelo seguinte comando:

## DISCONNECT &lt;nome da conex√£o&gt; ;

Nos exemplos deste cap√≠tulo, consideramos que a conex√£o apropriada j√° foi estabelecida com o banco de dados FUNCRESA e que ela √© a conex√£o atualmente ativa.

Comunica√ß√£o entre o programa e o SGBD usando SQLCODE e SQLSTATE. As  duas vari√°veis  de  comunica√ß√£o especiais que s√£o usadas pelo SGBD para comunicar condi√ß√µes de exce√ß√£o ou erro ao programa s√£o SQLCODE e SQLSTATE. A vari√°vel SQLCODE , mostrada na Figura 13.1, √© uma vari√°vel inteira. Ap√≥s cada comando do banco de dados ser executado, o SGBD retorna um valor em SQLCODE. Um valor 0 indica que a instru√ß√£o foi executada com sucesso pelo SGBD. Se SQLCODE &gt; 0 (ou, mais especificamente, se SQLCODE = 100), isso indica que n√£o h√° mais dados (registros) dispon√≠veis em um resultado de consulta. Se SQLCODE &lt; 0, isso indica que houve algum erro. Em alguns sistemas - por exemplo, no SGBDR da Oracle -, SQLCODE √©  um  campo  em  uma  estrutura  de  registro  chamada SQLCA (SQL  Communication  Area), de modo que √© referenciado como SQLCA.SQLCODE. Nesse caso, a defini√ß√£o da SQLCA precisa ser inclu√≠da no programa C utilizando a seguinte linha:

EXEC SQL include SQLCA ;

- 5 Usamos n√∫meros de linha em nossos segmentos de c√≥digo apenas para facilitar a refer√™ncia; esses n√∫meros n√£o fazem parte do c√≥digo real.

6 Strings SQL tamb√©m podem ser mapeadas para tipos char* em C.

Em vers√µes mais recentes do padr√£o SQL, uma vari√°vel  de  comunica√ß√£o  chamada SQLSTATE foi acrescentada, que √© uma string de cinco caracteres. Um valor '00000' em SQLSTATE indica nenhum erro ou exce√ß√£o; outros valores indicam diversos erros ou exce√ß√µes. Por exemplo, '02000' indica 'sem mais dados'  quando  se  usa SQLSTATE. Atualmente,  tanto SQLSTATE quanto SQLCODE est√£o  dispon√≠veis  no padr√£o SQL. Muitos dos c√≥digos de erro e exce√ß√£o retornados  em SQLSTATE supostamente  est√£o  padronizados para todos os vendedores e plataformas SQL, 7  enquanto os c√≥digos retornados em SQLCODE n√£o est√£o padronizados, mas s√£o definidos pelo vendedor do SGBD. Logo, em geral √© melhor usar SQLSTATE , pois isso torna o tratamento de erro nos programas de aplica√ß√£o independente de um SGBD em particular. Como um exerc√≠cio, o leitor dever√° reescrever os exemplos dados mais adiante neste cap√≠tulo usando SQLSTATE em vez de SQLCODE.

mos anteriormente. A cl√°usula INTO s√≥ pode ser usada desse modo quando o resultado da consulta √© um √∫nico registro; se v√°rios registros forem recuperados, ser√° gerado um erro. Veremos como m√∫ltiplos registros s√£o tratados na Se√ß√£o 13.2.2.

A linha 7 em E1 ilustra a comunica√ß√£o entre o banco de dados e o programa por meio da vari√°vel especial SQLCODE. Se o valor retornado pelo SGBD em SQLCODE for 0, a instru√ß√£o anterior foi executada sem erros ou condi√ß√µes de exce√ß√£o. A linha 7 verifica isso e assume que, se ocorreu um erro, foi porque n√£o existia nenhuma tupla FUNCIONARIO com o Cpf dado; portanto, ela gera uma mensagem de sa√≠da indicando isso (linha 8).

Exemplo  de  programa√ß√£o  SQL  embutida. Nosso primeiro exemplo para ilustrar a programa√ß√£o SQL embutida √© um segmento repetitivo (loop) do programa que recupera como entrada o n√∫mero do Cpf de um funcion√°rio e imprime algumas informa√ß√µes com base no registro de FUNCIONARIO correspondente no banco de dados. O c√≥digo de programa em C aparece como o segmento de programa E1 na Figura 13.2. O programa l√™ (entradas) um valor de Cpf e depois recupera a tupla de FUNCIONARIO com esse Cpf do banco de dados por meio do comando SQL embutido. A cl√°usula INTO (linha 5) especifica as vari√°veis do programa em que os valores de atributo do registro de banco de dados s√£o recuperados. As vari√°veis do  programa  em  C  na  cl√°usula INTO s√£o  iniciadas com um sinal de dois pontos (:), conforme discuti-

Em  E1,  um √∫nico  registro √©  selecionado  pela consulta SQL embutida (porque Cpf √©  um atributo de chave de FUNCIONARIO) . Quando um √∫nico registro √© recuperado, o programador pode designar seus valores de atributo diretamente √†s vari√°veis do programa em C na cl√°usula INTO , como na linha 5. Em geral, uma consulta SQL pode recuperar muitas tuplas. Nesse caso, o programa em C costuma percorrer as tuplas recuperadas e as processa uma de cada vez. O conceito de um cursor √© usado para permitir o processamento de uma tupla por vez no resultado de uma consulta pelo programa da linguagem hospedeira. A seguir, vamos descrever os cursores.

## 13.2.2 Recuperando m√∫ltiplas tuplas com SQL embutida usando cursores

Podemos imaginar um cursor como um ponteiro que aponta para uma √∫nica tupla  linha ( ) do resultado de uma consulta que recupera m√∫ltiplas tuplas. O cursor √© declarado quando o comando de consulta

- //Segmento de programa E1: 0) loop = 1 ; 1) while (loop) { 2) prompt('Digite um CPF: ', cpf) ; 3) EXEC SQL 4) select Pnome, Minicial, Unome, Endereco, Salario 5) into :pnome, :minicial, :unome, :endereco, :salario 6) from FUNCIONARIO where Cpf = :cpf ; 7) if (SQLCODE == 0) printf(pnome, minicial, unome, endereco, salario) 8) else printf('CPF n√£o existe: ', cpf) ; 9) prompt('Mais CPF (digite 1 para Sim, 0 para N√£o): ', loop) ; 10) }

Figura 13.2

Segmento de programa E1, um segmento de programa em C com SQL embutida.

7 Em particular, c√≥digos de SQLSTATE come√ßando com os caracteres 0 a 4 ou A a H supostamente s√£o padronizados, enquanto outros valores podem ser definidos pela implementa√ß√£o.

SQL √© declarado no programa. Mais adiante no programa, um comando OPEN CURSOR busca o resultado da consulta no banco de dados e define o cursor para uma posi√ß√£o antes da primeira linha no resultado da consulta. Esta se torna a linha atual para o cursor.  Depois,  comandos FETCH s√£o  emitidos  no programa. Cada FETCH move o cursor para a pr√≥xima linha no resultado da consulta, tornando-a a linha ativa e copiando seus valores de atributo para as vari√°veis do programa em C (linguagem hospedeira) especificadas no comando FETCH por uma cl√°usula INTO . A vari√°vel do cursor √© basicamente um iterador (iterator)que percorre as (por loop) tuplas no resultado da consulta - uma tupla de cada vez.

Para determinar quanto todas as tuplas no resultado  da  consulta  foram  processadas,  a  vari√°vel de  comunica√ß√£o SQLCODE (ou,  como  alternativa, SQLSTATE) √© verificada. Se um comando FETCH for emitido e resultar na movimenta√ß√£o do cursor al√©m da √∫ltima tupla no resultado da consulta, um valor positivo ( SQLCODE &gt; 0) √© retornado em SQLCODE, indicando que nenhum dado (tupla) foi encontrado (ou a string '02000' √© retornada em SQLSTATE) .  O programador usa isso para terminar um loop sobre tuplas no resultado da consulta. Em geral, diversos cursores podem ser abertos ao mesmo tempo. Um comando CLOSE CURSOR √© emitido para indicar que terminamos com o processamento do resultado da consulta associada a esse cursor.

- //Segmento de programa E2:
- 0) prompt('Digite o Nome do Departamento: ', dnome) ;
- 1) EXEC SQL
- 2) select Dnumero into :dnumero
- 3) from DEPARTAMENTO where Dnome = :dnome ;
- 4) EXEC SQL DECLARE FUNC CURSOR FOR
- 5) select Cpf, Pnome, Minicial, Unome, Salario
- 6) from FUNCIONARIO where Dnr = :dnumero
- 7) FOR UPDATE OF Salario ;
- 8) EXEC SQL OPEN FUNC ;
- 9) EXEC SQL FETCH from FUNC into :cpf, :pnome, :minicial, :unome, :salario ;
- 10) while (SQLCODE == 0) {
- 11) printf('O nome do funcionario √©:', Pnome, Minicial, Unome) ;
- 12) prompt('digite o valor de aumento: ', aumento) ;
- 13) EXEC SQL
- 14) update FUNCIONARIO
- 15) set Salario = Salario + :aumento
- 16) where CURRENT OF FUNC ;
- 17) EXEC SQL FETCH from FUNC into :cpf, :pnome, :minicial, :unome, :salario ;
- 18) }
- 19) EXEC SQL CLOSE FUNC ;

Figura 13.3

Um exemplo de uso de cursores para processar um resultado de consulta com m√∫ltiplos registros √© mostrado na Figura 13.3, onde um cursor chamado FUNC √© declarado na linha 4. O cursor FUNC √© associado √† consulta SQL declarada nas linhas 5 a 6, mas a consulta n√£o √© executada at√© que o comando OPEN FUNC (linha 8) seja processado. O comando OPEN &lt;nome cursor&gt; executa a consulta e busca seu resultado  como  uma  tabela  no  workspace  do  programa,  onde  o  programa  pode  percorrer  as  linhas (tuplas)  individuais  por  comandos FETCH &lt;nome cursor&gt;  subsequentes  (linha  9).  Consideramos  que as  vari√°veis  apropriadas  no  programa em C foram declaradas,  como  na  Figura  13.1.  O  segmento  de programa em E2 l√™ (entrada) um nome de departamento (linha 0), recupera o n√∫mero de departamento correspondente do banco de dados (linhas 1 a 3) e depois recupera os funcion√°rios que trabalham nesse departamento por meio do cursor FUNC .  Um  loop (linhas 10 a 18) passa por cada registro no resultado da consulta, um de cada vez, e imprime o nome do funcion√°rio. O programa ent√£o l√™ (entrada) um valor de aumento para esse funcion√°rio (linha 12) e atualiza o sal√°rio dele no banco de dados pelo valor do aumento que foi oferecido (linhas 14 a 16).

Este  exemplo  tamb√©m  ilustra  como  o  programador pode atualizar registros do banco de dados. Quando um cursor √© definido para linhas que devem ser modificadas ( atualizadas ), temos de acrescentar a

cl√°usula FOR UPDATE OF na declara√ß√£o do cursor e listar os nomes de quaisquer atributos que ser√£o atualizados pelo programa. Isso √© ilustrado na linha 7 do segmento de c√≥digo E2. Se as linhas tiverem de ser exclu√≠das , as palavras-chave FOR UPDATE devem ser acrescentadas sem especificar quaisquer atributos. No comando embutido UPDATE (ou DELETE) , a condi√ß√£o WHERE CURRENT OF &lt;nome cursor&gt; especifica que a tupla atual referenciada pelo cursor √© aquela a ser atualizada (ou exclu√≠da), como na linha 16 de E2.

Observe que declarar um cursor e associ√°-lo a uma consulta (linhas 4 a 7 em E2) n√£o executa a consulta. A consulta √© realizada somente quando o comando OPEN &lt;nome cursor&gt; (linha 8) √© executado. Observe tamb√©m que n√£o √© preciso incluir a cl√°usula FOR UPDATE OF na linha 7 de E2 se os resultados da consulta tiverem de ser usados apenas para fins de recupera√ß√£o (sem atualiza√ß√£o ou exclus√£o).

Op√ß√µes  gerais  para  uma  declara√ß√£o  de  cursor. V√°rias op√ß√µes podem ser especificadas quando se declara um cursor. O formato geral de uma declara√ß√£o de cursor √© o seguinte:

DECLARE &lt;nome cursor&gt; [ INSENSITIVE ] [ SCROLL ] CURSOR [ WITH HOLD ] FOR &lt;especifica√ß√£o da consulta&gt;

[ ORDER BY &lt;lista de atributos&gt;

&lt;especifica√ß√£o de ordena√ß√£o&gt; ] [ FOR READ ONLY | FOR UPDATE [ OF ] ] ;

J√° discutimos rapidamente as op√ß√µes listadas na √∫ltima linha. O padr√£o √© que a consulta seja para fins de recupera√ß√£o ( FOR READ ONLY ). Se algumas das tuplas no resultado da consulta tiverem de ser atualizadas, precisamos especificar FOR UPDATE OF &lt;lista atributos&gt; e listar os atributos que podem ser atualizados. Se algumas tuplas tiverem de ser exclu√≠das, precisamos especificar FOR UPDATE sem quaisquer atributos.

Quando  a  palavra-chave  opcional SCROLL √© especificada  em  uma  declara√ß√£o  de  cursor,  √©  poss√≠vel  posicionar  o  cursor  de  outras  maneiras  al√©m de simplesmente para acesso sequencial. Uma orienta√ß√£o de busca pode ser acrescentada ao comando FETCH ,  cujo  valor  pode  ser NEXT, PRIOR, FIRST, LAST, ABSOLUTE i e RELATIVE i . Nos dois √∫ltimos comandos,   precisa ser avaliado como um valor ini teiro que especifica uma posi√ß√£o de tupla absoluta no resultado da consulta (para ABSOLUTE i ) ou uma posi√ß√£o de tupla relativa √† posi√ß√£o atual do cursor (para RELATIVE i ). A orienta√ß√£o de busca padr√£o, que usamos em nossos exemplos, √© NEXT . A orienta√ß√£o de busca permite que o programador movimente o cur- sor pelas tuplas no resultado da consulta com maior flexibilidade, oferecendo acesso aleat√≥rio por posi√ß√£o ou acesso na ordem inversa. Quando SCROLL √©  especificado  no  cursor,  o  formato  geral  de  um comando FETCH √© o seguinte, com as partes entre colchetes sendo opcionais:

FETCH [ [ &lt;orienta√ß√£o de busca&gt; ] FROM ] &lt;nome do cursor&gt; INTO

&lt;lista de destino da busca&gt; ;

A cl√°usula ORDER BY ordena as tuplas de modo que o comando FETCH as buscar√° na ordem especificada. Ela √© determinada de modo semelhante √† cl√°usula correspondente para consultas SQL (ver Se√ß√£o 4.3.6). As duas √∫ltimas op√ß√µes quando se declara um cursor ( INSENSITIVE e WITH HOLD) referem-se a caracter√≠sticas de transa√ß√£o dos programas de banco de dados, que discutiremos no Cap√≠tulo 21.

## 13.2.3 Especificando consultas em tempo de execu√ß√£o usando a SQL din√¢mica

Nos exemplos anteriores, as consultas SQL embutidas foram escritas como parte do c√≥digo fonte do  programa  hospedeiro.  Logo,  quando  quisermos escrever uma consulta diferente, temos de modificar o c√≥digo do programa e passar por todas as etapas ambolvidas (compila√ß√£o, depura√ß√£o, teste etc.). Em alguns  casos,  √©  conveniente  escrever  um  programa que possa executar diferentes consultas ou atualiza√ß√µes SQL (ou outras opera√ß√µes) dinamicamente em tempo de execu√ß√£o .  Por  exemplo,  podemos  querer escrever um programa que aceite uma consulta SQL digitada pelo terminal, execute-a e apresente seu resultado,  como  as  interfaces  interativas  dispon√≠veis para a maioria dos SGBDs relacionais. Outro exemplo √© quando uma interface de f√°cil utiliza√ß√£o gera consultas SQL de maneira din√¢mica para o usu√°rio com base em opera√ß√µes do tipo apontar e clicar em um  esquema  gr√°fico  (por  exemplo,  uma  interface tipo  QBE;  ver  Ap√™ndice  C).  Nesta  se√ß√£o,  fazemos uma r√°pida vis√£o geral da SQL din√¢mica , que √© uma t√©cnica para escrever esse tipo de programa de banco de dados, dando um exemplo simples para ilustrar como essa linguagem pode funcionar. Na Se√ß√£o 13.3, descreveremos outra t√©cnica para lidar com consultas din√¢micas.

O segmento de programa E3 da Figura 13.4 l√™ uma string que √© inserida pelo usu√°rio (essa string poderia ser um comando de atualiza√ß√£o SQL) para a vari√°vel de string do programa sqlupdatestring na linha 3. Depois, ele prepara isso como um comando SQL na linha 4, associando-o √† vari√°vel SQL sqlcommand.

- //Segmento de programa E3:
- 0) EXEC SQL BEGIN DECLARE SECTION ;
- 1) varchar sqlupdatestring [256] ;
- 2) EXEC SQL END DECLARE SECTION ;

...

- 3) prompt('Digite o comando Update: ', sqlupdatestring) ;
- 4) EXEC SQL PREPARE sqlcommand FROM :sqlupdatestring ;
- 5) EXEC SQL EXECUTE sqlcommand ;

...

Figura 13.4

Segmento de programa E3, um segmento de programa em C que usa a SQL din√¢mica para atualizar uma tabela.

A linha 5 ent√£o executa o comando. Observe que, nesse caso, nenhuma verifica√ß√£o de sintaxe ou outros tipos de verifica√ß√µes sobre o comando s√£o poss√≠veis em tempo de compila√ß√£o , pois o comando SQL n√£o est√° dispon√≠vel em tempo de execu√ß√£o. Isso contrasta com nossos exemplos anteriores de SQL embutida, em que a consulta podia ser verificada em tempo de compila√ß√£o, pois seu texto estava no c√≥digo fonte do programa.

Embora a inclus√£o de um comando de atualiza√ß√£o din√¢mica seja relativamente simples na SQL din√¢mica, uma consulta din√¢mica √© muito mais complicada. Isso porque em geral n√£o conhecemos os tipos ou o n√∫mero de atributos a serem recuperados pela consulta SQL quando estamos escrevendo o programa.  Uma  estrutura  de  dados  complexa  √†s  vezes  √© necess√°ria para permitir diferentes n√∫meros e tipos de  atributos  no  resultado  da  consulta  se  nenhuma informa√ß√£o anterior for conhecida sobre a consulta din√¢mica. T√©cnicas semelhantes √†s que discutimos na Se√ß√£o 13.3 podem ser usadas para atribuir resultados da consulta (e par√¢metros da consulta) √†s vari√°veis do programa hospedeiro.

Em  E3,  o  motivo  para  separar PREPARE e EXECUTE √© que, se o comando tiver de ser executado v√°rias vezes em um programa, ele pode ser preparado apenas uma vez. A prepara√ß√£o do comando costuma ambolver sintaxe e outros tipos de verifica√ß√µes pelo sistema, bem como a gera√ß√£o do c√≥digo para execut√°-lo. √â poss√≠vel combinar os comandos PREPARE e EXECUTE (linhas 4 e 5 em E3) em um √∫nico comando ao escrever

Isso √© √∫til se o comando tiver de ser executado apenas  uma  vez.  Como  alternativa,  o  programador pode separar as duas instru√ß√µes para recuperar quaisquer erros ap√≥s a instru√ß√£o PREPARE , se houver algum.

## 13.2.4 SQLJ: embutindo comandos SQL em Java

Nas  subse√ß√µes  anteriores,  demos  uma  ideia de como os comandos SQL podem ser embutidos em  uma  linguagem  de  programa√ß√£o  tradicional, usando a linguagem C em nossos exemplos. Agora, voltamos nossa aten√ß√£o para como a SQL pode ser embutida em uma linguagem de programa√ß√£o orientada  a  objeto, 8   em  particular,  a  linguagem Java.  A  SQLJ  √©  um  padr√£o  que  foi  adotado  por diversos  vendedores  para  embutir  SQL  em  Java. Historicamente, a SQLJ foi desambolvida ap√≥s a JDBC, a qual √© usada para acessar bancos de dados SQL com a linguagem Java usando chamadas de fun√ß√£o. Vamos discutir a JDBC na Se√ß√£o 13.3.2. Nesta se√ß√£o, focamos em SQLJ e como ela √© usada no  SGBDR  Oracle.  Um  tradutor  de  SQLJ  geralmente  converter√°  comandos  SQL  para  Java,  que poder√£o ent√£o ser executados por meio da interface JDBC. Logo, √© necess√°rio instalar um driver JDBC ao  usar  a  SQLJ.   Nesta  se√ß√£o,  mostramos 9 como usar conceitos de SQLJ para escrever SQL embutida em um programa Java.

Antes  de  ser  capaz  de  processar  SQLJ  com Java em Oracle, √© necess√°rio importar v√°rias bibliotecas de classe, mostradas na Figura 13.5. Estas incluem as classes JDBC e IO (linhas 1 e 2), mais  as  classes  adicionais  listadas  nas  linhas  3, 4  e  5.  Al√©m  disso,  o  programa  precisa  primeiro se  conectar  ao  banco  de  dados  desejado  usando a  chamada  de  fun√ß√£o getConnection, que  √©  um dos m√©todos da classe oracle da linha 5 da Figura 13.5.  O  formato  dessa  chamada  de  fun√ß√£o,  que retorna um objeto do tipo contexto default , 10 √© o seguinte:

public static DefaultContext getConnection (String url, String user, String password,

Boolean autoCommit) throws SQLException ;

EXEC SQL EXECUTE IMMEDIATE :sqlupdatestring ;

Por exemplo, podemos escrever as instru√ß√µes nas linhas 6 a 8 da Figura 13.5 para conectar a um banco de dados Oracle localizado no url &lt;nome url&gt; usando

8 Esta se√ß√£o assume alguma familiaridade com conceitos orientados a objeto (ver Cap√≠tulo 11) e conceitos b√°sicos de Java.

9 Discutiremos sobre drivers JDBC na Se√ß√£o 13.3.2.

10 Um contexto default , quando definido, se aplica a comandos subsequentes no programa at√© que ele seja mudado.

- 1) import java.sql.* ;
- 2) import java.io.* ;
- 3) import sqlj.runtime.* ;
- 4) import sqlj.runtime.ref.* ;
- 5) import oracle.sqlj.runtime.* ;

‚Ä¶

- 6) DefaultContext cntxt =
- 7) oracle.getConnection('&lt;url name&gt;', '&lt;user name&gt;', '&lt;password&gt;', true) ;
- 8) DefaultContext.setDefaultContext(cntxt) ;

‚Ä¶

## Figura 13.5

Importando classes necess√°rias para incluir SQLJ em programas Java no Oracle e estabelecendo uma conex√£o e um contexto default.

o login de &lt;nome usu√°rio&gt; e &lt;senha&gt; com confirma√ß√£o autom√°tica de cada comando, 11  e depois definir essa conex√£o como o contexto default para comandos seguintes.

Nos exemplos a seguir, n√£o mostraremos as classes ou programas Java completos, pois n√£o √© nossa inten√ß√£o  ensinar  Java.  Em  vez  disso,  mostraremos segmentos de programa que ilustram o uso da SQLJ. A Figura 13.6 mostra as vari√°veis de programa Java usadas em nossos exemplos. O segmento de programa J1 na Figura 13.7 l√™ o Cpf de um funcion√°rio e imprime algumas das informa√ß√µes do funcion√°rio do banco de dados.

Observe que, como Java j√° usa o conceito de exce√ß√µes para  tratamento  de  erro,  uma  exce√ß√£o especial,  chamada SQLException ,  √©  utilizada  para

- //Segmento de programa J1:
- 1) cpf = readEntry('Digite o n√∫mero do CPF: ') ;
- 2) try {
- 3) #sql { select Pnome, Minicial, Unome, Endereco, Salario
- 4) into :pnome, :minicial, :unome, :endereco, :salario
- 5) from FUNCIONARIO where Cpf = :cpf} ;
- 6) } catch (SQLException se) {
- 7) System.out.println('N√∫mero do CPF n√£o existe: ' + cpf) ;
- 8) Return ;
- 9) }

10) System.out.println(pnome + ' ' + minicial + ' ' + unome + ' ' + endereco + ' ' + salario)

Figura 13.7 Segmento de programa J1, um segmento de programa Java com SQLJ.

11 Confirma√ß√£o autom√°tica significa mais ou menos que cada comando √© aplicado ao banco de dados depois de ser executado. A alternativa √© que o programador queira executar v√°rios comandos de banco de dados relacionados e, depois, os confirme juntos. Discutiremos conceitos de confirma√ß√£o ( commit ) no Cap√≠tulo 21, quando descrevermos transa√ß√µes do banco de dados.

- 1) string dnome, cpf, pnome, pn, unome, un, datanasc, endereco;
- 2) char sexo, minicial, mi ;
- 3) double salario, sal ;
- 4) integer dnr, dnumero ;

## Figura 13.6

Vari√°veis de programa Java usadas nos exemplos de J1 e J2 de SQLJ.

retornar  erros  ou  condi√ß√µes  de  exce√ß√£o  depois  de executar  um  comando  de  banco  de  dados  SQL. Isso desempenha um papel semelhante a SQLCODE e SQLSTATE na SQL embutida. A Java tem muitos tipos de exce√ß√µes predefinidas. Cada opera√ß√£o (fun√ß√£o)  Java  deve  especificar  as  exce√ß√µes  que  podem ser lan√ßadas - ou seja, as condi√ß√µes de exce√ß√£o que podem ocorrer enquanto se executa o c√≥digo Java dessa opera√ß√£o. Se ocorrer uma exce√ß√£o definida, o sistema transfere o controle ao c√≥digo Java especificado para tratamento da exce√ß√£o. Em J1, o tratamento da exce√ß√£o para uma SQLException √© especificado nas linhas 7 e 8. Em Java, a estrutura a seguir try {&lt;operacao&gt;} catch (&lt;excecao&gt;) {&lt;codigo de tratamento de excecao&gt;} &lt;continuacao de codigo&gt;

√© usada para lidar com exce√ß√µes que ocorrem durante a execu√ß√£o da &lt;operacao&gt;. Se n√£o houver exce√ß√£o, o &lt; continuacao de codigo &gt; √© processado diretamente. As exce√ß√µes que podem ser lan√ßadas pelo c√≥digo em determinada opera√ß√£o devem ser especificadas como parte da declara√ß√£o da opera√ß√£o ou interface - por exemplo, no formato a seguir:

&lt;tipo de retorno de operacao&gt; &lt;nome da operacao&gt; (&lt;parametros&gt;) throws SQLException, IOException ;

Em SQLJ, os comandos SQL embutidos em um programa  Java  s√£o  precedidos  por #sql, conforme ilustrado na linha 3 de J1, de modo que possam ser identificados pelo pr√©-processador. O #sql √© usado no lugar das palavras-chave EXEC SQL que s√£o utilizadas na SQL embutida com a linguagem de programa√ß√£o C (ver Se√ß√£o 13.2.1). A SQLJ usa uma cl√°usula INTO - semelhante √†quela da SQL embutida - para retornar os valores de atributo recuperados do banco de dados por uma consulta SQL em vari√°veis de programa Java. As vari√°veis de programa s√£o precedidas por sinais de dois pontos (:) na instru√ß√£o SQL, assim como na SQL embutida.

Em J1, uma √∫nica tupla √© recuperada pela consulta SQLJ embutida. √â por isso que podemos atribuir seus valores de atributo diretamente a vari√°veis do programa Java na cl√°usula INTO ,  na  linha  4  da Figura  13.7.  Para  consultas  que  recuperam  muitas tuplas, a SQLJ usa o conceito de um iterador (iterator), que √© semelhante a um cursor na SQL embutida.

## 13.2.5 Recuperando m√∫ltiplas tuplas em SQLJ usando iteradores

Em SQLJ, um iterador √© um tipo de objeto associado a uma cole√ß√£o (conjunto ou multiconjunto) de registros em um resultado de consulta. 12  O iterador est√° associado √†s tuplas e atributos que aparecem em um resultado de consulta. Existem dois tipos de iteradores:

- 1. Um iterador nomeado √©  associado a um resultado de consulta ao listar os nomes e tipos de atributo que aparecem no resultado dela. Os nomes de atributo devem corresponder a vari√°veis de programa Java apropriadamente declarados, como mostra a Figura 13.6.
- 2. Um iterador posicional lista apenas os tipos de  atributo que  aparecem  no  resultado  da consulta.

Nos dois casos, a lista deveria estar na mesma ordem dos atributos que s√£o listados na cl√°usula SELECT da consulta. No entanto, o looping sobre um resultado de consulta √© diferente para os dois tipos de iteradores, conforme veremos. Primeiro, mostramos um exemplo de uso de um iterador nomeado na Figura 13.8, segmento de programa J2A. A linha 9 na Figura 13.8 mostra como um tipo de iterador nomeado Func √© declarado. Observe que os nomes dos atributos em um tipo de iterador nomeado precisam combinar com os nomes dos atributos no resultado da consulta SQL. A linha 10 mostra como um objeto iterador e do tipo Func √© criado no programa e depois associado a uma consulta (linhas 11 e 12).

Quando  o  objeto  iterador  √©  associado  a  uma consulta (linhas 11 e 12 da Figura 13.8), o programa busca o resultado da consulta do banco de dados e define  o  iterador  para  uma  posi√ß√£o antes  da primeira linha no resultado da consulta. Esta torna-se a linha atual para o iterador. Subsequentemente, opera√ß√µes next s√£o emitidas sobre o objeto iterador. Cada next move o iterador para a pr√≥xima linha no resultado da consulta, tornando-a a linha atual. Se a linha existir, a opera√ß√£o recupera os valores de atributo para essa linha nas vari√°veis de programa correspondente. Se n√£o houver mais linhas, a opera√ß√£o next retorna NULL , e pode assim ser usada para controlar  o  looping.  Observe  que  o  iterador  nomeado n√£o precisa de uma cl√°usula INTO , pois as vari√°veis do programa correspondentes aos atributos recuperados j√° est√£o especificadas quando o tipo iterador √© declarado (linha 9 da Figura 13.8).

Na Figura 13.8, o comando (e.next(  )) na  linha 13 realiza duas fun√ß√µes: ele recupera a pr√≥xima tupla no resultado da consulta e controla o loop while . Quando o programa termina o processamento do resultado da consulta, o comando e.close( ) (linha 16) fecha o iterador.

A seguir, considere o mesmo exemplo usando iteradores posicionais , como mostra a Figura 13.9 (segmento de programa J2B). A linha 9 da Figura 13.9 mostra como um tipo iterador posicional Funcpos √© declarado. A principal diferen√ßa entre ele e o iterador nomeado √© que n√£o existem nomes de atributo (correspondentes a nomes de vari√°vel de programa) no iterador posicional - apenas tipos de atributo. Isso  pode  oferecer  mais  flexibilidade,  mas  torna  o processamento do resultado da consulta ligeiramente mais complexo. Os tipos de atributo ainda devem ser compat√≠veis com os tipos de atributo no resultado da consulta SQL e na mesma ordem. A linha 10 mostra como um objeto iterador posicional f do tipo Funcpos √© criado no programa e depois associado a uma consulta (linhas 11 e 12).

O iterador posicional se comporta de uma maneira mais parecida com a SQL embutida (ver Se√ß√£o 13.2.2). Um comando FETCH &lt; vari√°vel de itera√ß√£o &gt; INTO &lt; vari√°veis do programa &gt; √© necess√°rio para colocar a pr√≥xima tupla em um resultado da consulta. Na primeira vez em que fetch √© executado, ele recupera a primeira tupla (linha 13 na Figura 13.9). A

12 Discutimos sobre iteradores com mais detalhes no Cap√≠tulo 11, quando apresentamos os conceitos de banco de dados de objeto.

- //Segmento de programa J2A:
- 0) dnome = readEntry('Digite o nome do departamento: ') ;
- 1) try {
- 2) #sql { select Dnumero into :dnumero
- 3) from DEPARTAMENTO where Dnome = :dnome} ;
- 4) } catch (SQLException se) {
- 5) System.out.println('Departamento n√£o existe: ' + dnome) ;
- 6) Return ;
- 7) }
- 8) System.out.printline('Informa√ß√£o do funcion√°rio para departamento: ' + dnome) ;
- 9) #sql iterator Func(String cpf, String pnome, String minicial, String unome, double salario) ;
- 10) Func f = null ;
- 11) #sql f = { select cpf, pnome, minicial, unome, salario
- 12) from FUNCIONARIO where Dnr = :dnumero} ;
- 13) while (f.next( )) {
- 14) System.out.printline(f.cpf + ' ' + f.pnome + ' ' + f.minicial + ' ' + f.unome + ' ' + f.salario) ;
- 15) } ;
- 16) f.close( ) ;

## Figura 13.8

Segmento de programa J2A, um segmento de programa Java que usa um iterador nomeado para imprimir informa√ß√µes de funcion√°rio em determinado departamento.

//Segmento de programa J2B:

- 0) dnome = readEntry('Digite o nome do departamento: ') ;
- 1) try {
- 2) #sql { select Dnumero into :dnumero
- 3) from DEPARTAMENTO where Dnome = :dnome} ;
- 4) } catch (SQLException se) {
- 5) System.out.println('Departamento n√£o existe: ' + dnrme) ;
- 6) Return ;
- 7) }
- 8) System.out.printline('Informa√ß√£o do funcion√°rio para departamento: ' + dnome) ;
- 9) #sql iterator Funcpos(String, String, String, String, double) ;
- 10) Funcpos f = null ;
- 11) #sql e = { select cpf, pnome, minicial, unome, salario
- 12) from FUNCIONARIO where Dnr = :dnumero} ;
- 13) #sql { fetch :f into :cpf, :pn, :mi, :un, :sal} ;
- 14) while (!f.endFetch( )) {
- 15) System.out.printline(cpf + ' ' + pn + ' ' + mi + ' ' + un + ' ' + sal) ;
- 16) #sql { fetch :f into :cpf, :pn, :mi, :un, :sal} ;
- 17) } ;
- 18) f.close( ) ;

## Figura 13.9

Segmento de programa J2B, um segmento de programa em Java que usa um iterador posicional para imprimir informa√ß√µes de funcion√°rio em determinado departamento.

linha 16 recupera a pr√≥xima tupla at√© que n√£o haja mais tuplas no resultado da consulta. Para controlar o loop, uma fun√ß√£o de iterador posicional f.endFetch( ) √© utilizada. Essa fun√ß√£o √© definida para um valor TRUE

quando  o  iterador  √©  associado  inicialmente  a  uma consulta  SQL  (linha  11),  e  √©  definida  como FALSE toda vez que um comando de busca retorna uma tupla  v√°lida  do  resultado  da  consulta.  Ela  √©  definida

como TRUE novamente quando um comando de busca n√£o encontra mais tuplas. A linha 14 mostra como o loop  ing √© controlado pela nega√ß√£o.

## 13.3 Programa√ß√£o de banco de dados com chamadas de fun√ß√£o: SQL/CLI e JDBC

A SQL embutida (ver Se√ß√£o 13.2) √†s vezes √© chamada de t√©cnica de programa√ß√£o de banco de dados est√°tica ,  pois o texto da consulta √© escrito no c√≥digo fonte do programa e n√£o pode ser alterado sem uma nova compila√ß√£o ou reprocessamento do c√≥digo fonte. O uso de chamadas de fun√ß√£o √© uma t√©cnica mais din√¢mica para programa√ß√£o de banco de dados do  que  a  SQL  embutida.  J√°  vimos  uma  t√©cnica  de programa√ß√£o de banco de dados din√¢mico - SQL din√¢mica  -  na  Se√ß√£o  13.2.3.  As  t√©cnicas  discutidas aqui oferecem outro enfoque para a programa√ß√£o din√¢mica de banco de dados. Uma biblioteca de fun√ß√µes , tamb√©m  conhecida  como  uma interface de  programa√ß√£o  de  aplica√ß√£o ( API ),  √©  usada  para acessar o banco de dados. Embora isso ofere√ßa mais flexibilidade, pois nenhum pr√©-processador √© necess√°rio, uma desvantagem √© que a sintaxe e outras verifica√ß√µes sobre comandos SQL precisam ser feitas em tempo de execu√ß√£o. Outra desvantagem √© que isso √†s vezes requer uma programa√ß√£o mais complexa para acessar resultados da consulta, pois os tipos e n√∫meros de atributos em um resultado de consulta podem n√£o ser conhecidos previamente.

Nesta  se√ß√£o,  damos  uma  vis√£o  geral  de  duas interfaces  de  chamada  de  fun√ß√£o.  Primeiro,  discutimos a SQL Call Level Interface (SQL/CLI ), que √© parte  do  padr√£o  SQL.  Ela  foi  desambolvida  como um complemento para a t√©cnica mais antiga conhecida  como  ODBC  ( Open  Database  Connectivity ). Usamos  C  como  linguagem  hospedeira  em  nossos exemplos de SQL/CLI. Depois, oferecemos uma vis√£o  geral  da JDBC ,  que  √©  a  interface  de  chamada de fun√ß√£o para acessar bancos de dados com Java. Embora normalmente se considere que JDBC signifique Java Database Connectivity, trata-se apenas de uma marca registrada da Sun Microsystems, n√£o um acr√¥nimo.

programa√ß√£o de banco de dados Java com JDBC, embora essa vantagem tamb√©m se aplique √† programa√ß√£o de banco de dados com SQL/CLI e ODBC (ver Se√ß√£o 13.3.1).

## 13.3.1 Programa√ß√£o de banco de dados com SQL/CLI usando C como linguagem hospedeira

Antes de usar as chamadas de fun√ß√£o na SQL/ CLI, √© necess√°rio instalar os pacotes de bibliotecas apropriados no servidor de banco de dados. Esses pacotes s√£o obtidos com o vendedor do SGBD em uso.  Agora,  vamos  apresentar  uma  vis√£o  geral  de como a SQL/CLI pode ser usada em um programa em  C. 13 Ilustraremos  nossa  apresenta√ß√£o  com  um exemplo de segmento de programa CLI1, mostrado na Figura 13.10.

Ao usar a SQL/CLI, as instru√ß√µes SQL s√£o criadas dinamicamente e passadas como par√¢metros de string nas  chamadas de fun√ß√£o. Logo, √© necess√°rio registrar as informa√ß√µes sobre as intera√ß√µes do programa hospedeiro com o banco de dados nas estruturas de dados em tempo de execu√ß√£o, pois os comandos do banco de dados s√£o processados em tempo de execu√ß√£o. A informa√ß√£o √© mantida em quatro tipos de registros, representados como structs em tipos de dados C. Um registro de ambiente √© usado como um recipiente  para  registrar  uma  ou  mais  conex√µes  de banco de dados e definir informa√ß√µes de ambiente. Um registro de conex√£o registra as informa√ß√µes necess√°rias para determinada conex√£o de banco de dados. Um registro de instru√ß√£o registra as informa√ß√µes necess√°rias  para  uma  instru√ß√£o  SQL.  Um registro de descri√ß√£o registra as informa√ß√µes sobre tuplas ou par√¢metros - por exemplo, o n√∫mero de atributos e seus tipos em uma tupla, ou o n√∫mero e os tipos de  par√¢metros  em  uma  chamada de fun√ß√£o. Isso √© necess√°rio quando o programador n√£o conhece essa informa√ß√£o sobre a consulta ao escrever o programa. Em nossos exemplos, supomos que o programador conhe√ßa a consulta exata, de modo que n√£o mostramos quaisquer registros de descri√ß√£o.

A principal vantagem do uso de uma interface de  chamada  de  fun√ß√£o  √©  que  ela  facilita  o  acesso a m√∫ltiplos bancos de dados no mesmo programa de  aplica√ß√£o,  mesmo  que  eles  sejam  armazenados sob diferentes pacotes de SGBD. Discutiremos isso melhor  na  Se√ß√£o  13.3.2,  quando  abordaremos  a

Cada registro √© acess√≠vel ao programa por meio de uma vari√°vel de ponteiro C - chamada identificador (ou handle ) do registro. O identificador √© retornado  quando  um  registro  √©  criado  inicialmente. Para criar um registro e retornar seu identificador, a seguinte fun√ß√£o SQL √© usada:

SQLAllocHandle(&lt;tipo\_identificador&gt;, &lt;id\_1&gt;, &lt;id\_2&gt;)

13 Nossa discuss√£o aqui tamb√©m se aplica √† linguagem de programa√ß√£o C++, pois n√£o usamos nenhum dos recursos orientados a objeto, mas focalizamos o mecanismo de programa√ß√£o de banco de dados.

- //Programa CLI1:
- 0) #include sqlcli.h ;
- 1) void imprimeSalario( ) {
- 2) SQLHSTMT inst1 ;
- 3) SQLHDBC con1 ;
- 4) SQLHENV amb1 ;
- 5) SQLRETURN ret1, ret2, ret3, ret4 ;
- 6) ret1 = SQLAllocHandle(SQL\_HANDLE\_ENV, SQL\_NULL\_HANDLE, &amp;amb1) ;
- 7) if (!ret1) ret2 = SQLAllocHandle(SQL\_HANDLE\_DBC, amb1, &amp;con1) else exit ;
- 8) if (!ret2) ret3 = SQLConnect(con1, 'dbs', SQL\_NTS, 'js', SQL\_NTS, 'xyz', SQL\_NTS) else exit ;
- 9) if (!ret3) ret4 = SQLAllocHandle(SQL\_HANDLE\_STMT, con1, &amp;inst1) else exit ;
- 10) SQLPrepare(inst1, 'select Unome, Salario from FUNCIONARIO wher e Cpf = ?', SQL\_NTS) ;
- 11) prompt('Digite um n√∫mero de CPF: ', cpf) ;
- 12) SQLBindParameter(inst1, 1, SQL\_CHAR, &amp;cpf, 9, &amp;fetchlen1) ;
- 13) ret1 = SQLExecute(inst1) ;
- 14) if (!ret1) {
- 15) SQLBindCol(inst1, 1, SQL\_CHAR, &amp;unome, 15, &amp;fetchlen1) ;
- 16) SQLBindCol(inst1, 2, SQL\_FLOAT, &amp;salario, 4, &amp;fetchlen2) ;
- 17) ret2 = SQLFetch(inst1) ;
- 18) if (!ret2) printf(cpf, unome, salario)
- 19) else printf('O n√∫mero do CPF n√£o existe: ', cpf) ;
- 20) }
- 21) }

Figura 13.10

Segmento de programa CLI1, um segmento de programa em C com SQL/CLI.

## Nessa fun√ß√£o, os par√¢metros s√£o os seguintes:

- ¬Ñ &lt;tipo\_identificador&gt; indica o tipo do registro que est√°  sendo  criado.  Os  valores  poss√≠veis  para esse  par√¢metro  s√£o  as  palavras-chave SQL\_ HANDLE\_ENV, SQL\_HANDLE\_DBC, SQL\_HAN -DLE\_STMT ou SQL\_HANDLE\_DESC ,  para  um registro de ambiente, conex√£o, instru√ß√£o ou descri√ß√£o, respectivamente.
- chamada de sqlcli.h, e √© inclu√≠da usando a linha 0 na Figura 13.10.
- ¬Ñ &lt;id\_1&gt; indica  o  recipiente  dentro  do  qual o  novo  identificador  est√°  sendo  criado.  Por exemplo, para um registro de conex√£o, este seria o ambiente no qual a conex√£o est√° sendo  criada,  e  para  um  registro  de  instru√ß√£o, este seria a conex√£o para essa instru√ß√£o.
- ¬Ñ &lt;id\_2&gt; √©  o  ponteiro  (identificador)  para  o  registro rec√©m-criado do tipo &lt;tipo\_identificador&gt; .

Ao  escrever  um  programa  em  C  que  incluir√° chamadas de banco de dados por meio da SQL/CLI, as seguintes etapas t√≠picas s√£o tomadas. Ilustramos as etapas  referindo-nos  ao  exemplo  CLI1  da  Figura 13.10, que l√™ um n√∫mero de Cpf de um funcion√°rio e imprime seu sobrenome e sal√°rio.

- 2. Declare vari√°veis  de  identificador dos  tipos SQLHSTMT, SQLHDBC, SQLHENV e SQLHDESC para as instru√ß√µes, conex√µes, ambientes e descri√ß√µes necess√°rias no programa, respectivamente (linhas 2 a 4). 14 Tamb√©m declare vari√°veis do tipo SQLRETURN (linha 5) para manter os c√≥digos de retorno das chamadas de fun√ß√£o da SQL/CLI. Um c√≥digo de retorno 0 (zero) indica execu√ß√£o bem-sucedida da chamada de fun√ß√£o.
- 3. Um registro de ambiente deve ser configurado no programa usando SQLAllocHandle. A fun√ß√£o para fazer isso aparece na linha 6. Como um registro de ambiente n√£o est√° contido em qualquer outro registro, o par√¢metro &lt;id\_1&gt; √©  o  identificador NULL  SQL\_NULL\_HANDLE (ponteiro NULL) quando se cria um ambiente. O identificador (ponteiro) para o registro de ambiente rec√©m-criado √© retornado na vari√°vel amb1 na linha 6.
- 1. A biblioteca de fun√ß√µes compreendendo SQL/ CLI deve ser inclu√≠da no programa C. Esta √©
- 4. Um registro  de  conex√£o √©  configurado  no programa usando SQLAllocHandle. Na  linha 7, o registro de conex√£o criado tem o identifi-

14 Para manter nossa apresenta√ß√£o simples, n√£o mostraremos os registros de descri√ß√£o aqui.

- cador con1 e est√° contido no ambiente amb1. Uma conex√£o √©  ent√£o  estabelecida  em con1 para um banco de dados de servidor em particular usando a fun√ß√£o SQLConnect da SQL/ CLI (linha 8). Em nosso exemplo, o nome do servidor de banco de dados ao qual estamos nos conectando √© dbs e o nome de conta e senha para login s√£o js e xyz , respectivamente.
- 5. Um registro  de  instru√ß√£o √©  configurado  no programa usando SQLAllocHandle. Na  linha 9, o registro de instru√ß√£o criado tem um identificador inst1 e usa a conex√£o con1.
- 6. A  instru√ß√£o  √© preparada usando  a  fun√ß√£o SQL/CLI SQLPrepare. Na linha 10, isso atribui a string de instru√ß√£o SQL (a consulta em nosso exemplo) ao identificador inst1. O s√≠mbolo de ponto de interroga√ß√£o (?) na linha 10 representa um par√¢metro de instru√ß√£o , que √© um valor a ser determinado em tempo de execu√ß√£o - normalmente, por seu v√≠nculo com uma vari√°vel  de  programa  em  C.  Em  geral, poderia haver v√°rios par√¢metros na string da instru√ß√£o.  Eles  s√£o  distinguidos  pela  ordem de aparecimento dos pontos de interroga√ß√£o na  string  de  instru√ß√£o  (o  primeiro ? representa o par√¢metro 1, o segundo ? representa o par√¢metro 2, e assim por diante). O √∫ltimo par√¢metro em SQLPrepare deveria dar o tamanho da string da instru√ß√£o SQL em bytes, mas, se entrarmos com a palavra-chave SQL\_NTS, isso indica que a string que mant√©m a consulta √© uma string terminada em NULL ,  de modo que a SQL pode calcular seu tamanho automaticamente. Esse uso de SQL\_NTS tamb√©m se  aplica  a outros  par√¢metros  de  string nas chamadas de fun√ß√£o em nossos exemplos.
- 7. Antes de executar a consulta, quaisquer par√¢metros na string de consulta devem ser ligados a vari√°veis do programa usando a fun√ß√£o  SQL/CLI SQLBindParameter. Na  Figura 13.10, o par√¢metro (indicado por ?) para  a consulta  preparada  referenciada  por inst1 √© vinculado √† vari√°vel do programa em C cpf na linha 12. Se houver n par√¢metros na instru√ß√£o SQL, devemos ter n chamadas de fun√ß√£o SQLBindParameter , cada uma com uma posi√ß√£o de par√¢metro diferente (1, 2, ..., n ).
- inst1 usando a fun√ß√£o SQLExecute (linha 13). Observe que, embora a consulta seja executada na linha 13, seus resultados ainda n√£o foram  atribu√≠dos  a  quaisquer  vari√°veis  do programa em C.
- 9. Para determinar onde o resultado da consulta √© retornado, uma t√©cnica comum √© a abordagem de colunas vinculadas .  Aqui, cada coluna em um resultado de consulta √© vinculada a uma vari√°vel de programa em C usando a fun√ß√£o SQLBindCol . As colunas s√£o distinguidas por sua ordem de aparecimento na consulta SQL. Nas linhas 15 e 16 da Figura 13.10, as duas colunas na consulta ( Unome e Salario ) s√£o vinculadas √†s vari√°veis do programa em C unome e salario, respectivamente. 15
- 10. Finalmente, para recuperar os valores de coluna nas vari√°veis de programa em C, a fun√ß√£o SQLFetch √© usada (linha 17). Essa fun√ß√£o √© semelhante ao comando FETCH da SQL embutida. Se um resultado de consulta tem uma cole√ß√£o  de  tuplas,  cada SQLFetch recebe  a pr√≥xima tupla e retorna seus valores de coluna para as vari√°veis do programa vinculadas. A SQLFetch retorna  um  c√≥digo  de  exce√ß√£o (diferente de zero) se n√£o houver mais tuplas no resultado da consulta. 16

Como podemos ver, o uso de chamadas de fun√ß√£o  din√¢micas  requer  muita  prepara√ß√£o  para  configurar as instru√ß√µes SQL e vincular par√¢metros de instru√ß√£o  e  resultados  de  consulta  √†s  vari√°veis  de programa apropriadas.

Em CLI1, uma √∫nica tupla √©  selecionada pela consulta SQL. A Figura 13.11 mostra um exemplo da recupera√ß√£o de m√∫ltiplas tuplas. Consideramos que  as  vari√°veis  apropriadas  do  programa  em  C foram declaradas como na Figura 13.1. O segmento de programa em CLI2 l√™ (entrada) um n√∫mero de departamento e depois recupera os funcion√°rios que trabalham nesse departamento. Um loop, ent√£o, percorre cada registro de funcion√°rio, um de cada vez, e imprime o √∫ltimo nome e o sal√°rio do funcion√°rio.

## 13.3.2 DBC: chamadas de fun√ß√£o SQL J para programa√ß√£o Java

- 8. Ap√≥s essas prepara√ß√µes, podemos executar a instru√ß√£o SQL referenciada pelo identificador

Agora, vamos voltar nossa aten√ß√£o para o modo como a SQL pode ser chamada com base na lingua-

15 Uma t√©cnica alternativa, conhecida como colunas desvinculadas , utiliza diferentes fun√ß√µes SQL/CLI, a saber, SQLGetCol ou SQLGetData, para recuperar colunas do resultado da consulta sem vincul√°-las previamente; estas s√£o aplicadas ap√≥s o comando SQLFetch na linha 17.

16 Se forem usadas vari√°veis de programa desvinculadas, a SQLFetch retorna a tupla em uma √°rea de programa tempor√°ria. Cada SQLGetCol (ou SQLGetData) subsequente retorna um valor de atributo em ordem. Basicamente, para cada linha no resultado da consulta, o programa deve percorrer os valores de atributo (colunas) nessa linha. Isso √© √∫til se o n√∫mero de colunas no resultado da consulta for vari√°vel.

- //Segmento de programa CLI2:
- 0) #include sqlcli.h ;
- 1) void imprimeFuncsDepartamento( ) {
- 2) SQLHSTMT inst1 ;
- 3) SQLHDBC con1 ;
- 4) SQLHENV amb1 ;
- 5) SQLRETURN ret1, ret2, ret3, ret4 ;
- 6) ret1 = SQLAllocHandle(SQL\_HANDLE\_ENV, SQL\_NULL\_HANDLE, &amp;amb1) ;
- 7) if (!ret1) ret2 = SQLAllocHandle(SQL\_HANDLE\_DBC, amb1, &amp;con1) else exit ;
- 8) if (!ret2) ret3 = SQLConnect(con1, 'dbs', SQL\_NTS, 'js', SQL\_NTS, 'xyz', SQL\_NTS) else exit ;
- 9) if (!ret3) ret4 = SQLAllocHandle(SQL\_HANDLE\_STMT, con1, &amp;inst1) else exit ;
- 10) SQLPrepare(inst1, 'select Unome, Salario from FUNCIONARIO wher e Dnr = ?', SQL\_NTS) ;
- 11) prompt('Digite o n√∫mero do Departamento: ', dnr) ;
- 12) SQLBindParameter(inst1, 1, SQL\_INTEGER, &amp;dnr, 4, &amp;fetchlen1) ;
- 13) ret1 = SQLExecute(inst1) ;
- 14) if (!ret1) {
- 15) SQLBindCol(inst1, 1, SQL\_CHAR, &amp;unome, 15, &amp;fetchlen1) ;
- 16) SQLBindCol(inst1, 2, SQL\_FLOAT, &amp;salario, 4, &amp;fetchlen2) ;
- 17) ret2 = SQLFetch(inst1) ;
- 18) while (!ret2) {
- 19) printf(unome, salario) ;
- 20) ret2 = SQLFetch(inst1) ;

21)

}

22)

}

23)

}

Figura 13.11

Segmento de programa CLI2, um segmento de programa em C que usa SQL/CLI para uma consulta com uma cole√ß√£o de tuplas em seu resultado.

gem de programa√ß√£o orientada a objeto Java. 17  As bibliotecas  de  fun√ß√£o  para  esse  acesso  s√£o  conhecidas como JDBC . 18 A linguagem de programa√ß√£o Java foi projetada para ser independente de plataforma - ou seja, um programa deve ser capaz de rodar em qualquer  tipo  de  sistema  de  computador  que  tenha  um interpretador Java instalado. Por causa dessa portabilidade, muitos fornecedores de SGBDR oferecem drivers JDBC de modo que seja poss√≠vel acessar seus sistemas por meio de programas Java. Um driver JDBC √© basicamente uma implementa√ß√£o das chamadas de fun√ß√£o  especificadas  na  interface  de  programa√ß√£o de aplica√ß√£o (API) JDBC para o SGBDR de determinado fornecedor. Logo, um programa Java com chamadas de fun√ß√£o JDBC pode acessar qualquer SGBDR que tenha um driver JDBC dispon√≠vel.

JDBC com Java, √© necess√°rio importar as bibliotecas de classes JDBC , que se chamam java.sql.*. Estas podem ser baixadas e instaladas pela Web. 19

Como a Java √© orientada a objeto, suas bibliotecas  de  fun√ß√£o  s√£o  implementadas  como classes . Antes de ser capaz de processar chamadas de fun√ß√£o

A JDBC foi elaborada para permitir que um √∫nico programa Java se conecte a v√°rios bancos de dados diferentes. Estes √†s vezes s√£o chamados de fontes de dados acessadas pelo programa Java. Essas fontes de dados poderiam ser armazenadas usando SGBDRs de diferentes vendedores, e poderiam ficar em diferentes m√°quinas. Logo, variados acessos a fontes de dados no mesmo programa Java podem exigir drivers JDBC de  diferentes  vendedores.  Para  alcan√ßar  essa  flexibilidade,  uma  classe  JDBC  especial,  chamada  classe gerenciadora  de  driver ,  √©  empregada,  e  registra  os drivers instalados. Um driver deve ser registrado no gerenciador de driver antes de ser usado. As opera√ß√µes (m√©todos)  da  classe  gerenciadora  de  driver  incluem getDriver, registerDriver e deregisterDriver. Estas podem ser usadas para acrescentar e remover drivers dinami-

17 Esta se√ß√£o pressup√µe uma familiaridade com conceitos orientados a objeto (ver Cap√≠tulo 11) e conceitos b√°sicos de Java.

18 Como j√° dissemos, JDBC √© uma marca registrada da Sun Microsystems, embora normalmente seja considerado um acr√¥nimo para Java Database Connectivity .

19 Estas est√£o dispon√≠veis em v√°rios sites Web - por exemplo, em &lt;http://industry.java.sun.com/products/ jdbc/drivers&gt;.

camente. Outras fun√ß√µes configuram e fecham conex√µes com fontes de dados, conforme veremos.

Para carregar um driver JDBC de maneira expl√≠cita, a fun√ß√£o Java gen√©rica para carregar uma classe pode ser usada. Por exemplo, para carregar o driver JDBC para o SGBDR da Oracle, o comando a seguir pode ser usado:

Class.forName('oracle.jdbc.driver.OracleDriver')

Isso registrar√° o driver no gerenciador e o tornar√° dispon√≠vel ao programa. Tamb√©m √© poss√≠vel carregar  e  registrar  os  drivers  necess√°rios  na  linha  de comandos que executa o programa, por exemplo, ao incluir o seguinte na linha de comando:

-Djdbc.drivers = oracle.jdbc.driver

A seguir, vemos as etapas t√≠picas que s√£o realizadas ao escrever um programa de aplica√ß√£o Java com acesso a banco de dados por meio de chamadas de fun√ß√£o JDBC. Ilustramos as etapas nos referindo ao exemplo JDBC1 da Figura 13.12, que l√™ um n√∫mero de Cpf de um funcion√°rio e imprime o √∫ltimo nome e sal√°rio dele.

- 1. A biblioteca de classes JDBC precisa ser importada para o programa Java. Essas classes s√£o chamadas de java.sql.*, e  podem ser importadas usando a linha 1 da Figura 13.12. Quaisquer bibliotecas de classe Java adicionais  necess√°rias  pelo  programa  tamb√©m  devem ser importadas.
- 2. Carregar o driver JDBC conforme discutido anteriormente (linhas 4 a 7). A exce√ß√£o Java na linha 5 ocorre se o driver n√£o for carregado com sucesso.
- 3. Criar  vari√°veis  apropriadas  conforme  a  necessidade no programa Java (linhas 8 e 9).
- 4. O objeto Connection . Um objeto de conex√£o √©  criado  usando  a  fun√ß√£o getConnection da classe DriverManager do JDBC. Nas linhas 12 e 13, o objeto Connection √© criado usando a chamada  de  fun√ß√£o getConnection(urlstring), na qual urlstring tem a forma

jdbc:oracle:&lt;tipoDriver&gt;:&lt;conta\_dba&gt;/&lt;senha&gt;

```
//Programa JDBC1: 0) import java.io.* ; 1) import java.sql.* ... 2) class obterInfFunc { 3) public static void main (String args []) throws SQLException, IOException { 4) try { Class.forName('oracle.jdbc.driver.OracleDriver') 5) } catch (ClassNotFoundException x) { 6) System.out.println ('Driver n√£o pode ser carregado') ; 7) } 8) String dbacct, senha, cpf, unome ; 9) Double salario ; 10) dbacct = readentry('Digite a conta do banco de dados:') ; 11) senha = readentry('Digite a senha:') ; 12) Connection con = DriverManager.getConnection 13) ('jdbc:oracle:oci8:' + dbacct + '/' + senha) ; 14) String inst1 = 'select Unome, Salario from FUNCIONARIO where Cpf = ?' ; 15) PreparedStatement p = conn.prepareStatement(inst1) ; 16) cpf = readentry('Digite um n√∫mero de CPF: ') ; 17) p.clearParameters( ) ; 18) p.setString(1, cpf) ; 19) ResultSet r = p.executeQuery( ) ; 20) while (r.next( )) { 21) unome = r.getString(1) ; 22) salario = r.getDouble(2) ; 23) system.out.printline(unome + salario) ; 24) } } 25) }
```

Uma forma alternativa √©

getConnection(url, conta\_dba, senha)

V√°rias propriedades podem ser definidas para um objeto de conex√£o, mas elas s√£o relacionadas principalmente a propriedades transicionais, que discutiremos no Cap√≠tulo 21.

- 5. O objeto Statement . Um objeto de instru√ß√£o √© criado no programa. Em JDBC, existe uma classe  de  instru√ß√£o  b√°sica, Statement, com duas subclasses especializadas: PreparedStatement e CallableStatement. O exemplo da Figura 13.12 ilustra como objetos PreparedStatement s√£o criados e usados. O pr√≥ximo exemplo (Figura 13.13) ilustra o outro tipo de objetos Statement . Na linha 14 da Figura 13.12, uma string de consulta com um √∫nico par√¢metro - indicado pelo s√≠mbolo ? - √© criada  na  vari√°vel  de  string inst1. Na  linha 15,  um  objeto p do  tipo PreparedStatement

//Program Segment JDBC2:

- 0) import java.io.* ;
- 1) import java.sql.* ... 2) class imprimeFuncsDepartamento { 3) public static void main (String args [ ]) throws SQLException, IOException { 4) try { Class.forName('oracle.jdbc.driver.OracleDriver') 5) } catch (ClassNotFoundException x) { 6) System.out.println ('Driver n√£o pode ser carregado') ; 7) } 8) String dbacct, senha, unome ; 9) Double salario ; 10) Integer dnr ; 11) dbacct = readentry('Digite a conta do banco de dados:') ; 12) senha = readentry('Digite a senha:') ; 13) Connection con = DriverManager.getConnection 14) ('jdbc:oracle:oci8:' + dbacct + '/' + senha) ; 15) dnr = readentry("Digite o n√∫mero do departamento: ') ; 16) String q = 'select Unome, Salario from FUNCIONARIO where Dnr = ' + dnr.tostring( ) ; 17) Statement s = con.createStatement( ) ; 18) ResultSet r = s.executeQuery(q) ; 19) while (r.next( )) { 20) unome = r.getString(1) ; 21) salario = r.getDouble(2) ; 22) system.out.printline(unome + salario) ; 23) } }

24) }

√© criado com base na string de consulta em inst1 e usando o objeto de conex√£o con . Em geral, o programador deve usar objetos PreparedStatement se uma consulta tiver de ser executada m√∫ltiplas vezes , pois ela seria preparada,  verificada  e  compilada  apenas  uma vez, economizando assim esse custo para execu√ß√µes adicionais da consulta.

- 6. Definindo os par√¢metros de instru√ß√£o. O ponto de interroga√ß√£o ( ? ) na linha 14 representa um par√¢metro de instru√ß√£o ,  que √© um valor a  ser  determinado  em  tempo  de  execu√ß√£o, normalmente  vinculando-o  a  uma  vari√°vel de  programa Java. Em geral, poderia haver v√°rios  par√¢metros,  distinguidos  pela  ordem de aparecimento dos pontos de interroga√ß√£o na string de instru√ß√£o (o primeiro ? representa o par√¢metro 1, o segundo ? representa o par√¢metro 2, e assim por diante), conforme discutimos anteriormente.

- 7. Antes  de  executar  uma  consulta PreparedStatement , quaisquer par√¢metros devem ser vinculados a vari√°veis do programa. Dependendo do  tipo  do  par√¢metro,  diferentes  fun√ß√µes, como setString, setInteger, setDouble, e assim por  diante,  podem  ser  aplicadas  ao  objeto PreparedStatement para definir seus par√¢metros. A fun√ß√£o apropriada deve ser usada para corresponder ao tipo de dado do par√¢metro que  est√°  sendo  definido.  Na  Figura  13.12, o par√¢metro (indicado por ? )  no  objeto p √© vinculado √† vari√°vel de programa Java cpf na linha 18. A fun√ß√£o setString √© utilizada porque cpf √© uma vari√°vel de string. Se houver n par√¢metros na instru√ß√£o SQL, devemos ter n fun√ß√µes set... , cada uma com uma posi√ß√£o de par√¢metro diferente (1, 2, ..., n ). Geralmente, √©  aconselh√°vel  limpar  todos  os  par√¢metros antes de definir quaisquer valores novos (linha 17).
- 8. Ap√≥s  essas prepara√ß√µes, podemos  executar  a  instru√ß√£o  SQL  referenciada  pelo  objeto p usando a fun√ß√£o executeQuery (linha 19). Existe uma fun√ß√£o gen√©rica execute em JDBC,  mais  duas  fun√ß√µes  especializadas: executeUpdate e executeQuery. A executeU -pdate √© utilizada para instru√ß√µes insert, delete ou update da SQL, e retorna um valor inteiro indicando o n√∫mero de tuplas que foram afetadas.  A executeQuery √©  empregada para instru√ß√µes de recupera√ß√£o SQL, e retorna um objeto do tipo ResultSet, que vamos discutir na sequ√™ncia.
- 9. O objeto ResultSet . Na linha 19, o resultado da  consulta  √©  retornado  em  um objeto r do tipo ResultSet .  Isso  √©  semelhante  a  um  array  bidimensional  ou  a  uma  tabela,  na  qual as  tuplas  s√£o  as  linhas  e  os  atributos  retornados  s√£o  as  colunas.  Um  objeto ResultSet √©  semelhante a um cursor na SQL embutida e um iterador em SQLJ. Em nosso exemplo, quando a consulta √© executada, r refere-se  a uma tupla antes da primeira tupla no resultado da consulta. A fun√ß√£o r.next( ) (linha 20) se move para a pr√≥xima tupla (linha) no objeto ResultSet e retorna NULL se n√£o houver mais objetos. Isso serve para controlar o looping. O programador pode se referir aos atributos na tupla atual usando diversas fun√ß√µes get... que dependem do tipo de cada atributo (por exemplo, getString, getInteger, getDouble, e  assim por diante). O programador pode usar tanto as posi√ß√µes de atributo (1, 2) como os nomes de atributo reais  ( 'Unome', 'Salario' )  com  as

fun√ß√µes get... . Em nossos exemplos, usamos a nota√ß√£o posicional nas linhas 21 e 22.

Em geral, o programador pode verificar exce√ß√µes SQL depois de cada chamada de fun√ß√£o JDBC. N√£o fizemos isso para simplificar os exemplos.

Observe  que  a  JDBC  n√£o  distingue  consultas que retornam tuplas isoladas daquelas que retornam m√∫ltiplas  tuplas,  diferentemente  de  algumas  outras t√©cnicas.  Isso  √©  justific√°vel  porque  um  conjunto  de resultados de √∫nica tupla √© apenas um caso especial.

No Exemplo JDBC1, uma √∫nica tupla √© selecionada  pela  consulta  SQL,  de  modo  que  o  loop  nas linhas 20 a 24 √© executado no m√°ximo uma vez. O exemplo mostrado na Figura 13.13 ilustra a recupera√ß√£o de m√∫ltiplas tuplas. O segmento de programa em JDBC2 l√™ (entrada) um n√∫mero de departamento e depois recupera os funcion√°rios que trabalham nesse departamento. Um loop, ent√£o, percorre cada registro de funcion√°rio, um de cada vez, e imprime o sobrenome e sal√°rio de cada um. Esse exemplo tamb√©m ilustra  como  podemos  executar  uma  consulta diretamente, sem ter de prepar√°-la como no exemplo anterior. Essa t√©cnica √© prefer√≠vel para consultas que ser√£o executadas apenas uma vez, pois √© mais simples de programar. Na linha 17 da Figura 13.13, o programador cria um objeto Statement (em vez de um PreparedStatement, como no exemplo anterior) sem associ√°-lo a uma string de consulta em particular. A string de consulta q √© passada ao objeto de instru√ß√£o s ao ser executada na linha 18.

Isso conclui nossa breve introdu√ß√£o √† JDBC. O leitor  interessado  deve  consultar  o  Website  &lt;http:// java.sun.com/docs/books/tutorial/jdbc/&gt;, que cont√©m muitos outros detalhes sobre essa linguagem.

## 13.4 Procedimentos armazenados de banco de dados e SQL/PSM

Esta  se√ß√£o  introduz  dois  t√≥picos  adicionais  relacionados  √†  programa√ß√£o  de  banco  de  dados.  Na Se√ß√£o 13.4.1, vamos discutir o conceito de procedimentos  armazenados,  que  s√£o  m√≥dulos  de  programa armazenados pelo SGBD no servidor de banco de dados. Depois, na Se√ß√£o 13.4.2, vamos abordar as extens√µes √† SQL que s√£o especificadas no padr√£o para incluir constru√ß√µes de programa√ß√£o de uso geral em SQL. Essas extens√µes s√£o conhecidas como SQL/ PSM (SQL/ Persistent Stored Modules )  e  podem ser usadas  para  escrever  procedimentos  armazenados. A SQL/PSM tamb√©m serve como exemplo de uma linguagem de programa√ß√£o de banco de dados que estende um modelo de banco de dados e linguagem - a saber, a SQL - com algumas constru√ß√µes de programa√ß√£o, como instru√ß√µes condicionais e loops.

## 13.4.1 Procedimentos armazenados e fun√ß√µes de banco de dados

Em nossa apresenta√ß√£o das t√©cnicas de programa√ß√£o de banco de dados at√© aqui, houve uma suposi√ß√£o  impl√≠cita  de  que  o  programa  de  aplica√ß√£o de banco de dados estava rodando em uma m√°quina cliente ou, mais provavelmente, no computador do  servidor  de  aplica√ß√£o na  camada  intermedi√°ria de uma arquitetura cliente-servidor de tr√™s camadas (ver Se√ß√£o 2.5.4 e Figura 2.7). Em ambos os casos, a  m√°quina onde o programa est√° executando √© diferente  da  m√°quina  em  que  o  servidor  de  banco de  dados  -  e  a  parte  principal  do  pacote  de  software  de SGBD - est√° localizado. Embora isso seja adequado para muitas aplica√ß√µes, √†s vezes √© √∫til criar m√≥dulos de programa de banco de dados - procedimentos ou fun√ß√µes - que s√£o armazenados e executados pelo SGBD no servidor de banco de dados. Estes s√£o historicamente conhecidos como procedimentos armazenados (ou stored procedures ) do banco de dados, embora  possam  ser  fun√ß√µes  ou  procedimentos.  O termo usado no padr√£o SQL para os procedimentos armazenados  √© m√≥dulos  armazenados  persistentes porque esses programas s√£o armazenados persistentemente pelo SGBD, de modo semelhante aos dados persistentes armazenados pelo SGBD.

Os procedimentos armazenados s√£o √∫teis nas seguintes circunst√¢ncias:

- ¬Ñ Se um programa de banco de dados √© necess√°rio por v√°rias aplica√ß√µes, ele pode ser armazenado no servidor e invocado por qualquer um dos programas de aplica√ß√£o. Isso reduz a duplica√ß√£o de esfor√ßo e melhora a modularidade do software.
- ¬Ñ A execu√ß√£o de um programa no servidor pode reduzir a transfer√™ncia de dados e o custo de comunica√ß√£o entre o cliente e o servidor em certas situa√ß√µes.
- ¬Ñ Esses procedimentos podem melhorar o poder de modelagem fornecido pelas vis√µes ao permitir que tipos mais complexos de dados derivados  estejam  dispon√≠veis  aos  usu√°rios do banco de dados. Al√©m disso, eles podem ser usados para verificar restri√ß√µes complexas que est√£o al√©m do poder de especifica√ß√£o de asser√ß√µes e triggers.

Com frequ√™ncia, muitos SGBDs comerciais permitem que procedimentos armazenados e fun√ß√µes sejam escritos em uma linguagem de programa√ß√£o de uso geral. Como alternativa, um procedimento armazenado pode ser feito de comandos SQL simples, como recupera√ß√µes e atualiza√ß√µes. O formato geral da declara√ß√£o de procedimentos armazenados √© o seguinte:

CREATE PROCEDURE &lt;nome do procedimento&gt; (&lt;parametros&gt;)

&lt;declaracoes de local&gt; &lt;corpo do procedimento&gt; ;

Os  par√¢metros  e  declara√ß√µes  locais  s√£o  opcionais e especificados apenas se necess√°rio. Para declarar uma fun√ß√£o, um tipo de retorno √© necess√°rio, de modo que o formato da declara√ß√£o √©

CREATE FUNCTION &lt;nome da funcao&gt; (&lt;parametros&gt;) RETURNS &lt;tipo de retorno&gt; &lt;declaracoes de local&gt; &lt;corpo da funcao&gt; ;

Se  o  procedimento  (ou  fun√ß√£o)  for  escrito  em uma linguagem de programa√ß√£o de uso geral, √© comum especificar a linguagem e tamb√©m um nome de arquivo em que o c√≥digo do programa √© armazenado. Por exemplo, o formato a seguir pode ser utilizado:

CREATE PROCEDURE &lt;nome do procedimento&gt; (&lt;parametros&gt;)

LANGUAGE &lt;nome da linguagem de programacao&gt; EXTERNAL NAME &lt;nome do caminho do arquivo&gt; ;

Em geral, cada par√¢metro deve ter um tipo de par√¢metro , o qual √© um dos tipos de dados da SQL. Cada par√¢metro tamb√©m deve ter um modo de par√¢metro , que √© um dentre IN, OUT ou INOUT. Estes correspondem a par√¢metros cujos valores s√£o apenas de entrada, apenas de sa√≠da (retornados) ou de entrada e sa√≠da, respectivamente.

Como os procedimentos e fun√ß√µes s√£o armazenados  de  maneira  persistente  pelo  SGBD,  deve  ser poss√≠vel cham√°-los das v√°rias interfaces SQL e linguagens de programa√ß√£o. A instru√ß√£o CALL no padr√£o SQL pode ser usada para chamar um procedimento armazenado - ou por uma interface interativa, ou SQLJ ou SQL embutida. O formato da instru√ß√£o √© o seguinte:

CALL &lt;nome do procedimento ou funcao&gt; (&lt;lista de argumentos&gt;) ;

Se essa instru√ß√£o for chamada da JDBC, ela deve ser atribu√≠da a um objeto de instru√ß√£o do tipo CallableStatement (ver Se√ß√£o 13.3.2).

## 13.4.2 SQL/PSM: estendendo a SQL para especificar m√≥dulos armazenados persistentes

A SQL/PSM √© a parte do padr√£o SQL que especifica como escrever m√≥dulos armazenados persis-

tentes. Ela inclui as instru√ß√µes para criar fun√ß√µes e procedimentos  que  descrevemos  na  se√ß√£o  anterior. Tamb√©m inclui constru√ß√µes de programa√ß√£o adicionais para melhorar o poder da SQL com a finalidade de escrever o c√≥digo (ou corpo) dos procedimentos armazenados e fun√ß√µes.

Nesta se√ß√£o, vamos discutir as constru√ß√µes SQL/ PSM para instru√ß√µes condicionais (desvio) e para instru√ß√µes  de  looping.  Estas  dar√£o  uma  ideia  do  tipo de constru√ß√£o que a SQL/PSM incorporou. 20  Depois, oferecemos  um  exemplo  para  ilustrar  como  essas constru√ß√µes podem ser usadas.

A instru√ß√£o de desvio condicional na SQL/PSM tem a seguinte forma:

```
IF <condicao> T HEN <lista de instrucoes> LSEIF <condicao> THEN <lista de instrucoes> E ... LSEIF <condi√ß√£o> THEN <lista de instrucoes> E ELSE <lista de instrucoes> END IF ;
```

Considere o exemplo da Figura 13.14, que ilustra como a estrutura de desvio condicional pode ser usada em uma fun√ß√£o SQL/PSM. A fun√ß√£o retorna um valor de string (linha 1) descrevendo o tamanho de um departamento em uma empresa com base no n√∫mero de funcion√°rios. Existe um par√¢metro inteiro IN, nrdep, que indica um n√∫mero de departamento. Uma vari√°vel local Nr\_de\_funcs √© declarada na linha 2. A  consulta  nas  linhas  3  e  4  retorna  o  n√∫mero  de funcion√°rios no departamento, e o desvio condicional  nas  linhas  5  a  8  ent√£o  retorna  um  dos  valores

//Fun√ß√£o PSM1:

- 0) CREATE FUNCTION Tam\_dep(IN nrdep INTEGER)
- 1) RETURNS VARCHAR [7]
- 2) DECLARE Nr\_de\_funcs INTEGER ;
- 3) SELECT COUNT(*) INTO Nr\_de\_funcs
- 4) FROM FUNCIONARIO WHERE Dnr = nrdep ;
- 5) IF Nr\_de\_funcs &gt; 100 THEN RETURN 'ENORME'

6) ELSEIF Nr\_de\_funcs &gt; 25 THEN RETURN 'GRANDE'

7) ELSEIF Nr\_de\_funcs &gt; 10 THEN RETURN 'MEDIO'

- 8) ELSE RETURN 'PEQUENO'
- 9) END IF;

Figura 13.14

Declarando uma fun√ß√£o em SQL/PSM.

{'ENORME', 'GRANDE', 'MEDIO', 'PEQUENO'} com base no n√∫mero de funcion√°rios.

A SQL/PSM tem v√°rias constru√ß√µes para loop  ing. Existem estruturas de looping padr√£o while e repeat , com as seguintes formas:

WHILE &lt;condicao&gt; DO

```
<lista de instrucoes> END WHILE ; REPEAT <lista de instrucoes> UNTIL <condicao> END REPEAT ;
```

H√° tamb√©m uma estrutura de looping baseada em cursor. A lista de instru√ß√£o em tal loop √© executada uma vez para cada tupla no resultado da consulta. Esta tem a seguinte forma:

FOR &lt;nome do loop&gt; AS &lt;nome do cursor&gt; CURSOR FOR &lt;consulta&gt; DO

&lt;lista de instrucoes&gt;

END FOR ;

Os  loops  podem  ter  nomes,  e  existe  uma  instru√ß√£o LEAVE &lt;nome do loop&gt; para parar um loop quando uma condi√ß√£o √© satisfeita. A SQL/PSM tem muitos outros recursos,  mas eles est√£o fora do escopo de nossa apresenta√ß√£o.

## 13.5 Comparando as tr√™s t√©cnicas

Nesta  se√ß√£o,  comparamos  rapidamente  as  tr√™s t√©cnicas para programa√ß√£o de banco de dados e discutimos as vantagens e desvantagens de cada uma.

- 1. T√©cnica da SQL embutida. A principal vantagem dessa t√©cnica √© que o texto da consulta faz parte do pr√≥prio c√≥digo fonte do programa e, portanto, √© poss√≠vel verificar erros de sintaxe e validar contra o esquema do banco de dados em tempo de compila√ß√£o. Isso tamb√©m torna o programa bastante leg√≠vel, pois as consultas s√£o prontamente vis√≠veis no c√≥digo fonte. As principais desvantagens s√£o a perda de flexibilidade na mudan√ßa da consulta em tempo de execu√ß√£o e o fato de que todas as mudan√ßas nas consultas devem passar pelo processo inteiro  de  recompila√ß√£o.  Al√©m  disso,  como  as consultas s√£o conhecidas de antem√£o, a escolha de vari√°veis de programa para manter os resultados da consulta √© uma tarefa simples e, dessa forma, a programa√ß√£o da aplica√ß√£o costuma  ser  mais  f√°cil.  Por√©m,  para  aplica√ß√µes complexas em que as consultas precisam ser

20 S√≥ oferecemos uma breve introdu√ß√£o √† SQL/PSM aqui. Existem muitos outros recursos no padr√£o SQL/PSM.

geradas em tempo de execu√ß√£o, a t√©cnica de chamada de fun√ß√£o ser√° mais adequada.

- 2. T√©cnica  da  biblioteca  de  chamadas  de  fun√ß√£o. Essa  t√©cnica  oferece  mais  flexibilidade porque  as  consultas  podem  ser  geradas  em tempo de execu√ß√£o, se necess√°rio. Contudo, isso leva a uma programa√ß√£o mais complexa, visto que as vari√°veis do programa que combinam com as colunas no resultado da consulta podem n√£o ser conhecidas de antem√£o. Como as consultas s√£o passadas como strings de instru√ß√£o nas chamadas de fun√ß√£o, nenhuma  verifica√ß√£o  pode  ser  feita  em  tempo  de compila√ß√£o. Toda verifica√ß√£o de sintaxe e valida√ß√£o de consulta precisa ser feita em tempo de execu√ß√£o, e o programador deve verificar e levar em conta poss√≠veis erros adicionais em tempo de execu√ß√£o no c√≥digo do programa.
- 3. T√©cnica  da  linguagem  de  programa√ß√£o  de banco de dados. Essa t√©cnica n√£o sofre do problema de diverg√™ncia de imped√¢ncia, pois os tipos de dados da linguagem de programa√ß√£o s√£o os mesmos que os tipos de dados do banco de dados. Por√©m, os programadores precisam aprender uma nova linguagem de programa√ß√£o, em vez de usar uma linguagem com a qual j√°  est√£o  familiarizados.  Al√©m  disso,  algumas linguagens de programa√ß√£o de banco de dados s√£o espec√≠ficas do vendedor, ao passo que as de uso geral podem funcionar facilmente com sistemas de diversos vendedores.

## Resumo

Neste cap√≠tulo, apresentamos recursos adicionais da linguagem de banco de dados SQL. Em particular, apresentamos uma vis√£o geral das t√©cnicas mais importantes para programa√ß√£o de banco de dados na Se√ß√£o 13.1. Depois, discutimos as diversas t√©cnicas para a programa√ß√£o de aplica√ß√£o de banco de dados nas se√ß√µes 13.2 a 13.4.

Na Se√ß√£o 13.2, discutimos a t√©cnica geral conhecida como SQL embutida, na qual as consultas fazem parte do c√≥digo fonte do programa. Um pr√©-compilador normalmente √© usado para extrair comandos SQL do programa, para processamento pelo SGBD, e substituindo-os pelas chamadas de fun√ß√£o ao c√≥digo compilado do SGBD. Apresentamos uma vis√£o geral da SQL embutida, usando a linguagem de programa√ß√£o C como linguagem hospedeira  em  nossos  exemplos.  Tamb√©m  discutimos a t√©cnica SQLJ para embutir SQL em programas Java. Os conceitos de cursor (para a SQL embutida) e iterador (para a SQLJ) foram apresentados e ilustrados com exemplos para mostrar como eles s√£o usados para percorrer as tuplas em um resultado de consulta e extrair o valor do atributo de vari√°veis do programa, para processamento posterior.

Na Se√ß√£o 13.3, discutimos como as bibliotecas de chamada de fun√ß√£o podem ser usadas para acessar bancos de dados SQL. Essa t√©cnica √© mais din√¢mica do que a SQL embutida, mas requer programa√ß√£o mais complexa porque os tipos e o n√∫mero de atributos em um resultado de consulta podem ser determinados em tempo de execu√ß√£o. Uma vis√£o geral do padr√£o SQL/CLI foi apresentada, com exemplos usando C como a linguagem hospedeira. Discutimos algumas das fun√ß√µes na biblioteca SQL/CLI, como as consultas s√£o passadas como strings, quantos par√¢metros s√£o atribu√≠dos em tempo de execu√ß√£o e como os resultados s√£o retornados √†s vari√°veis do programa. Depois, demos uma vis√£o geral da biblioteca de classes JDBC, que √© usada em Java, e abordamos algumas de suas classes e opera√ß√µes. Em particular, a classe ResultSet √© utilizada para criar objetos que mant√™m os resultados da consulta, que podem ent√£o ser percorridos pela opera√ß√£o next( ). As fun√ß√µes get e set, para recuperar valores de atributo e definir valores de par√¢metro tamb√©m foram discutidas.

Na Se√ß√£o 13.4, falamos rapidamente sobre os procedimentos armazenados e discutimos a SQL/PSM como um exemplo de linguagem de programa√ß√£o de banco de dados. Finalmente, comparamos brevemente as tr√™s t√©cnicas na Se√ß√£o 13.5. √â importante observar que escolhemos dar uma vis√£o geral comparativa das tr√™s t√©cnicas principais para programa√ß√£o de banco de dados, pois o estudo de uma t√©cnica em particular em profundidade √© um assunto que merece ser abordado em um livro inteiro.

## Perguntas de revis√£o

- 13.1. O que √© ODBC? Qual √© sua rela√ß√£o com a SQL/ CLI?
- 13.2. O que √© JDBC? Ela √© um exemplo de SQL embutida ou de uso de chamadas de fun√ß√£o?
- 13.3. Liste as tr√™s t√©cnicas principais para programa√ß√£o de banco de dados. Quais s√£o as vantagens e desvantagens de cada uma?
- 13.4. O que √© o problema da diverg√™ncia de imped√¢ncia? Qual das tr√™s t√©cnicas de programa√ß√£o minimiza esse problema?
- 13.5. Descreva o conceito de um cursor e como ele √© usado na SQL embutida.
- 13.6. Para que √© usada a SQLJ? Descreva os dois tipos de iteradores dispon√≠veis na SQLJ.

## Exerc√≠cios

- 13.7. Considere o banco de dados mostrado na Figura 1.2, cujo esquema √© mostrado na Figura 2.1. Escreva um segmento de programa para ler o nome de um aluno e imprimir sua m√©dia de notas, considerando que A=4, B=3, C=2 e D=1 ponto. Use a SQL embutida com C como linguagem hospedeira.
- 13.8. Repita  o  Exerc√≠cio  13.7,  mas  use  a  SQLJ  com Java como linguagem hospedeira.

- 13.9. Considere  o  esquema  de  banco  de  dados  relacional de biblioteca da Figura 4.6. Escreva um segmento de programa que recupere a lista de livros que ficaram em atraso ontem e que imprima o t√≠tulo do livro e o nome de quem pegou cada um emprestado. Use a SQL embutida e C como linguagem hospedeira.
- 13.10. Repita o Exerc√≠cio 13.9, mas use SQLJ com Java como linguagem hospedeira.
- 13.11. Repita os exerc√≠cios 13.7 e 13.9, mas use SQL/ CLI com C como linguagem hospedeira.
- 13.12. Repita os exerc√≠cios 13.7 e 13.9, mas use JDBC com Java como linguagem hospedeira.
- 13.13. Repita o Exerc√≠cio 13.7, mas escreva uma fun√ß√£o em SQL/PSM.
- 13.14. Crie uma fun√ß√£o em PSM que calcule o sal√°rio m√©dio  para  a  tabela FUNCIONARIO mostrada na Figura 3.5.

## Bibliografia selecionada

Existem muitos livros que descrevem os diversos aspectos da programa√ß√£o de banco de dados em SQL. Por exemplo, Sunderraman (2007) descreve a programa√ß√£o no SGBD Oracle 10g e Reese (1997) foca a JDBC e a programa√ß√£o Java. Muitos recursos tamb√©m est√£o dispon√≠veis na Web.



## Programa√ß√£o de banco de dados Web usando PHP

N o cap√≠tulo anterior, fornecemos uma vis√£o geral das t√©cnicas de programa√ß√£o de banco de dados utilizando  linguagens  de  programa√ß√£o  tradicionais, e  usamos as linguagens Java e C em nossos exemplos.  Agora,  vamos  voltar  nossa  aten√ß√£o  para  o modo como os bancos de dados s√£o acessados com linguagens de scripting. Muitas aplica√ß√µes de com√©rcio  eletr√¥nico  (e-commerce)  e  outras  aplica√ß√µes  da Internet,  que  oferecem interfaces Web para acessar informa√ß√µes armazenadas em um ou mais bancos de dados, est√£o utilizando linguagens de scripting. Essas linguagens normalmente s√£o usadas para gerar documentos HTML, que s√£o ent√£o exibidos pelo navegador Web para intera√ß√£o com o usu√°rio.

No Cap√≠tulo 12, tivemos uma vis√£o geral da linguagem XML para representa√ß√£o e interc√¢mbio de dados na Web, e discutimos algumas das maneiras como ela pode ser usada. Apresentamos a HTML e discutimos como ela difere da XML. A HTML b√°sica √© √∫til para gerar p√°ginas Web est√°ticas com texto fixo e outros objetos, mas a maioria das aplica√ß√µes de e-commerce exige p√°ginas Web que oferecem recursos interativos com o usu√°rio. Por exemplo, considere o caso de um cliente de companhia a√©rea que deseja verificar as informa√ß√µes de hora e port√£o de chegada de determinado voo. O usu√°rio pode inserir informa√ß√µes  como  uma  data  e  um  n√∫mero  de  voo em certos campos de formul√°rio da p√°gina Web. O programa Web primeiro precisa submeter uma consulta  ao  banco  de  dados  da  companhia  a√©rea  para recuperar  essa  informa√ß√£o,  e  depois  exibi-la.  Essas p√°ginas Web, nas quais parte da informa√ß√£o √© extra√≠da de bancos de dados ou outras fontes de dados, s√£o denominadas p√°ginas Web din√¢micas . Os dados extra√≠dos e exibidos a cada vez ser√£o para diferentes voos e datas.

Existem  v√°rias  t√©cnicas  para  a  programa√ß√£o  de recursos  din√¢micos  nas  p√°ginas  Web.  Vamos  focar uma t√©cnica aqui, que √© baseada no uso da linguagem de scripting de fonte aberto PHP. A PHP recentemente passou a ser bastante utilizada. Os interpretadores para PHP s√£o fornecidos gratuitamente e escritos na linguagem C, de modo que est√£o dispon√≠veis na maioria das plataformas de computador. Um interpretador PHP oferece um pr√©-processador de hipertexto, que executar√° comandos PHP em um arquivo de texto e criar√° o arquivo HTML desejado. Para acessar bancos de dados, uma biblioteca de fun√ß√µes PHP precisa ser inclu√≠da no interpretador PHP, conforme discutiremos na Se√ß√£o 14.3. Os programas PHP s√£o executados no computador servidor Web. Isso √© diferente de algumas linguagens de scripting, como JavaScript, que s√£o executadas no computador cliente.

Este cap√≠tulo √© organizado da seguinte forma. A Se√ß√£o 14.1 cont√©m um exemplo simples para ilustrar como a PHP pode ser utilizada. A Se√ß√£o 14.2 oferece uma vis√£o geral da linguagem PHP e como ela √© usada para programar algumas fun√ß√µes b√°sicas para p√°ginas Web interativas. A Se√ß√£o 14.3 focaliza o uso da PHP para interagir com bancos de dados SQL por meio de uma biblioteca de fun√ß√µes conhecida como PEAR DB. Por fim, apresentamos um resumo do cap√≠tulo.

## 14.1 Um exemplo simples em PHP

A PHP √© uma linguagem de scripting de uso geral com fonte aberto. O mecanismo interpretador da PHP √© escrito na linguagem de programa√ß√£o C, de modo que pode ser utilizado em quase todos os tipos de computadores e sistemas operacionais. A PHP normalmente vem instalada com o sistema operacional UNIX. Para plataformas de computa√ß√£o com outros sistemas ope-

racionais,  como  Windows,  Linux  ou  Mac  OS,  o  interpretador  PHP  pode  ser  baixado  em  &lt;http://www. php.net&gt;. Assim como outras linguagens de scripting, a PHP √© particularmente adequada para manipula√ß√£o de p√°ginas de texto, e em particular para manipula√ß√£o de p√°ginas HTML din√¢micas no computador servidor Web. Isso √© diferente da JavaScript, que √© baixada com as p√°ginas Web para execu√ß√£o no computador cliente.

onde os comandos de programa em PHP manipulariam os arquivos HTML para criar as p√°ginas Web din√¢micas personalizadas. A HTML √© ent√£o enviada √† camada cliente para exibi√ß√£o e intera√ß√£o com o usu√°rio.

A PHP possui bibliotecas de fun√ß√µes para acessar bancos  de  dados  armazenados  em  diversos  tipos  de sistemas de bancos de dados relacionais, como Oracle, MySQL, SQLServer e qualquer sistema que suporta o padr√£o ODBC (ver Cap√≠tulo 13). Sob a arquitetura de tr√™s camadas (ver Cap√≠tulo 2), o SGBD residiria no servidor de banco de dados da camada inferior . A PHP seria executada  no servidor  Web  da  camada  intermedi√°ria ,

Considere o exemplo mostrado na Figura 14.1(a), que pede que um usu√°rio informe o nome e √∫ltimo nome e depois imprime uma mensagem de boas-vindas a ele. Os n√∫meros de linha n√£o fazem parte do c√≥digo do programa; eles s√£o utilizados a seguir apenas como refer√™ncia para a explica√ß√£o:

- 1. Suponha que o arquivo contendo o script em PHP no segmento de programa P1 esteja armazenado no seguinte local da Internet: &lt;http:// www.meuservidor.com/saudacao.php&gt;. Ent√£o, se  um  usu√°rio  digita  esse  endere√ßo  no  navegador, o interpretador PHP come√ßaria a inter-



- //Segmento de programa P1: (a)

- 0) &lt;?php

- 1)

- // Imprimindo mensagem de boas-vindas se o usu√°rio submeteu // seu nome por este formul√°rio HTML

- 2) if ($\_POST[ nome\_usuario ]) { ' '

- 3) print( Bem-vindo,  ) ; ' '

- 4) print($\_POST[ nome\_usuario ]); ' '

- 5) }

- 6) else

- 8)

- 9)

- 10) Digite seu nome: &lt;input type= text  name= nome\_usuario &gt; ' ' ' ' 11) &lt;BR/&gt;

- 12) &lt;INPUT type= submit  value='SUBMETER NOME'&gt; ' '

- 13) &lt;/FORM&gt;

- 14) \_HTML\_;

- 15) }

- 16) ?&gt;

Figura 14.1

(a) Segmento de programa PHP para a entrada de uma sauda√ß√£o. (b) Formul√°rio inicial exibido pelo segmento de programa PHP. (c) Usu√°rio informa o nome Jo√£o Silva . (d) Formul√°rio imprime sauda√ß√£o para Jo√£o Silva .

- pretar o c√≥digo e a produzir o formul√°rio mostrado na Figura 14.1(b). Explicaremos como isso acontece enquanto examinamos as linhas no segmento de c√≥digo P1.
- 2. A linha 0 mostra a tag de in√≠cio da PHP &lt;?php , que  indica  ao  mecanismo  interpretador PHP que ele dever√° processar todas as linhas de texto seguintes at√© encontrar a tag de fim PHP ?&gt;, mostrada na linha 16. O texto fora dessas tags √© impresso tal como est√°. Isso permite que os segmentos de c√≥digo PHP sejam inclu√≠dos  em  um  arquivo  HTML maior. Somente as se√ß√µes no arquivo entre &lt;?php e ?&gt; s√£o processadas pelo pr√©-processador PHP.
- 3. A  linha 1 mostra um  modo  de  postar coment√°rios  em  um  programa  PHP  em  uma √∫nica  linha  iniciada  por //. Coment√°rios  de uma linha tamb√©m podem ser iniciados com #, e  terminam ao final da linha em que s√£o inseridos.  Coment√°rios  em  m√∫ltiplas  linhas come√ßam com /* e terminam com */.
- 4. A vari√°vel PHP autoglobal predefinida $\_POST (linha  2)  √©  um  vetor  que  mant√©m  todos  os valores inseridos por meio de par√¢metros do formul√°rio. Vetores em PHP s√£o vetores din√¢micos , sem um n√∫mero fixo de elementos. Eles podem ser vetores indexados numericamente, cujos √≠ndices (posi√ß√µes) s√£o numerados (0, 1, 2, ...), ou podem ser vetores associativos cujos √≠ndices podem ser quaisquer valores de string. Por exemplo, um vetor associativo indexado com base na cor pode ter os √≠ndices {'vermelho', 'azul', 'verde'}. Neste exemplo, $\_POST √© indexado de forma associativa pelo nome do valor postado nome\_usuario que √© especificado no atributo de nome da tag de entrada na linha 10. Assim, $\_POST['nome\_ usuario'] ter√°  o  valor  digitado  pelo  usu√°rio. Discutiremos mais sobre vetores em PHP na Se√ß√£o 14.2.2.
- 5. Quando a p√°gina Web em &lt;http://www.meu servidor.com/saudacao.php&gt; √© aberta inicialmente, a condi√ß√£o if na linha 2 ser√° avaliada como falsa porque ainda n√£o existe valor em $\_POST['nome\_usuario']. Logo,  o  interpretador PHP processar√° as linhas 6 a 15, as quais criam o texto para um arquivo HTML que  exibe  o  formul√°rio  mostrado  na  Figura 14.1(b). Este √© ent√£o exibido no lado do cliente pelo navegador Web.
- 6. A linha 8 mostra uma maneira de criar strings  de  texto  longas em  um  arquivo  HTML. Discutiremos  outras  maneiras  de  especificar
- strings  mais  adiante  nesta  se√ß√£o.  Todo  texto  entre  um &lt;&lt;&lt;\_HTML\_ de  abertura  e  um \_HTML\_; de  fechamento  √©  impresso  no  arquivo HTML tal como est√°. O \_HTML\_; de fechamento  precisa  estar  sozinho,  em  uma linha separada. Assim, o texto acrescentado ao arquivo HTML enviado ao cliente ser√° o texto entre as linhas 9 e 13. Isso inclui as tags HTML para criar o formul√°rio mostrado na Figura 14.1(b).
- 7. Nomes de vari√°vel PHP come√ßam com um sinal $ e podem incluir caracteres, n√∫meros e o caractere de sublinhado \_. A vari√°vel autoglobal (predefinida) do PHP $\_SERVER (linha 9) √©  um  vetor  que  inclui  informa√ß√µes  sobre  o servidor local. O elemento $\_SERVER['PHP\_ SELF'] no vetor √© o nome do caminho do arquivo PHP que atualmente est√° sendo executado no servidor. Portanto, o atributo action da tag FORM (linha 9) instrui o interpretador PHP a reprocessar o mesmo arquivo, quando os par√¢metros do formul√°rio forem inseridos pelo usu√°rio.
- 8. Logo que o usu√°rio digita o nome Jo√£o Silva na caixa de texto e clica no bot√£o SUBMETER NOME (Figura  14.1(c)),  o  segmento de programa P1 √© reprocessado. Dessa vez, $\_POST['nome\_usuario'] incluir√° a string 'Jo√£o Silva', de  modo  que  as  linhas  3  e  4 agora  ser√£o  colocadas  no  arquivo  HTML enviado ao cliente, que exibe a mensagem da Figura 14.1(d).

Como podemos ver por esse exemplo, o programa PHP pode criar dois comandos HTML diferentes, dependendo se o usu√°rio acabou de entrar ou se ele j√° submeteu seu nome pelo formul√°rio. Em geral, um programa PHP pode criar diversas varia√ß√µes de texto  HTML  em  um  arquivo  HTML  no  servidor, dependendo dos caminhos condicionais particulares tomados no programa. Logo, a HTML enviada ao cliente ser√° diferente, dependendo da intera√ß√£o com o usu√°rio. Esse √© um modo como a PHP √© usada para criar p√°ginas Web din√¢micas .

## 14.2 Vis√£o geral dos recursos b√°sicos da PHP

Nesta se√ß√£o, fornecemos uma vis√£o geral de alguns dos recursos da PHP que s√£o √∫teis na cria√ß√£o de p√°ginas HTML interativas. A Se√ß√£o 14.3 focalizar√° como os  programas em PHP podem acessar bancos de dados para consulta e atualiza√ß√£o. N√£o podemos oferecer uma discuss√£o abrangente sobre PHP, pois existem li-

vros inteiros dedicados a esse assunto. Em vez disso, focalizamos a ilustra√ß√£o de certas caracter√≠sticas da PHP que s√£o particularmente adequadas para a cria√ß√£o de p√°ginas Web din√¢micas que cont√™m comandos de acesso a banco de dados. Esta se√ß√£o abrange alguns conceitos e recursos da PHP que ser√£o necess√°rios quando discutirmos o acesso a banco de dados na Se√ß√£o 14.3.

## 14.2.1 Vari√°veis, tipos de dados e constru√ß√µes de programa√ß√£o em PHP

Os nomes de vari√°vel em PHP come√ßam com o s√≠mbolo $ e podem incluir caracteres, letras e o caractere  de  sublinhado ( \_ ).  Nenhum outro caractere especial √© permitido. Os nomes de vari√°vel diferenciam mai√∫sculas de min√∫sculas, e o primeiro caractere n√£o pode ser um n√∫mero. O tipo das vari√°veis n√£o precisa ser definido antecipadamente. Os valores atribu√≠dos √†s vari√°veis determinam seu tipo. De fato, a mesma vari√°vel pode mudar seu tipo quando um novo valor for atribu√≠do a ela. A atribui√ß√£o √© feita por meio do operador = .

Como  a  PHP  √©  direcionada  para  processamento de textos, existem v√°rios tipos diferentes de valores de string.  Tamb√©m h√° muitas fun√ß√µes dispon√≠veis para o processamento  de  strings.  S√≥  vamos  discutir  algumas propriedades  b√°sicas  dos  valores  de  string  e  vari√°veis aqui. A Figura 14.2 ilustra alguns desses valores. Existem quatro formas principais de expressar strings e texto:

- 0) print  Bem-vindo ao meu Web site. ; ' '
- 1) print  Eu disse a ele, 'Bem-vindo √† casa ' '' ;
- 2) print  Vamos agora visitar o pr√≥ximo site ; ' '
- 3) printf( O pre√ßo √© $%.2f e o imposto √© ' R$%.2f , $pre√ßo, $imposto) ; '
- 4) print strtolower( AbCdE ); ' '
- 5) print ucwords(strtolower( JOAO silva )); ' '
- 6) print  abc  .  efg ' ' ' '
- 7) print  envie seu e-mail para: $endereco\_ ' email '
- 8) print &lt;&lt;&lt;FORM\_HTML
- 9) &lt;FORM method= post  action= $\_ ' ' ' SERVER[ PHP\_SELF ] &gt; ' ' '
- 10)   Digite seu nome: &lt;input type= text ' ' name= nome\_usuario &gt; ' '
- 11) FORM\_HTML
- 1. Strings com aspas simples. Delimite a string com aspas simples, como nas linhas 0, 1 e 2. Se uma aspa simples for necess√°ria dentro da string, use o caractere de escape ( ) (ver a linha 2). \
- 2. Strings  com  aspas  duplas. Delimite  strings com  aspas  duplas,  como  na  linha  7.  Nesse caso, nomes de vari√°vel que aparecem dentro da string s√£o substitu√≠dos pelos valores que est√£o atualmente armazenados nessas vari√°veis. O interpretador identifica nomes de vari√°vel  nas  strings  com  aspas  duplas  por  seu caractere inicial $ e os substitui pelo valor na vari√°vel. Isso √© conhecido como interpola√ß√£o de vari√°veis nas strings. A interpola√ß√£o n√£o ocorre nas strings com aspas simples.
- 3. Here documents (heredoc). Delimite  uma  parte de um documento entre um &lt;&lt;&lt;DOCNAME e termine essa parte com uma √∫nica linha contendo o nome do documento DOCNAME. DOCNAME pode  ser  qualquer  string,  desde que  seja  usado  tanto  para  iniciar  quanto para  terminar  o  heredoc.  Isso  √©  ilustrado nas linhas 8 a 11 da Figura 14.2. As vari√°veis tamb√©m s√£o interpoladas substituindo-as por seus valores de string, se aparecerem em heredoc. Esse recurso √© utilizado de um modo semelhante √†s strings com aspas duplas, mas √© mais conveniente para texto de m√∫ltiplas linhas.
- 4. Aspas simples e duplas. Aspas simples e duplas usadas pela PHP para delimitar strings devem ser aspas retas ( ' ' ) nos dois lados da string. O editor de textos que criar essas aspas n√£o dever√° produzir aspas curvas de abertura e fechamento (' ') em torno da string.

H√°  tamb√©m  um  operador  de  concatena√ß√£o  de string  especificado  pelo  s√≠mbolo  de  ponto  ( .) ,  conforme ilustrado na linha 6 da Figura 14.2. Existem muitas fun√ß√µes de string. Ilustramos apenas algumas delas  aqui.  A  fun√ß√£o strtolower muda os caracteres alfab√©ticos  na  string  para  min√∫sculas,  enquanto  a fun√ß√£o ucwords converte para mai√∫sculo o primeiro caracter de cada palavra. Estas s√£o ilustradas nas linhas 4 e 5 da Figura 14.2.

A  regra  geral  √©  usar  strings  com  aspas  simples para strings literais, que n√£o cont√™m vari√°veis de programa em PHP, e os outros dois tipos (strings com aspas duplas e heredoc), quando os valores das vari√°veis precisarem ser interpolados na string. Para grandes blocos de texto em m√∫ltiplas linhas, o programa dever√° usar o estilo de here documents para as strings.

A PHP tamb√©m possui tipos de dados para n√∫meros inteiros e ponto flutuante, e geralmente segue

as  regras  da  linguagem  de  programa√ß√£o  C  para  o processamento desses tipos. Os n√∫meros podem ser formatados para impress√£o em strings ao especificar o n√∫mero de d√≠gitos que segue o ponto decimal. Uma varia√ß√£o da fun√ß√£o print ,  chamada printf (print  formatado) permite a formata√ß√£o de n√∫meros em uma string, conforme ilustra a linha 3 da Figura 14.2.

Existem as constru√ß√µes da linguagem de programa√ß√£o padr√£o para loops for, loops while e instru√ß√µes if condicionais. Elas costumam ser semelhantes as  suas  equivalentes  na  linguagem  C.  N√£o  vamos discuti-las aqui. De modo semelhante, qualquer valor √© avaliado como verdadeiro se usado como uma express√£o booleana, exceto pelo zero num√©rico ( 0) e a string vazia, que s√£o avaliados como falso. H√° tamb√©m os valores literais true e false que podem ser atribu√≠dos. Os operadores de compara√ß√£o tamb√©m geralmente seguem as regras da linguagem C. S√£o eles == (igual), != (n√£o igual), &gt; (maior que), &gt;= (maior ou igual), &lt; (menor que) e &lt;= (menor ou igual).

## 14.2.2 Vetores em PHP

Vetores  s√£o  muito  importantes  em  PHP,  pois permitem listas de elementos. Eles s√£o usados constantemente em formul√°rios que empregam menus pull-down. Um vetor unidimensional serve para manter a lista de escolhas no menu pull-down. Para resultados de consulta de banco de dados, vetores bidimensionais s√£o utilizados com a primeira dimens√£o representando linhas de uma tabela e a segunda dimens√£o representando colunas (atributos) em uma linha.

Existem dois tipos principais de vetores: num√©ricos e associativos. Vamos discutir cada um deles no contexto dos vetores unidimensionais a seguir.

Um vetor  num√©rico associa  um  √≠ndice  num√©rico (posi√ß√£o ou n√∫mero de sequ√™ncia) a cada elemento no vetor.  Os  √≠ndices  s√£o  n√∫meros  inteiros  que  come√ßam em zero e crescem de forma incremental. Um elemento no vetor √© referenciado por meio de seu √≠ndice. Um vetor associativo oferece pares de elementos (chave =&gt; valor). O valor de um elemento √© referenciado por meio de sua chave, e todos os valores de chave em determinado vetor precisam ser exclusivos. Os valores de elemento podem ser strings ou inteiros, ou eles mesmos podem ser vetores, levando assim a vetores de maior dimens√£o.

A Figura 14.3 oferece dois exemplos de vari√°veis de vetor: $ensinar e $disciplina. O primeiro vetor $ensinar √© associativo (ver a linha 0 da Figura 14.3), e cada elemento associa um nome de disciplina (como chave) ao nome do professor da disciplina (como valor).  Existem  tr√™s  elementos  nesse  vetor.  A  linha  1 mostra como o vetor pode ser atualizado. O primeiro comando na linha 1 atribui um novo professor √† disciplina  'Grafico'  atualizando  seu  valor.  Como  o

- 0) $ensinar  =  array( banco  dados   =&gt; ' ' ' Silva , ' ' SO =&gt;  Carrick , ' ' ' ' Grafico ' =&gt;  Kam ); ' '
- 1) $ensinar[ ' Grafico ' ] = ' Benson ; ' $ensinar[ Minera√ß√£o dados ] =  Kam ; ' ' ' '
- 2) sort($ensinar);
- 3) foreach ($ensinar as $chave =&gt; $valor) {
- 4) print   $chave : $valor\n ;} ' '
- 5) $disciplinas = array( Banco ' dados , ' ' SO, ' ' Grafico ' ,  Minera√ß√£o dados ); ' '
- 6) $alterna\_cor = array( azul ,  amarelo ); ' ' ' '
- 7) or  ($i  =  0,  $num  =  count($disciplinas);  i  &lt; f $num; $i++) {
- 8) print  &lt;TR bgcolor= ' '' . $alterna\_cor[$i % 2] . '' &gt; ; '
- 9) print ' &lt;TD&gt;Disciplina $i is&lt;/ TD&gt;&lt;TD&gt;$disciplinas[$i]&lt;/TD&gt;&lt;/

TR&gt;\n ; '

10) } Figura 14.3 Ilustrando o processamento de vetor b√°sico em PHP.

valor-chave 'Grafico' j√° existe no vetor, nenhum elemento √© criado, mas o valor existente √© atualizado. O segundo comando cria um elemento, pois o valor-chave 'Minera√ßao dados' n√£o existia no vetor antes. Novos elementos s√£o acrescentados ao final do vetor.

Se  s√≥  oferecermos  valores  (n√£o  chaves)  como elementos do vetor, as chaves s√£o automaticamente  num√©ricas  e  numeradas  com 0, 1, 2, ....  Isso  √© ilustrado  na  linha  5  da  Figura  14.3,  pelo  vetor $disciplinas .  Vetores  associativos  e  num√©ricos  n√£o t√™m limites de tamanho. Se algum valor de outro tipo de dado, digamos, um inteiro, for atribu√≠do a uma vari√°vel PHP que estava mantendo um vetor, a vari√°vel agora mant√©m o valor inteiro e o conte√∫do do vetor √© perdido. Basicamente, a maioria das vari√°veis pode receber valores de qualquer tipo de dado a qualquer momento.

Existem v√°rias t√©cnicas para percorrer vetores em PHP. Ilustramos duas delas na Figura 14.3. As linhas 3 e 4 mostram um m√©todo de percorrer todos os elementos em um vetor usando a constru√ß√£o foreach , e de imprimir a chave e o valor de cada elemento em uma linha separada. As linhas 7 a 10 mostram como uma constru√ß√£o de loop for tradicional pode ser usada. Um contador de fun√ß√£o embutido (linha 7) retorna o n√∫mero atual de elementos no vetor, que √© atribu√≠do √† vari√°vel $num e utilizado para controlar o t√©rmino do loop.

O exemplo nas linhas 7 a 10 ilustra como uma tabela HTML pode ser exibida com cores de linha alternadas, ao definir as cores em um vetor $alt\_row\_ color (linha 8). A cada passada do loop, a fun√ß√£o de resto $i % 2 muda de uma linha (√≠ndice 0) para a seguinte (√≠ndice 1) (ver a linha 8). A cor √© atribu√≠da ao atributo HTML bgcolor da tag &lt;TR&gt; (que em ingl√™s significa table row ou linha de tabela).

A fun√ß√£o count (linha 7) retorna o n√∫mero atual de elementos no vetor. A fun√ß√£o sort (linha 2) classifica o vetor com base nos valores de elemento nela contidos (n√£o as chaves). Para vetores associativos, cada chave permanece associada ao mesmo valor de elemento ap√≥s a classifica√ß√£o. Isso n√£o ocorre quando se classifica vetores num√©ricos. Existem muitas outras fun√ß√µes que podem ser aplicadas a vetores PHP, mas uma discuss√£o completa est√° fora do escopo de nossa apresenta√ß√£o aqui.

## 14.2.3 un√ß√µes em PHP F

Assim como em outras linguagens de programa√ß√£o, as fun√ß√µes podem ser definidas em PHP para estruturar melhor um programa complexo e compartilhar se√ß√µes comuns do c√≥digo, que podem ser reutilizadas por v√°rias aplica√ß√µes. A vers√£o mais nova da PHP, a PHP5, tamb√©m possui recursos orientados a objeto, mas n√£o discutiremos a respeito deles aqui, pois estamos focalizando os fundamentos das PHP. As fun√ß√µes b√°sicas das PHP podem ter argumentos que s√£o passados por valor . Vari√°veis globais podem ser acessadas nas fun√ß√µes. As regras de escopo padr√£o se aplicam a vari√°veis que aparecem em uma fun√ß√£o e no c√≥digo que chama a fun√ß√£o.

Agora, vamos dar dois exemplos simples para ilustrar as fun√ß√µes b√°sicas da PHP. Na Figura 14.4, mostramos como poder√≠amos rescrever o segmento de c√≥digo P1 da Figura 14.1(a) usando fun√ß√µes. O segmento de c√≥digo P1' da Figura 14.4 tem duas fun√ß√µes: exibir\_sau-dacao( ) (linhas 0 a 3) e exibir\_form\_vazio( ) (linhas 5 a  13).  Nenhuma  dessas  fun√ß√µes  tem  argumentos  ou valores de retorno. As linhas 14 a 19 mostram como podemos chamar essas fun√ß√µes para produzir o mesmo efeito do segmento de c√≥digo P1 na Figura 14.1(a). Como podemos ver neste exemplo, as fun√ß√µes podem ser  utilizadas  apenas  para  tornar  o  c√≥digo  PHP  mais bem estruturado e mais f√°cil de acompanhar.

Um segundo exemplo √© mostrado na Figura 14.5. Aqui, estamos usando o vetor $ensinar apresentado na Figura 14.3. A fun√ß√£o professor\_disciplina( ) nas linhas 0 a 8 da Figura 14.5 possui dois argumentos: $disciplina (uma string contendo um nome de disciplina) e $ativi-dades\_ensino (um vetor associativo contendo trabalhos de disciplina, semelhante ao vetor $ensinar mostrado na Figura 14.3). A fun√ß√£o acha o nome do professor que leciona uma disciplina em particular. As linhas 9 a 14 da Figura 14.5 mostram como essa fun√ß√£o pode ser usada.

- //Segmento de programa P1 : '
- 0) function exibir\_saudacao( ) {
- 1) print( Bem-vindo,  ) ; ' '
- 2) print($\_POST[ nome\_usuario ]); ' '
- 3) }

4)

- 5) function exibir\_form\_vazio( ); {
- 6) print &lt;&lt;&lt;\_HTML\_
- 7) &lt;FORM method= post  action= $\_ ' ' ' SERVER[ PHP\_SELF ] &gt; ' ' '
- 8) Digite seu nome: &lt;INPUT type= text ' ' name= nome\_usuario &gt; ' '
- 9) &lt;BR/&gt;
- 10)   &lt;INPUT type= submit  value= Enviar ' ' ' nome &gt; '
- 11) &lt;/FORM&gt;
- 12) \_HTML\_;

13) }

- 14) if ($\_POST[ nome\_usuario ]) { ' '
- 15) exibir\_saudacao( );

16) }

17) else {

- 18)
- 19) }

Figura 14.4

Reescrevendo o segmento de programa P1 como P1' usando fun√ß√µes.

A chamada de fun√ß√£o na linha 11 retornaria a string: Silva est√° lecionando Banco de Dados , pois a entrada de vetor com a chave 'Banco dados' tem o valor 'Silva' para professor. Por sua vez, a chamada  de  fun√ß√£o  na  linha  13  retornaria  a  string: n√£o existe a disciplina de Arquitetura de Computadores ,  pois  n√£o  h√°  uma  entrada  no  vetor  com a  chave  'Arquitetura  Computadores'.  Alguns  coment√°rios  sobre  este  exemplo  e  sobre  as  fun√ß√µes em PHP em geral:

- ¬Ñ A  fun√ß√£o  de  vetor  em  PHP  embutida ve-tor\_key\_exists($k, $a) retorna verdadeira se o valor na vari√°vel $k existir como uma chave no vetor associativo na vari√°vel $a. Em nosso exemplo, ela verifica se o valor $disciplina fornecida  existe  como  uma  chave  no  vetor $atividades\_ensino (linha 1 da Figura 14.5).
- ¬Ñ Os argumentos de fun√ß√£o s√£o passados por valor. Logo, neste exemplo, as chamadas nas

exibir\_form\_vazio( );

- 0) function professor\_disciplina ($disciplina, $atividades\_ensino) {
- 1) if (array\_key\_exists($disciplina, $atividades\_ensino)) {
- 2) $professor = $atividades\_ensino [$disciplina];
- 3) RETURN  $professor est√° lecionando $disciplina ; ' '
- 4) }
- 5) else {
- 6) RETURN  n√£o existe a disciplina $disciplina ; ' '
- 7) }

8)

}

- 9) $ensinar = array( Banco dados  =&gt;  Silva ,  SO  =&gt;  Carrick , ' ' ' ' ' ' ' ' ' Grafico ' =&gt;  Kam ); ' '
- 10) $ensinar[ ' Grafico ' ] =  Benson ; $ensinar[ Mineracao dados ] =  Kam ; ' ' ' ' ' '
- 11) $x = professor\_disciplina( Banco dados , $ensinar); ' '

12) print($x);

- 13) $x = professor\_disciplina( Arquitetura Computadores , $ensinar); ' '

14) print($x);

## Figura 14.5

Ilustrando uma fun√ß√£o com argumentos e valor de retorno.

linhas 11 e 13 n√£o poderiam mudar o vetor $ensinar fornecido  como  argumento  para  a chamada.  Os  valores  fornecidos  nos  argumentos s√£o passados (copiados) para os argumentos da fun√ß√£o quando esta √© chamada.

- ¬Ñ Os valores de retorno de uma fun√ß√£o s√£o colocados ap√≥s a palavra-chave RETURN .  Uma fun√ß√£o  pode  retornar  qualquer  tipo.  Neste exemplo,  ela  retorna  um  tipo  string.  Duas strings  diferentes  podem  ser  retornadas  em nosso exemplo, dependendo de o valor da chave $disciplina fornecido existir ou n√£o no vetor.
- ¬Ñ As  regras  de  escopo  para  nomes  de  vari√°vel  se  aplicam  como  nas  outras  linguagens de  programa√ß√£o.  Vari√°veis  globais  fora  da fun√ß√£o  n√£o  podem  ser  utilizadas  a  menos que sejam referenciadas usando o vetor embutido da PHP $GLOBALS. Basicamente, $GLOBALS['abc'] acessar√°  o  valor  em  uma vari√°vel global $abc definida fora da fun√ß√£o. Caso contr√°rio, as vari√°veis que aparecem em uma fun√ß√£o s√£o locais mesmo que haja uma vari√°vel global com o mesmo nome.

A discuss√£o anterior oferece uma breve introdu√ß√£o √†s fun√ß√µes da PHP. Muitos detalhes n√£o foram discutidos,  pois  n√£o  √©  nosso  objetivo  apresentar  a PHP em detalhes.

## 14.2.4 Vari√°veis e formul√°rios de servidor PHP

Existem v√°rias entradas embutidas em uma vari√°vel de  autoglobal  de  vetor  embutida  da  PHP,  chamada $\_SERVER ,  que podem oferecer ao programador in- forma√ß√µes √∫teis sobre o servidor onde o interpretador PHP est√° rodando, bem como outras informa√ß√µes. Estas podem ser necess√°rias quando se constr√≥i o texto em um documento HTML (por exemplo, veja a linha 7 da Figura 14.4). Aqui est√£o algumas dessas entradas:

- 1. $\_SERVER['SERVER\_NAME']. Essa  fornece o  nome  do  Website  do  computador  servidor onde o interpretador PHP est√° rodando. Por  exemplo,  se  o  interpretador  PHP  estiver  rodando  no  Website  &lt;http://www.uta. edu&gt;,  ent√£o  essa  string  seria  o  valor  em $\_ SERVER['SERVER\_NAME'].
- 2. $\_SERVER['REMOTE\_ADDRESS']. Esse  √©  o endere√ßo IP (Internet Protocol) do computador usu√°rio do cliente que est√° acessando o servidor, por exemplo, 129.107.61.8.
- 3. $\_SERVER['REMOTE\_HOST']. Esse √© o nome do site Web do computador usu√°rio do cliente,  por  exemplo, abc.uta.edu. Nesse caso, o servidor precisar√° traduzir o nome para um endere√ßo IP para acessar o cliente.
- 4. $\_SERVER['PATH\_INFO']. Essa  √©  a  parte  do endere√ßo URL que vem ap√≥s a barra (/) ao final do URL.
- 5. $\_SERVER['QUERY\_STRING']. Isso  fornece a  string  que  mant√©m  os  par√¢metros  em  um URL ap√≥s o ponto de interroga√ß√£o (?) ao final do URL. Isso pode manter par√¢metros de pesquisa, por exemplo.
- 6. $\_SERVER['DOCUMENT\_ROOT']. Esse √© o diret√≥rio raiz que mant√©m os arquivos no servidor Web que s√£o acess√≠veis aos usu√°rios clientes.

Estas e outras entradas no vetor $\_SERVER normalmente s√£o necess√°rias ao se criar o arquivo HTML a ser enviado para exibi√ß√£o.

Outra importante vari√°vel  autoglobal  de  vetor embutida da PHP √© $\_POST. Esta oferece ao programador os valores de entrada submetidos pelo usu√°rio  por  meio  de  formul√°rios  HTML  especificados na  tag  HTML &lt;INPUT&gt; e  outras  tags  semelhantes. Por  exemplo,  na  linha  14  da  Figura  14.4,  a  vari√°vel $\_POST['nome\_usuario'] oferece ao programador o valor digitado pelo usu√°rio no formul√°rio HTML especificado pela tag &lt;INPUT&gt; na linha 8. As chaves para esse vetor s√£o os nomes dos diversos par√¢metros de entrada fornecidos por meio do formul√°rio, por exemplo,  usando  o  atributo name da  tag &lt;INPUT&gt; da  HTML,  como  na  linha  8.  Quando  os  usu√°rios inserem dados nos formul√°rios, os valores de dados podem ser armazenados nesse vetor.

## 14.3 Vis√£o geral da programa√ß√£o de banco de dados em PHP

Existem v√°rias t√©cnicas para acessar um banco de dados por meio de uma linguagem de programa√ß√£o. Discutimos algumas delas no Cap√≠tulo 13, nas vis√µes gerais sobre como acessar um banco de dados SQL usando as linguagens de programa√ß√£o C e Java. Em  particular,  discutimos  SQL  embutida,  JDBC, SQL/CLI (semelhante √† ODBC) e SQLJ. Nesta se√ß√£o, oferecemos um panorama de como acessar o banco de dados usando a linguagem de scripting PHP, que √© bastante adequada para a cria√ß√£o de interfaces Web para busca e atualiza√ß√£o de bancos de dados, bem como p√°ginas Web din√¢micas.

Existe  uma  biblioteca  de  fun√ß√µes  de  acesso  a banco de dados PHP que faz parte do PHP Extension and Application Repository (PEAR), uma cole√ß√£o de v√°rias bibliotecas de fun√ß√µes para melhorar a PHP. A biblioteca PEAR DB oferece fun√ß√µes para acesso a banco de dados. Muitos sistemas de banco de dados podem ser acessados por essa biblioteca,  incluindo Oracle, MySQL, SQLite e Microsoft SQLServer, entre outros.

Discutiremos v√°rias fun√ß√µes que fazem parte da PEAR DB no contexto de alguns exemplos. A Se√ß√£o 14.3.1 mostra como se conectar a um banco de dados usando a PHP. A Se√ß√£o 14.3.2 discute como os dados  coletados  de  formul√°rios  HTML  podem  ser usados para inserir um novo registro em uma tabela (rela√ß√£o) de banco de dados. A Se√ß√£o 14.3.3 mostra como consultas de recupera√ß√£o podem ser executadas  e  ter  seus  resultados  exibidos  em  uma  p√°gina Web din√¢mica.

## 14.3.1 Conectando a um banco de dados

Para usar as fun√ß√µes de banco de dados em um programa PHP, o m√≥dulo de biblioteca PEAR DB, chamado DB.php, precisa ser carregado. Na Figura 14.6, isso √© feito na linha 0 do exemplo. As fun√ß√µes de biblioteca DB agora podem ser acessadas usando DB::&lt;function\_name&gt;. A fun√ß√£o para conectar a um banco de dados √© chamada de DB::connect('string'), na qual o argumento de string especifica a informa√ß√£o de banco de dados. O formato para 'string' √©:

&lt;software SGBD&gt;://&lt;conta do usu√°rio&gt;: &lt;senha&gt;@&lt;servidor de banco de dados&gt;

Na Figura 14.6, a linha 1 conecta ao banco de dados que est√° armazenado usando Oracle (especificado  por  meio  da  string oci8) .  A  parte &lt;software SGBD&gt; da 'string' especifica o pacote de software de SGBD em particular que est√° sendo conectado. Alguns  dos  pacotes  de  software  SGBD  acess√≠veis  por meio do PEAR DB s√£o:

- ¬Ñ MySQL. Especificado como mysql para vers√µes mais antigas e mysqli para vers√µes mais recentes, come√ßando com a vers√£o 4.1.2.
- ¬Ñ Oracle. Especificado como oc8i para as vers√µes 7, 8 e 9. Este √© usado na linha 1 da Figura 14.6.
- ¬Ñ SQLite. Especificado como sqlite.
- ¬Ñ Microsoft  SQL  Server. Especificado  como mssql.
- ¬Ñ Mini SQL. Especificado como msql.
- ¬Ñ Informix. Especificado como ifx.
- ¬Ñ Sybase. Especificado como sybase.
- ¬Ñ Qualquer  sistema  compat√≠vel  com  ODBC. Especificado como odbc.

Esta n√£o √© uma lista completa.

Ap√≥s o &lt;software SGDB&gt; no argumento de string passado a DB::connect est√° o separador ://, seguido pelo nome da conta do usu√°rio &lt;conta do usu√°rio&gt; , seguido pelo separador : e a senha da conta &lt;senha&gt;. Estes s√£o seguidos pelo separador @ e o nome e diret√≥rio do servidor &lt;servidor de banco de dados&gt; em que o banco de dados est√° armazenado.

Na  linha  1  da  Figura  14.6,  o  usu√°rio  est√°  se conectando  ao  servidor  em  &lt;www.host.com/db1&gt; usando o nome de conta conta1 e a senha senha12 armazenada sob o SGBD Oracle oci8. A string inteira √© passada usando DB::connect. A  informa√ß√£o de conex√£o √© mantida na vari√°vel de conex√£o do banco de dados $d, que √© usada sempre que uma opera√ß√£o para esse banco de dados em particular √© aplicada.

- 0) require  DB.php ; ' '
- 1) $d = DB::connect( oci8://conta1:senha12@www.host.com/db1 ); ' '
- 2) if (DB::isError($d)) { die( n√£o pode conectar -   . $d-&gt;getMessage( ));} ' '

...

- 3) $q = $d-&gt;query( CREATE TABLE FUNCIONARIO '
- 4) (Func\_id INT,
- 5) Nome VARCHAR(15),
- 6) Cargo VARCHAR(10),
- 7) Dnr INT)  ); '
- 8) if (DB::isError($q)) { die( criacao de tabela sem sucesso -   . ' ' $d-&gt;getMessage( )); }

...

- 9) $d-&gt;setErrorHandling(PEAR\_ERROR\_DIE);

...

- 10)	$fid	=	$d-&gt;nextID( ' FUNCIONARIO ); '
- 11) $d = $d-&gt;query( INSERT INTO FUNCIONARIO VALUES '
- 12) ($eid, $\_POST[ func\_nome ], $\_POST[ func\_cargo ], $\_POST['func\_dnr ])  ); ' ' ' ' ' '

...

- 13)	$fid	=	$d-&gt;nextID( ' FUNCIONARIO ); '
- 14) $q = $d-&gt;query( INSERT INTO FUNCIONARIO VALUES (?, ?, ?, ?) , ' '
- 15)	vetor($fid,	$\_POST[ ' func\_nome ], $\_POST[ func\_cargo ], $\_POST[ func\_dnr ]) ); ' ' ' ' '

Figura 14.6

Conectando a um banco de dados, criando uma tabela e inserindo um registro.

A linha  2  da  Figura  14.6  mostra  como  verificar  se  a  conex√£o  com  o  banco  de  dados  foi  estabelecida com sucesso ou n√£o. A PEAR DB tem uma  fun√ß√£o DB::isError, que  pode  determinar  se qualquer  opera√ß√£o  de  acesso  ao  banco  de  dados foi bem-sucedida ou n√£o. O argumento para essa fun√ß√£o  √©  a  vari√°vel  de  conex√£o  de  banco  de  dados ( $d neste exemplo). Em geral, o programador PHP pode verificar ap√≥s cada chamada ao banco de dados para determinar se a √∫ltima opera√ß√£o do banco de dados teve sucesso ou n√£o, e terminar o programa (usando a fun√ß√£o die) se n√£o tiver obtido sucesso. Uma mensagem de erro tamb√©m √© retornada do banco de dados por meio da opera√ß√£o $d-&gt;get\_message( ). Esta tamb√©m pode ser exibida como mostra a linha 2 da Figura 14.6.

Na maioria das vezes, muitos comandos SQL podem ser enviados ao banco de dados quando uma conex√£o √© estabelecida por meio da fun√ß√£o query . A  fun√ß√£o $d-&gt;query usa  um  comando  SQL  como seu  argumento  de  string  e  o  envia  ao  servidor  de banco de dados para execu√ß√£o. Na Figura 14.6, as linhas  3  a  7  enviam  um  comando CREATE TABLE para criar uma tabela chamada FUNCIONARIO com quatro atributos. Sempre que uma consulta √© executada, seu resultado √© atribu√≠do a uma vari√°vel de consulta, que √© chamada $q em nosso exemplo. A linha 8 verifica se a consulta foi executada com sucesso ou n√£o.

A biblioteca PEAR DB da PHP oferece uma alternativa para verificar erros ap√≥s cada comando do banco de dados. A fun√ß√£o

$d-&gt;setErrorHandling(PEAR\_ERROR\_DIE)

terminar√° o programa e imprimir√° as mensagens de erro padr√£o se quaisquer erros subsequentes ocorrerem ao acessar o banco de dados por meio da conex√£o $d (ver a linha 9 da Figura 14.6).

## 14.3.2 Coletando dados de formul√°rios e inserindo registros

√â comum, em aplica√ß√µes de banco de dados, coletar informa√ß√µes por meio da HTML ou de outros tipos de formul√°rios Web. Por exemplo, ao adquirir uma passagem a√©rea ou solicitar um cart√£o de cr√©dito, o  usu√°rio  precisa  entrar  com  informa√ß√µes  pessoais como nome, endere√ßo e n√∫mero de telefone.  Essa informa√ß√£o  normalmente  √©  coletada  e  armazenada em um registro do banco de dados em um servidor.

As linhas 10 a 12 da Figura 14.6 ilustram como isso pode ser feito. Neste exemplo, omitimos o c√≥digo para criar o formul√°rio e coletar os dados, que pode ser uma varia√ß√£o do exemplo na Figura 14.1. Assumimos que o usu√°rio inseriu valores v√°lidos nos par√¢metros de entrada chamados func\_nome, func\_ cargo e func\_dnr. Estes seriam acess√≠veis por meio do vetor autoglobal em PHP $\_POST , conforme discutido no final da Se√ß√£o 14.2.4.

No comando SQL INSERT mostrado nas linhas 11 e 12 da Figura 14.6, as entradas de vetor $POST['func\_ nome'], $POST['func\_cargo'] e $POST['func\_dnr'] manter√£o  os  valores  coletados  do  usu√°rio  por  meio  do formul√°rio de entrada de HTML. Estes s√£o ent√£o inseridos como um novo registro de funcion√°rio na tabela FUNCIONARIO .

Esse exemplo tamb√©m ilustra outro recurso da PEAR DB. √â comum, em algumas aplica√ß√µes, criar um  identificador  de  registro  exclusivo  para  cada novo registro inserido no banco de dados. 1

PHP tem uma fun√ß√£o $d-&gt;nextID para criar uma sequ√™ncia de valores exclusivos para determinada tabela. Em nosso exemplo, o campo Func\_id da tabela FUNCIONARIO (ver Figura 14.6, linha 4) √© criado para essa finalidade. A linha 10 mostra como recuperar o pr√≥ximo valor exclusivo na sequ√™ncia para a tabela FUNCIONARIO e inseri-lo como parte do novo registro nas linhas 11 e 12.

O c√≥digo para inser√ß√£o nas linhas 10 a 12 da Figura 14.6 pode permitir que strings maliciosas sejam inseridas,  podendo  alterar  o  comando INSERT .  Um modo mais seguro de realizar inser√ß√µes e outras consultas √© por meio do uso de marcadores de lugar (especificados pelo s√≠mbolo ? ). Um exemplo √© ilustrado nas linhas 13 a 15, onde outro registro deve ser inserido.

Nessa forma da fun√ß√£o $d-&gt;query( ) , existem dois argumentos. O primeiro argumento √© a instru√ß√£o SQL, com um ou mais s√≠mbolos ? (marcadores de lugar). O segundo argumento √© um vetor, cujos valores de elemento ser√£o usados para substituir os marcadores de lugar na ordem em que s√£o especificados.

## 14.3.3 Consultas de recupera√ß√£o de tabelas do banco de dados

Agora, oferecemos tr√™s exemplos de consultas de recupera√ß√£o por meio da PHP, mostradas na Figura 14.7. As primeiras linhas, de 0 a 3, estabelecem uma conex√£o de banco de dados $d e definem o tratamento  de  erro  para  o  default,  conforme  discutimos  na se√ß√£o anterior. A primeira consulta (linhas 4 a 7) recupera o nome e o n√∫mero do departamento de todos os registros de funcion√°rios. A vari√°vel de consulta $q √© usada para se referir ao resultado da consulta . Um loop while para percorrer cada linha no resultado aparece nas linhas 5 a 7. A fun√ß√£o $q-&gt;fetchRow( ) na linha 5 serve para recuperar o pr√≥ximo registro no resultado da consulta e controlar o loop. O looping come√ßa no primeiro registro.

O segundo exemplo de consulta aparece nas linhas 8 a 13 e ilustra uma consulta din√¢mica. Nesta  consulta,  as  condi√ß√µes  para  sele√ß√£o  de  linhas

- 0) require  DB.php ; ' '
- 1) $d = DB::connect( oci8://conta1:senha12@www.host.com/dbname ); ' '
- 2) if (DB::isError($d)) { die( n√£o pode conectar -   . $d-&gt;getMessage( )); } ' '
- 3) $d-&gt;setErrorHandling(PEAR\_ERROR\_DIE);

...

- 4) $q = $d-&gt;query( SELECT Nome, Dnr FROM FUNCIONARIO ); ' '
- 5) while ($r = $q-&gt;fetchRow( )) {
- 6) print  funcionario $r[0] trabalha para o departamento $r[1] \n  ; ' '
- 7) }

...

- 8) $q = $d-&gt;query( SELECT Nome FROM FUNCIONARIO WHERE Cargo = ? AND Dnr = ? , ' '
- 9) vetor($\_POST[ func\_cargo ], $\_POST[ func\_dnr']) ); ' ' '
- 10) print 'funcionarios no dep $\_POST[ func\_dnr ] cujo cargo √© $\_POST[ func\_cargo ]: \n ' ' ' ' '
- 11) while ($r = $q-&gt;fetchRow( )) {
- 12) print  funcionario $r[0] \n  ; ' '
- 13) }

...

- 14) $todos resultados = $d-&gt;getAll( SELECT Nome, Cargo, Dnr FROM FUNCIONARIO ); ' '
- 15) foreach ($allresult as $r) {
- 16) 17) }
- print  funcionario $r[0] tem cargo $r[1] e trabalha para o departamento $r[2] \n  ; ' '

...

Figura 14.7

Ilustrando as consultas de recupera√ß√£o do banco de dados.

1 Este seria semelhante ao OID gerado pelo sistema, discutido no Cap√≠tulo 11, para sistemas de banco de dados de objeto e objeto-relacional.

s√£o  baseadas  nos  valores  inseridos  pelo  usu√°rio. Aqui, queremos recuperar os nomes dos funcion√°rios que t√™m um cargo espec√≠fico e trabalham para determinado departamento. O cargo e n√∫mero de departamento em particular s√£o inseridos  por  um formul√°rio nas vari√°veis de vetor $POST['func\_car-go'] e $POST['func\_dnr']. Se  o  usu√°rio  tivesse  inserido 'Engenheiro' para o cargo e 5 para o n√∫mero do departamento, a consulta selecionaria os nomes de todos os engenheiros que trabalharam no departamento 5. Como podemos ver, essa √© uma consulta  din√¢mica,  cujos  resultados  diferem  dependendo das escolhas que o usu√°rio informa como entrada. Usamos dois marcadores de lugar ? neste exemplo, conforme discutido no final da Se√ß√£o 14.3.2.

A √∫ltima consulta (linhas 14 a 17) mostra uma forma alternativa de especificar uma consulta e percorrer suas linhas. Neste exemplo, a fun√ß√£o $d-&gt;getAll mant√©m todos os registros de um resultado da consulta em uma √∫nica vari√°vel,  chamada $todos\_resultados. Para percorrer os registros individuais, um loop foreach pode ser usado, com a vari√°vel de linha $r percorrendo cada linha em $todos\_resultados. 2

Como podemos  ver,  a  PHP  √©  adequada  tanto para acesso a banco de dados quanto para cria√ß√£o de p√°ginas Web din√¢micas.

## Resumo

Neste  cap√≠tulo,  tivemos  uma  vis√£o  geral  de  como converter alguns dados estruturados de bancos de dados para elementos a serem inseridos ou exibidos em uma p√°gina Web. Focalizamos a linguagem de scripting PHP, que est√° se tornando muito popular para a programa√ß√£o de  banco  de  dados  na  Web.  A  Se√ß√£o  14.1  apresentou alguns fundamentos de PHP para programa√ß√£o na Web por meio de um exemplo simples. A Se√ß√£o 14.2 mostrou alguns  dos  fundamentos  da  linguagem  PHP,  incluindo seus tipos de dados de vetor e string, que s√£o bastante utilizados.  A  Se√ß√£o  14.3  apresentou  um  panorama  de como a PHP pode ser usada para especificar diversos tipos de comandos de banco de dados, incluindo a cria√ß√£o de tabelas, inser√ß√£o de novos registros e recupera√ß√£o de registros de banco de dados. A PHP roda no computador servidor, em compara√ß√£o com algumas outras linguagens de scripting, que rodam no computador cliente.

Fizemos  apenas  uma  introdu√ß√£o  muito  b√°sica  √† PHP. Existem muitos livros, al√©m de sites Web, dedica- dos √† programa√ß√£o PHP introdut√≥ria e avan√ßada. Tamb√©m existem diversas bibliotecas de fun√ß√µes para PHP, pois esse √© um produto de fonte aberto.

## Perguntas de revis√£o

- 14.1. Por que as linguagens de scripting s√£o populares para a programa√ß√£o de aplica√ß√µes Web? Onde, na  arquitetura  de  tr√™s  camadas,  um  programa em PHP √© executado? Onde um programa em JavaScript √© executado?
- 14.2.
- 14.3. strings em PHP.
- Que tipo de linguagem de programa√ß√£o √© a PHP? Discuta  as  diferentes  maneiras  de  especificar
- 14.4. Discuta os diferentes tipos de vetores em PHP.
- 14.5. O que s√£o vari√°veis autoglobais da PHP? D√™ alguns exemplos de vetores autoglobais em PHP e discuta como cada um costuma ser usado.
- 14.6. O que √© PEAR? O que √© PEAR DB?
- 14.7. Discuta  as  principais  fun√ß√µes  para  acessar  um banco de dados em PEAR DB e como cada uma √© usada.
- 14.8. Discuta  as  diferentes  maneiras  de  realizar  um looping durante um resultado de consulta em PHP.
- 14.9. O que s√£o marcadores de lugar? Como eles s√£o usados na programa√ß√£o de banco de dados em PHP?

## Exerc√≠cios

- 14.10. Considere  o  esquema  de  banco  de  dados BIBLIOTECA da Figura 4.6. Escreva um c√≥digo em PHP para criar as tabelas desse esquema.
- 14.11. Escreva um programa em PHP que crie formul√°rios Web para a entrada de informa√ß√µes sobre uma nova entidade USUARIO . Repita para uma nova entidade LIVRO .
- 14.12. Escreva interfaces Web em PHP para as consultas especificadas no Exerc√≠cio 6.18.

## Bibliografia selecionada

Existem muitas fontes para programa√ß√£o PHP, tanto impressas quanto na Web. Indicamos dois livros como exemplos. Uma introdu√ß√£o bastante boa √† PHP √© dada em Sklar (2005). Para o desenvolvimento avan√ßado de site Web, o livro de Schlossnagle (2005) oferece muitos exemplos detalhados.



Teoria e normaliza√ß√£o de projeto de banco de dados cap√≠tulo



## Fundamentos de depend√™ncias funcionais e normaliza√ß√£o para bancos de dados relacionais

N os cap√≠tulos 3 a 6, apresentamos diversos aspectos do modelo relacional e as linguagens associadas a ele. Cada esquema de rela√ß√£o consiste em uma s√©rie  de  atributos,  e  o esquema de banco de dados relacional consiste em uma s√©rie de esquemas de rela√ß√£o. At√© aqui, assumimos que os atributos s√£o agrupados para formar um esquema de rela√ß√£o usando o bom senso do projetista de banco de dados ou mapeando um projeto de esquema de banco de dados com base no modelo de dados conceitual, como o modelo de dados  ER  ou  ER  Estendido  (EER).  Esses  modelos fazem o projetista identificar os tipos de entidade e de relacionamento e seus respectivos atributos, o que leva a um agrupamento natural e l√≥gico dos atributos em rela√ß√µes quando os procedimentos de mapeamento discutidos no Cap√≠tulo 9 s√£o seguidos. Por√©m, ainda precisamos de algum modo formal de an√°lise porque um agrupamento de atributos em um esquema de rela√ß√£o pode ser melhor do que outro. Ao discutir o projeto de banco de dados nos cap√≠tulos 7 a 10, n√£o desenvolvemos nenhuma medida de adequa√ß√£o ou boas pr√°ticas para medir a qualidade do projeto, al√©m da intui√ß√£o do projetista. Neste cap√≠tulo, vamos discutir parte da teoria que foi desenvolvida com o objetivo de avaliar esquemas relacionais para a qualidade do projeto - ou seja, para medir formalmente por que um conjunto de agrupamentos de atributos em esquemas de rela√ß√£o √© melhor do que outro.

Existem dois n√≠veis em que podemos discutir as boas pr√°ticas de esquemas de rela√ß√£o. O primeiro √© o n√≠vel  l√≥gico (ou conceitual )  -  como os usu√°rios interpretam os esquemas de rela√ß√£o e o significado de seus atributos. Ter bons esquemas de rela√ß√£o nesse n√≠vel permite que os usu√°rios entendam claramente o significado dos dados nas rela√ß√µes, e da√≠ formulem suas consultas corretamente. O segundo √© o n√≠vel de implementa√ß√£o (ou armazenamento f√≠sico ) - como as tuplas em uma rela√ß√£o da base s√£o armazenadas e  atualizadas.  Esse  n√≠vel  se  aplica  apenas  a  esquemas das  rela√ß√µes  da  base  -  que  ser√£o  fisicamente armazenadas como arquivos -, enquanto no n√≠vel l√≥gico estamos interessados em esquemas de rela√ß√µes da base e vis√µes (rela√ß√µes virtuais). A teoria de projeto de banco de dados relacional desenvolvida neste cap√≠tulo se aplica principalmente a rela√ß√µes da base , embora  alguns  crit√©rios  de  adequa√ß√£o  tamb√©m  se apliquem a vis√µes, como mostra a Se√ß√£o 15.1.

Assim como em muitos problemas de projeto, o projeto de banco de dados pode ser realizado usando duas t√©cnicas: de baixo para cima (bottom-up) ou de cima  para  baixo  (top-down).  Uma metodologia  de projeto de baixo para cima (tamb√©m chamada projeto por s√≠ntese ) considera os relacionamentos b√°sicos entre atributos individuais como ponto de partida e os utiliza para construir esquemas de rela√ß√£o. Essa t√©cnica n√£o √© muito popular na pr√°tica, 1  pois sofre

do problema de ter que coletar um grande n√∫mero de relacionamentos bin√°rios entre atributos como ponto de  partida.  Para  situa√ß√µes  pr√°ticas,  √©  quase  imposs√≠vel  capturar relacionamentos bin√°rios entre todos esses pares de atributos. Ao contr√°rio, uma metodologia  de  projeto  de  cima  para  baixo (tamb√©m chamada projeto por an√°lise ) come√ßa com uma s√©rie de agrupamentos de atributos em rela√ß√µes que existem naturalmente juntas,  por  exemplo,  em  uma  fatura, formul√°rio ou relat√≥rio. As rela√ß√µes s√£o ent√£o analisadas individual e coletivamente, levando a mais decomposi√ß√£o, at√© que todas as propriedades desej√°veis sejam atendidas. A teoria descrita neste cap√≠tulo se aplica  √†s  t√©cnicas  de  projeto  de  cima  para  baixo  e de baixo par cima, mas √© mais apropriada quando usada com a t√©cnica de cima para baixo.

O projeto de banco de dados relacional por fim produz  um  conjunto  de  rela√ß√µes.  Os  objetivos  impl√≠citos  da  atividade  de  projeto  s√£o preserva√ß√£o da informa√ß√£o e redund√¢ncia  m√≠nima .  A  informa√ß√£o √© muito dif√≠cil de se quantificar - logo, consideramos a preserva√ß√£o de informa√ß√£o em mat√©ria de manuten√ß√£o de todos os conceitos, incluindo tipos de atributo, tipos de entidade e tipos de relacionamento, bem como os relacionamentos de generaliza√ß√£o/ especializa√ß√£o, que s√£o descritos usando um modelo como o EER. Assim, o projeto relacional precisa preservar todos esses conceitos, que s√£o capturados originalmente no projeto conceitual ap√≥s o mapeamento do projeto conceitual para l√≥gico. A minimiza√ß√£o da redund√¢ncia implica diminuir o armazenamento redundante da mesma informa√ß√£o e reduzir a necessidade  de  m√∫ltiplas  atualiza√ß√µes  para  manter a consist√™ncia entre diversas c√≥pias da mesma informa√ß√£o, em resposta a eventos do mundo real que exijam fazer uma atualiza√ß√£o.

Come√ßamos este  cap√≠tulo  discutindo  informalmente alguns crit√©rios para esquemas de rela√ß√£o bons e  ruins  na  Se√ß√£o 15.1. Na Se√ß√£o 15.2, definimos o conceito  de depend√™ncia  funcional , uma  restri√ß√£o formal entre os atributos que √© a principal ferramenta  para  medir  formalmente  a  adequa√ß√£o  dos  agrupamentos de atributo em esquemas de rela√ß√£o. Na Se√ß√£o  15.3,  vamos  discutir  as  formas  normais  e  o processo de normaliza√ß√£o usando depend√™ncias funcionais. As formas normais sucessivas s√£o definidas para atender a um conjunto de restri√ß√µes desej√°veis, expressas com depend√™ncias funcionais. O procedimento de normaliza√ß√£o consiste em aplicar uma s√©rie de testes √†s rela√ß√µes para atender a esses requisitos cada vez mais r√≠gidos e decompor as rela√ß√µes quando necess√°rio. Na Se√ß√£o 15.4, discutimos defini√ß√µes mais gerais das formas normais, que podem ser aplicadas diretamente a qualquer projeto dado e n√£o exigem an√°lise e normaliza√ß√£o passo a passo. As se√ß√µes 15.5 a 15.7 discutem outras formas normais, at√© a quinta forma normal. Na Se√ß√£o 15.6, apresentamos a  depend√™ncia  multivalorada  (MVD),  seguida  pela depend√™ncia de jun√ß√£o (DJ) na Se√ß√£o 15.7. No final h√° um resumo do cap√≠tulo.

O Cap√≠tulo 16 continuar√° o desenvolvimento da teoria relacionada ao projeto de bons esquemas relacionais. Discutimos as propriedades desej√°veis da decomposi√ß√£o relacional - propriedade de jun√ß√£o n√£o aditiva e propriedade de preserva√ß√£o da depend√™ncia funcional. Um algoritmo geral testa se uma decomposi√ß√£o tem ou n√£o a propriedade de jun√ß√£o n√£o aditiva (ou sem perdas ) (o Algoritmo 16.3 tamb√©m √© apresentado). Depois, abordamos as propriedades das depend√™ncias funcionais e o conceito de uma cobertura m√≠nima de depend√™ncias. Consideramos a t√©cnica de baixo para cima para o projeto de banco de dados que consiste em um conjunto de algoritmos para projetar rela√ß√µes em uma forma normal desejada. Esses algoritmos  consideram  como  entrada  determinado conjunto de depend√™ncias funcionais e alcan√ßam um projeto relacional em uma forma normal de destino, enquanto aderem √†s propriedades desej√°veis acima. No Cap√≠tulo 16, tamb√©m definimos outros tipos de depend√™ncias que melhoram ainda mais a avalia√ß√£o das boas pr√°ticas de esquemas de rela√ß√£o.

Se o Cap√≠tulo 16 n√£o for inclu√≠do no curso, recomendamos uma r√°pida introdu√ß√£o √†s propriedades desej√°veis de decomposi√ß√£o e √† discuss√£o da Propriedade NJB da Se√ß√£o 16.2.

## 15.1 Diretrizes de projeto informais para esquemas de rela√ß√£o

Antes de discutirmos a teoria formal do projeto de banco de dados relacional, vamos abordar quatro diretrizes informais que podem ser usadas como medidas para determinar a qualidade de projeto do esquema da rela√ß√£o:

- ¬Ñ Garantir que a sem√¢ntica dos atributos seja clara no esquema.
- ¬Ñ Reduzir a informa√ß√£o redundante nas tuplas.
- ¬Ñ Reduzir os valores NULL nas tuplas.
- ¬Ñ Reprovar a possibilidade de gerar tuplas falsas.

Essas  medidas  nem  sempre  s√£o  independentes uma da outra, conforme veremos.

## 15.1.1 Comunicando uma sem√¢ntica clara aos atributos nas rela√ß√µes

Sempre  que  agrupamos  atributos  para  formar um esquema de rela√ß√£o, consideramos que aqueles atributos pertencentes a uma rela√ß√£o t√™m certo significado  no  mundo  real  e  uma  interpreta√ß√£o  apro-

priada associada a eles. A sem√¢ntica de uma rela√ß√£o refere-se a seu significado resultante da interpreta√ß√£o dos valores de atributo em uma tupla. No Cap√≠tulo 3, discutimos como uma rela√ß√£o pode ser interpretada como um conjunto de fatos. Se o projeto conceitual descrito nos cap√≠tulos 7 e 8 for feito cuidadosamente e o procedimento de mapeamento do Cap√≠tulo 9 for seguido de maneira sistem√°tica, o projeto do esquema relacional dever√° ter um significado claro.

Em geral, quanto mais f√°cil for explicar a sem√¢ntica da rela√ß√£o, melhor ser√° o projeto do esquema de rela√ß√£o. Para ilustrar isso, considere a Figura 15.1, uma vers√£o simplificada do esquema de banco de dados relacional EMPRESA da Figura 3.5, e a Figura 15.2, que apresenta um exemplo de estados de rela√ß√£o preenchidos desse esquema. O significado  do  esquema  de  rela√ß√£o FUNCIONARIO √©  muito simples: cada tupla representa um funcion√°rio, com valores  para  o  nome  do  funcion√°rio  ( Fnome ),  n√∫mero do Cadastro de Pessoa F√≠sica ( Cpf ),  data  de nascimento ( Datanasc ), endere√ßo ( Endereco ) e o n√∫mero do departamento para o qual o funcion√°rio trabalha ( Dnumero ). O atributo Dnumero √© uma chave  estrangeira  que  representa  um relacionamento impl√≠cito entre FUNCIONARIO e DEPARTAMENTO. A sem√¢ntica dos esquemas DEPARTAMENTO e PROJETO √© muito simples: cada tupla DEPARTAMENTO

## FUNCIONARIO

Figura 15.1



Um esquema de banco de dados relacional EMPRESA simplificado.

representa  uma  entidade  de  departamento,  e  cada tupla PROJETO representa uma entidade de projeto. O atributo Cpf\_gerente de DEPARTAMENTO relaciona um departamento ao funcion√°rio que √© seu gerente, enquanto Dnum de PROJETO relaciona um projeto a seu departamento de controle; ambos s√£o atributos de chave estrangeira. A facilidade com que o significado dos atributos de uma rela√ß√£o pode ser explicado  √©  uma medida informal de  qu√£o  bem  a rela√ß√£o est√° projetada.

A sem√¢ntica dos outros dois esquemas de rela√ß√£o da Figura 15.1 √© ligeiramente mais complexa. Cada tupla em LOCALIZACAO\_DEP gera um n√∫mero de departamento ( Dnumero ) e um dos locais do departamento  ( Dlocalizacao ).  Cada  tupla  em TRA-BALHA\_EM gera um n√∫mero de Cadastro de Pessoa F√≠sica ( Cpf ), o n√∫mero de projeto de um dos projetos  em  que  o  funcion√°rio  trabalha  ( Projnumero )  e o n√∫mero de horas por semana que o funcion√°rio trabalha  nesse  projeto  ( Horas ).  Por√©m,  os  dois  esquemas t√™m uma interpreta√ß√£o bem definida e n√£o amb√≠gua. O esquema LOCALIZACAO\_DEP representa um atributo multivalorado de DEPARTAMENTO , enquanto TRABALHA\_EM representa um relacionamento M:N entre FUNCIONARIO e PROJETO . Logo, todos  os  esquemas  de  rela√ß√£o  na  Figura  15.1  podem ser considerados f√°ceis de explicar e, portanto, bons do ponto de vista de ter uma sem√¢ntica clara. Assim, podemos formular as seguintes diretrizes de projeto informal:

Diretriz 1

Projete um esquema de rela√ß√£o de modo que seja f√°cil explicar seu significado. N√£o combine atributos de v√°rios tipos de entidade e de relacionamento em uma √∫nica rela√ß√£o. Intuitivamente,  se  um  esquema de rela√ß√£o corresponde a um tipo de entidade ou um tipo  de  relacionamento,  √©  simples  interpretar  e  explicar  seu  significado.  Caso  contr√°rio,  se  a  rela√ß√£o corresponder a uma mistura de v√°rias entidades e relacionamentos, haver√° ambiguidades sem√¢nticas e a rela√ß√£o n√£o poder√° ser explicada com facilidade.

Exemplos de viola√ß√£o da diretriz 1. Os esquemas de rela√ß√£o das figuras 15.3(a) e 15.3(b) tamb√©m t√™m sem√¢ntica clara. (O leitor deve ignorar as linhas sob as rela√ß√µes por enquanto; elas s√£o usadas para ilustrar  a  nota√ß√£o  da  depend√™ncia  funcional,  discutida na  Se√ß√£o  15.2.)  Uma  tupla  no  esquema  de  rela√ß√£o FUNC\_DEP na  Figura  15.3(a)  representa  um  √∫nico funcion√°rio,  mas  inclui  informa√ß√µes  adicionais  a  saber,  o  nome  ( Dnome )  do  departamento  para  o qual o funcion√°rio trabalha e o n√∫mero do Cadastro de Pessoa F√≠sica ( Cpf\_gerente ) do gerente de departamento.  Para  a  rela√ß√£o FUNC\_PROJ da  Figura

## FUNCIONARIO

| Fnome              |         Cpf | Datanasc   | Endereco                                |   Dnumero |
|--------------------|-------------|------------|-----------------------------------------|-----------|
| Silva, Joao B.     | 12345678966 | 09-01-1965 | Rua das Flores, 751, S√£o Paulo, SP      |         5 |
| Wong, Fernando T.  | 33344555587 | 08-12-1955 | Rua da Lapa, 34, S√£o Paulo, SP          |         5 |
| Zelaya, Alice J.   | 99988777767 | 19-01-1968 | Rua Souza Lima, 35, Curitiba, PR        |         4 |
| Souza, Jennifer S. | 98765432168 | 20-06-1941 | Av. Arthur de Lima, 54, Santo Andr√©, SP |         4 |
| Lima, Ronaldo K.   | 66688444476 | 15-09-1962 | Rua Rebou√ßas, 65, Piracicaba, SP        |         5 |
| Leite, Joice A.    | 45345345376 | 31-07-1972 | Av. Lucas Obes, 74, S√£o Paulo, SP       |         5 |
| Pereira, Andr√© V.  | 98798798733 | 29-03-1969 | Rua Timbira, 35, S√£o Paulo, SP          |         4 |
| Brito, Jorge E.    | 88866555576 | 10-11-1937 | Rua do Horto, 35, S√£o Paulo, SP         |         1 |

## DEPARTAMENTO

| Dnome         |   Dnumero |   Cpf_gerente |
|---------------|-----------|---------------|
| Pesquisa      |         5 |   33344555587 |
| Administra√ß√£o |         4 |   98765432168 |
| Matriz        |         1 |   88866555576 |

## LOCALIZACAO\_DEP

|   Dnumero | Dlocal      |
|-----------|-------------|
|         1 | S√£o Paulo   |
|         4 | Mau√°        |
|         5 | Santo Andr√© |
|         5 | Itu         |
|         5 | S√£o Paulo   |

## TRABALHA\_EM

|         Cpf |   Projnumero | Horas   |
|-------------|--------------|---------|
| 12345678966 |            1 | 32,5    |
| 12345678966 |            2 | 7,5     |
| 66688444476 |            3 | 40,0    |
| 45345345376 |            1 | 20,0    |
| 45345345376 |            2 | 20,0    |
| 33344555587 |            2 | 10,0    |
| 33344555587 |            3 | 10,0    |
| 33344555587 |           10 | 10,0    |
| 33344555587 |           20 | 10,0    |
| 99988777767 |           30 | 30,0    |
| 99988777767 |           10 | 10,0    |
| 98798798733 |           10 | 35,0    |
| 98798798733 |           30 | 5,0     |
| 98765432168 |           30 | 20,0    |
| 98765432168 |           20 | 15,0    |
| 88866555576 |           20 | NULL    |

| Projnome        |   Projnumero | Projlocal   |   Dnum |
|-----------------|--------------|-------------|--------|
| ProdutoX        |            1 | Santo Andr√© |      5 |
| ProdutoY        |            2 | Itu         |      5 |
| ProdutoZ        |            3 | S√£o Paulo   |      5 |
| informatiza√ß√£o  |           10 | Mau√°        |      4 |
| Reorganiza√ß√£o   |           20 | S√£o Paulo   |      1 |
| Novosbenef√≠cios |           30 | Mau√°        |      4 |

## Figura 15.2

Exemplo de estado de banco de dados para o esquema relacional da Figura 15.1.

15.3(b), cada tupla relaciona um funcion√°rio a um projeto, mas tamb√©m inclui o nome do funcion√°rio ( Fnome ), nome do projeto ( Projnome ) e local do projeto  ( Projlocal ).  Embora n√£o haja nada logicamente errado logicamente com essas duas rela√ß√µes, elas violam a Diretriz 1 ao misturar atributos de entidades distintas do mundo real: FUNC\_DEP mistura atribu- tos dos funcion√°rios e departamentos, e FUNC\_PROJ mistura atributos de funcion√°rios e projetos e o relacionamento TRABALHA\_EM . Logo, elas se saem mal contra a medida de qualidade de projeto citado. Elas podem ser usadas como vis√µes, mas causam problemas quando utilizadas como rela√ß√µes da base, conforme discutiremos na pr√≥xima se√ß√£o.

## PROJETO

## (a) FUNC\_DEP

Figura 15.3



Dois esquemas de rela√ß√£o sofrendo de anomalias de atualiza√ß√£o. (a) FUNC\_DEP e (b) FUNC\_PROJ.

## 15.1.2 nforma√ß√£o redundante nas tuplas I e anomalias de atualiza√ß√£o

Um objetivo do projeto de esquema √© minimizar o espa√ßo de armazenamento usado pelas rela√ß√µes (e, portanto, pelos arquivos correspondentes). O agrupamento de atributos em esquemas de rela√ß√£o tem um efeito significativo no espa√ßo de armazenamento. Por exemplo, compare o espa√ßo usado pelas duas rela√ß√µes da base FUNCIONARIO e DEPARTAMENTO da Figura  15.2  com  o  da  rela√ß√£o  da  base FUNC\_DEP da  Figura  15.4,  que  √©  o  resultado  da  aplica√ß√£o  da opera√ß√£o JUNCAO NATURAL em FUNCIONARIO e DEPARTAMENTO . Em FUNC\_DEP, os valores de atributo pertencentes a determinado departamento ( Dnumero, Dnome, Cpf\_gerente ) s√£o repetidos para cada funcion√°rio que trabalha para esse departamento. Ao contr√°rio, a informa√ß√£o de cada departamento aparece apenas uma vez na rela√ß√£o DEPARTAMENTO da Figura 15.2. Somente o n√∫mero do departamento ( Dnumero ) √© repetido na rela√ß√£o FUNCIONARIO para cada funcion√°rio que trabalha nesse departamento, como uma chave estrangeira.  Coment√°rios  semelhantes  se aplicam √† rela√ß√£o FUNC\_PROJ (ver Figura 15.4), que aumenta a rela√ß√£o TRABALHA\_EM com atributos adicionais de FUNCIONARIO e PROJETO .

- ¬Ñ Para inserir uma nova tupla de funcion√°rio em FUNC\_DEP, temos de incluir ou os valores de atributo do departamento para o qual o funcion√°rio trabalha ou NULL s (se o funcion√°rio ainda n√£o trabalha para nenhum departamento). Por exemplo, para inserir uma nova tupla para um funcion√°rio que trabalha no departamento 5, temos de inserir todos os valores de  atributo  do  departamento  5  corretamente,  de modo que eles sejam coerentes com os valores correspondentes  para  o  departamento  5  em outras  duplas  de FUNC\_DEP. No  projeto  da Figura 15.2, n√£o temos de nos preocupar com esse  problema  de  coer√™ncia,  pois  entramos apenas  com  o  n√∫mero  do  departamento  na tupla do funcion√°rio. Todos os outros valores de  atributo  do  departamento  5  s√£o  registrados apenas uma vez no banco de dados, como uma √∫nica tupla na rela√ß√£o DEPARTAMENTO .
- O armazenamento de jun√ß√µes naturais de rela√ß√µes da base leva a um problema adicional conhecido como anomalias de atualiza√ß√£o . Estas podem ser classificadas em anomalias de inser√ß√£o, anomalias de exclus√£o e anomalias de modifica√ß√£o. 2

Anomalias de inser√ß√£o. As  anomalias  de  inser√ß√£o podem ser diferenciadas em dois tipos, ilustrados pelos seguintes exemplos baseados na rela√ß√£o FUNC\_DEP :

- ¬Ñ √â  dif√≠cil  inserir  um  novo  departamento  que ainda n√£o tenha funcion√°rios na rela√ß√£o FUNC\_DEP .  A  √∫nica  maneira  de  fazer  isso  √© colocar valores NULL nos atributos para funcion√°rio.  Isso  viola  a  integridade  de  entidade para FUNC\_DEP ,  porque Cpf √©  sua  chave prim√°ria.  Al√©m  do  mais,  quando  o  primeiro funcion√°rio √© atribu√≠do a esse departamento, n√£o precisamos mais dessa tupla com valores NULL .  Esse  problema  n√£o  ocorre  no  projeto da Figura 15.2, visto que um departamento √© inserido na rela√ß√£o DEPARTAMENTO independentemente de haver ou n√£o funcion√°rios trabalhando para ele, e sempre que um funcion√°rio √© atribu√≠do a esse departamento, uma tupla correspondente √© inserida em FUNCIONARIO.

2 Essas anomalias foram identificadas por Codd (1972a) para justificar a necessidade de normaliza√ß√£o das rela√ß√µes, conforme discutiremos na Se√ß√£o 15.3.

## FUNC\_DEP

| Fnome              |         Cpf | Datanasc   | Endereco                                |   Dnumero | Dnome         |   Cpf_gerente |
|--------------------|-------------|------------|-----------------------------------------|-----------|---------------|---------------|
| Silva, Jo√£o B.     | 12345678966 | 09-01-1965 | Rua das Flores, 751, S√£o Paulo, SP      |         5 | Pesquisa      |   33344555587 |
| Wong, Fernando T.  | 33344555587 | 08-12-1955 | Rua da Lapa, 34, S√£o Paulo, SP          |         5 | Pesquisa      |   33344555587 |
| Zelaya, Alice J.   | 99988777767 | 19-01-1968 | Rua Souza Lima, 35, Curitiba, PR        |         4 | Administra√ß√£o |   98765432168 |
| Souza, Jennifer S. | 98765432168 | 20-06-1941 | Av. Arthur de Lima, 54, Santo Andr√©, SP |         4 | Administra√ß√£o |   98765432168 |
| Lima, Ronaldo K.   | 66688444476 | 15-09-1962 | Rua Rebou√ßas, 65, Piracicaba, SP        |         5 | Pesquisa      |   33344555587 |
| Leite, Joice A.    | 45345345376 | 31-07-1972 | Av. Lucas Obes, 74, S√£o Paulo, SP       |         5 | Pesquisa      |   33344555587 |
| Pereira, Andr√© V.  | 98798798733 | 29-03-1969 | Rua Timbira, 35, S√£o Paulo, SP          |         4 | Administra√ß√£o |   98765432168 |
| Brito, Jorge E.    | 88866555576 | 10-11-1937 | Rua do Horto, 35, S√£o Paulo, SP         |         1 | Matriz        |   88866555576 |

## Redund√¢ncia

## Redund√¢ncia

| FUNC_PROJ   | FUNC_PROJ   | FUNC_PROJ   | FUNC_PROJ          | FUNC_PROJ       | FUNC_PROJ   |
|-------------|-------------|-------------|--------------------|-----------------|-------------|
| Cpf         | Projnumero  | Horas       | Fnome              | Projnome        | Projlocal   |
| 12345678966 | 1           | 32,5        | Silva, Jo√£o B.     | ProdutoX        | Santo Andr√© |
| 12345678966 | 2           | 7,5         | Silva, Jo√£o B.     | ProdutoY        | Itu         |
| 66688444476 | 3           | 40,0        | Lima, Ronaldo K.   | ProdutoZ        | S√£o Paulo   |
| 45345345376 | 1           | 20,0        | Leite, Joice A.    | ProdutoX        | Santo Andr√© |
| 45345345376 | 2           | 20,0        | Leite, Joice A.    | ProdutoY        | Itu         |
| 33344555587 | 2           | 10,0        | Wong, Fernando T.  | ProdutoY        | Itu         |
| 33344555587 | 3           | 10,0        | Wong, Fernando T.  | ProdutoZ        | S√£o Paulo   |
| 33344555587 | 10          | 10,0        | Wong, Fernando T.  | Informatiza√ß√£o  | Mau√°        |
| 33344555587 | 20          | 10,0        | Wong, Fernando T.  | Reorganiza√ß√£o   | S√£o Paulo   |
| 99988777767 | 30          | 30,0        | Zelaya, Alice J.   | Novosbenef√≠cios | Mau√°        |
| 99988777767 | 10          | 10,0        | Zelaya, Alice J.   | Informatiza√ß√£o  | Mau√°        |
| 98798798733 | 10          | 35,0        | Pereira, Andr√© V.  | Informatiza√ß√£o  | Mau√°        |
| 98798798733 | 30          | 5,0         | Pereira, Andr√© V.  | Novosbenef√≠cios | Mau√°        |
| 98765432168 | 30          | 20,0        | Souza, Jennifer S. | Novosbenef√≠cios | Mau√°        |
| 98765432168 | 20          | 15,0        | Souza, Jennifer S. | Reorganiza√ß√£o   | S√£o Paulo   |
| 88866555576 | 20          | Null        | Brito, Jorge E.    | Reorganiza√ß√£o   | S√£o Paulo   |

Figura 15.4

Exemplos de estados para FUNC\_DEP e FUNC\_PROJ resultando na aplica√ß√£o da JUN√á√ÉO NATURAL √†s rela√ß√µes da Figura 15.2. Estas podem ser armazenadas como rela√ß√µes da base por quest√µes de desempenho.

Anomalias de exclus√£o. O problema das anomalias de exclus√£o est√° relacionado √† segunda situa√ß√£o de anomalia de inser√ß√£o que acabamos de discutir. Se excluirmos de FUNC\_DEP uma tupla de funcion√°rio que represente o √∫ltimo funcion√°rio trabalhando para determinado departamento, a informa√ß√£o referente a esse departamento se perde do banco de dados. Esse problema n√£o ocorre no banco de dados da Figura 15.2, pois as tuplas de DEPARTAMENTO s√£o armazenadas separadamente.

departamento - digamos, o gerente do departamento 5 -, temos de atualizar as tuplas de todos os funcion√°rios que trabalham nesse departamento; caso contr√°rio, o banco de dados ficar√° incoerente. Se deixarmos de atualizar algumas tuplas, o mesmo departamento mostrar√° dois valores diferentes para o gerente em diferentes tuplas de funcion√°rio, o que seria errado. 3

Anomalias de modifica√ß√£o. Em FUNC\_DEP , se mudarmos o valor de um dos atributos de determinado

√â f√°cil ver que essas tr√™s anomalias s√£o indesej√°veis e causam dificuldades para manter a coer√™ncia dos dados, bem como exigem atualiza√ß√µes desnecess√°rias que podem ser evitadas; logo, podemos declarar a pr√≥xima diretriz como se segue.

3 Este n√£o √© t√£o s√©rio quanto os outros problemas, pois todas as tuplas podem ser atualizadas por uma √∫nica consulta SQL.

## Diretriz 2

Projete os esquemas de rela√ß√£o da base de modo que  nenhuma  anomalia  de  inser√ß√£o,  exclus√£o  ou modifica√ß√£o esteja presente nas rela√ß√µes. Se houver alguma anomalia, 4  anote-as claramente e cuide para que os programas que atualizam o banco de dados operem corretamente.

A  segunda  diretriz  √©  coerente  com  e,  de  certa  forma,  √©  uma  reafirma√ß√£o  da  primeira  diretriz. Tamb√©m podemos ver a necessidade de uma t√©cnica mais formal para avaliar se um projeto atende a essas diretrizes. As se√ß√µes 15.2 a 15.4 oferecem esses conceitos formais necess√°rios. √â importante observar  que  essas  diretrizes  √†s  vezes podem ter de ser violadas a fim de melhorar o desempenho de certas consultas. Se FUNC\_DEP for usado como uma rela√ß√£o  armazenada (conhecida de outra forma como uma vis√£o materializada ) al√©m das rela√ß√µes da base de FUNCIONARIO e DEPARTAMENTO , as anomalias em FUNC\_DEP precisam ser observadas e consideradas (por exemplo, usando triggers ou procedimentos  armazenados que fariam atualiza√ß√µes autom√°ticas). Desse modo, sempre que a rela√ß√£o da base √© atualizada, n√£o ficamos com incoer√™ncias. Em geral, √© aconselh√°vel usar rela√ß√µes da base sem anomalias e especificar vis√µes que incluem as jun√ß√µes para reunir  os  atributos  frequentemente  referenciados  nas consultas importantes.

## 15.1.3 Valores NULL nas tuplas

Em alguns projetos de esquema, podemos agrupar muitos atributos em uma rela√ß√£o 'gorda'. Se muitos dos atributos n√£o se aplicarem a todas as tuplas na rela√ß√£o, acabamos com muitos NULL s nessas tuplas. Isso pode desperdi√ßar espa√ßo no n√≠vel de armazenamento e tamb√©m ocasionar problemas com o conhecimento do significado dos atributos e com a especifica√ß√£o de opera√ß√µes JUN√á√ÉO no n√≠vel l√≥gico. 5 Outro problema com NULL s √© como consider√°-los quando opera√ß√µes de agrega√ß√£o como CONTA ou SOMA s√£o aplicadas. Opera√ß√µes SELE√á√ÉO e JUN√á√ÉO envolvem compara√ß√µes;  se  valores NULL estiverem  presentes, os resultados podem se tornar imprevis√≠veis. 6  Al√©m do mais, os NULL s podem ter v√°rias interpreta√ß√µes, como as seguintes:

- ¬Ñ O  valor  do  atributo  para  essa  tupla  √© desconhecido .  Por  exemplo,  a Data\_nascimento pode ser desconhecida para um funcion√°rio.
- ¬Ñ O valor  √© conhecido,  mas  ausente ;  ou  seja, ele ainda n√£o foi registrado. Por exemplo, o Numero\_telefone\_residencial para  um  funcion√°rio pode existir, mas ainda n√£o estar dispon√≠vel e registrado.

Ter a mesma representa√ß√£o para todos os NULL s compromete os diferentes  significados  que  eles  podem ter. Portanto, podemos declarar outra diretriz.

## Diretriz 3

Ao m√°ximo poss√≠vel, evite colocar atributos em uma rela√ß√£o da base cujos valores podem ser NULL com frequ√™ncia. Se os NULL s  forem inevit√°veis, garanta que eles se apliquem apenas em casos excepcionais, e n√£o √† maioria das tuplas na rela√ß√£o.

Usar o espa√ßo de modo eficaz e evitar jun√ß√µes com valores NULL s√£o os dois crit√©rios priorit√°rios que determinam a inclus√£o das colunas que podem ter NULL s em uma rela√ß√£o ou que podem ter uma rela√ß√£o separada para essas colunas (com as colunas de chave apropriadas). Por exemplo, se apenas 15 por cento  dos  funcion√°rios  t√™m  escrit√≥rios  individuais, h√° pouca justificativa para incluir um atributo Nume-ro\_escritorio na rela√ß√£o FUNCIONARIO . Em vez disso, uma rela√ß√£o FUNC\_ESCRITORIO (Fcpf, Numero\_escri-torio ) pode ser criada para incluir tuplas apenas para funcion√°rios com escrit√≥rios individuais.

## 15.1.4 Gera√ß√£o de tuplas falsas

- ¬Ñ O  atributo n√£o  se  aplica a  essa  tupla.  Por exemplo, Estado\_visto pode n√£o se aplicar a alunos do Brasil.

Considere os esquemas de duas rela√ß√µes FUNC\_ LOCAL  FUNC\_PROJ1 e da Figura 15.5(a), que podem ser usados no lugar da √∫nica rela√ß√£o FUNC\_PROJ da Figura 15.3(b). Uma tupla em FUNC\_LOCAL significa que o funcion√°rio cujo nome √© Fnome trabalha em algum  projeto cujo  local  √© Projlocal. Uma  tupla em FUNC\_PROJ1 refere-se ao fato de o funcion√°rio cujo n√∫mero de Cadastro de Pessoa F√≠sica √© Cpf trabalhar Horas por semana no projeto cujo nome, n√∫mero e localiza√ß√£o s√£o Projnome, Projnumero e Projlocal. A Figura 15.5(b) mostra os estados da rela√ß√£o de FUNC\_LOCAL e FUNC\_PROJ1 correspondentes √† rela√ß√£o FUNC\_PROJ da Figura 15.4, que s√£o obtidos aplicando as opera√ß√µes PROJETO ( œÄ ) apropriadas a FUNC\_PROJ (ignore as linhas tracejadas na Figura 15.5(b) por enquanto).

4 Outras considera√ß√µes de aplica√ß√£o podem determinar e tornar certas anomalias inevit√°veis. Por exemplo, a rela√ß√£o FUNC\_DEP pode corresponder a uma consulta ou a um relat√≥rio que √© exigido com frequ√™ncia.

5 Isso porque as jun√ß√µes interna e externa produzem diferentes resultados quando NULLs s√£o envolvidos nas jun√ß√µes. Assim, os usu√°rios precisam estar cientes dos diferentes significados dos v√°rios tipos de jun√ß√µes. Embora isso seja razo√°vel para usu√°rios sofisticados, pode ser dif√≠cil para outros.

6 Na Se√ß√£o 5.5.1, apresentamos compara√ß√µes envolvendo valores NULL onde o resultado (na l√≥gica de tr√™s valores) √© TRUE, FALSE e UNKNOWN.

## (a) FUNC\_LOCAL



(b)

## FUNC\_PROJ1

Cpf

ChP

(c)

## FUNC\_LOCAL

| Fnome              | Projlocal   |
|--------------------|-------------|
| Silva, Jo√£o B.     | Santo Andr√© |
| Silva, Jo√£o B.     | Itu         |
| Lima, Ronaldo K.   | S√£o Paulo   |
| Leite, Joice A.    | Santo Andr√© |
| Leite, Joice A.    | Itu         |
| Wong, Fernando T.  | Itu         |
| Wong, Fernando T.  | S√£o Paulo   |
| Wong, Fernando T.  | Mau√°        |
| Zelaya, Alice J.   | Mau√°        |
| Pereira, Andr√© V.  | Mau√°        |
| Souza, Jennifer S. | Mau√°        |
| Souza, Jennifer S. | S√£o Paulo   |
| Brito, Jorge E.    | S√£o Paulo   |

Horas

Projnome

Projlocal

## FUNC\_PROJ1

|         Cpf |   Projnumero | Horas   | Projnome         | Projlocalizacao   |
|-------------|--------------|---------|------------------|-------------------|
| 12345678966 |            1 | 32,5    | ProdutoX         | Santo Andr√©       |
| 12345678966 |            2 | 7,5     | ProdutoY         | Itu               |
| 66688444476 |            3 | 40,0    | ProdutoZ         | S√£o Paulo         |
| 45345345376 |            1 | 20,0    | ProdutoX         | Santo Andr√©       |
| 45345345376 |            2 | 20,0    | ProdutoY         | Itu               |
| 33344555587 |            2 | 10,0    | ProdutoY         | Itu               |
| 33344555587 |            3 | 10,0    | ProdutoZ         | S√£o Paulo         |
| 33344555587 |           10 | 10,0    | Computadoriza√ß√£o | Mau√°              |
| 33344555587 |           20 | 10,0    | Reorganiza√ß√£o    | S√£o Paulo         |
| 99988777767 |           30 | 30,0    | Novosbenef√≠cios  | Mau√°              |
| 99988777767 |           10 | 10,0    | Computadoriza√ß√£o | Mau√°              |
| 98765432168 |           10 | 35,0    | Computadoriza√ß√£o | Mau√°              |
| 98765432168 |           30 | 5,0     | Novosbenef√≠cios  | Mau√°              |
| 98765432168 |           30 | 20,0    | Novosbenef√≠cios  | Mau√°              |
| 98798798733 |           20 | 15,0    | Reorganiza√ß√£o    | S√£o Paulo         |
| 88866555576 |           20 | NULL    | Reorganiza√ß√£o    | S√£o Paulo         |

## Figura 15.5

Projeto particularmente fraco para a rela√ß√£o FUNC\_PROJ da Figura 15.3(b). (a) Esquemas de duas rela√ß√µes FUNC\_LOCAL e FUNC\_PROJ1. (b) Resultado da proje√ß√£o da extens√£o de FUNC\_PROJ da Figura 15.4 para as rela√ß√µes FUNC\_LOCAL e FUNC\_ PROJ1.

Suponha que usamos FUNC\_PROJ1 e FUNC\_LO-CAL como rela√ß√µes da base em vez de FUNC\_PROJ. Isso produz um projeto de esquema particularmente ruim, pois n√£o podemos recuperar a informa√ß√£o que havia originalmente em FUNC\_PROJ de FUNC\_PROJ1 e FUNC\_LOCAL. Se tentarmos uma opera√ß√£o JUN√á√ÉO NATURAL sobre FUNC\_PROJ1 e FUNC\_LOCAL, o  resultado produz muito mais tuplas do que o conjunto original de tuplas em FUNC\_PROJ. Na Figura 15.6, mostramos o resultado da aplica√ß√£o da jun√ß√£o apenas √†s tuplas acima das linhas tracejadas da Figura 15.5(b) (para reduzir o tamanho da rela√ß√£o resultante). Tuplas adicionais, que n√£o estavam em FUNC\_PROJ , s√£o chamadas de tuplas falsas , pois representam informa√ß√£o falsa, que n√£o √© v√°lida. As tuplas falsas s√£o marcadas com asteriscos ( √© ) na Figura 15.6.

A decomposi√ß√£o de FUNC\_PROJ em FUNC\_LO-CAL e FUNC\_PROJ1 √© indesej√°vel porque, quando as juntamos ( JUN√á√ÉO )  de  volta  usando JUN√á√ÉO NATURAL, n√£o obtemos a informa√ß√£o original correta. Isso porque, neste caso, Projlocal √© o atributo que relaciona FUNC\_LOCAL e FUNC\_PROJ1, e Projlocal n√£o √©  a  chave  prim√°ria  nem  uma  chave  estrangeira  em FUNC\_LOCAL ou FUNC\_PROJ1. Agora podemos declarar informalmente outra diretriz de projeto.

## Diretriz 4

Projete esquemas de rela√ß√£o de modo que possam ser unidos com condi√ß√µes de igualdade sobre os atributos  que  s√£o  pares  relacionados  corretamente (chave prim√°ria, chave estrangeira) de um modo que garanta  que  nenhuma  tupla  falsa  ser√°  gerada.  Evi-

Projnumero

| Cpf          |   Projnumero | Horas   | Projnome         | Projlocal   | Fnome             |
|--------------|--------------|---------|------------------|-------------|-------------------|
| 12345678966  |            1 | 32,5    | ProdutoX         | Santo Andr√© | Silva, Jo√£o B.    |
| *12345678966 |            1 | 32,5    | ProdutoX         | Santo Andr√© | Leite, Joice A.   |
| 12345678966  |            2 | 7,5     | ProdutoY         | Itu         | Silva, Jo√£o B.    |
| *12345678966 |            2 | 7,5     | ProdutoY         | Itu         | Leite, Joice A.   |
| *12345678966 |            2 | 7,5     | ProdutoY         | Itu         | Wong, Fernando T. |
| 66688444476  |            3 | 40,0    | ProdutoZ         | S√£o Paulo   | Lima, Ronaldo K.  |
| *66688444476 |            3 | 40,0    | ProdutoZ         | S√£o Paulo   | Wong, Fernando T. |
| *45345345376 |            1 | 20,0    | ProdutoX         | Santo Andr√© | Silva, Jo√£o B.    |
| 45345345376  |            1 | 20,0    | ProdutoX         | Santo Andr√© | Leite, Joice A.   |
| *45345345376 |            2 | 20,0    | ProdutoY         | Itu         | Silva, Jo√£o B.    |
| 45345345376  |            2 | 20,0    | ProdutoY         | Itu         | Leite, Joice A.   |
| *45345345376 |            2 | 20,0    | ProdutoY         | Itu         | Wong, Fernando T. |
| *33344555587 |            2 | 10,0    | ProdutoY         | Itu         | Silva, Jo√£o B.    |
| *33344555587 |            2 | 10,0    | ProdutoY         | Itu         | Leite, Joice A.   |
| 33344555587  |            2 | 10,0    | ProdutoY         | Itu         | Wong, Fernando T. |
| *33344555587 |            3 | 10,0    | ProdutoZ         | S√£o Paulo   | Lima, Ronaldo K.  |
| 33344555587  |            3 | 10,0    | ProdutoZ         | S√£o Paulo   | Wong, Fernando T. |
| 33344555587  |           10 | 10,0    | Computadoriza√ß√£o | Mau√°        | Wong, Fernando T. |
| *33344555587 |           20 | 10,0    | Reorganiza√ß√£o    | S√£o Paulo   | Lima, Ronaldo K.  |
| 33344555587  |           20 | 10,0    | Reorganiza√ß√£o    | S√£o Paulo   | Wong, Fernando T. |

*

*

*

## Figura 15.6

Resultado da aplica√ß√£o do NATURAL JOIN √†s tuplas acima das linhas tracejadas em FUNC\_PROJ1 e FUNC\_LOCAL da Figura 15.5. As tuplas falsas geradas s√£o marcadas com asteriscos.

te  rela√ß√µes  com  atributos  correspondentes  que  n√£o sejam combina√ß√µes (chave estrangeira, chave prim√°ria), pois a jun√ß√£o sobre tais atributos pode produzir tuplas falsas.

- de  informa√ß√£o  durante  a  exclus√£o  de  uma rela√ß√£o.

Essa  diretriz  informal,  obviamente,  precisa  ser declarada de maneira mais formal. Na Se√ß√£o 16.2, discutiremos uma condi√ß√£o formal chamada propriedade de jun√ß√£o n√£o aditiva (ou sem perda), que garante que certas jun√ß√µes n√£o produzam tuplas falsas.

## 15.1.5 Resumo e discuss√£o das diretrizes de projeto

Nas  se√ß√µes  15.1.1  a  15.1.4,  discutimos  informalmente situa√ß√µes que levam a esquemas de rela√ß√£o problem√°ticas e propusemos diretrizes informais para um bom projeto relacional. Os problemas que apontamos, que podem ser detectados sem ferramentas de an√°lise adicionais, s√£o os seguintes:

- ¬Ñ Anomalias que causam trabalho redundante durante a inser√ß√£o e modifica√ß√£o em uma rela√ß√£o, e que podem causar perda acidental
- ¬Ñ Desperd√≠cio de espa√ßo de armazenamento devido a NULL s e a dificuldade de realizar sele√ß√µes,  opera√ß√µes  de  agrega√ß√£o  e  jun√ß√µes  por causa de valores NULL.
- ¬Ñ Gera√ß√£o de dados inv√°lidos e falsos durante as jun√ß√µes em rela√ß√µes da base com atributos correspondentes que possam n√£o representar um relacionamento apropriado (chave estrangeira, chave prim√°ria).

No  restante  deste  cap√≠tulo,  apresentamos  os conceitos formais e a teoria que pode ser usada para definir os pontos positivos e negativos dos esquemas de rela√ß√£o individuais com mais precis√£o. Primeiro, discutimos a depend√™ncia funcional como uma ferramenta para an√°lise. Depois, especificamos as tr√™s formas normais e a Forma Normal de Boyce-Codd (FNBC) para esquemas de rela√ß√£o. A estrat√©gia para alcan√ßar  um  bom  projeto  √©  decompor  de  maneira correta uma rela√ß√£o mal projetada. Tamb√©m intro-

duzimos rapidamente formas normais adicionais que lidam com depend√™ncias adicionais. No Cap√≠tulo 16, discutimos  as  propriedades  da  decomposi√ß√£o  com detalhes, e oferecemos algoritmos que projetam rela√ß√µes de baixo para cima, usando as depend√™ncias funcionais como ponto de partida.

## 15.2 Depend√™ncias funcionais

At√© aqui, lidamos com as medidas informais do projeto de banco de dados. Agora, vamos introduzir uma ferramenta formal para a an√°lise de esquemas relacionais, que nos permite detectar e descrever alguns dos  problemas  mencionados  em  termos  precisos.  O conceito isolado mais importante na teoria de projeto de esquema relacional √© o de uma depend√™ncia funcional. Nesta se√ß√£o, definimos formalmente o conceito e, na Se√ß√£o 15.3, veremos como ele pode ser usado para definir formas normais para esquemas de rela√ß√£o.

## 15.2.1 Defini√ß√£o de depend√™ncia funcional

Uma depend√™ncia funcional √© uma restri√ß√£o entre dois conjuntos de atributos do banco de dados. Suponha que nosso esquema de banco de dados relacional tenha n atributos A 1 , A 2 , ..., A n . Vamos pensar no banco de dados inteiro sendo descrito por um √∫nico esquema de rela√ß√£o universal R = { A 1 , A 2 , ... , A n }. 7 N√£o queremos dizer que realmente armazenaremos o banco de dados como uma √∫nica tabela universal usamos esse conceito apenas no desenvolvimento da teoria formal das depend√™ncias de dados. 8

Defini√ß√£o. Uma depend√™ncia funcional , indicada por X ‚Üí Y , entre dois conjuntos de atributos X e Y que s√£o subconjuntos de R, especifica uma restri√ß√£o sobre poss√≠veis tuplas que podem formar um estado de rela√ß√£o r de R .  A  restri√ß√£o √©  que,  para  quaisquer  duas  tuplas t 1 e t 2 em r que tenham t 1 [ X ] = t 2 [ X ],  elas  tamb√©m devem ter t 1 [ Y ] = t 2 [ Y ].

Isso significa que os valores do componente Y de uma tupla em   dependem dos (ou s√£o r determinados pelos )  valores do componente X ;  como alternativa, os valores do componente X de uma tupla determinam exclusivamente (ou funcionalmente ) os valores do componente Y . Tamb√©m dizemos que existe uma depend√™ncia funcional de X para Y , ou que Y √© funcionalmente dependente de X .  A abrevia√ß√£o para a depend√™ncia funcional √© DF ou d.f. O  conjunto de atributos X √© chamado de lado esquerdo da DF, e Y √© chamado de lado direito .

Assim, a funcionalidade X determina Y em um esquema de rela√ß√£o R se, e somente se, sempre que duas tuplas de r R ( ) combinarem sobre seu valor X , elas devem necessariamente combinar sobre seu valor Y . Observe o seguinte:

- ¬Ñ Se  uma  restri√ß√£o  sobre R declarar  que  n√£o pode haver mais de uma tupla com determinado valor X em qualquer inst√¢ncia de rela√ß√£o r R ( )  -  ou  seja, X √©  uma chave  candidata de R -, isso implica que X ‚Üí Y para qualquer  subconjunto  de  atributos Y de R (porque a restri√ß√£o de chave implica que duas tuplas em qualquer estado v√°lido  ( r R ) n√£o ter√£o o mesmo valor de X ). Se X for uma chave candidata de R , ent√£o X ‚Üí R .
- ¬Ñ Se X ‚Üí Y em R , isso n√£o quer dizer que Y ‚Üí X em R .

Uma depend√™ncia funcional √© uma propriedade da sem√¢ntica ou significado dos atributos . Os projetistas de banco de dados usar√£o seu conhecimento da sem√¢ntica dos atributos de R - ou seja, como eles se relacionam entre si - para especificar as depend√™ncias funcionais que devem ser mantidas em todos os estados de rela√ß√£o (extens√µes) r de R .  Toda vez que a sem√¢ntica de dois conjuntos de atributos em R indicar  que  uma  depend√™ncia  funcional  deve  ser mantida, especificamos a depend√™ncia como uma restri√ß√£o. As extens√µes de rela√ß√£o  ( r R ) que satisfazem as restri√ß√µes de depend√™ncia funcional s√£o chamadas de estados  de  rela√ß√£o  v√°lidos (ou extens√µes  v√°lidas ) de R . Logo, o uso principal das depend√™ncias funcionais √© para descrever melhor um esquema de rela√ß√£o R ao especificar restri√ß√µes sobre seus atributos que devem ser mantidas o tempo todo . Certas DFs podem ser  especificadas  sem  que  se  refiram  a  uma  rela√ß√£o espec√≠fica,  mas  como  uma  propriedade  desses  atributos,  dado  seu  significado  comumente  entendido. Por exemplo, { Estado, Num\_habilitacao} ‚Üí Cpf deve ser  mantido  para  qualquer  adulto  no  Brasil  e,  por isso, ser mantido sempre que esses atributos aparecerem em uma rela√ß√£o. Tamb√©m √© poss√≠vel que certas depend√™ncias funcionais possam deixar de existir  no  mundo real se o relacionamento mudar. Por exemplo, a DF Cep ‚Üí Codigo\_area costumava existir como um relacionamento entre os c√≥digos postais e os c√≥digos de √°rea de telefone no Brasil, mas, com a prolifera√ß√£o dos c√≥digos de √°rea telef√¥nicos, isso n√£o √© mais verdadeiro.

Considere o esquema de rela√ß√£o FUNC\_PROJ da Figura 15.3(b). Pela sem√¢ntica dos atributos e da re-

7 Esse conceito de uma rela√ß√£o universal ser√° importante quando discutirmos os algoritmos para o projeto de banco de dados relacional no Cap√≠tulo 16.

8 Esta suposi√ß√£o implica que cada atributo no banco de dados tenha um nome distinto. No Cap√≠tulo 3, iniciamos os nomes de atributo com nomes de rela√ß√£o, para obter exclusividade sempre que os atributos em rela√ß√µes distintas tinham o mesmo nome.

la√ß√£o, sabemos que as seguintes depend√™ncias funcionais devem ser mantidas:

- a. Cpf ‚Üí Fnome
- b. Projnumero ‚Üí {Projnome, Projlocal}
- c. {Cpf, Projnumero} ‚Üí Horas

Essas depend√™ncias funcionais especificam que (a) o valor do n√∫mero do Cadastro de Pessoa F√≠sica ( Cpf) de  um funcion√°rio determina exclusivamente o nome do funcion√°rio ( Fnome ), (b) o valor do n√∫mero de um projeto ( Projnumero ) determina exclusivamente o nome do projeto ( Projnome ) e seu local ( Projlocal ) e (c) uma combina√ß√£o de valores de Cpf e Projnumero determina exclusivamente o n√∫mero de horas que o funcion√°rio costuma trabalhar no projeto por semana ( Horas ). Como alternativa, dizemos que Fnome √© determinado de maneira funcional por (ou  dependente  funcionalmente  de) Cpf, ou dado um valor de Cpf, sabemos o valor de Fnome , e assim por diante.

Uma depend√™ncia funcional √© uma propriedade do esquema de rela√ß√£o R ,  e  n√£o  um  estado  de rela√ß√£o  v√°lido  e  espec√≠fico r de R .  Portanto,  uma DF n√£o  pode ser  deduzida  automaticamente  por determinada  extens√£o  de  rela√ß√£o r ,  mas  deve  ser definida  de  maneira  expl√≠cita  por  algu√©m  que  conhece  a  sem√¢ntica  dos  atributos  de R .  Por  exemplo, a Figura 15.7 mostra um estado em particular do esquema de rela√ß√£o ENSINA . Embora √† primeira vista possamos pensar que Texto ‚Üí Disciplina, n√£o podemos confirmar isso a menos que saibamos que √© verdadeiro para todos os estados legais poss√≠veis de ENSINA . √â, no entanto, suficiente demonstrar um √∫nico contraexemplo para refutar uma depend√™ncia funcional. Por exemplo, como 'Silva' leciona tanto 'Estruturas de Dados' e 'Gerenciamento de Dados', podemos  concluir  que  o Professor n√£o determina funcionalmente a Disciplina .

Dada uma rela√ß√£o preenchida, n√£o se podem determinar quais DFs s√£o mantidas e quais n√£o s√£o, a

## ENSINA

| Professor   | Disciplina             | Texto    |
|-------------|------------------------|----------|
| Silva       | Estruturas de Dados    | Bartram  |
| Silva       | Gerenciamento de Dados | Martin   |
| Neto        | Compiladores           | Hoffman  |
| Braga       | Estruturas de Dados    | Horowitz |

## Figura 15.7

Um estado de rela√ß√£o de ENSINA com uma poss√≠vel depend√™ncia funcional TEXTO ‚Üí DISCIPLINA. Por√©m, PROFESSOR ‚Üí DISCIPLINA est√° exclu√≠da.

Figura 15.8

| A   | B   | C   | D   |
|-----|-----|-----|-----|
| a1  | b1  | c1  | d1  |
| a1  | b2  | c2  | d2  |
| a2  | b2  | c2  | d3  |
| a3  | b3  | c4  | d3  |

Uma rela√ß√£o R (A, B, C, D) com sua extens√£o.

menos que o significado e os relacionamentos entre os atributos sejam conhecidos. Tudo o que se pode dizer √© que certa DF pode existir se for mantida nessa extens√£o em particular. N√£o se pode garantir sua exist√™ncia at√© que o significado dos atributos correspondentes  seja  claramente  compreendido.  Por√©m, pode-se afirmar de modo enf√°tico que certa DF n√£o se mant√©m se houver tuplas que mostrem a viola√ß√£o de tal DF. Veja a rela√ß√£o de exemplo ilustrativa na Figura 15.8. Nela, as DFs a seguir podem ser mantidas porque as quatro tuplas na extens√£o atual n√£o t√™m viola√ß√£o dessas restri√ß√µes: B ‚Üí C C ; ‚Üí B ; { A, B } ‚Üí C ; { A, B } ‚Üí D ; e { C, D } ‚Üí B. No entanto, as seguintes n√£o se mant√™m porque j√° temos viola√ß√µes delas na extens√£o dada: A ‚Üí B (tuplas 1 e 2 violam essa restri√ß√£o); B ‚Üí A (tuplas 2 e 3 violam essa restri√ß√£o); D ‚Üí C (tuplas 3 e 4 a violam).

A  Figura  15.3  apresenta  uma nota√ß√£o  diagram√°tica para exibir DFs: cada DF aparece como uma linha horizontal. Os atributos do lado esquerdo da DF s√£o conectados por linhas verticais √† linha que representa a DF, enquanto os atributos do lado direito s√£o conectados pelas linhas com setas que apontam para os atributos.

Indicamos  com F o  conjunto  de  depend√™ncias funcionais que s√£o especificadas no esquema de rela√ß√£o R . Em geral, o projetista do esquema especifica as depend√™ncias funcionais que s√£o semanticamente √≥bvias . Por√©m, diversas outras depend√™ncias funcionais  se  mant√™m  em todas as  inst√¢ncias  de  rela√ß√£o v√°lidas entre conjuntos de atributos que podem ser derivados das (e satisfazem as) depend√™ncias em F . Essas outras depend√™ncias podem ser deduzidas das DFs em F .  Adiaremos os detalhes das regras de infer√™ncia e propriedades das depend√™ncias funcionais para o Cap√≠tulo 16.

## 15.3 ormas normais baseadas em F chaves prim√°rias

Ap√≥s  introduzir as depend√™ncias  funcionais, agora estamos prontos para us√°-las na especifica√ß√£o de alguns aspectos da sem√¢ntica dos esquemas de rela√ß√£o. Consideramos que um conjunto de depend√™ncias funcionais √© dado para cada rela√ß√£o, e que cada

rela√ß√£o tem uma chave prim√°ria designada. Essa informa√ß√£o combinada com os testes (condi√ß√µes) para formas normais controla o processo de normaliza√ß√£o para o projeto do esquema relacional. A maioria dos projetos  relacionais  pr√°ticos  assume  uma  das  duas t√©cnicas a seguir:

- ¬Ñ Realiza  um  projeto  de  esquema  conceitual usando um modelo conceitual como ER ou EER e mapeia o projeto conceitual para um conjunto de rela√ß√µes.
- ¬Ñ Projeta as rela√ß√µes com base no conhecimento externo derivado de uma implementa√ß√£o existente de arquivos, formul√°rios ou relat√≥rios.

Ao seguir uma dessas t√©cnicas, √© √∫til  avaliar  a virtude de rela√ß√µes e decomp√¥-las ainda mais, conforme a necessidade, para obter formas normais mais altas, usando a teoria de normaliza√ß√£o apresentada neste  cap√≠tulo  e  no  seguinte.  Nesta  se√ß√£o,  focalizamos as tr√™s primeiras formas normais para esquemas de rela√ß√£o e a intui√ß√£o por tr√°s delas, e discutimos como elas foram desenvolvidas historicamente. Defini√ß√µes mais gerais dessas formas normais, que levam em  conta  todas  as  chaves  candidatas  de  uma  rela√ß√£o,  em vez de apenas a chave prim√°ria, s√£o adiadas para a Se√ß√£o 15.4.

Come√ßamos  discutindo  informalmente  as  formas normais e a motiva√ß√£o por tr√°s de seu desenvolvimento, bem como revisando algumas defini√ß√µes do Cap√≠tulo 3, que s√£o necess√°rias aqui. Depois, discutimos a primeira forma normal (1FN) na Se√ß√£o 15.3.4, e apresentamos as defini√ß√µes da segunda forma normal (2FN) e terceira forma normal (3FN), que s√£o baseadas  em  chaves  prim√°rias,  nas  se√ß√µes  15.3.5  e 15.3.6, respectivamente.

## 15.3.1 Normaliza√ß√£o de rela√ß√µes

O processo  de  normaliza√ß√£o,  proposto  inicialmente por Codd (1972a), leva um esquema de rela√ß√£o por uma s√©rie de testes para certificar se ele satisfaz certa forma normal . O processo, que prossegue em um padr√£o de cima para baixo, avaliando cada rela√ß√£o em compara√ß√£o com os crit√©rios para as formas normais e decompondo as rela√ß√µes conforme a necessidade, pode assim ser considerado projeto relacional por an√°lise . Inicialmente, Codd prop√¥s tr√™s formas normais, que ele chamou de primeira, segunda e terceira forma normal. Uma defini√ß√£o mais forte da 3FN - chamada Forma Normal Boyce-Codd (FNBC) - foi proposta posteriormente por Boyce e Codd.  Todas  essas  formas  normais  est√£o  baseadas em uma √∫nica ferramenta anal√≠tica: as depend√™ncias funcionais entre os atributos de uma rela√ß√£o. Depois, uma quarta forma normal (4FN) e uma quinta forma normal (5FN) foram propostas, com base nos conceitos  de  depend√™ncias multivaloradas e depend√™ncias de jun√ß√£o, respectivamente: estas ser√£o discutidas rapidamente nas se√ß√µes 15.6 e 15.7.

A normaliza√ß√£o de dados pode ser considerada um processo de analisar os esquemas de rela√ß√£o dados com base em suas DFs e chaves prim√°rias para conseguir as propriedades desejadas de (1) minimiza√ß√£o da redund√¢ncia e (2) minimiza√ß√£o das anomalias de inser√ß√£o, exclus√£o e atualiza√ß√£o discutidas na Se√ß√£o 15.1.2. Esse pode ser considerado um processo  de  'filtragem'  ou  'purifica√ß√£o'  para  fazer que o projeto tenha uma qualidade cada vez melhor. Esquemas de rela√ß√£o insatisfat√≥rios, que n√£o atendem a certas condi√ß√µes - os testes de forma normal -, s√£o decompostos em esquemas de rela√ß√£o menores, que atendem aos testes e, portanto, possuem as propriedades desej√°veis. Assim, o procedimento de normaliza√ß√£o oferece aos projetistas de banco de dados o seguinte:

- ¬Ñ Uma estrutura formal para analisar esquemas de rela√ß√£o com base em suas chaves e nas depend√™ncias funcionais entre seus atributos.
- ¬Ñ Uma s√©rie de testes de forma normal que podem ser executados em esquemas de rela√ß√£o individuais, de modo que o banco de dados relacional possa ser normalizado para qualquer grau desejado.

Defini√ß√£o. A forma normal de uma rela√ß√£o refere-se √† condi√ß√£o de forma normal mais alta a que ela atende e, portanto, indica o grau ao qual ela foi normalizada.

As formas normais, quando consideradas isoladamente de  outros  fatores,  n√£o  garantem  um  bom projeto de banco de dados. Em geral, n√£o √© suficiente verificar em separado se cada esquema de rela√ß√£o no banco de dados est√°, digamos, na FNBC ou 3FN. Em vez disso, o processo de normaliza√ß√£o pela decomposi√ß√£o  tamb√©m  precisa  confirmar  a  exist√™ncia  de propriedades adicionais que os esquemas relacionais, tomados juntos, devem possuir. Estas incluiriam duas propriedades:

A propriedade de jun√ß√£o n√£o aditiva ou jun√ß√£o sem perdas , que garante que o problema de gera√ß√£o de tuplas falsas, discutido na Se√ß√£o 15.1.4, n√£o ocorra com rela√ß√£o aos esquemas de rela√ß√£o criados ap√≥s a decomposi√ß√£o.

- ¬Ñ A propriedade de preserva√ß√£o de depend√™ncia ,  que  garante  que  cada  depend√™ncia  funcional  seja  representada  em  alguma  rela√ß√£o individual resultante ap√≥s a decomposi√ß√£o.

- ¬Ñ A propriedade de jun√ß√£o n√£o aditiva √© extremamente cr√≠tica e deve ser alcan√ßada a todo custo , ao passo que a propriedade de preserva√ß√£o  de  depend√™ncia,  embora  desej√°vel,  √†s vezes √© sacrificada, conforme discutiremos na Se√ß√£o 16.1.2. Adiaremos a apresenta√ß√£o dos conceitos e t√©cnicas formais que garantem as duas propriedades citadas para o Cap√≠tulo 16.

## 15.3.2 Uso pr√°tico das formas normais

A maioria dos projetos pr√°ticos adquire projetos existentes de bancos de dados anteriores, projetos em modelos legados ou de arquivos existentes. A normaliza√ß√£o √© executada na pr√°tica, de modo que os projetos  resultantes  sejam  de  alta  qualidade  e  atendam √†s  propriedades  desej√°veis  indicadas  anteriormente. Embora v√°rias formas normais mais altas tenham sido definidas, como a 4FN e a 5FN, que discutiremos nas se√ß√µes 15.6 e 15.7, a utilidade pr√°tica dessas formas normais  torna-se  question√°vel  quando  as  restri√ß√µes sobre as quais elas est√£o baseadas s√£o raras, e dif√≠ceis de entender ou detectar pelos projetistas e usu√°rios de banco de dados que precisam descobrir essas restri√ß√µes. Assim, o projeto de banco de dados praticado na ind√∫stria hoje presta aten√ß√£o particular √† normaliza√ß√£o apenas at√© a 3FN, FNBC ou, no m√°ximo, 4FN.

Outro  ponto  que  merece  ser  observado  √©  que os projetistas de banco de dados n√£o precisam normalizar para a forma normal mais alta poss√≠vel. As rela√ß√µes podem ser deixadas em um estado de normaliza√ß√£o inferior, como 2FN, por quest√µes de desempenho, como aquelas discutidas ao final da Se√ß√£o 15.1.2. Fazer isso gera as penalidades correspondentes de lidar com as anomalias.

Defini√ß√£o. Desnormaliza√ß√£o √©  o  processo  de  armazenar a jun√ß√£o de rela√ß√µes na forma normal mais alta como uma rela√ß√£o da base, que est√° em uma forma normal mais baixa.

## 15.3.3 Defini√ß√µes de chaves e atributos participantes em chaves

Antes de prosseguirmos, vejamos novamente as defini√ß√µes de chaves de um esquema de rela√ß√£o, do Cap√≠tulo 3.

Defini√ß√£o. Uma superchave de um esquema de rela√ß√£o R = { A 1 , A 2 , ... , A n } √© um conjunto de atributos S ‚äÜ R com a propriedade de que duas tuplas t 1 e t 2 em qualquer estado de rela√ß√£o v√°lido   de r R n√£o ter√£o t 1 [ S ] = t 2 [ S ]. Uma chave Ch √© uma superchave com a propriedade adicional de que a remo√ß√£o de qualquer atributo de Ch far√° que Ch n√£o seja mais uma superchave.

A diferen√ßa entre uma chave e uma superchave √© que a primeira precisa ser m√≠nima ;  ou  seja,  se  tivermos uma chave Ch = { A 1 , A 2 , ..., A k } de R , ent√£o Ch -{ A i } n√£o √© uma chave de R para qualquer A i , 1 ‚â§ i ‚â§ k . Na Figura 15.1, { Cpf } √© uma chave para FUNCIONARIO, enquanto  { Cpf },  { Cpf,  Fnome },  { Cpf, Fnome, Datanasc }  e  qualquer conjunto de atributos que inclua Cpf s√£o todos superchaves.

Se um esquema de rela√ß√£o tiver mais de uma chave,  cada  uma  √©  chamada  de chave  candidata .  Uma das  chaves  candidatas  √© arbitrariamente designada para ser a chave prim√°ria , e as outras s√£o chamadas de chaves secund√°rias. Em um banco de dados relacional  pr√°tico,  cada  esquema  de  rela√ß√£o  precisa  ter uma chave prim√°ria. Se nenhuma chave candidata for conhecida para uma rela√ß√£o, a rela√ß√£o inteira pode ser tratada como uma superchave padr√£o. Na Figura 15.1, { Cpf } √© a √∫nica chave candidata para FUNCIONARIO, de modo que tamb√©m √© a chave prim√°ria.

Defini√ß√£o. Um atributo do esquema de rela√ß√£o R √© chamado de atributo principal de R se  ele  for  um membro de alguma chave candidata de R .  Um atributo  √©  chamado n√£o  principal se  n√£o  for um atributo principal - ou seja, se n√£o for um membro de qualquer chave candidata.

Na Figura 15.1, tanto Cpf quanto Projnumero s√£o atributos principais de TRABALHA\_EM, ao passo que outros atributos de TRABALHA\_EM s√£o n√£o principais.

Agora, vamos apresentar as tr√™s primeiras formas normais: 1FN, 2FN e 3FN. Elas foram propostas por Codd (1972a) como uma sequ√™ncia para conseguir o estado desej√°vel de rela√ß√µes 3FN ao prosseguir pelos estados intermedi√°rios de 1FN e 2FN, se necess√°rio. Conforme  veremos,  2FN  e  3FN  atacam  diferentes problemas.  Contudo,  por  motivos  hist√≥ricos,  √©  comum segui-los nessa sequ√™ncia. Logo, por defini√ß√£o, uma rela√ß√£o 3FN j√° satisfaz a 2FN.

## 15.3.4 Primeira forma normal

A primeira forma normal (1FN) agora √© considerada parte da defini√ß√£o formal de uma rela√ß√£o no modelo relacional b√°sico (plano). Historicamente, ela foi definida para reprovar atributos multivalorados, atributos compostos e suas combina√ß√µes. Ela afirma que o dom√≠nio de um atributo deve incluir apenas valores at√¥micos (simples, indivis√≠veis) e que o valor de qualquer atributo em uma tupla deve ser um √∫nico valor do dom√≠nio desse atributo. Logo, 1FN reprova ter um conjunto de valores, uma tupla de valores ou uma combina√ß√£o de ambos como um valor de atributo para uma √∫nica tupla . Em outras palavras, a 1FN reprova rela√ß√µes dentro de rela√ß√µes ou rela√ß√µes como

valores de atributo dentro de tuplas .  Os √∫nicos valores de atributo permitidos pela 1FN s√£o os valores at√¥micos (ou indivis√≠veis ).

Considere o esquema de rela√ß√£o DEPARTAMENTO da Figura 15.1, cuja chave prim√°ria √© Dnumero, e suponha que a estendamos ao incluir o atributo Dlocal , conforme  mostra  a  Figura  15.9(a).  Supomos  que cada departamento pode ter certo n√∫mero de locais. O esquema DEPARTAMENTO e um exemplo de estado de rela√ß√£o s√£o mostrados na Figura 15.9. Como podemos ver, esta n√£o est√° em 1FN porque Dlocal n√£o √© um atributo at√¥mico, conforme ilustrado pela primeira tupla na Figura 15.9(b). Existem duas maneiras poss√≠veis para examinar o atributo Dlocal :

- ¬Ñ O dom√≠nio de Dlocal cont√©m valores at√¥micos, mas algumas tuplas podem ter um conjunto desses valores. Nesse caso, Dlocal n√£o √© funcionalmente dependente da chave prim√°ria Dnumero .

## (a) DEPARTAMENTO



## (b) DEPARTAMENTO

| Dnome         |   Dnumero |   Cpf_gerente | Dlocal                      |
|---------------|-----------|---------------|-----------------------------|
| Pesquisa      |         5 |   33344555587 | Santo Andr√©, Itu, S√£o Paulo |
| Administra√ß√£o |         4 |   98765432168 | Mau√°                        |
| Matriz        |         1 |   88866555576 | S√£o Paulo                   |

## (c) DEPARTAMENTO

| Dnome         |   Dnumero |   Cpf_gerente | Dlocal      |
|---------------|-----------|---------------|-------------|
| Pesquisa      |         5 |   33344555587 | Santo Andr√© |
| Pesquisa      |         5 |   33344555587 | Itu         |
| Pesquisa      |         5 |   33344555587 | S√£o Paulo   |
| Administra√ß√£o |         4 |   98765432168 | Mau√°        |
| Matriz        |         1 |   88866555576 | S√£o Paulo   |

## Figura 15.9

Normaliza√ß√£o na 1FN. (a) Um esquema de rela√ß√£o que n√£o est√° em 1FN. (b) Exemplo de estado da rela√ß√£o DEPARTAMENTO. (c) Vers√£o 1FN da mesma rela√ß√£o com redund√¢ncia.

- ¬Ñ O dom√≠nio de Dlocal cont√©m conjuntos de valores e, portanto, √© n√£o at√¥mico. Nesse caso, Dnumero ‚Üí Dlocal , pois cada conjunto √© considerado  um  √∫nico  membro  do  dom√≠nio  de atributo. 9

De qualquer forma, a rela√ß√£o DEPARTAMENTO da  Figura  15.9  n√£o  est√°  na  1FN;  de  fato,  ela  nem sequer se qualifica como uma rela√ß√£o, de acordo com nossa defini√ß√£o na Se√ß√£o 3.1. Existem tr√™s t√©cnicas principais  para  conseguir  a  primeira  forma  normal para tal rela√ß√£o:

- 1. Remover o atributo Dlocal que viola a 1FN e coloc√°-lo em uma rela√ß√£o separada LOCA-LIZACAO\_DEP ,  junto  com  a  chave  prim√°ria Dnumero de DEPARTAMENTO .  A  chave  prim√°ria dessa rela√ß√£o √© a combina√ß√£o { Dnumero, Dlocal }, como mostra a Figura 15.2. Existe uma  tupla  distinta  em LOCALIZACAO\_DEP para cada local de um departamento. Isso decomp√µe a rela√ß√£o n√£o 1FN em duas rela√ß√µes 1FN.
- 2. Expandir a chave de modo que haver√° uma tupla  separada  na  rela√ß√£o  original DEPARTAMENTO para cada local de um DEPARTAMENTO , como mostra a Figura 15.9(c). Nesse caso, a chave prim√°ria torna-se a combina√ß√£o { Dnumero, Dlocal }. Essa solu√ß√£o tem a desvantagem  de  introduzir  a redund√¢ncia na  rela√ß√£o.
- 3. Se  o n√∫mero  m√°ximo  de  valores for  conhecido  para  o  atributo  -  por  exemplo,  se  for conhecido que no m√°ximo tr√™s locais poder√£o existir para um departamento -, substituir o atributo Dlocal pelos tr√™s atributos at√¥micos: Dlocal1, Dlocal2 e Dlocal3. Essa solu√ß√£o tem a desvantagem de introduzir valores NULL se a maioria dos departamentos tiver menos de tr√™s locais. Ela ainda introduz uma falsa sem√¢ntica sobre a ordena√ß√£o entre os valores de local,  que n√£o era intencionado originalmente. A consulta sobre esse atributo torna-se mais dif√≠cil. Por exemplo, considere como voc√™ escreveria  a  consulta: Listar  os  departamentos que t√™m 'Santo Andr√©' como um de seus locais nesse projeto.

Das  tr√™s  solu√ß√µes  anteriores,  a  primeira  geralmente √© considerada a melhor, pois n√£o sofre de redund√¢ncia  e  √©  completamente  gen√©rica,  n√£o  tendo limite imposto sobre o n√∫mero m√°ximo de valores. De fato, se escolhermos a segunda solu√ß√£o, ela ser√°

9 Nesse caso, podemos considerar o dom√≠nio de Dlocalizacoes como sendo o conjunto de pot√™ncia do conjunto de locais isolados; ou seja, o dom√≠nio √© composto por todos os subconjuntos poss√≠veis do conjunto de locais isolados.

decomposta ainda mais durante as etapas de normaliza√ß√£o subsequentes para a primeira solu√ß√£o.

A  primeira  forma  normal  tamb√©m  desaprova atributos  multivalorados  que  por  si  s√≥  sejam  compostos.  Estes  s√£o  chamados  de rela√ß√µes  aninhadas , pois  cada  tupla  pode  ter  uma  rela√ß√£o dentro  dela . A Figura 15.10 mostra como a rela√ß√£o FUNC\_PROJ poderia  aparecer  se  o  aninhamento  for  permitido. Cada tupla representa uma entidade de funcion√°rio, e a rela√ß√£o PROJS(Projnumero, Horas) dentro de cada

(a)

| FUNC_PROJ   | FUNC_PROJ   | Projs      | Projs   |
|-------------|-------------|------------|---------|
| Cpf         | Fnome       | Projnumero | Horas   |

## (b) FUNC\_PROJ

| Cpf         | Fnome              |   Projnumero | Horas   |
|-------------|--------------------|--------------|---------|
| 12345678966 | Silva, Jo√£o B.     |            1 | 32,5    |
|             |                    |            2 | 7,5     |
| 66688444476 | Lima, Ronaldo K.   |            3 | 40,0    |
| 45345345376 | Leite, Joice A.    |            1 | 20,0    |
|             |                    |            2 | 20,0    |
| 33344555587 | Wong, Fernando T.  |            2 | 10,0    |
|             |                    |            3 | 10,0    |
|             |                    |           10 | 10,0    |
|             |                    |           20 | 10,0    |
| 99988777767 | Zelaya, Alice J.   |           30 | 30,0    |
|             |                    |           10 | 10,0    |
| 98798798733 | Pereira, Andr√© V.  |           10 | 35,0    |
|             |                    |           30 | 5,0     |
| 98765432168 | Souza, Jennifer S. |           30 | 20,0    |
|             |                    |           20 | 15,0    |
| 88866555576 | Brito, Jorge E.    |           20 | NULL    |

(c)

## FUNC\_PROJ1

## FUNC\_PROJ2

Cpf

Projnumero

Horas

## Figura 15.10

Normalizando rela√ß√µes aninhadas para a 1FN. (a) Esquema da rela√ß√£o FUNC\_PROJ com um atributo de rela√ß√£o aninhada PROJS. (b) Exemplo de extens√£o da rela√ß√£o FUNC\_PROJ mostrando rela√ß√µes aninhadas dentro de cada tupla. (c) Decomposi√ß√£o de FUNC\_PROJ nas rela√ß√µes FUNC\_PROJ1 e FUNC\_PROJ2 pela propaga√ß√£o da chave prim√°ria.

tupla representa os projetos do funcion√°rio e o n√∫mero de horas por semana que ele trabalha em cada projeto. O esquema dessa rela√ß√£o FUNC\_PROJ pode ser representado da seguinte forma:

## FUNC\_PROJ(Cpf, Fnome, {PROJS(Projnumero, Horas)})

O conjunto  de  chaves  {  }  identifica  o  atributo PROJS como multivalorado, e listamos os atributos componentes que formam o PROJS entre par√™nteses ( ). O interessante √© que as tend√™ncias recentes para dar suporte a objetos complexos (ver Cap√≠tulo 11) e  dados  XML  (ver  Cap√≠tulo  12)  tentam  permitir  e formalizar  as  rela√ß√µes  aninhadas  nos  sistemas  de bancos  de  dados  relacionais,  que  eram  reprovadas inicialmente pela 1FN.

Observe que Cpf √© a chave prim√°ria da rela√ß√£o FUNC\_PROJ nas  figuras  15.10(a)  e  (b),  enquanto Projnumero √© a chave parcial da rela√ß√£o aninhada; ou seja, dentro de cada tupla, a rela√ß√£o aninhada precisa ter valores √∫nicos de Projnumero. Para normalizar isso para a 1FN, removemos os atributos da rela√ß√£o aninhada  para  uma  nova  rela√ß√£o  e propagamos  a chave prim√°ria para ela. A chave prim√°ria da nova rela√ß√£o combinar√° a parcial com a chave prim√°ria da rela√ß√£o original. A decomposi√ß√£o e a propaga√ß√£o da chave prim√°ria resultam nos esquemas FUNC\_PROJ1 e FUNC\_PROJ2 , como mostra a Figura 15.10(c).

Esse procedimento pode ser aplicado recursivamente a uma rela√ß√£o com aninhamento em n√≠vel m√∫ltiplo para desaninhar a rela√ß√£o para um conjunto de rela√ß√µes 1FN. Isso √© √∫til na convers√£o de um esquema de rela√ß√£o n√£o normalizado com muitos n√≠veis de aninhamento em rela√ß√µes 1FN. A exist√™ncia de mais de um atributo multivalorado em uma rela√ß√£o deve ser tratada com cuidado. Como um exemplo, considere a seguinte rela√ß√£o n√£o 1FN:

## PESSOA (Cpf, {Placa}, {Telefone})

Essa rela√ß√£o representa o fato de uma pessoa ter v√°rios carros e v√°rios telefones. Se a estrat√©gia 2 acima for seguida, ela resulta em uma rela√ß√£o com todas as chaves:

## PESSOA\_NA\_1FN (Cpf, Placa, Telefone)

Para evitar a introdu√ß√£o de qualquer relacionamento estranho entre Placa e Telefone, todas as combina√ß√µes de valores poss√≠veis s√£o representadas para cada Cpf, fazendo  surgir  a  redund√¢ncia.  Isso  leva aos  problemas  tratados  pelas  depend√™ncias  multivaloradas e 4FN, que discutiremos na Se√ß√£o 15.6. O modo certo de lidar com os dois atributos multivalorados  em PESSOA mostrados  anteriormente √© decomp√¥-los em duas rela√ß√µes separadas, usando

a estrat√©gia 1 j√° discutida: P1(Cpf, Placa) e P2(Cpf, Telefone) .

## 15.3.5 Segunda forma normal

A segunda  forma  normal ( 2FN )  √©  baseada  no conceito de depend√™ncia funcional total . Uma depend√™ncia funcional X ‚Üí Y √© uma depend√™ncia funcional total se a remo√ß√£o de qualquer atributo A de X significar que a depend√™ncia n√£o se mant√©m mais; ou seja,  para  qualquer atributo A Œµ X ,  ( X -{ A }) n√£o determina Y funcionalmente. Uma depend√™ncia funcional X ‚Üí Y √©  uma depend√™ncia parcial se  algum atributo A Œµ X puder ser removido de X e a depend√™ncia ainda se mantiver; ou seja, para algum A Œµ X , ( X -{ A }) ‚Üí Y . Na Figura 15.3(b), { Cpf, Projnumero } ‚Üí Horas √© uma depend√™ncia total (nem Cpf ‚Üí Horas nem Projnumero ‚Üí Horas se mant√™m). Contudo, a depend√™ncia { Cpf, Projnumero } ‚Üí Fnome √© parcial porque Cpf ‚Üí Fnome se mant√©m.

Defini√ß√£o. Um esquema de rela√ß√£o R est√°  em 2FN se cada atributo n√£o principal A em R for total e funcionalmente dependente da chave prim√°ria de R .

O teste para a 2FN envolve testar as depend√™ncias  funcionais  cujos  atributos  do  lado  esquerdo fazem parte da chave prim√°ria. Se a chave prim√°ria tiver um √∫nico atributo, o teste n√£o precisa ser aplicado. A rela√ß√£o FUNC\_PROJ na Figura 15.3(b) est√° na 1FN, mas n√£o est√° na 2FN. O atributo n√£o principal Fnome viola a 2FN por causa da DF2 , assim  como  os  atributos  n√£o  principais Projnome e Projlocal ,  por  causa  da DF3 .  As  depend√™ncias  funcionais DF2 e DF3 tornam Fnome, Projnome e Projlocal parcialmente  dependentes  da  chave  prim√°ria { Cpf, Projnumero } de FUNC\_PROJ, violando, assim, o teste da 2FN.

Se um esquema de rela√ß√£o n√£o estiver na 2FN, ele  pode  ser segundo normalizado ou normalizado pela 2FN para uma s√©rie de rela√ß√µes 2FN em que os atributos n√£o principais s√£o associados com a parte da chave prim√°ria em que eles s√£o total e funcionalmente dependentes. Portanto, as depend√™ncias funcionais DF1, DF2 e DF3 da  Figura  15.3(b)  levam  √† decomposi√ß√£o de FUNC\_PROJ nos tr√™s esquemas de rela√ß√£o FP1, FP2 e FP3 mostrados na Figura 15.11(a), cada qual estando na 2FN.

## 15.3.6 Terceira forma normal

A terceira  forma  normal ( 3FN )  √©  baseada  no conceito de depend√™ncia transitiva. Uma depend√™n- cia funcional X ‚Üí Y em um esquema de rela√ß√£o R √© uma depend√™ncia transitiva se  houver um conjunto de atributos Z em R que nem sejam uma chave candidata  nem  um  subconjunto  de  qualquer  chave  de R , 10 e  tanto X ‚Üí Z quanto Z ‚Üí Y se  mantiverem. A  depend√™ncia Cpf ‚Üí Cpf\_gerente √©  transitiva  por meio de Dnumero em FUNC\_DEP na Figura 15.3(a), pois ambas as depend√™ncias Cpf ‚Üí Dnumero e Dnumero ‚Üí Cpf\_gerente se mant√™m e Dnumero n√£o √© nem uma chave por si s√≥ nem um subconjunto da chave de FUNC\_DEP. Intuitivamente,  podemos  ver  que  a depend√™ncia de Cpf\_gerente sobre Dnumero √© indesej√°vel em FUNC\_DEP , pois Dnumero n√£o √© uma chave de FUNC\_DEP .

Defini√ß√£o. De acordo com a defini√ß√£o original de Codd, um esquema de rela√ß√£o R est√° na 3FN se  ele  satisfizer  a  2FN e nenhum  atributo  n√£o principal  de R for  transitivamente  dependente da chave prim√°ria.

O  esquema  de  rela√ß√£o FUNC\_DEP da  Figura 15.3(a)  est√°  na  2FN,  pois  n√£o  existe  depend√™ncia parcial  sobre  uma  chave.  Por√©m, FUNC\_DEP n√£o est√°  na  3FN  devido  √†  depend√™ncia  transitiva  de Cpf\_gerente (e  tamb√©m Dnome )  em Cpf por  meio de Dnumero .  Podemos  normalizar FUNC\_DEP decompondo-o nos dois esquemas de rela√ß√£o 3FN DF1 e DF2 mostrados na Figura 15.11(b). Intuitivamente, vemos que DF1 e DF2 representam fatos de entidades  independentes  sobre  funcion√°rios  e  departamentos. Uma opera√ß√£o JUN√á√ÉO NATURAL sobre DF1 e DF2 recuperar√° a rela√ß√£o original FUNC\_DEP sem gerar tuplas falsas.

De maneira intuitiva, podemos ver que qualquer depend√™ncia  funcional  de  que  o  lado  esquerdo  faz parte (√© um subconjunto apropriado) da chave prim√°ria, ou qualquer depend√™ncia funcional de que o lado esquerdo √© um atributo n√£o chave, √© uma DF problem√°tica .  A  normaliza√ß√£o  2FN  e  3FN  remove essas DFs problem√°ticas ao decompor a rela√ß√£o original em novas rela√ß√µes. Em rela√ß√£o ao processo de normaliza√ß√£o,  n√£o  √©  necess√°rio  remover  as  depend√™ncias parciais antes das depend√™ncias transitivas, por√©m, historicamente, a 3FN tem sido definida com a suposi√ß√£o de que uma rela√ß√£o √© testada primeiro pela 2FN, antes de ser testada pela 3FN. A Tabela 15.1 resume informalmente as tr√™s formas normais com base nas chaves prim√°rias, os testes usados em cada uma e a solu√ß√£o ou normaliza√ß√£o realizada para alcan√ßar a forma normal.

10 Essa √© a defini√ß√£o geral de depend√™ncia transitiva. Como estamos preocupados apenas com as chaves prim√°rias nesta se√ß√£o, permitimos depend√™ncias transitivas onde X √© a chave prim√°ria, mas Z pode ser (um subconjunto de) uma chave candidata.

(a)

FUNC\_PROJ

Figura 15.11



Normalizando para 2FN e 3FN. (a) Normalizando FUNC\_PROJ em rela√ß√µes 2FN. (b) Normalizando FUNC\_DEP em rela√ß√µes 3FN.

Tabela 15.1

Resumo das formas normais baseadas em chaves prim√°rias e a normaliza√ß√£o correspondente.

| Forma normal   | Teste                                                                                                                                                                                                                                             | Solu√ß√£o (normaliza√ß√£o)                                                                                                                                                                                                                      |
|----------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Primeira (1FN) | Rela√ß√£o n√£o deve ter atributos multivalorados ou rela√ß√µes aninhadas.                                                                                                                                                                              | Formar novas rela√ß√µes para cada atributo multivalorado ou rela√ß√£o aninhada.                                                                                                                                                                 |
| Segunda (2FN)  | Para rela√ß√µes em que a chave prim√°ria cont√©m m√∫ltiplos atributos, nenhum atributo n√£o chave dever√° ser funcionalmente dependente de uma parte da chave prim√°ria.                                                                                  | Decompor e montar uma nova rela√ß√£o para cada chave parcial com seu(s) atributo(s) dependente(s). Certificar-se de manter uma rela√ß√£o com a chave prim√°ria original e quaisquer atributos que sejam total e funcionalmente dependentes dela. |
| Terceira (3FN) | A rela√ß√£o n√£o deve ter um atributo n√£o chave determinado funcionalmente por outro atributo n√£o chave (ou por um conjunto de atributos n√£o chave). Ou seja, n√£o deve haver depend√™ncia transitiva de um atributo n√£o chave sobre a chave prim√°ria. | Decompor e montar uma rela√ß√£o que inclua o(s) atributo(s) n√£o chave que determina(m) funcionalmente outro(s) atributo(s) n√£o chave.                                                                                                         |

## 15.4 Defini√ß√µes gerais da segunda e terceira formas normais

Em geral,  queremos  projetar  nossos  esquemas de rela√ß√£o de modo que n√£o tenham depend√™ncias parciais nem transitivas, pois esses tipos de depend√™ncias causam as anomalias de atualiza√ß√£o discutidas na Se√ß√£o 15.1.2. As etapas para normaliza√ß√£o para rela√ß√µes 3FN que discutimos at√© aqui desaprovam  depend√™ncias  parciais  e  transitivas  na chave

prim√°ria . O procedimento de normaliza√ß√£o descrito √© √∫til para an√°lise em situa√ß√µes pr√°ticas para determinado banco de dados, no qual as chaves prim√°rias j√° foram definidas. Essas defini√ß√µes, entretanto, n√£o levam  em  conta  outras  chaves  candidatas  de  uma rela√ß√£o, se houver. Nesta se√ß√£o, mostramos as defini√ß√µes mais gerais da 2FN e da 3FN que levam em conta todas as  chaves  candidatas  de  uma  rela√ß√£o. Observe que isso n√£o afeta a defini√ß√£o da 1FN, pois ela independe das chaves e depend√™ncias funcionais. Como uma defini√ß√£o geral de atributo principal , um atributo que faz parte de qualquer chave candidata ser√° considerado principal. Depend√™ncias funcionais parciais e totais e depend√™ncias transitivas agora ser√£o consideradas com rela√ß√£o a todas as chaves candidatas de uma rela√ß√£o.

## 15.4.1 Defini√ß√£o geral da segunda forma normal

Defini√ß√£o. Um esquema de rela√ß√£o R est√°  na segunda  forma  normal ( 2FN )  se  cada  atributo n√£o principal A em R n√£o for parcialmente dependente de qualquer chave de R . 11

O teste para 2FN envolve avaliar as depend√™ncias funcionais cujos atributos do lado esquerdo fa√ßam parte  da chave  prim√°ria.  Se  a  chave  prim√°ria contiver um √∫nico atributo, o teste n√£o precisa ser aplicado.  Considere  o  esquema  de  rela√ß√£o LOTES mostrado na Figura 15.12(a), que descreve lotes de terreno √† venda em diversas cidades de um estado. Suponha que existam duas chaves candidatas: Pro-priedade\_num e  { Nome\_cidade, Num\_lote} ;  ou  seja, n√∫meros de lote s√£o √∫nicos apenas dentro de cada cidade,  mas  n√∫meros  de Id\_propriedade s√£o  √∫nicos entre as cidades do estado inteiro.

Com base nas duas chaves candidatas Proprieda-de\_num e { Nome\_cidade, Num\_lote }, as depend√™ncias funcionais DF1 e DF2 da Figura 15.12(a) se mant√™m. Escolhemos Propriedade\_num como a chave prim√°ria, por isso ela est√° sublinhada na Figura 15.12(a), mas nenhuma considera√ß√£o especial ser√° feita a essa chave sobre a outra chave candidata. Suponha que as duas outras depend√™ncias funcionais se mantenham em LOTES:

```
DF3: Nome_cidade ‚Üí Imposto DF4: Area ‚Üí Preco
```

Em palavras, a depend√™ncia DF3 diz que Imposto √© fixo para determinada cidade (n√£o varia de lote para lote na mesma cidade), enquanto DF4 diz que o pre√ßo de um lote √© determinado por sua √°rea, independentemente da cidade em que esteja. (Suponha que esse seja o pre√ßo do lote para fins de imposto.)

O esquema de rela√ß√£o LOTES viola a defini√ß√£o geral da 2FN porque Imposto √© parcialmente dependente da chave candidata { Nome\_cidade, Num\_lote }, por causa da DF3. Para normalizar LOTES na 2FN, decomponha-o nas duas rela√ß√µes LOTES1 e LOTES2 , mostradas na Figura 15.12(b). Constru√≠mos LOTES1 ao remover o atributo Imposto que viola a 2FN de LOTES e colocando-o com Nome\_cidade (o lado esquerdo da DF3 que causa a depend√™ncia parcial) em outra  rela√ß√£o LOTES2. Tanto LOTES1 quanto LOTES2 est√£o na 2FN. Observe que a DF4 n√£o viola a 2FN e √© transportada para LOTES1 .

## 15.4.2 Defini√ß√£o geral da terceira forma normal

Defini√ß√£o. Um esquema de rela√ß√£o R est√°  na terceira forma normal se toda vez que uma depend√™ncia funcional n√£o trivial X ‚Üí A se mantiver em R , ou (a) X for uma superchave de R ou (b) A for um atributo principal de R .

De  acordo  com  essa  defini√ß√£o, LOTES2 (Figura 15.12(b)) est√° na 3FN. No entanto, DF4 em LOTES1 viola a 3FN, pois Area n√£o √© uma superchave e Preco n√£o √© um atributo principal em LOTES1. Para normalizar LOTES1 para a 3FN, n√≥s a decompomos nos esquemas de rela√ß√£o LOTES1A e LOTES1B mostrados na Figura 15.12(c). Constru√≠mos LOTES1A removendo o atributo Preco que viola a 3FN de LOTES1 e colocando-o com Area (o lado esquerdo de DF4 que causa a depend√™ncia  transitiva)  em  outra  rela√ß√£o LOTES1B . Tanto LOTES1A quanto LOTES1B est√£o na 3FN.

Dois pontos precisam ser observados sobre esse exemplo e a defini√ß√£o geral da 3FN:

- ¬Ñ LOTES1 viola a 3FN porque Preco √© transitivamente dependente em cada uma das chaves candidatas de LOTES1 por meio do atributo n√£o principal Area.
- ¬Ñ Essa  defini√ß√£o  geral  pode  ser  aplicada diretamente para testar se um esquema de rela√ß√£o est√° na 3FN (este n√£o precisa passar pela 2FN primeiro). Se aplicarmos a defini√ß√£o da 3FN dada a LOTES com as depend√™ncias de DF1 a DF4, descobriremos que ambas violam a 3FN. Portanto, poder√≠amos decompor LOTES em LOTES1A, LOTES1B e LOTES2 diretamente. Logo, as depend√™ncias transitiva e

11 Essa defini√ß√£o pode ser reformulada da seguinte forma: um esquema de rela√ß√£o R est√° na 2FN se cada atributo n√£o principal A em R for total e funcionalmente dependente de cada chave de R .

Figura 15.12



Normaliza√ß√£o para 2FN e 3FN. (a) A rela√ß√£o LOTES com suas depend√™ncias funcionais de DF1 a DF4. (b) Decompondo para as rela√ß√µes 2FN LOTES1 e LOTES2. (c) Decompondo LOTES1 para as rela√ß√µes 3FN LOTES1A e LOTES1B. (d) Resumo da normaliza√ß√£o progressiva de LOTES.

parcial que violam a 3FN podem ser removidas em qualquer ordem .

n√£o principal. Aqui, temos uma depend√™ncia parcial que viola a 3FN (e tamb√©m a 2FN).

## 15.4.3 nterpretando a defini√ß√£o geral da I terceira forma normal

Um esquema de rela√ß√£o R viola a defini√ß√£o geral da 3FN se uma depend√™ncia funcional X ‚Üí A, que se mant√©m em R , n√£o atender a qualquer condi√ß√£o significando que ela viola ambas as  condi√ß√µes (a) e (b) da 3FN. Isso pode ocorrer devido a dois tipos de depend√™ncias funcionais problem√°ticas:

- ¬Ñ Um atributo  n√£o  principal  determina  outro atributo n√£o principal. Aqui, em geral, temos uma depend√™ncia transitiva que viola a 3FN.
- ¬Ñ Um subconjunto  apropriado  de  uma  chave de R determina funcionalmente um atributo

Portanto, podemos indicar uma defini√ß√£o alternativa geral da 3FN da seguinte forma:

Defini√ß√£o alternativa. Um esquema de rela√ß√£o R est√° na 3FN se cada atributo n√£o principal de R atender √†s duas condi√ß√µes a seguir:

- ¬Ñ Ele  √©  total  e  funcionalmente  dependente  de cada chave de R .
- ¬Ñ Ele √© dependente n√£o transitivamente de cada chave de R .

## 15.5 orma Normal de Boyce-Codd F

A Forma Normal Boyce-Codd ( FNBC ) foi proposta como uma forma mais simples da 3FN, mas descobriu-se que ela era mais rigorosa. Ou seja, cada rela√ß√£o

em FNBC tamb√©m est√° na 3FN. Por√©m, uma rela√ß√£o na 3FN n√£o necessariamente est√° na FNBC. Intuitivamente,  podemos ver a necessidade de uma forma normal mais forte que a 3FN ao voltar ao esquema de rela√ß√£o LOTES da Figura 15.12(a) com suas quatro depend√™ncias funcionais, de DF1 a DF4. Suponha que tenhamos milhares de lotes na rela√ß√£o, mas que eles sejam de apenas duas cidades: Ribeir√£o Preto e Anal√¢ndia. Suponha tamb√©m que os tamanhos de lote em Ribeir√£o Preto sejam de apenas 0,5, 0,6, 0,7, 0,8, 0,9 e 1,0 hectare, enquanto os tamanhos de lote em Anal√¢ndia sejam restritos a 1,1, 1,2, ..., 1,9 e 2,0 hectares. Em tal situa√ß√£o, ter√≠amos a depend√™ncia funcional adicional DF5: Area ‚Üí Nome\_cidade. Se  acrescentamos isso √†s outras depend√™ncias, o esquema de rela√ß√£o LOTES1A ainda estar√° na 3FN, pois Nome\_cidade √© um atributo principal.

A √°rea de um lote que determina a cidade, conforme especificada pela DF5, pode ser representada por 16 tuplas em uma rela√ß√£o separada R ( Area, Nome\_cidade) ,  pois  existem  apenas  16  valores  de Area poss√≠veis  (ver  Figura  15.13).  Essa  representa√ß√£o  diminui  a  redund√¢ncia  de  repetir  a  mesma informa√ß√£o  em  milhares  de  tuplas LOTES1A . A FNBC √© uma forma normal mais forte , que reprovaria LOTES1A e sugeriria a necessidade de sua decomposi√ß√£o.

## (a) LOTES1A

Figura 15.13



Forma normal de Boyce-Codd. (a) Normaliza√ß√£o FNBC de LOTES1A com a depend√™ncia funcional DF2 sendo perdida na decomposi√ß√£o. (b) Uma rela√ß√£o esquem√°tica com DFs; ela est√° na 3FN, mas n√£o na FNBC.

Defini√ß√£o. Um esquema de rela√ß√£o R est√°  na FNBC se toda vez que uma depend√™ncia funcional n√£o trivial X ‚Üí A se mantiver em R , ent√£o X √© uma superchave de R .

A defini√ß√£o formal da FNBC difere da defini√ß√£o da 3FN porque a condi√ß√£o (b) da 3FN, que permite que A seja principal, est√° ausente da FNBC. Isso torna a FNBC uma forma normal mais forte em compara√ß√£o com a 3FN. Em nosso exemplo, a DF5 viola a FNBC em LOTES1A porque AREA n√£o √© uma superchave de LOTES1A. Observe que DF5 satisfaz a 3FN em LOTES1A porque Nome\_cidade √© um atributo principal (condi√ß√£o b), mas essa condi√ß√£o n√£o existe na defini√ß√£o da FNBC. Podemos decompor LOTES1A em duas  rela√ß√µes FNBC, LOTES1AX e LOTES1AY , mostradas na Figura 15.13(a). Essa decomposi√ß√£o perde a depend√™ncia funcional DF2 porque seus atributos n√£o coexistem mais na mesma rela√ß√£o ap√≥s a decomposi√ß√£o.

Na pr√°tica, a maioria dos esquemas de rela√ß√£o que est√£o na 3FN tamb√©m est√£o na FNBC. Somente se X ‚Üí A se  mantiver  em  um  esquema  de  rela√ß√£o R com X n√£o sendo uma superchave e A sendo um atributo principal √© que R estar√° na 3FN, mas n√£o na FNBC. O esquema de rela√ß√£o R mostrado na Figura 15.13(b) ilustra o caso geral de tal rela√ß√£o. O ideal √© que o projeto de banco de dados relacional lute para alcan√ßar  FNBC  ou  3FN  para  cada  esquema  de rela√ß√£o.  Obter  o status de  normaliza√ß√£o  apenas de 1FN ou 2FN n√£o √© considerado adequado, visto que  eles  foram  desenvolvidos  historicamente  como trampolins para a 3FN e a FNBC.

Como outro exemplo, considere a Figura 15.14, que mostra uma rela√ß√£o ENSINA com as seguintes depend√™ncias:

<!-- formula-not-decoded -->

DF2: 12 Professor ‚Üí Disciplina

## ENSINA

| Aluno   | Disciplina            | Professor   |
|---------|-----------------------|-------------|
| Lima    | Banco de dados        | Marcos      |
| Silva   | Banco de dados        | Navathe     |
| Silva   | Sistemas operacionais | Omar        |
| Silva   | Teoria                | Charles     |
| Souza   | Banco de dados        | Marcos      |
| Souza   | Sistemas operacionais | Antonio     |
| Wong    | Banco de dados        | Gomes       |
| Zelaya  | Banco de dados        | Navathe     |
| Lima    | Sistemas operacionais | Omar        |

Figura 15.14

Uma rela√ß√£o ENSINA que est√° na 3FN, mas n√£o na FNBC.

12 Essa depend√™ncia significa que cada professor ensina uma disciplina √© uma restri√ß√£o para essa aplica√ß√£o.



## Nota√ß√µes diagram√°ticas alternativas para modelos ER

A Figura  A.1  mostra  uma  s√©rie  de  nota√ß√µes  diagram√°ticas  diferentes  para  representar  conceitos de  modelo ER e EER. Infelizmente, n√£o existe uma nota√ß√£o-padr√£o: diferentes profissionais de projeto de banco de dados preferem nota√ß√µes distintas. De modo semelhante,  diversas  ferramentas CASE (Computer aided software engineering - engenharia de software auxiliada por computador) e metodologias de OOA (object-oriented analysis - an√°lise orientada a objeto) utilizam v√°rias nota√ß√µes. Algumas nota√ß√µes s√£o associadas a modelos que possuem conceitos e restri√ß√µes adicionais, al√©m daqueles dos modelos ER e EER descritos nos cap√≠tulos 7 a 9, enquanto outros modelos t√™m menos conceitos e restri√ß√µes. A nota√ß√£o que usamos no Cap√≠tulo 7 √© muito pr√≥xima da nota√ß√£o original para diagramas ER, que ainda √© bastante utilizada. Discutimos aqui algumas nota√ß√µes alternativas.

A  Figura  A.1(c)  mostra  v√°rias  nota√ß√µes  para representar a raz√£o de cardinalidade dos relacionamentos bin√°rios. Usamos a nota√ß√£o (i) nos cap√≠tulos 7 a 9. A nota√ß√£o (ii) - conhecida como nota√ß√£o p√© de galinha - √© muito popular. A nota√ß√£o (iv) utiliza a seta como uma refer√™ncia funcional (do N para o lado 1) e √© semelhante a nossa nota√ß√£o para chaves estrangeiras no modelo relacional (ver Figura 9.2); a nota√ß√£o (v) - usada nos diagramas de Bachman e no modelo de dados de rede - usa a seta na dire√ß√£o inversa (do 1 para o lado N). Para um relacionamento 1:1, (ii) utiliza uma linha reta sem qualquer p√© de galinha; (iii) torna as duas metades do losango brancas; e (iv) coloca pontas de seta nos dois lados. Para um relacionamento M:N, (ii) usa p√©s de galinha nas duas pontas da linha; (iii) torna as duas metades do losango escuras; e (iv) n√£o exibe qualquer ponta de seta.

A Figura A.1(a) mostra diferentes nota√ß√µes para exibir  tipos/classes  de  entidade,  atributos  e  relacionamentos. Nos cap√≠tulos 7 a 9, usamos os s√≠mbolos marcados com (i)  na  Figura  A.1(a)  -  a  saber,  ret√¢ngulo, oval e losango. Observe que o s√≠mbolo (ii) para  tipos/classes  de  entidade,  o  s√≠mbolo  (ii)  para atributos e o s√≠mbolo (ii) para relacionamentos s√£o semelhantes, mas usados por diferentes metodologias para representar tr√™s conceitos distintos. O s√≠mbolo de linha reta (iii) para representar relacionamentos √© utilizado por v√°rias ferramentas e metodologias.

A  Figura  A.1(b)  mostra  algumas  nota√ß√µes  para conectar atributos a tipos de entidade. Usamos a nota√ß√£o (i). A nota√ß√£o (ii) utiliza a terceira nota√ß√£o (iii) para atributos da Figura A.1(a). As duas √∫ltimas nota√ß√µes na Figura A.1(b) - (iii) e (iv) - s√£o populares em metodologias OOA e em algumas ferramentas CASE. Em particular, a √∫ltima nota√ß√£o mostra os atributos e os m√©todos de uma classe, separados por uma linha horizontal.

A  Figura  A.1(d)  traz  diversas  varia√ß√µes  para exibi√ß√£o (min, max) de restri√ß√µes, que s√£o utilizadas para mostrar a raz√£o de cardinalidade e a participa√ß√£o total/parcial. Usamos principalmente a nota√ß√£o (i). A nota√ß√£o (ii) √© a nota√ß√£o alternativa que empregamos na Figura 7.15 e discutimos na Se√ß√£o 7.7.4. Lembre-se de que nossa nota√ß√£o especifica a restri√ß√£o de que cada entidade precisa participar em pelo menos min e no m√°ximo max inst√¢ncias de relacionamento. Logo, para um relacionamento 1:1, os dois valores max s√£o 1; para M:N, os dois valores max s√£o n. Um valor min maior que 0 (zero) especifica participa√ß√£o  total  (depend√™ncia  de  exist√™ncia).  Em metodologias  que  utilizam  a  linha  reta  para  exibir relacionamentos, √© comum inverter o posicionamento das  restri√ß√µes  (min,  max),  como  mostramos  em (iii); uma varia√ß√£o comum em algumas ferramentas (e na nota√ß√£o UML) aparece em (v). Outra t√©cnica popular - que segue o mesmo posicionamento de



## Figura A.1

Nota√ß√µes alternativas. (a) S√≠mbolos para tipo/classe, atributo e relacionamento de entidade. (b) Exibindo atributos. (c) Exibindo raz√µes de cardinalidade. (d) Diversas nota√ß√µes (min, max). (e) Nota√ß√µes para exibir especializa√ß√£o/generaliza√ß√£o.

(iii) - √© exibir o min como o (a letra ou um c√≠rculo, que representa zero) ou como | (barra vertical, que representa 1), e exibir o max como | (barra vertical, que representa 1) ou como p√©s de galinha (que representam n), como mostramos em (iv).

A Figura A.1(e) mostra algumas nota√ß√µes para exibir especializa√ß√£o/generaliza√ß√£o. Usamos a nota√ß√£o (i) no Cap√≠tulo 8, onde um d no c√≠rculo especi- fica que as subclasses ( S1, S2 e S3 )  s√£o disjuntas e um o no c√≠rculo especifica subclasses sobrepostas. A nota√ß√£o (ii) usa G (de generaliza√ß√£o) para especificar disjun√ß√£o, e Gs para especificar sobreposi√ß√£o; algumas nota√ß√µes utilizam a seta s√≥lida, enquanto outras usam a seta vazia (mostrada acima). A nota√ß√£o (iii) utiliza um tri√¢ngulo que aponta para a superclasse, e  a  nota√ß√£o  (v),  um  tri√¢ngulo  que  aponta  para  as

subclasses; tamb√©m √© poss√≠vel usar as duas nota√ß√µes na mesma metodologia, com (iii) indicando generaliza√ß√£o e (v) indicando especializa√ß√£o. A nota√ß√£o (iv) coloca as caixas que representam subclasses dentro da caixa que representa a superclasse. Das nota√ß√µes baseadas em (vi), algumas usam uma seta de √∫nica linha, enquanto outras utilizam uma seta de linha dupla (mostrada na p√°gina anterior).

As nota√ß√µes mostradas na Figura A.1 trazem apenas alguns dos s√≠mbolos diagram√°ticos que t√™m sido usados ou sugeridos para exibir esquemas conceituais de  banco  de  dados.  Outras  nota√ß√µes,  bem  como diversas  combina√ß√µes  das  anteriores,  tamb√©m  t√™m sido  empregadas.  Seria  √∫til  estabelecer  um  padr√£o a que todos pudessem aderir, a fim de evitar mal-entendidos e reduzir a confus√£o.



## Par√¢metros de discos

O par√¢metro de disco mais importante √© o tempo exigido para localizar um bloco de disco qualquer, dado seu endere√ßo, e depois transferir o bloco entre o disco e o buffer da mem√≥ria principal. Esse √© o tempo de acesso aleat√≥rio para acessar um bloco de disco. Existem tr√™s componentes de tempo a considerar:

- 1. Tempo de busca ( s )  Esse √© o tempo necess√°-. rio para posicionar mecanicamente a cabe√ßa de leitura/grava√ß√£o na trilha correta para os discos de cabe√ßa m√≥vel. (Para os discos de cabe√ßa fixa, esse √© o tempo necess√°rio para alternar eletronicamente para a cabe√ßa de leitura/grava√ß√£o  apropriada.)  Para  discos  de cabe√ßa m√≥vel, esse tempo varia, dependendo da dist√¢ncia entre a trilha atual sob a cabe√ßa e a trilha especificada no endere√ßo do bloco. Em geral, o fabricante do disco oferece um tempo de busca m√©dio em milissegundos. A faixa t√≠pica do tempo de busca m√©dio √© de 4 a 10 ms. Esse √© o principal culpado pelo atraso envolvido na transfer√™ncia de blocos entre o disco e a mem√≥ria.
- 2. Atraso de rota√ß√£o ( ar ). Quando a cabe√ßa de leitura/grava√ß√£o est√° na trilha correta, o usu√°rio  precisa  esperar  que  o  in√≠cio  do  bloco solicitado  gire  at√©  a  posi√ß√£o  sob  a  cabe√ßa de  leitura/grava√ß√£o.  Na  m√©dia,  isso  leva  cerca de meia rota√ß√£o do disco, mas na realidade varia do acesso imediato (se o in√≠cio do bloco solicitado estiver na posi√ß√£o sob a cabe√ßa de leitura/grava√ß√£o logo ap√≥s a busca) at√© uma rota√ß√£o de disco inteira (se o in√≠cio do bloco solicitado tiver acabado de passar pela cabe√ßa de leitura/grava√ß√£o ap√≥s a busca). Se a velocidade da rota√ß√£o do disco for p rota√ß√µes

por minuto (rpm), ent√£o o atraso de rota√ß√£o m√©dio ar √© dado por

<!-- formula-not-decoded -->

Um valor t√≠pico para p √© 10.000 rpm, que gera um atraso de rota√ß√£o de ar = 3 ms. Para discos de cabe√ßa fixa, nos quais o tempo de busca √© desprez√≠vel, esse componente causa um atraso maior na transfer√™ncia de um bloco de disco.

- 3. Tempo de transfer√™ncia de bloco ( ttb ). Quando a cabe√ßa de leitura/grava√ß√£o estiver no in√≠cio do bloco solicitado, algum tempo √© necess√°rio para transferir os dados no bloco. Esse tempo de transfer√™ncia depende do tamanho do bloco, tamanho da trilha e velocidade de rota√ß√£o. Se a taxa de transfer√™ncia para o disco for tt bytes/ms e o tamanho do bloco for B bytes, ent√£o

ttb = B tt / ms

Se  tivermos  um  tamanho  de  trilha  de  50  Kbytes  e p for  3.600  rpm,  ent√£o  a  taxa  de  transfer√™ncia  em bytes/ms √©

tt =  (50 * 1.000)/(60 * 1.000/3.600)  =  3.000 bytes/ms

Nesse caso, ttb = B /3.000 ms, onde B √© o tamanho do bloco em bytes.

- O tempo m√©dio ( ) necess√°rio para encontrar e s transferir um bloco, dado seu endere√ßo de bloco, √© estimado por

( s + a  + r ttb ) ms

Isso se mant√©m para a leitura ou a grava√ß√£o de um bloco. O m√©todo principal para reduzir esse tempo √© transferir v√°rios blocos que est√£o armazenados em uma ou mais trilhas do mesmo cilindro; depois, o tempo de busca √© exigido apenas para o primeiro bloco. Para transferir consecutivamente k blocos n√£o cont√≠guos que est√£o no mesmo cilindro, precisamos de aproximadamente

<!-- formula-not-decoded -->

Nesse caso, precisamos de dois ou mais buffers no armazenamento principal, pois estamos continuamente  lendo  ou  gravando  os k blocos,  conforme discutimos no Cap√≠tulo 17. O tempo de transfer√™ncia por bloco √© reduzido ainda mais quando blocos consecutivos na mesma trilha ou cilindro s√£o transferidos. Isso elimina o atraso rotacional para todos menos o primeiro bloco, de modo que a estimativa da transfer√™ncia de k blocos consecutivos √©

<!-- formula-not-decoded -->

Uma estimativa mais precisa para transferir blocos consecutivos leva em conta a lacuna entre blocos (ver Se√ß√£o 17.2.1), que inclui a informa√ß√£o que permite que a cabe√ßa de leitura/grava√ß√£o determine qual bloco est√° para ser lido. Normalmente, o fabricante de disco oferece uma taxa de transfer√™ncia bruta ( ttbr ) que leva em conta o tamanho da lacuna ao ler blocos  armazenados  consecutivamente.  Se  o  tamanho da lacuna for de G bytes, ent√£o

<!-- formula-not-decoded -->

A taxa de transfer√™ncia bruta √© a taxa da transfer√™ncia de bytes √∫teis nos blocos de dados. A cabe√ßa de  leitura/grava√ß√£o  do  disco  precisa  passar  por  todos os bytes em uma trilha enquanto o disco gira, incluindo os bytes nas lacunas entre blocos, que armazenam informa√ß√µes de controle, mas n√£o dados reais. Quando a taxa de transfer√™ncia bruta √© usada, o tempo necess√°rio para transferir os dados √∫teis em um bloco para fora dos v√°rios blocos consecutivos √© B ttbr / .  Logo, o tempo estimado para ler k blocos armazenados  consecutivamente  no  mesmo  cilindro torna-se

<!-- formula-not-decoded -->

Outro par√¢metro dos discos √© o tempo de regrava√ß√£o . Este √© √∫til em casos em que lemos um bloco do disco para o buffer da mem√≥ria principal, atualizamos o buffer e depois gravamos o buffer de volta no mesmo bloco de disco em que ele estava armazenado. Em muitos casos, o tempo exigido para atualizar o buffer na mem√≥ria principal √© menor que o tempo exigido para uma rota√ß√£o do disco. Se soubermos que o buffer est√° pronto para regrava√ß√£o, o sistema pode manter as cabe√ßas do disco na mesma trilha e, durante a pr√≥xima rota√ß√£o do disco, o buffer atualizado √© regravado de volta para o bloco do disco. Logo, o tempo de regrava√ß√£o T rw normalmente √© estimado como sendo o tempo necess√°rio para uma rota√ß√£o do disco:

<!-- formula-not-decoded -->

Resumindo, a lista a seguir mostra os par√¢metros que discutimos e os s√≠mbolos que usamos para eles:

Tempo de busca:

s ms

Atraso de rota√ß√£o: ar ms

Tempo de transfer√™ncia de bloco:

btt ms

Tempo de regrava√ß√£o:

T rw ms

Tempo de transfer√™ncia:

tt bytes/ms

Taxa de transfer√™ncia bruta:

ttbr bytes/ms

Tamanho do bloco:

B bytes

Tamanho da lacuna entre blocos:

G bytes

Velocidade do disco:

p rpm  (rota√ß√µes por minuto)



A linguagem Query-By-Example (QBE) √© importante porque √© uma das primeiras linguagens de consulta gr√°ficas com sintaxe m√≠nima desenvolvida para sistemas de banco de dados. Ela foi desenvolvida na IBM Research e est√° dispon√≠vel como um produto comercial IBM como parte da op√ß√£o de interface QMF (Query Management Facility) para DB2. A linguagem tamb√©m foi implementada no SGBD Paradox e est√° relacionada a uma interface tipo apontar-e-clicar no SGBD Microsoft Access. Ela difere da SQL porque o usu√°rio n√£o precisa especificar explicitamente uma consulta usando uma sintaxe fixa. Em vez disso, a consulta √© formulada ao preencher modelos de rela√ß√µes que s√£o exibidos na tela de um monitor. A Figura  C.1  mostra  como  podem  ser  esses  modelos para o banco de dados da Figura 3.5. O usu√°rio n√£o precisa se lembrar dos nomes dos atributos ou das rela√ß√µes,  pois  eles  s√£o  exibidos  como  parte  desses modelos. Al√©m disso, o usu√°rio n√£o precisa seguir regras de sintaxe r√≠gidas para especifica√ß√£o de consulta; em lugar disso, constantes e vari√°veis s√£o inseridas nas colunas dos modelos para construir um exemplo relacionado √† solicita√ß√£o de recupera√ß√£o ou atualiza√ß√£o. A QBE est√° relacionada ao c√°lculo relacional do dom√≠nio, conforme veremos, e sua especifica√ß√£o original tem sido mostrada como completa do ponto de vista relacional.

## C.1 Recupera√ß√µes b√°sicas em QBE

Em QBE, as consultas de recupera√ß√£o s√£o especificadas ao preencher uma ou mais linhas nos modelos das tabelas. Para uma consulta de √∫nica rela√ß√£o, inserimos constantes ou elementos de exemplo (um termo da QBE) nas colunas do modelo dessa rela√ß√£o. Um exemplo de elemento representa uma vari√°vel de dom√≠nio e √© especificado como um valor de exem-

## Vis√£o geral da linguagem QBE

plo precedido pelo caractere de sublinhado (\_). Al√©m disso, um prefixo P. (chamado operador P ponto) √© inserido em certas colunas para indicar que gostar√≠amos de imprimir (ou exibir) valores nessas colunas para o resultado. As constantes especificam valores que devem ser combinados de maneira exata nessas colunas.

Por exemplo, considere a consulta C0: recuperar  a  data  de  nascimento  e  o  endere√ßo  de  Jo√£o  B. Silva . Nas figuras C.2(a) a C.2(d), mostramos como essa  consulta  pode  ser  especificada  em  uma  forma progressivamente mais concisa em QBE. Na Figura C.2(a), um exemplo de um funcion√°rio √© apresentado como o tipo de linha em que estamos interessados. Ao deixar Jo√£o B. Silva como constantes nas colunas Pnome, Minicial e Unome , estamos especificando uma combina√ß√£o exata nessas colunas. O restante das colunas √© precedido por um sublinhado indicando que elas  s√£o  vari√°veis  de  dom√≠nio  (elementos  de  exemplo). O prefixo P. √© colocado nas colunas Data\_nasc e Endereco para  indicar  que  gostar√≠amos  de  enviar valor(es) nessas colunas.

C0 pode  ser  abreviada  como  mostra  a  Figura C.2(b). N√£o √© preciso especificar valores de exemplo para colunas em que n√£o estamos interessados. Al√©m do  mais,  como  valores  de  exemplo  s√£o  completamente arbitr√°rios, podemos simplesmente especificar nomes de vari√°vel para eles, como mostra a Figura C.2(c).  Por  fim,  tamb√©m  podemos  omitir  os  valores de exemplo inteiramente, como mostra a Figura C.2(d), e apenas especificar um P. sob as colunas a serem recuperadas.

Para ver como as consultas de recupera√ß√£o em QBE s√£o semelhantes ao c√°lculo relacional do dom√≠nio, compare a Figura C.2(d) com C0 (simplificada) no c√°lculo de dom√≠nio da seguinte forma:

## FUNCIONARIO

Pnome

Minicial

## DEPARTAMENTO

Dnome

Dnumero

## LOCALIZACOES\_DEP

Dnumero

Dlocal

## PROJETO

Projnome

Projnumero

## TRABALHA\_EM

Fcpf

Pnr

## DEPENDENTE

Fcpf

Nome\_dependente

Sexo

Datanasc

Unome

Cpf

Cpf\_gerente

Endereco

Data\_inicio\_gerente

Projlocal

Horas

Dnum

Datanasc

## Figura C.1

O esquema relacional da Figura 3.5 conforme exibido pela QBE.

## (a) FUNCIONARIO

Pnome

Minicial

Jo√£o

B.

Unome

Silva

Cpf

\_12345678966

Datanasc

P.\_9/1/60

Parentesco

Endereco

Sexo

P.\_ Rua das

Flores, 751,

S√£o Paulo, SP

## (b) FUNCIONARIO

| Pnome   | Minicial   | Unome   | Cpf   | Datanasc   | Endereco                               | Sexo   | Salario   | Cpf_supervisor   | Dnr   |
|---------|------------|---------|-------|------------|----------------------------------------|--------|-----------|------------------|-------|
| Jo√£o    | B.         | Silva   |       | P._9/1/60  | P._ Rua das Flores, 751, S√£o Paulo, SP |        |           |                  |       |

## (c) FUNCIONARIO

Pnome

Minicial

Jo√£o

B.

## (d) FUNCIONARIO

Pnome

Minicial

Jo√£o

B.

Unome

Silva

Unome

Silva

Datanasc

P.\_X

Datanasc

P.

## Figura C.2

Quatro maneiras de especificar a consulta C0 em QBE.

Cpf

Cpf

Endereco

P.\_Y

Endereco

P.

Sexo

Sexo

Salario

Salario

Cpf\_supervisor

Cpf\_supervisor

Dnr

Dnr

Salario

Cpf\_supervisor

Salario

\_M

Cpf\_supervisor

\_25.000

\_12345678966

Sexo

Dnr

Dnr

\_3

C0 : { uv | FUNCIONARIO (qrstuvwxyz) and q ='Joao' and r ='B' and s ='Silva'}

Podemos pensar em cada coluna em um modelo  QBE  como  uma vari√°vel  de  dom√≠nio  impl√≠cita . Logo, Pnome corresponde  √†  vari√°vel  de  dom√≠nio q , Minicial corresponde a r , ..., e Dnr corresponde a z . Na consulta QBE, as colunas com P. correspondem √†s vari√°veis especificadas √† esquerda da barra no  c√°lculo  de  dom√≠nio,  enquanto  as  colunas  com valores constantes correspondem a vari√°veis de tupla com condi√ß√µes de sele√ß√£o de igualdade nelas. A condi√ß√£o FUNCIONARIO (qrstuvwxyz) e os quantificadores existenciais s√£o impl√≠citos na consulta QBE, pois o modelo correspondente √† rela√ß√£o FUNCIONARIO √© utilizado.

Em QBE, a interface com o usu√°rio primeiro permite que este escolha as tabelas (rela√ß√µes) necess√°rias para formular uma consulta ao exibir uma lista de todos os nomes de rela√ß√£o. Depois, os modelos para as rela√ß√µes escolhidas s√£o exibidos. O usu√°rio passa para as colunas apropriadas nos modelos e especifica

TRABALHA\_EM

| Fcpf   | Pnr   | Horas   |
|--------|-------|---------|
| P.     |       | > 20    |

## TRABALHA\_EM

| (b) Fcpf   | Pnr   | Horas   |
|------------|-------|---------|
| P.         | _PX   | _HX     |

## CONDICOES

\_HX &gt; 20 e (PX = 1 ou PX = 2)

## TRABALHA\_EM

| Fcpf   |   Pnr | Horas   |
|--------|-------|---------|
| P.     |     1 | > 20    |
| P.     |     2 | > 20    |

## Figura C.3

Especificando condi√ß√µes complexas em QBE. (a) A consulta C0A. (b) A consulta C0B com uma caixa de condi√ß√£o. (c) A consulta C0B sem uma caixa de condi√ß√£o.

1 A nega√ß√£o com o s√≠mbolo ¬¨ n√£o √© permitida em uma caixa de condi√ß√£o.

a consulta. Teclas de fun√ß√£o especiais s√£o fornecidas para mover entre os modelos e realizar certas fun√ß√µes.

Agora, oferecemos exemplos para ilustrar as facilidades b√°sicas da QBE. Operadores de compara√ß√£o diferentes de = (como &gt; ou ‚â• ) podem ser inseridos em uma coluna antes de digitar um valor constante. Por exemplo, a consulta C0A: listar os n√∫meros de cadastro de pessoa f√≠sica dos funcion√°rios que trabalham mais de 20 horas por semana no projeto n√∫mero 1 pode ser especificada como mostra a Figura C.3(a). Para condi√ß√µes mais complexas, o usu√°rio pode solicitar uma caixa de condi√ß√£o , que √© criada pressionando uma tecla de fun√ß√£o em particular. O usu√°rio pode ent√£o digitar a condi√ß√£o complexa. 1

Por exemplo, a consulta C0B: listar os n√∫meros de cadastro de pessoa f√≠sica dos funcion√°rios que trabalham mais de 20 horas por semana no projeto 1 ou no  projeto  2 ,  pode  ser  especificada  como  mostra  a Figura C.3(b).

Algumas condi√ß√µes complexas podem ser especificadas sem uma caixa de condi√ß√£o. A regra √© que todas as condi√ß√µes especificadas na mesma linha de um modelo de rela√ß√£o sejam alinhadas por um conectivo l√≥gico and ( todas devem ser satisfeitas por uma tupla selecionada), enquanto as condi√ß√µes especificadas em linhas  distintas  s√£o  conectadas  por or ( pelo  menos uma deve ser satisfeita). Logo, C0B tamb√©m pode ser satisfeita,  como  mostra  a  Figura  C.3(c),  inserindo duas linhas distintas no modelo.

Agora, considere a consulta C0C: Listar os n√∫meros de cadastro de pessoa f√≠sica dos funcion√°rios que trabalham no projeto 1 e no projeto 2 . Esta n√£o pode  ser  especificada  como  na  Figura  C.4(a),  que lista  aqueles  que trabalham ou no projeto 1 ou no projeto 2. A vari√°vel de exemplo \_FC se ligar√° aos valores de Fcpf em tuplas &lt;-, 1, -&gt;, bem como √†queles nas tuplas &lt;-, 2, -&gt;. A Figura C.4(b) mostra como especificar C0C corretamente, onde a condi√ß√£o ( \_FX = \_FY ) na caixa faz que as vari√°veis \_FX e \_FY se vinculem somente a valores de Fcpf id√™nticos.

Em geral, quando uma consulta √© especificada, os valores resultantes s√£o exibidos no modelo sob as colunas apropriadas. Se o resultado tiver mais linhas do que podem ser exibidas na tela, a maioria das implementa√ß√µes de QBE possui teclas de fun√ß√£o para permitir rolar para cima e para baixo nas linhas. De modo semelhante, se um modelo ou v√°rios modelos

## TRABALHA\_EM

(a)

| Fcpf   |   Pnr | Horas   |
|--------|-------|---------|
| P._FC  |     1 |         |
| P._FC  |     2 |         |

## TRABALHA\_EM

| Fcpf   |   Pnr | Horas   |
|--------|-------|---------|
| P._FX  |     1 |         |
| P._FY  |     2 |         |

## CONDICOES



## Figura C.4

Especificando FUNCIONARIOS que trabalham em ambos os projetos. (a) Especifica√ß√£o incorreta de uma condi√ß√£o AND. (b) Especifica√ß√£o correta.

forem muito largos para aparecerem na tela, √© poss√≠vel rolar de lado para examinar todos eles.

Uma opera√ß√£o de jun√ß√£o √© especificada em QBE usando a mesma vari√°vel 2 nas colunas a serem juntadas. Por exemplo, a consulta C1: listar o nome e endere√ßo  de  todos  os  funcion√°rios  que  trabalham para o departamento 'Pesquisa' pode ser especificada como mostra a Figura C.5(a). Qualquer n√∫mero de jun√ß√µes pode ser especificado em uma √∫nica consulta.  Tamb√©m  podemos especificar  uma tabela  de  resultado para  exibir  o  resultado  da  consulta de jun√ß√£o, como mostra a Figura C.5(a); isso √© necess√°rio se o resultado incluir atributos de duas ou mais rela√ß√µes. Se nenhuma tabela de resultado for especificada, o sistema oferece um resultado de consulta nas colunas das v√°rias rela√ß√µes, o que pode tornar dif√≠cil  interpretar.  A  Figura  C.5(a)  tamb√©m ilustra o recurso da QBE para especificar que todos os atributos de uma rela√ß√£o devem ser recuperados, colocando o operador P. sob o nome da rela√ß√£o no modelo da rela√ß√£o.

## (a) FUNCIONARIO

| Pnome   | Minicial Unome   | Cpf   | Datanasc   | Endereco   | Sexo   | Salario   | Cpf_supervisor   | Dnr   |
|---------|------------------|-------|------------|------------|--------|-----------|------------------|-------|
| _PN     | _UN              |       |            | _End       |        |           |                  | _DX   |

## DEPARTAMENTO

| Dnome    | Dnumero   | Cpf_gerente   | Data_inicio_gerente   |
|----------|-----------|---------------|-----------------------|
| Pesquisa | _DX       |               |                       |

| RESULTADO   |     |     |      |
|-------------|-----|-----|------|
| P.          | _PN | _UN | _End |

## (b) FUNCIONARIO

Figura C.5

| Pnome   | Minicial   | Unome   | Cpf   | Datanasc   | Endereco   | Sexo   | Salario   | Cpf_supervisor   | Dnr   |
|---------|------------|---------|-------|------------|------------|--------|-----------|------------------|-------|
| _F1     |            | _F2     |       |            |            |        |           | _Xcpf            |       |
| _S1     |            | _S2     | _Xcpf |            |            |        |           |                  |       |

| RESULTADO   |     |     |     |     |
|-------------|-----|-----|-----|-----|
| P.          | _F1 | _F2 | _S1 | _S2 |

Ilustrando JOIN e rela√ß√µes de resultado em QBE. (a) A consulta C1. (b) A consulta C8.

2 Uma vari√°vel √© chamada de elemento de exemplo nos manuais de QBE.

Para juntar uma tabela consigo mesma, especificamos  diferentes  vari√°veis  para  representar  diversas refer√™ncias √† tabela. Por exemplo, a consulta C8: para cada funcion√°rio, recupere o nome e sobrenome do funcion√°rio, bem como o nome e sobrenome de seu supervisor imediato , pode ser especificada como mostra a Figura C.5(b), em que as vari√°veis que come√ßam com F referem-se a um funcion√°rio e aquelas que come√ßam com S referem-se a um supervisor.

## C.2 Agrupamento, agrega√ß√£o e modifica√ß√£o de banco de dados em QBE

Em seguida, considere os tipos de consultas que exigem  fun√ß√µes  de  agrupamento  ou  agrega√ß√£o.  Um operador  de  agrupamento G .  pode  ser  especificado em uma coluna para indicar que as tuplas devem ser agrupadas pelo valor dessa coluna. Fun√ß√µes comuns podem ser especificadas, como AVG., SUM., CNT. (contador), MAX. e MIN. Em QBE, as fun√ß√µes AVG.,  SUM. e CNT. s√£o aplicadas a valores distintos em um grupo no caso default. Se quisermos que essas fun√ß√µes se apliquem a todos os valores, temos de usar o prefixo ALL. 3 Essa conven√ß√£o √© diferente em SQL, onde o default √© aplicar uma fun√ß√£o a todos os valores.

A  Figura  C.6(a)  mostra  a  consulta C23, que conta o n√∫mero de valores de sal√°rio distintos na rela√ß√£o FUNCIONARIO . A  consulta C23A (Figura C.6(b)) conta todos os valores de sal√°rio, que √© o mesmo que contar o n√∫mero de funcion√°rios. A Figura C.6(c) mostra C24, que recupera cada n√∫mero de departamento e o n√∫mero de funcion√°rios e sal√°rio m√©dio em cada departamento. Logo, a coluna Dnr √© usada para agrupamento, conforme indicado pela fun√ß√£o G . Diversos dos operadores G., P. e ALL podem ser especificados em uma √∫nica coluna. A Figura C.6(d) mostra a consulta C26, que exibe cada nome de projeto  e  o  n√∫mero  de  funcion√°rios  que trabalham nele para os projetos em que h√° mais de dois funcion√°rios.

A QBE tem um s√≠mbolo de nega√ß√£o, ¬¨, que √© usado  de  uma  maneira  semelhante  √†  fun√ß√£o NOT EXISTS em SQL. A Figura C.7 mostra a consulta C6, que lista os nomes dos funcion√°rios que n√£o possuem dependentes. O s√≠mbolo de nega√ß√£o ¬¨ diz que selecionaremos valores da vari√°vel \_SX da rela√ß√£o FUNCIONARIO somente se eles n√£o ocorrerem na rela√ß√£o DEPENDENTE .  O mesmo efeito pode ser produzido ao colocar um ¬¨ \_SX na coluna Fcpf .

3 ALL em QBE n√£o est√° relacionado ao quantificador universal.

Embora a linguagem QBE, conforme proposta originalmente,  fosse  demonstrada  para  dar  suporte ao equivalente das fun√ß√µes EXISTS e NOT EXISTS da SQL, a implementa√ß√£o da QBE em QMF (sob o sistema DB2) n√£o oferece esse suporte. Assim, a vers√£o QMF da QBE, que discutimos aqui, n√£o √© completa do ponto de vista relacional . Consultas como C3: achar todos os funcion√°rios que trabalham em todos os  projetos  controlados  pelo  departamento  5 ,  n√£o podem ser especificadas.

Existem tr√™s operadores da QBE para modificar o banco de dados: I. para inser√ß√£o (insert), D. para exclus√£o (delete) e U. para atualiza√ß√£o (update). Os operadores de inser√ß√£o e exclus√£o s√£o especificados na coluna de modelo sob o nome da rela√ß√£o, enquanto  o  operador  de  atualiza√ß√£o  √©  especificado  sob  as colunas a serem atualizadas. A Figura C.8(a) mostra como inserir uma nova tupla de FUNCIONARIO . Para exclus√£o, primeiro inserimos o operador D. e depois especificamos as tuplas  a  serem  exclu√≠das  por  uma condi√ß√£o (Figura C.8(b)). Para atualizar uma tupla, especificamos o operador U. sob o nome do atributo, seguido pelo novo nome do atributo. Tamb√©m devemos selecionar a tupla ou tuplas a serem atualizadas da forma normal. A Figura C.8(c) mostra uma solicita√ß√£o de atualiza√ß√£o para aumentar o sal√°rio de 'Jo√£o Silva' em 10 por cento e tamb√©m reatribu√≠-lo ao departamento n√∫mero 4.

A QBE tamb√©m tem capacidades de defini√ß√£o. As  tabelas  de  um  banco  de  dados  podem  ser  especificadas  interativamente,  e  uma  defini√ß√£o  de tabela tamb√©m pode ser atualizada pela inclus√£o, renomea  √ß√£o ou remo√ß√£o de uma coluna. Tamb√©m podemos  especificar  diversas  caracter√≠sticas  para cada coluna, como se ela √© uma chave da rela√ß√£o, qual √© seu tipo de dados e se um √≠ndice deve ser criado nesse campo. A QBE tamb√©m tem facilidades para defini√ß√£o de vis√£o, autoriza√ß√£o, armazenamento de defini√ß√µes de consulta para uso posterior, e assim por diante.

A QBE n√£o usa o estilo linear da SQL; em vez disso, ela √© uma linguagem bidimensional ,  pois  os usu√°rios  especificam  uma  consulta  movimentando por toda a √°rea da tela. Os testes nos usu√°rios t√™m mostrado que a QBE √© mais f√°cil de aprender do que a SQL, principalmente para n√£o especialistas. De certa forma, a QBE foi a primeira linguagem de banco de dados de rela√ß√£o visual amig√°vel ao usu√°rio.

## (a) FUNCIONARIO

| Pnome   | Minicial   | Unome   | Cpf   | Datanasc   | Endereco   | Sexo   | Salario   | Cpf_supervisor   | Dnr   |
|---------|------------|---------|-------|------------|------------|--------|-----------|------------------|-------|
|         |            |         |       |            |            |        | P.CNT.    |                  |       |

## (b) FUNCIONARIO

| Pnome   | Minicial   | Unome   | Cpf   | Datanasc   | Endereco   | Sexo   | Salario   | Cpf_supervisor   | Dnr   |
|---------|------------|---------|-------|------------|------------|--------|-----------|------------------|-------|
|         |            |         |       |            |            |        | P.CNT.ALL |                  |       |

## (c) FUNCIONARIO

| Pnome   | Minicial   | Unome   | Cpf       | Datanasc   | Endereco   | Sexo   | Salario   | Cpf_supervisor   | Dnr   |
|---------|------------|---------|-----------|------------|------------|--------|-----------|------------------|-------|
|         |            |         | P.CNT.ALL |            |            |        | P.AVG.ALL |                  | P.G.  |

## (d) PROJETO

| Projnome   | Projnumero   | Projlocal   | Dnum   |
|------------|--------------|-------------|--------|
| P.         | _PX          |             |        |

## TRABALHA\_EM

| Fcpf     | Pnr   | Horas   |
|----------|-------|---------|
| P.CNT.FX | G._PX |         |

## CONDICOES

CNT.FX &gt; 2

## Figura C.6

Fun√ß√µes e agrupamento em QBE. (a) A consulta C23. (b) A consulta C23A. (c) A consulta C24. (d) A consulta C26.

## FUNCIONARIO

| Pnome   | Minicial Unome   | Cpf   | Datanasc   | Endereco   | Sexo   | Salario   | Cpf_supervisor   | Dnr   |
|---------|------------------|-------|------------|------------|--------|-----------|------------------|-------|
| P.      | P.               | _SX   |            |            |        | P.CNT.    |                  |       |

## DEPENDENTE

|    | Fcpf   | Nome_dependente   | Sexo   | Datanasc   | Parentesco   |
|----|--------|-------------------|--------|------------|--------------|
| ¬¨  | _SX    |                   |        |            |              |

## Figura C.7

Ilustrando nega√ß√£o pela consulta C6.

Mais  recentemente,  diversas  outras  interfaces amig√°veis  ao  usu√°rio  t√™m  sido  desenvolvidas  para sistemas  de  banco  de  dados  comerciais.  O  uso  de menus, gr√°ficos e formul√°rios agora est√° se tornando muito comum. Preencher formul√°rios de maneira parcial para emitir uma solicita√ß√£o de busca √© semelhante a usar QBE. As linguagens de consulta visuais, que  n√£o  s√£o  sobremaneira  comuns,  provavelmente ser√£o oferecidas com os bancos de dados relacionais comerciais no futuro.

## (a) FUNCIONARIO

| Pnome   | Minicial   | Unome     |         Cpf |            | Datanasc                         | Endereco Sexo   |   Salario |             |   Cpf_supervisor Dnr |
|---------|------------|-----------|-------------|------------|----------------------------------|-----------------|-----------|-------------|----------------------|
| I.      | Ricardo    | K. Marini | 65329865328 | 30-12-1952 | Rua Perneiras, 55, S√£o Paulo, SP | M               |        37 | 98765432168 |                    4 |

## (b) FUNCIONARIO

| Pnome   | Minicial   | Unome   |         Cpf | Datanasc   | Endereco   | Sexo   | Salario   | Cpf_supervisor   | Dnr   |
|---------|------------|---------|-------------|------------|------------|--------|-----------|------------------|-------|
| D.      |            |         | 65329865328 |            |            |        |           |                  |       |

## (c) FUNCIONARIO

| Pnome   | Minicial Unome   | Cpf   | Datanasc   | Endereco   | Sexo   | Salario   | Cpf_supervisor   | Dnr   |
|---------|------------------|-------|------------|------------|--------|-----------|------------------|-------|
| Jo√£o    | Silva            |       |            |            |        | U._S*1.1  |                  | U.4   |

## Figura C.8

Modificando o banco de dados na QBE. (a) Inser√ß√£o. (b) Exclus√£o. (c) Atualiza√ß√£o na QBE.



## Abrevia√ß√µes usadas na bibliografia

ACM: Association for Computing Machinery

AFIPS: American Federation of Information Processing Societies

CACM: Communications of the ACM (peri√≥dico)

CIKM: Proceedings of the International Conference on Information and Knowledge Management

DASFAA: Proceedings of the International Conference on Database Systems for Advanced Applications

DKE: Data and Knowledge Engineering, Elsevier Publishing (peri√≥dico) EDS: Proceedings of the International Conference on Expert Database Systems

ER Conference: Proceedings of the International Conference on Entity-Relationship Approach (agora chamada de International Conference on Conceptual Modeling)

ICDCS: Proceedings of the IEEE International Conference on Distributed Computing Systems

ICDE: Proceedings of the IEEE International Conference on Data Engineering

IEEE: Institute of Electrical and Electronics Engineers

IEEE Computer: Revista Computer (peri√≥dico) da IEEE CS

IEEE CS: IEEE Computer Society

IFIP: International Federation for Information Processing

JACM: Journal of the ACM

KDD: Knowledge Discovery in Databases

LNCS: Lecture Notes in Computer Science

NCC: Proceedings of the National Computer Conference (publicado pela AFIPS)

OOPSLA: Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications

PAMI: Pattern Analysis and Machine Intelligence

PODS: Proceedings of the ACM Symposium on Principles of Database Systems

SIGMOD: Proceedings of the ACM SIGMOD International Conference on Management of Data

SOSP: ACM Symposium on Operating System Principles

TKDE: IEEE Transactions  on  Knowledge  and  Data  Engineering (peri√≥dico)

TOCS: ACM Transactions on Computer Systems (peri√≥dico)

TODS: ACM Transactions on Database Systems (peri√≥dico)

TOIS: ACM Transactions on Information Systems (peri√≥dico)

## Bibliografia

TOOIS: ACM Transactions on Office Information Systems (peri√≥dico) TSE: IEEE Transactions on Software Engineering (peri√≥dico) VLDB: Proceedings of the International Conference on Very Large Data Bases (edi√ß√µes ap√≥s 1981 dispon√≠veis na Morgan Kaufmann, Menlo Park, Calif√≥rnia)

## Refer√™ncias bibliogr√°ficas

ABADI, D. J.; MADDEN, S. R.; HACHEM, N. Column stores vs. Row stores: How different are they really? In: SIGMOD , 2008.

ABBOTT, R.; GARCIA-MOLINA, H. Scheduling real-time transactions with disk resident data. In: VLDB , 1989.

ABITEBOUL, S.; KANELLAKIS, P. Object identity as a query language primitive. In: SIGMOD , 1989.

\_\_\_\_\_\_.; HULL, R.; VIANU, V. Foundations of databases . Addison-Wesley, 1995.

ABRIAL, J. Data semantics . In: KLIMBIE; KOFFEMAN, 1974.

ACHARYA, S. et al. Broadcast disks: Data management for asymmetric communication environments. In: SIGMOD , 1995.

ADAM, N.; GONGOPADHYAY, A. Integrating functional and data modeling  in  a  computer  integrated  manufacturing  system.  In: ICDE , 1993.

ADRIAANS, P.; ZANTINGE, D. Data mining . Addison-Wesley, 1996. AFSARMANESH, H. et al. An extensible object-oriented approach to databases for VLSI/CAD. In: VLDB , 1985.

AGRAWAL, D.; El ABBADI, A. Storage efficient replicated databases. TKDE , v. 2, n. 3, set. 1990.

AGRAWAL, R. et al. The claremont report on database research . Dispon√≠vel em: &lt;http://db.cs.berkeley.edu/claremont/claremontreport08.pdf&gt;. Acesso em: maio 2008.

\_\_\_\_\_\_.; GEHANI, N. ODE: The language and the data model. In: SIGMOD , 1989.

\_\_\_\_\_\_.; SRIKANT, R. Fast algorithms for mining association rules in large databases. In: VLDB , 1994.

\_\_\_\_\_\_; GEHANI, N.; SRINIVASAN, J. OdeView: The graphical interface to ode. In: SIGMOD , 1990.

\_\_\_\_\_\_.; IMIELINSKI, T.; SWAMI, A. Mining association rules between sets of items in databases. In: SIGMOD , 1993.

\_\_\_\_\_\_.; \_\_\_\_\_\_.; \_\_\_\_\_\_. Database mining: A performance perspective. TKDE , v. 5, n. 6, dez. 1993b.

\_\_\_\_\_\_. et al. The quest data mining system. In: KDD , 1996.

AHAD, R.; BASU, A. ESQL: A query language for the relational model supporting image domains. In: ICDE , 1991.

- AHO, A.; ULLMAN, J. Universality of data retrieval languages. Proc. POPL Conference. San Antonio, TX, ACM, 1979.
- \_\_\_\_\_\_.; BEERI, C.; ULLMAN, J. The theory of joins in relational databases. TODS , v. 4, n. 3, set. 1979.
- \_\_\_\_\_\_.; SAGIV, Y.; ULLMAN, J. Efficient optimization of a class of relational expressions. TODS , v. 4, n. 4, dez. 1979a.
- AKL, S. Digital signatures: A tutorial survey. IEEE Computer , v. 16, n. 2, fev. 1983.
- ALAGIC, S. A family of the ODMG object models. In: EDER, J.; ROZMAN, I.; WELZER, T. (Eds.). Advances in databases and information systems. Third East European Conference ,  ADBIS'99. LNCS, n. 1691. Maribor, Slovenia, Springer, set. 1999.
- ALASHQUR, A.; SU, S.; LAM, H. OQL: A query language for manipulating object-oriented databases. In: VLDB , 1989.
- ALBANO, A.; CARDELLI, L.; ORSINI, R. GALILEO: A strongly typed interactive conceptual language. TODS , v. 10, n. 2, p. 230260, jun. 1985.
- ALBRECHT, J. H. Universal GIS operations .  1996. Disserta√ß√£o de Ph.D. - University of Osnabrueck, Germany, 1996.
- ALLEN, F.; LOOMIS, M.; MANNINO, M. The integrated dictionary/ directory system. ACM Computing Surveys , v. 14, n. 2, jun. 1982.
- ALLEN,  J.  Maintaining  knowledge  about  temporal  intervals.  In: CACM , v. 26, n. 11, p. 832-843, nov. 1983.
- ALONSO, G. et al. Functionalities and limitations of current workflow management systems. IEEE Expert , 1997.
- AMIR, A.; FELDMAN, R.; KASHI, R. A new and versatile method for association generation. Information Systems , v. 22, n. 6, set. 1997.
- ANDERSON, S. et al. Sequence and organization of the human mitochondrial genome. Nature , v. 290, p. 457-465, 1981.
- ANDREWS, T.; HARRIS, C. Combining language and database advances in an object-oriented development environment. OOPSLA , 1987.
- ANSI. American National Standards Institute Study Group on Data Base Management Systems: Interim Report. FDT , v. 7, n. 2, ACM, 1975.
- ANSI. American National Standards Institute. The database language SQL . Documento ANSI X3.135, 1986.
- ANSI. American National Standards Institute. The database lnguage NDL . Documento ANSI X3.133, 1986a.
- ANSI. American National Standards Institute. Information resource dictionary systems . Documento ANSI X3.138, 1989.
- ANTENUCCI, J. et al. Geographic information systems : A guide to the technology. Chapman e Hall, maio 1998.
- ANWAR, T.; BECK, H.; NAVATHE, S. Knowledge mining by imprecise querying: A classification based approach. In: ICDE , 1992.
- APERS, P.; HEVNER, A.; YAO, S. Optimization algorithms for distributed queries. TSE , v. 9, n. 1, jan. 1983.
- APWEILER, R. et al. Managing core resources for genomics and proteomics. Pharmacogenomics , v. 4, n. 3, p. 343-350, maio 2003.
- AREF, W. et al. VDBMS: A testbed facility or research in video database benchmarking. In: Multimedia Systems ( MMS ), v. 9, n. 6, p. 98-115, jun. 2004.
- ARISAWA, H.; CATARCI, T. Advances in visual information management. In: ARISAWA, H.; CATARCI, T. (Eds.). Proc. Fifth Working Conf. on Visual Database Systems. IFIP Conference Proceedings 168. Fujkuoka, Jap√£o, Kluwer, 2000.

ARMSTRONG, W. Dependency structures of data base relationships. Proc. IFIP Congress , 1974.

- ASHBURNER, M. et al. Gene ontology: Tool for the unification of biology. Nature Genetics , v. 25, p. 25-29, maio 2000.
- ASTRAHAN, M. et al. System R: A relational approach to data base management. TODS , v. 1, n. 2, jun. 1976.
- ATKINSON, M.; BUNEMAN, P. Types and persistence in database programming languages. In: ACM Computing Surveys , v. 19, n. 2, jun. 1987.
- ATKINSON,  Malcolm  et  al.  The  object-oriented  database  system manifesto. Proc.  Deductive  and  Object  Oriented  Database  Conf. ( DOOD ). Kyoto, Jap√£o, 1990.
- ATLURI, V. et al. Multilevel secure transaction processing: Status and prospects.  In: Database  Security :  Status  and  Prospects,  p.  79-98. Chapman and Hall, 1997.
- ATZENI, P.; De ANTONELLIS, V. Relational Database Theory . Benjamin/Cummings, 1993.
- \_\_\_\_\_\_.; MECCA, G.; MERIALDO, P. To weave the Web. In: VLDB , 1997.
- BACHMAN,  C.  Data  structure  diagrams. Data  Base (Boletim  da ACM SIGFIDET), v. 1, n. 2, mar. 1969.
- \_\_\_\_\_\_.The programmer as a navigator. CACM ,  v.  16,  n.  1,  nov. 1973. \_\_\_\_\_\_.The data structure set model. In: Rustin , 1974.
- \_\_\_\_\_\_.; WILLIAMS, S. A general purpose programming system for random access memories. Proc. Fall Joint Computer Conferenc e, AFIPS, 26, 1964.
- BADAL, D.; POPEK, G. Cost and performance analysis of semantic integrity validation methods. In: SIGMOD , 1979.
- BADRINATH,  B.;  IMIELINSKI,  T.  Replication  and  mobility. Proc. Workshop on the Management of Replicated Data 1992 , p. 9-12, 1992.
- \_\_\_\_\_\_.;  RAMAMRITHAM, K. Semantics-Based concurrency control: Beyond commutativity. TODS , v. 17, n. 1, mar. 1992.
- BAEZA-YATES, R.; LARSON, P. A. Performance of B+-trees with partial expansions. TKDE , v. 1, n. 2, jun. 1989.
- \_\_\_\_\_\_.;  RIBERO-NETO, B. Modern Information Retrieval .  Addison-Wesley, 1999.
- BALBIN, I.; RAMAMOHANRAO, K. A generalization of the different approach to recursive query evaluation. Journal of Logic Programming , v. 15, n. 4, 1987.
- BANCILHON, F. Naive evaluation of recursively defined relations. In: BRODIE, M.; MYLOPOULOS, J. (Eds.). On knowledge base management systems . Islamorada workshop 1985, p. 165-178, Springer, 1985.
- \_\_\_\_\_\_.; BUNEMAN, P. (Eds.). Advances in database programming languages . ACM Press, 1990.
- \_\_\_\_\_\_.; FERRAN, G. The ODMG standard for object databases. DASFAA 1995 , p. 273-283. Singapore, 1995.
- \_\_\_\_\_\_.; RAMAKRISHNAN, R. An amateur's introduction to recursive query processing strategies. In: SIGMOD , 1986.
- \_\_\_\_\_\_.; DELOBEL, C.; KANELLAKIS, P. (Eds.). Building an object-oriented database system : The story of O2. Morgan Kaufmann, 1992.
- \_\_\_\_\_\_. et al. Magic sets and other strange ways to implement logic programs. PODS , 1986.
- BANERJEE, J. et al. Data model issues for object-oriented applications. TOOIS , v. 5, n. 1, jan. 1987.
- \_\_\_\_\_\_\_. et al. Semantics and implementation of schema evolution in object-oriented databases. In: SIGMOD , 1987a.
- BARBARA, D. Mobile computing and databases - A Survey. TKDE , v. 11, n. 1, jan. 1999.
- BAROODY, A.; DeWITT, D. An object-oriented approach to database system implementation. TODS , v. 6, n. 4, dez. 1981.
- BARRETT, T. et al. NCBI GEO: mining millions of expression profiles - database and tools. Nucleic Acid Research , v. 33, edi√ß√£o de banco de dados, p. 562-566, 2005.
- \_\_\_\_\_\_. et al. NCBI GEO: mining tens of millions of expression profiles - database and tools update. In: Nucleic Acids Research , v. 35, n. 1, jan. 2007.
- BARSALOU, T. et al. Updating relational databases through object-based views. In: SIGMOD , 1991.
- BASSIOUNI, M. Single-Site and distributed optimistic protocols for concurrency control. TSE , v. 14, n. 8, ago. 1988.
- BATINI, C.; CERI, S.; NAVATHE, S. Database design :  An  entity-relationship approach. Benjamin/Cummings, 1992.

- \_\_\_\_\_\_.; LENZERINI, M.; NAVATHE, S. A comparative analysis of methodologies for database schema integration. ACM Computing Surveys , v. 18, n. 4, dez. 1987.
- BATORY, D. et al. GENESIS: An extensible database management system. TSE , v. 14, n. 11, nov. 1988.
- \_\_\_\_\_\_.;  BUCHMANN, A. Molecular objects,  abstract  data  types, and data models: A framework. In: VLDB , 1984.
- BAY, H.; TUYTELAARS, T.; GOOL, L. V. SURF: Speeded up robust features. In: Proc. Ninth European Conference on Computer Vision , maio 2006.
- BAYER, R.; McCREIGHT, E. Organization and maintenance of large ordered indexes. Acta Informatica , v. 1, n. 3, fev. 1972.
- \_\_\_\_\_\_.; GRAHAM, M.; SEEGMULLER, G. (Eds.). Operating systems : An advanced course. Springer-Verlag, 1978.
- BECK, H.; ANWAR, T.; NAVATHE, S. A conceptual clustering algorithm for database schema design. TKDE , v. 6, n. 3, jun. 1994.
- \_\_\_\_\_\_.; GALA, S.; NAVATHE, S. Classification as a query processing technique in the CANDIDE semantic data model. In: ICDE , 1989. BEERI,  C.;  RAMAKRISHNAN,  R.  On  the  power  of  magic.  In: PODS , 1987.
- \_\_\_\_\_\_.; FAGIN, R.; HOWARD, J. A complete axiomatization for functional and multivalued dependencies. In: SIGMOD , 1977.
- BEN-ZVI, J. The time relational model. Disserta√ß√£o de Ph.D. - University of California, Los Angeles, 1982.
- BENSON, D. et al. GenBank. Nucleic Acids Research , v. 24, n. 1, 1996. \_\_\_\_\_\_. et al. (2002). GenBank. Nucleic Acids Research , v. 36, n. 1, jan. 2008.
- BERG, B.; ROTH, J. Software for optical storage . Meckler, 1989. BERGMAN, M. K. The deep Web: Surfacing hidden value. The Journal of Electronic Publishing , v. 7, n. 1, ago. 2001.
- BERNERS-LEE, T. et al. World-Wide Web: The information universe. Electronic  Networking :  Research,  applications  and  policy,  v.  1, n. 2, 1992.
- \_\_\_\_\_\_. et al. The world wide Web. CACM , v. 13, n. 2, ago. 1994.

BERNSTEIN, P. Synthesizing third normal form relations from func- tional dependencies.

TODS

, v. 1, n. 4, dez. 1976.

- BERNSTEIN, P.; GOODMAN, N. Multiversion concurrency control - Theory and algorithms. TODS , v. 8, n. 4, p. 465-483, 1983.
- \_\_\_\_\_\_.;  \_\_\_\_\_\_.Timestamp-Based  algorithms  for  concurrency  con-
- trol in distributed database systems. In: VLDB , 1980.
- \_\_\_\_\_\_.; \_\_\_\_\_\_.Concurrency control in distributed database systems. ACM Computing Surveys , v. 13, n. 2, jun. 1981a.
- \_\_\_\_\_\_.;  \_\_\_\_\_\_.The  power  of  natural  semijoins. SIAM Journal  of Computing , v. 10, n. 4, dez. 1981b.
- \_\_\_\_\_\_.; \_\_\_\_\_\_. An algorithm for concurrency control and recovery in replicated distributed databases. TODS , v. 9, n. 4, dez. 1984.
- \_\_\_\_\_\_.; BLAUSTEIN, B.; CLARKE, E. Fast maintenance of semantic integrity assertions using redundant aggregate data. In: VLDB , 1980.
- \_\_\_\_\_\_.; HADZILACOS, V.; GOODMAN, N. Concurrency control and recovery in database systems . Addison-Wesley, 1987.
- BERTINO, E. Data hiding and security in object-oriented databases. In: ICDE , 1992.

\_\_\_\_\_\_. Data security. In: DKE , v. 25, n. 1-2, p. 199-216, 1998.

- \_\_\_\_\_\_.; SANDHU, R. Security - Concepts, approaches and challenges. In: IEEE Transactions on Dependable Secure Computing ( TDSC ), v. 2, n. 1, p. 2-19, 2005.
- \_\_\_\_\_\_.; GUERRINI, G. Extending the ODMG object model with composite objects. OOP-SLA . Vancouver, Canad√°, p. 259-270, 1998.
- \_\_\_\_\_\_.; KIM, W. Indexing techniques for queries on nested objects. TKDE , v. 1, n. 2, jun. 1989.
- \_\_\_\_\_\_.; CATANIA, B.; FERRARI, E. A nested transaction model for multilevel  secure  database  management  systems. ACM Transactions on Information and System Security ( TISSEC ), v. 4, n. 4, p. 321-370, nov. 2001.
- \_\_\_\_\_\_. et al. Object-oriented query languages: The notion and the issues. TKDE , v. 4, n. 3, jun. 1992.
- \_\_\_\_\_\_.; PAGANI, E.; ROSSI, G. Fault tolerance and recovery in mobile computing systems . In: KUMAR; HAN, 1992.
- \_\_\_\_\_\_.; RABITTI, F.; GIBBS, S. Query processing in a multimedia document system. TOIS , v. 6, n. 1, 1988.
- BHARGAVA, B.; HELAL, A. Efficient reliability mechanisms in distributed database systems. CIKM , nov. 1993.
- \_\_\_\_\_\_.;  REIDL,  J.  A  model  for  adaptable  systems  for  transaction processing. In: ICDE , 1988.
- BILIRIS, A. The performance of three database storage structures for managing large objects. In: SIGMOD , 1992.
- BILLER, H. On the equivalence of data base schemas - A semantic approach to data translation. Information Systems , v. 4, n. 1, 1979.
- BISCHOFF, J.; ALEXANDER, T. (Eds.). Data warehouse : Practical advice from the experts. Prentice-Hall, 1997.
- BISKUP, J.; DAYAL, U.; BERNSTEIN, P. Synthesizing independent database schemas. In: SIGMOD , 1979.
- BITTON, D.; GRAY, J. Disk shadowing. In: VLDB , p. 331-338, 1988. BJORK, A. Recovery scenario for a DB/DC system. Proc. ACM National Conference , 1973.
- BJORNER, D.; LOVENGREN, H. Formalization of database systems and a formal definition of IMS. In: VLDB , 1982.
- BLAHA, M.; RUMBAUGH, J. Object-oriented modeling and design with UML . 2. ed. Prentice-Hall, 2005.
- \_\_\_\_\_\_.; PREMERLANI, W. Object-oriented modeling and design for database applications . Prentice-Hall, 1998.
- BLAKELEY, J.; MARTIN, N. Join index, materialized view, and hybrid-hash join: A performance analysis. In: ICDE , 1990.
- \_\_\_\_\_\_.; COBURN, N.; LARSON, P. Updated derived relations: Detecting irrelevant  and autonomously computable updates. TODS , v. 14, n. 3, set. 1989.
- BLASGEN, M. et al. System R: An architectural overview. IBM Systems Journal , v. 20, n. 1, jan. 1981.
- \_\_\_\_\_\_.; ESWARAN, K. On the evaluation of queries in a relational database system. IBM Systems Journal , v. 16, n. 1, jan. 1976.
- BLEIER, R.;  VORHAUS, A. File  organization  in  the  SDC  TDMS. Proc. IFIP Congress , 1968.
- BOCCA, J. EDUCE - A marriage of convenience: Prolog and a relational DBMS. Proc. Third International Conference on Logic Programming. Springer-Verlag, 1986.
- \_\_\_\_\_\_. On the evaluation strategy of EDUCE. In: SIGMOD , 1986a. BODORICK, P.; RIORDON, J.; PYRA, J. Deciding on correct distributed query processing. TKDE , v. 4, n. 3, jun. 1992.
- BONCZ, P.; ZUKOWSKI, M.; NES, N. MonetDB/X100: Hyper-pipelining query execution. In: Proc. Conf. on Innovative Data Systems Research CIDR , 2005.
- BONNET, P.; GEHRKE, J.; SESHADRI, P. Towards sensor database systems. In: Proc. 2nd Int. Conf. on Mobile Data Management. Hong Kong, China, LNCS 1987, p. 3-14. Springer, jan. 2001.
- BOOCH, G.; RUMBAUGH, J.; JACOBSON, I. Unified modeling language user guide . Addison-Wesley, 1999.
- BORGES,  K.;  LAENDER,  A.;  DAVIS,  C.  Spatial  data  integrity constraints in object oriented geographic data modeling. Proc. 7th ACM International Symposium on Advances in Geographic Information Systems , 1999.
- BORGIDA, A. et al. CLASSIC: A structural data model for objects. In: SIGMOD , 1989.
- BORKIN, S. Data model equivalence. In: VLDB , 1978.

BOSSOMAIER, T.; GREEN, D. Online GIS and Metadata .  Taylor and Francis, 2002.

BOUKERCHE,  A.;  TUCK,  T.  Improving  concurrency  control  in distributed databases with predeclared tables. In: Proc. Euro-Par 2001: Parallel Processing, 7th International Euro-Par Conference , p. 301-309. Manchester, Reino Unido, 28-31 ago. 2001.

BOUTSELAKIS, H. et al. E-MSD: The european bioinformatics institute macromolecular structure database. Nucleic Acids Research , v. 31, n. 1, p. 458-462, jan. 2003.

- BOUZEGHOUB,  M.;  METAIS,  E.  Semantic  modelling  of  object-oriented databases. In: VLDB , 1991.
- BOYCE, R. et al. Specifying queries as relational expressions. CACM , v. 18, n. 11, nov. 1975.
- BOYD, S.; KEROMYTIS, A. SQLrand: Preventing SQL injection attacks. In: Proc. 2nd Applied Cryptography and Network Security Conf.  ACNS 2004 , ( ) p. 292-302, jun. 2004.

BRACCHI, G.; PAOLINI, P.; PELAGATTI, G. Binary logical associations in data modeling . In: NIJSSEN, 1976.

BRACHMAN, R.; LEVESQUE, H. What makes a knowledge base knowledgeable? A view of databases from the knowledge level. In: EDS , 1984.

BRANDON, M. et al. MITOMAP: A human mitochondrial genome database - 2004 Update. Nucleic Acid Research , v. 34, n. 1, jan. 2005. BRATBERGSENGEN, K. Hashing methods and relational algebra operators. In: VLDB , 1984.

BRAY, O. Computer integrated manufacturing - The data management strategy. Digital Press, 1988.

- BREITBART, Y. et al. Update propagation protocols for replicated databases. In: SIGMOD , p. 97-108, 1999.
- \_\_\_\_\_\_.; SILBERSCHATZ, A.; THOMPSON, G. Reliable transaction management in a multidatabase system. In: SIGMOD , 1990.
- BRINKHOFF, T.; KRIEGEL, H.-P.; SEEGER, B. Efficient processing of spatial joins using R-trees. In: SIGMOD , 1993.
- BRODER, A. A taxonomy of Web search. In: SIGIR Forum , v. 36, n. 2, p.3-10, set. 2002.

BRODEUR, J.;  B√âDARD,  Y.;  PROULX,  M.  Modelling  geospatial application databases using UML-based repositories aligned with international standards in geomatics. Proc. 8th ACM International Symposium on Advances in Geographic Information Systems ,  p. 39-46. Washington, DC, ACM Press, 2000.

- BRODIE, M.; MYLOPOULOS, J. (Eds.). On Knowledge Base Management Systems. Springer-Verlag, 1985.
- \_\_\_\_\_\_.;  \_\_\_\_\_\_.;  SCHMIDT,  J.  (Eds.). On  Conceptual  Modeling . Springer-Verlag, 1984.

BROSEY, M.; SHNEIDERMAN, B. Two experimental comparisons of relational and hierarchical database models. International Journal of Man Machine Studies -, 1978.

- BRY, F. Query evaluation in recursive databases: Bottom-up and top-down reconciled. DKE , v. 5, p. 289-312, 1990.

BUCKLEY, C.; SALTON, G.; ALLAN, J. The SMART information retrieval project. In: Proc. of the Workshop on Human Language Technology, Human Language Technology Conference, Association for Computational Linguistics, mar. 1993.

BUKHRES, O. Performance comparison of distributed deadlock detection algorithms. In: ICDE , 1992.

BUNEMAN, P.; FRANKEL, R. FQL: A functional query language. In: SIGMOD , 1979.

BURKHARD, W. Hashing and trie algorithms for partial match retrieval. TODS , v. 1, n. 2, p. 175-187, jun. 1976.

- \_\_\_\_\_\_. Partial-match hash coding: Benefits of redundancy. TODS , v. 4, n. 2, p. 228-239, jun. 1979.
- BUSH, V. As we may think. Atlantic Monthly ,  v.  176, n. 1, jan. 1945. Reimpresso: Kochen, M. (Ed.) The Growth of Knowledge , Wiley, 1967.

BUTTERWORTH, P.; OTIS, A.; STEIN, J. The gemstone object database management system. In: CACM , v. 34, n. 10, p. 64-77, out. 1991. BYTE. Edi√ß√£o especial sobre computa√ß√£o m√≥vel, jun. 1995.

- CACM. Edi√ß√£o especial da Communications of the ACM sobre bibliotecas digitais, v. 38, n. 5, maio 1995.
- CACM Edi√ß√£o especial da Communications of the ACM sobre bibliotecas digitais. Global Scope and Unlimited Access, v. 41, n. 4, abril 1998.
- CAMMARATA, S.; RAMACHANDRA, P.; SHANE, D. Extending a relational database with deferred referential integrity checking and intelligent joins. In: SIGMOD , 1989.
- CAMPBELL, D.; EMBLEY, D.; CZEJDO, B. A relationally complete query  language  for  the  entity-relationship  model.  In: ER Conference , 1985.
- CARDENAS, A. Data Base Management Systems . 2. ed. Allyn e Bacon, 1985.
- CAREY,  M.  et  al. The  architecture  of  the  EXODUS  extensible DBMS . In: DITTRICH; DAYAL, 1986.
- \_\_\_\_\_\_.; DeWITT, D.; VANDENBERG, S. A data model and query language for exodus. In: SIGMOD , 1988.
- \_\_\_\_\_\_. et al. Object and file management in the EXODUS extensible database system. In: VLDB , 1986a.
- \_\_\_\_\_\_. et al. Data caching tradeoffs in client-server DBMS architectures. In: SIGMOD , 1991.
- CARLIS, J. HAS, a relational algebra operator or divide is not enough to conquer. In: ICDE , 1986.
- \_\_\_\_\_\_; MARCH, S. A descriptive model of physical database design problems and solutions. In: ICDE , 1984.
- CARNEIRO, G.; VASCONSELOS, N. A database centric view of semantic image annotation and retrieval. In: SIGIR , 2005.
- CARROLL, J. M. Scenario-based design : Envisioning work and technology in system development. Wiley, 1995.
- CASANOVA, M.; VIDAL, V. Toward a sound view integration method. In: PODS , 1982.
- \_\_\_\_\_\_.;  FAGIN,  R.;  PAPADIMITRIOU,  C.  Inclusion  dependencies and their interaction with functional dependencies. In: PODS , 1981.
- \_\_\_\_\_\_.;  FURTADO, A.; TUCHERMANN, L. A software tool for modular database design. TODS , v. 16, n. 2, jun. 1991.
- \_\_\_\_\_\_. et al. Optimization of relational schemas containing inclusion dependencies. In: VLDB , 1989.
- CASTANO, S. et al. Conceptual schema analysis: Techniques and applications. TODS , v. 23, n. 3, p. 286-332, set. 1998.
- CATARCI, T. et al. Visual query systems for databases: A survey. Journal of Visual Languages and Computing ,  v.  8,  n.  2,  p.  215260, jun. 1997.
- \_\_\_\_\_\_. et al. (Eds.). Proc. Fourth International Workshop on Advanced Visual Interfaces. ACM Press, 1998.
- CATTELL, R. Object data management: Object-oriented and extended relational database systems. Addison-Wesley, 1991.
- \_\_\_\_\_\_.; BARRY, D. K. The object data standard : ODMG 3.0. Morgan Kaufmann, 2000.
- \_\_\_\_\_\_.; SKEEN, J. Object operations benchmark. TODS , v. 17, n. 1, mar. 1992.
- \_\_\_\_\_\_. (Ed.). The object database standard : ODMG-93, release 1.2. Morgan Kaufmann, 1993.
- \_\_\_\_\_\_.  (Ed.). The  object  database  standard :  ODMG,  release  2.0. Morgan Kaufmann, 1997.
- CERI,  S.;  FRATERNALI,  P. Designing  database  applications  with objects and rules : The IDEA methodology. Addison-Wesley, 1997.
- \_\_\_\_\_\_.;  OWICKI,  S.  On  the  use  of  optimistic  methods  for  concurrency  control  in  distributed  databases. Proc.  Sixth  Berkeley Workshop on Distributed Data Management and Computer Networks , fev. 1983.

- \_\_\_\_\_\_.; PELAGATTI, G. Correctness of query execution strategies in distributed databases. TODS , v. 8, n. 4, dez. 1984.
- \_\_\_\_\_\_.; \_\_\_\_\_\_. Distributed databases : Principles and systems. McGraw-Hill, 1984a.
- \_\_\_\_\_\_.; TANCA, L. Optimization of systems of algebraic equations for evaluating datalog queries. In: VLDB , 1987.
- \_\_\_\_\_\_.; GOTTLOB, G.; TANCA, L. Logic programming and databases . Springer-Verlag, 1990.
- \_\_\_\_\_\_.; NAVATHE, S.; WIEDERHOLD, G. Distribution design of logical database schemas. TSE , v. 9, n. 4, jul. 1983.
- \_\_\_\_\_\_.; NEGRI, M.; PELAGATTI, G. Horizontal data partitioning in database design. In: SIGMOD , 1982.
- CESARINI, F.; SODA, G. A dynamic hash method with signature. TODS , v. 16, n. 2, jun. 1991.
- CHAKRABARTI,  S. Mining  the  Web : Discovering  knowledge  from hypertext data. Morgan-Kaufmann, 2002.
- \_\_\_\_\_\_. et al. Mining the Web's link structure. Computer , v. 32, n. 8, p. 60-67, ago 1999.
- CHAKRAVARTHY, S. Active database management systems: Requirements, state-of-the-art, and an evaluation. In: ER Conference , 1990.
- \_\_\_\_\_\_. Divide and conquer: A basis for augmenting a conventional query  optimizer  with  multiple  query  processing  capabilities.  In: ICDE , 1991.
- \_\_\_\_\_\_. et al. HiPAC: A research project in active, time constrained database management. Relat√≥rio t√©cnico final XAIT-89-02 , Xerox Advanced Information Technology, ago. 1989.
- \_\_\_\_\_\_. et al. Design of sentinel: An object-oriented DBMS with event-based rules. Information and Software Technology , v. 36, n. 9, 1994.
- \_\_\_\_\_\_. et al. Database supported co-operative problem solving. International Journal of Intelligent Cooperative Information Systems , v. 2, n. 3, set. 1993.
- CHAKRAVARTHY, U.; GRANT, J.; MINKER, J. Logic-based approach to semantic query optimization. TODS , v. 15, n. 2, jun. 1990.
- CHALMERS, M.; CHITSON, P. Bead: Explorations in information visualization. Proc. ACM SIGIR International Conference , jun. 1992.
- CHAMBERLIN, D. et al. 'SEQUEL 2: A unified approach to data definition, manipulation and control. IBM Journal of Research and Development , v. 20, n. 6, nov. 1976.
- \_\_\_\_\_\_. et al. A history and evaluation of system R. CACM , v. 24, n. 10, out. 1981.
- \_\_\_\_\_\_.; BOYCE, R. 'SEQUEL: A structured english query language. In: SIGMOD , 1974.
- CHAN, C.; OOI, B.; LU, H. Extensible buffer management of indexes. In: VLDB , 1992.
- CHANDY, K. et al. analytical models for rollback and recovery strategies in database systems. TSE , v. 1, n. 1, mar. 1975.
- CHANG, C. On the evaluation of queries containing derived relations in a relational database . In: GALLAIRE et al., 1981.
- \_\_\_\_\_\_.;  WALKER, A. PROSQL: A prolog programming interface with SQL/DS. In: EDS , 1984.
- CHANG, E.; KATZ, R. Exploiting inheritance and structure semantics for effective clustering and buffering in object-oriented databases. In: SIGMOD , 1989.
- CHANG, N.; FU, K. Picture query languages for pictorial databases. IEEE Computer , v. 14, n. 11, nov. 1981.
- CHANG, P.; MYRE, W. OS/2 EE database manager: Overview and technical highlights. IBM Systems Journal , v. 27, n. 2, 1988.
- CHANG, S.; LIN, B.; WALSER, R. Generalized zooming techniques for pictorial database systems. NCC , AFIPS, v. 48, 1979.
- CHATZOGLU, P. D.; McCAULAY, L. A. Requirements capture and analysis: A survey of current practice. Requirements Engineering , p. 75-88, 1997.
- CHAUDHRI, A.; RASHID, A.; ZICARI, R. (Eds.). XML data management : Native XML and XML-Enabled database systems. Addison-Wesley, 2003.
- CHAUDHURI, S.; DAYAL, U. An overview of data warehousing and OLAP technology. SIGMOD Record , v. 26, n. 1, mar. 1997.
- CHEN, M.; YU, P. Determining beneficial semijoins for a join sequence in distributed query processing. In: ICDE , 1991.
- \_\_\_\_\_\_.; HAN, J.; YU, P. S. Data mining: An overview from a database perspective. TKDE , v. 8, n. 6, dez. 1996.
- CHEN, P. The entity relationship mode - Toward a unified view of data. TODS , v. 1, n. 1, mar. 1976.
- \_\_\_\_\_\_.; PATTERSON, D. Maximizing performance in a striped disk array. In: Proceedings of Symposium on Computer Architecture, IEEE . New York, 1990.
- \_\_\_\_\_\_.  et  al.  RAID  high  performance,  reliable  secondary  storage. ACMComputing Surveys , v. 26, n. 2, 1994.
- CHEN, Q.; KAMBAYASHI, Y. Nested relation based database knowledge representation. In: SIGMOD , 1991.
- CHENG, J. Effective clustering of complex objects in object-oriented databases. In: SIGMOD , 1991.
- CHEUNG, D. et al. A fast and distributed algorithm for mining association rules. In: Proc. Int. Conf. on Parallel and Distributed Information Systems , ( PDIS ), 1996.
- CHILDS, D. Feasibility of a set theoretical data structure - A general structure based on a reconstituted definition of relation. Proc. IFIP Congress , 1968.
- CHIMENTI, D. et al. An overview of the LDL system. IEEE Data Engineering Bulletin , v. 10, n. 4, p. 52-62, 1987.
- \_\_\_\_\_\_. et al. The LDL system prototype. TKDE , v. 2, n. 1, mar. 1990. CHIN,  F.  Security  in  statistical  databases  for  queries  with  small counts. TODS , v. 3, n. 1, mar. 1978.
- \_\_\_\_\_\_.; OZSOYOGLU, G. Statistical database design. TODS , v. 6, n. 1, mar. 1981.
- CHINTALAPATI, R.; KUMAR, V.; DATTA, A. An adaptive location management algorithm for mobile computing. Proc. 22nd Annual Conf. on Local Computer Networks  LCN '97 ( ). Minneapolis, 1997.
- CHOU, H.-T.;  DeWITT,  D.  An  evaluation  of  buffer  management strategies or relational databases. In: VLDB, p. 127-141, 1985.
- \_\_\_\_\_\_.; KIM, W. A unifying framework for version control in a CAD environment. In: VLDB, p. 336-344, 1986.
- CHRISTODOULAKIS, S. et al. Development of a multimedia information system for an office environment. In: VLDB , 1984.
- \_\_\_\_\_\_.;  FALOUTSOS,  C.  Design  and  performance  considerations for an optical disk-based multimedia object server. IEEE Computer , v. 19, n. 12, dez. 1986.
- CHRYSANTHIS, P. Transaction processing in a mobile computing environment. Proc. IEEE Workshop on Advances in Parallel and Distributed Systems , p. 77-82, out. 1993.
- CHU, W.; HURLEY, P. Optimal query processing for distributed database systems. IEEE Transactions on Computers , v. 31, n. 9, set. 1982.
- CIBORRA, C.; MIGLIARESE, P.; ROMANO, P. A methodological inquiry of organizational noise in socio-technical systems. Human Relations , v. 37, n. 8, 1984.
- CLAYBROOK, B. File management techniques . Wiley, 1992.
- \_\_\_\_\_\_. OLTP : OnLine transaction processing systems. Wiley, 1992. CLEMENTINI, E.; Di FELICE, P. Spatial operators. In: SIGMOD Record , v. 29, n. 3, p. 31-38, 2000.
- CLIFFORD, J.; TANSEL, A. On an algebra for historical relational databases: Two views. In: SIGMOD , 1985.
- CLOCKSIN, W. F.; MELLISH, C. S. Programming in prolog : Using the ISO standard. 5. ed. Springer, 2003.
- COCKCROFT, S. A taxonomy of spatial data integrity constraints. GeoInformatica , p. 327-343, 1997.

- CODASYL. Data description language journal of development . Canadian Government Publishing Centre, 1978.
- CODD, E. A relational model for large shared data banks. CACM , v. 13, n. 6, jun. 1970.
- \_\_\_\_\_\_. A data base sublanguage founded on the relational calculus. Proc. ACM SIGFIDET Workshop on Data Description, Access, and Control , nov. 1971.
- \_\_\_\_\_\_. Relational completeness of data base sublanguages . In: RUSTIN, 1972.
- \_\_\_\_\_\_. Further normalization of the data base relational model . In: RUSTIN, 1972a.

\_\_\_\_\_\_.  Recent  investigations  in  relational  database  systems. Proc. IFIP Congress , 1974.

- \_\_\_\_\_\_. How about recently? (English dialog with relational data bases using rendezvous version 1). In: SHNEIDERMAN, 1978.
- \_\_\_\_\_\_. Extending the database relational model to capture more meaning. TODS , v. 4, n. 4, dez. 1979.
- \_\_\_\_\_\_. Relational database: A practical foundation for productivity. CACM , v. 25, n. 2, dez. 1982.
- \_\_\_\_\_\_. Is your DBMS really relational? e Does your DBMS run by the rules?. Computer World , 14 out. e 21 out. 1985.
- \_\_\_\_\_\_. An evaluation scheme for database management systems that are claimed to be relational. In: ICDE , 1986.
- \_\_\_\_\_\_. Relational model for data management-version 2. Addison-Wesley, 1990.
- CODD, E. F.; CODD, S. B.; SALLEY, C. T. Providing OLAP (On-line analytical processing) to user analyst: An IT mandate, um informe oficial. Dispon√≠vel em: &lt;http://www.cs.bgu.ac.il/~dbm031/dw042/ Papers/olap\_to\_useranalysts\_wp.pdf&gt;, 1993. (n√£o consegui acessar a p√°gina em 08/11/10)
- COMER, D. The ubiquitous B-tree. ACM Computing Surveys , v. 11, n. 2, jun. 1979.

\_\_\_\_\_\_.

- Computer networks and internets . 5. ed. Prentice-Hall, 2008.
- COOLEY, R. The use of Web structure and content to identify subjectively interesting Web usage patterns. ACM Trans . On Internet Technology, v. 3, n. 2, p. 93-116, maio 2003.
- \_\_\_\_\_\_.; MOBASHER, B.; SRIVASTAVA, J. Web mining: Information and pattern discovery on the world wide Web. In: Proc. Ninth IEEE Int. Conf. on Tools with Artificial Intelligence  ICTAI ( ), p. 558-567, nov. 1997.
- \_\_\_\_\_\_.; \_\_\_\_\_\_.; \_\_\_\_\_\_. Automatic personalization based on Web usage mining. CACM , v. 43, n. 8, ago. 2000.
- CORCHO,  C.;  FERNANDEZ-LOPEZ,  M.;  GOMEZ-PEREZ,  A. Methodologies, tools and languages for building ontologies. Where is their meeting point? DKE , v. 46, n. 1, jul. 2003.
- CORNELIO, A.; NAVATHE, S. Applying active database models for simulation. In: Proceedings of 1993 Winter Simulation Conference , IEEE. Los Angeles, dez. 1993.
- CORSON, S.; MACKER, J. Mobile ad-hoc networking: Routing protocol  performance  issues  and  performance  considerations.  IETF Request for Comments n. 2501 , jan. 1999. Dispon√≠vel em: &lt;www. ietf.org/rfc/rfc2501.txt&gt;. Acesso em: 07 nov. 2010.
- COSMADAKIS, S.; KANELLAKIS, P. C.; VARDI, M. Polynomial-time implication problems for unary inclusion dependencies. JACM ,  v. 37, n. 1, p. 15-46, 1990.
- COVI, L.; KLING, R. Organizational dimensions of effective digital library use: Closed rational and open natural systems models. Journal of American Society of Information Science  JASIS ( ),  v.  47,  n.  9,  p. 672-689, 1996.
- CROFT, B.; METZLER, D.; STROHMAN, T. Search engines : Information retrieval in practice. Addison-Wesley, 2009.
- CRUZ, I. Doodle: A visual language for object-oriented databases. In: SIGMOD , 1992.
- CURTICE, R. Data dictionaries: An assessment of current practice and problems. In: VLDB , 1981.
- CUTICCHIA, A. et al. The GDB human genome database anno 1993. Nucleic Acids Research , v. 21, n. 13, 1993.
- CZEJDO, B. et al.  An  algebraic  language  for  graphical  query  formulation using an extended entity-relationship model. Proc. ACM Computer Science Conference , 1987.
- DAHL, R.; BUBENKO, J. IDBD: An interactive design tool for CODASYL DBTG type databases. In: VLDB , 1982.
- DAHL, V. Logic programming for constructive database systems. In: EDS , 1984.
- DANFORTH, S.; TOMLINSON, C. Type theories and object-oriented programming. ACM Computing Surveys , v. 20, n. 1, p. 29-72, 1998.
- DAS,  S. Deductive  databases  and  logic  programming .  Addison-Wesley, 1992.
- \_\_\_\_\_\_. et al. Clouded data: Comprehending scalable data management systems. UCSB CS Technical Report 2008-18 , nov. 2008.
- DATE, C. An introduction to database systems . v. 2. Addison-Wesley, 1983.
- \_\_\_\_\_\_.  The  outer  join. Proc.  Second  International  Conference  on Databases  ICOD-2 ( ), 1983a.
- \_\_\_\_\_\_. A critique of the SQL database language. ACM SIGMOD Record , v. 14, n. 3, nov. 1984.
- \_\_\_\_\_\_. The database relational model :  A  retrospective  review  and analysis: A historical account and assessment of E. F. Codd's contribution to the field of database technology. Addison-Wesley, 2001. \_\_\_\_\_\_. An introduction to database systems . 8.  ed.  Addison-Wesley, 2004.
- DATE, C. J.;  DARWEN, H. A guide  to  the  SQL  standard .  3.  ed. Addison-Wesley, 1993.
- DATE, C.; WHITE, C. A guide to SQL/DS . Addison-Wesley, 1988. \_\_\_\_\_\_.; \_\_\_\_\_\_. A guide to DB2 . 3. ed. Addison-Wesley, 1989.
- DAVIES, C. Recovery semantics for a DB/DC system. Proc. ACM National Conference , 1973.
- DAYAL, U. et al. PROBE final report . Technical report CCA-87-02, computer corporation of America, dez. 1987.
- \_\_\_\_\_\_.; BERNSTEIN, P. On the updatability of relational views. In: VLDB , 1978.
- \_\_\_\_\_\_.; HSU, M.; LADIN, R. A transaction model for long-running activities. In: VLDB , 1991.
- DBTG. Report of the CODASYL data base task group . ACM, abril 1971.
- DEELMAN, E.; CHERVENAK, A. L. Data management challenges of data-intensive scientific workflows. In: Proc. IEEE International Symposium on Cluster, Cloud, and Grid Computing , p. 687-692, 2008.
- DELCAMBRE, L.; LIM, B.; URBAN, S. Object-centered constraints. In: ICDE , 1991.
- DeMARCO, T. Structured analysis and system specification . Prentice-Hall, 1979.
- DeMERS, M. Fundamentals of GIS . John Wiley, 2002.
- DeMICHIEL, L. Performing operations over mismatched domains. In: ICDE , 1989.
- DENNING, D. Secure statistical databases with random sample queries. TODS , v. 5, n. 3, set. 1980.
- DENNING, D. E.; DENNING, P. J. Data security. ACM Computing Surveys , v. 11, n. 3, p. 227-249, set. 1979.
- DENNING, D. et al. A multi-level relational data model. In: Proc. IEEE Symp. On Security and Privacy , p. 196-201, 1987.
- DESHPANDE, A. An implementation for nested relational databases . Relat√≥rio T√©cnico. Disserta√ß√£o de Ph.D. - Indiana University, 1989.
- DEVOR, C.; WEELDREYER, J. DDTS: A testbed for distributed database research. Proc. ACM Pacific Conference , 1980.
- DeWITT, D. et al. Implementation techniques for main memory databases. In: SIGMOD , 1984.

- \_\_\_\_\_\_. et al. The gamma database machine project. TKDE , v. 2, n. 1, mar. 1990.
- \_\_\_\_\_\_. et al. A study of three alternative workstation server architectures for object-oriented database systems. In: VLDB , 1990.

DHAWAN, C.

Mobile computing

.

McGraw-Hill, 1997.

- DI, S. M. Distributed data management in grid environments .  Wiley, 2005. DIETRICH, S.; FRIESEN, O.; CALLISS, W. On deductive and object oriented databases : The VALIDITY experience. Technical Report. Arizona State University, 1999.
- DIFFIE, W.; HELLMAN, M. Privacy and authentication. Proceedings of the IEEE , v. 67, n. 3, p. 397-429, mar. 1979.
- DIMITROVA, N. Multimedia content analysis and indexing for filtering and retrieval applications. Information Science , edi√ß√£o especial sobre tecnologias de informa√ß√£o de multim√≠dia, Parte 1, v. 2, n. 4, 1999.
- DIPERT, B.; LEVY, M. Designing with flash memory .  Annabooks, 1993. DITTRICH, K. Object-oriented database systems : The notion and the issues. In: DITTRICH e DAYAL, 1986.
- \_\_\_\_\_\_.; DAYAL, U. (Eds.). Proc. International Workshop on Object-Oriented Database Systems . IEEE CS, Pacific Grove, CA, set. 1986.
- \_\_\_\_\_\_; KOTZ, A.; MULLE, J. An event/trigger mechanism to enforce complex consistency constraints in design databases. In: ACM SIGMOD Record , v. 15, n. 3, 1986.
- DKE. Special Issue on Natural Language Processing. DKE , v. 22, n. 1, 1997.
- DODD, G. APL - A language for associative data handling in PL/I. Proc. Fall Joint Computer Conference. AFIPS, v. 29, 1969.
- \_\_\_\_\_\_.  Elements  of  data  management  systems. ACM  Computing Surveys , v. 1, n. 2, jun. 1969.
- DOGAC, A. Special section on electronic commerce. ACM SIGMOD Record , v. 27, n. 4, dez. 1998.
- \_\_\_\_\_\_. et al. (Eds.). Advances in Object-oriented Databases Systems. NATO ASI series . Series F: Computer and systems sciences, v. 130. Springer-Verlag, 1994.

DOS SANTOS, C.; NEUHOLD, E.; FURTADO, A. A data type approach to the entity-relationship model. In: ER Conference , 1979. DU, D.; TONG, S. Multilevel extendible hashing: A file structure for very large databases. TKDE , v. 3, n. 3, set. 1991.

- DU, H.; GHANTA, S. A framework for efficient IC/VLSI CAD databases. In: ICDE , 1987.
- DUMAS, P. et al. MOBILE-burotique: Prospects for the future. In: Naffah , 1982.
- DUMPALA, S.; ARORA, S. Schema translation using the entity-relationship approach. In: ER Conference , 1983.
- DUNHAM,  M.;  HELAL,  A.  Mobile  computing  and  databases: Anything new? ACM SIGMOD Record , v. 24, n. 4, dez. 1995.
- DWYER, S. et al. A diagnostic digital imaging system. Proc. IEEE CS Conference on Pattern Recognition and Image Processing , jun. 1982. Proce-
- EASTMAN, C. (1987) Database facilities for engineering design. edings of the IEEE , v. 69, n. 10, out. 1981.
- EDS. Expert database systems. KERSCHBERG, L. (Ed.). ( Proc. First International Workshop on Expert Database Systems. Kiawah Island, SC, out. 1984). Benjamin/Cummings, 1986.
- EDS. Expert Database Systems. KERSCHBERG, L. (Ed.). ( Proc. First International Conference on Expert Database Systems , Charleston. SC, abril 1986). Benjamin/ Cummings, 1987.
- EDS. Expert Database Systems. KERSCHBERG, L. (Ed.). ( Proc. Second International Conference on Expert Database Systems. Tysons Corner, VA, abril 1988). Benjamin/Cummings.
- EICK, C. A Methodology for the design and transformation of conceptual schemas. In: VLDB , 1991.
- ElABBADI, A.; TOUEG, S. The group paradigm for concurrency control. In: SIGMOD , 1988.
- \_\_\_\_\_\_.; \_\_\_\_\_\_. Maintaining availability in partitioned replicated databases. TODS , v. 14, n. 2, jun. 1989.
- ELLIS, C.; NUTT, G. Office information systems and computer science. ACM Computing Surveys , v. 12, n. 1, mar. 1980.
- ELMAGARMID, A. K. (Ed.). Database transaction models for advanced applications . Morgan Kaufmann, 1992.
- ELMAGARMID, A.; HELAL,  A.  Supporting  updates  in  heterogeneous distributed database systems. In: ICDE, p. 564-569, 1988.
- \_\_\_\_\_\_. et al.  A  multidatabase  transaction  model  for  interbase.  In: VLDB , 1990.
- ELMASRI, R.; LARSON, J. A graphical query facility for ER databases. In: ER Conference , 1985.
- \_\_\_\_\_\_.; WIEDERHOLD, G. Data model integration using the structural model. In: SIGMOD , 1979.
- \_\_\_\_\_\_.; \_\_\_\_\_\_. Structural properties of relationships and their representation. NCC , AFIPS, v. 49, 1980.
- \_\_\_\_\_\_.; \_\_\_\_\_\_. GORDAS: A formal, high-level query language for the entity-relationship model. In: ER Conference , 1981.
- \_\_\_\_\_\_.; WUU, G. A temporal model and query language for ER databases. In: ICDE , 1990.
- \_\_\_\_\_\_.;  \_\_\_\_\_\_.  The  time  index:  An  access  structure  for  temporal data. In: VLDB , 1990a.
- \_\_\_\_\_\_.; JAMES, S.; KOURAMAJIAN, V. Automatic class and method generation for object-oriented databases. Proc. Third International Conference on Deductive and Object-Oriented Databases ( DOOD-93 ). Phoenix, AZ, dez. 1993.
- \_\_\_\_\_\_.; KOURAMAJIAN, V.; FERNANDO, S. Temporal database modeling: An object-oriented approach. CIKM , nov. 1993.
- \_\_\_\_\_\_.; LARSON, J.; NAVATHE, S. Schema integration algorithms for  federated  databases  and  logical  database  design .  Honeywell CSDD, Relat√≥rio t√©cnico CSC-86-9, n. 8212, jan. 1986.
- \_\_\_\_\_\_.; SRINIVAS, P.; THOMAS, G. Fragmentation and query decomposition in the ECR model. In: ICDE , 1987.
- \_\_\_\_\_\_.; WEELDREYER, J.; HEVNER, A. The category concept: An extension to the entity-relationship model. DKE , v. 1, n. 1, maio 1985.
- ENGELBART, D.; ENGLISH, W. A research center for augmenting human intellect. Proc. Fall Joint Computer Conference . AFIPS, dez. 1968.
- EPSTEIN, R.; STONEBRAKER, M.; WONG, E. Distributed query processing in a relational database system. In: SIGMOD , 1978.
- ER CONFERENCE. Entity-Relationship  Approach  to  Systems  Analysis and Design. CHEN, P. (Ed.). ( Proc. First International Conference on  Entity-Relationship  Approach. Los  Angeles,  dez.  1979).  North-Holland, 1980.
- ER CONFERENCE. Entity-Relationship Approach to Information Modeling and Analysis. CHEN, P. (Ed.). ( Proc.  Second International Conference on Entity Relationship Approach -, Washington, out. 1981). Elsevier Science, 1981.
- ER  CONFERENCE. Entity-Relationship  Approach  to  Software Engineering.  DAVIS,  C.  et  al.  (Eds.). (Proc.  Third  International Conference on Entity-Relationship Approach. Anaheim, CA, out. 1983). North-Holland, 1983.
- ER CONFERENCE . Proc. Fourth International Conference on Entity-Relationship Approach. LIU, J. (Ed.). IEEE CS. Chicago, out. 1985.
- ER CONFERENCE .  Proc.  Fifth  International  Conference  on  Entity-Relationship Approach. SPACCAPIETRA, S. (Ed.). Express-Tirages. Dijon, France, nov. 1986.
- ER CONFERENCE . Proc. Sixth International Conference on Entity-Relationship Approach. MARCH, S. (Ed.). Nova York, nov. 1987.
- ER CONFERENCE . Proc. Seventh International Conference on Entity-Relationship Approach. BATINI, C. (Ed.). Roma, nov. 1988.

- ER CONFERENCE . Proc. Eighth International Conference on Entity-Relationship Approach. LOCHOVSKY, F. (Ed.). Toronto, out. 1989.
- ER CONFERENCE .  Proc.  Ninth  International  Conference  on  Entity-Relationship Approach. KANGASSALO, H. (Ed.). Lausanne, Su√≠√ßa, set. 1990.
- ER CONFERENCE .  Proc.  Tenth  International  Conference  on  Entity-Relationship Approach. TEOREY, T. (Ed.). San Mateo, CA, out. 1991.
- ER  CONFERENCE .  Proc.  Eleventh  International  Conference  on Entity-Relationship  Approach.  PERNUL,  G.;  TJOA,  A.  (Eds.). Karlsruhe, Alemanha, out. 1992.
- ER CONFERENCE . Proc. Twelfth International Conference on Entity-Relationship Approach. ELMASRI, R.; KOURAMAJIAN, V. (Eds.). Arlington, TX, dez. 1993.
- ER CONFERENCE .  Proc.  Thirteenth International Conference on Entity-Relationship Approach. LOUCOPOULOS, P.; THEODOULIDIS, B. (Eds.). Manchester, Inglaterra, dez. 1994.
- ER CONFERENCE. Proc. Fourteenth International Conference on ER-OO Modeling. PAPAZOUGLOU, M.; TARI, Z. (Eds.). Brisbane, Austr√°lia, dez. 1995.
- ER  CONFERENCE .  Proc.  Fifteenth  International  Conference  on Conceptual Modeling. THALHEIM, B. (Ed.). Cottbus, Alemanha, out. 1996.
- ER  CONFERENCE .  Proc.  Sixteenth  International  Conference  on Conceptual Modeling. EMBLEY, D. (Ed.). Los Angeles, out. 1997.
- ER CONFERENCE . Proc. Seventeenth International Conference on Conceptual Modeling. LING, T.-K. (Ed.). Cingapura, nov. 1998.
- ER  CONFERENCE.  Proc.  Eighteenth  Conference  on  Conceptual Modeling. AKOKA,  J.  et  al.  (Eds.).  LNCS  1728.  Paris,  Fran√ßa, Springer, 1999.
- ER  CONFERENCE. Proc.  Nineteenth  Conference  on  Conceptual Modeling. LAENDER, A.; LIDDLE, S.; STOREY, V. (Eds.). LNCS 1920. Salt Lake City, Springer, 2000.
- ER  CONFERENCE.  Proc.  Twentieth  Conference  on  Conceptual  Modeling. KUNII, H.; JAJODIA, S.; SOLVEBERG, A. (Eds.). LNCS 2224. Yokohama, Jap√£o, Springer, 2001.
- ER CONFERENCE. Proc. 21st Int. Conference on Conceptual Modeling. SPACCAPIETRA, S.; MARCH de, S.; KAMBAYASHI, Y. (Eds.). LNCS 2503. Tampere, Finl√¢ndia, Springer, 2002.
- ER CONFERENCE. Proc. 22nd Int. Conference on Conceptual Modeling. SONG, I.-Y. et al. (Eds.). LNCS 2813. Tampere, Finl√¢ndia, Springer, 2003.
- ER  CONFERENCE.  Proc.  23rd  Int.  Conference  on  Conceptual Modeling. ATZENI, P. et al. (Eds.). LNCS 3288. Shanghai, China, Springer, 2004.
- ER CONFERENCE. Proc. 24th Int. Conference on Conceptual Modeling. DELACAMBRE, L. M. L. et al. (Eds.). LNCS 3716. Klagenfurt, √Åustria, Springer, 2005.
- ER CONFERENCE. Proc. 25th Int. Conference on Conceptual Modeling. EMBLEY, D.; OLIVE, A.; RAM, S. (Eds.). LNCS 4215. Tucson, AZ, Springer, 2006.
- ER CONFERENCE. Proc . 26th Int. Conference on Conceptual Modeling. PARENT, C. et al. (Eds.). LNCS 4801. Auckland, Nova Zel√¢ndia, Springer, 2007.
- ER  CONFERENCE.  Proc.  27th  Int.  Conference  on  Conceptual Modeling. LI, Q. et al. (Eds.). LNCS 5231. Barcelona, Espanha, Springer, 2008.
- ER CONFERENCE. Proc. 28th Int. Conference on Conceptual Modeling. LAENDER, A. et al.  (Eds.).  LNCS  5829.  Gramado,  RS, Brasil, Springer, 2009.
- ER CONFERENCE . Proc. 29th Int. Conference on Conceptual Modeling. LNCS. Vancouver, Canada, Springer, 2010.
- ESRI. (2009). The geodatabase: Modeling and managing spatial data. In: ArcNews , v. 30, n. 4, ESRI, Winter 2008/2009.
- ESTER, M.; KRIEGEL, H.-P.; JORG, S. Algorithms and applications for spatial data mining. In: Research Monograph in GIS . CRC Press, 2001.
- \_\_\_\_\_\_. et al. A density-based algorithm for discovering clusters in large spatial databases with noise. In: KDD . AAAI Press, p. 226231, 1996.
- ESWARAN, K.; CHAMBERLIN, D. Functional specifications of a subsystem for database integrity. In: VLDB , 1975.
- \_\_\_\_\_\_. et al. The notions of consistency and predicate locks in a data base system. CACM , v. 19, n. 11, nov. 1976.
- ETZIONI, O. The world-wide Web: quagmire or gold mine? CACM , v. 39, n. 11, p. 65-68nov. 1996.
- EVERETT, G.; DISSLY, C.; HARDGRAVE, W. (1971) RFMS User Manual . TRM-16, Computing Center, Universidade do Texas. Austin, 1981.
- FAGIN, R. Multivalued dependencies and a new normal form for relational databases. TODS , v. 2, n. 3, set. 1977.
- \_\_\_\_\_\_.  Normal  forms  and  relational  database  operators.  In: SIGMOD , 1979.
- \_\_\_\_\_\_. A normal form for relational databases that is based on domains and keys. TODS , v. 6, n. 3, set. 1981.
- \_\_\_\_\_\_. et al. Extendible hashing - A fast access method for dynamic files. TODS , v. 4, n. 3, set. 1979.
- FALCONE, S.; PATON, N. Deductive object-oriented database systems: A survey. Proc. 3rd International Workshop Rules in Database Systems  RIDS '97 ( ). Skovde, Su√©cia, jun. 1997.
- FALOUTSOS,  C. Searching  multimedia  databases  by  content . Kluwer, 1996.
- FALOUTSOS, C. et al. Efficient and effective querying by image content. Journal of Intelligent Information Systems , v. 3, n. 4, 1994.
- FALOUTSOS, G.; JAGADISH, H. On B-tree indices for skewed distributions. In: VLDB , 1992.
- FAN, J. et al. Automatic image annotation by using concept-sensitive salient objects for image content representation. In: SIGIR , 2004.
- FARAG, W.; TEOREY, T. FunBase: A function-based information management system. CIKM , nov. 1993.
- FARAHMAND, F. et al. Managing vulnerabilities of information systems to security incidents. Proc. ACM 5th International Conference on Electronic Commerce, ICEC 2003, p. 348-354  Pittsburgh, . PA, set. 2003.
- \_\_\_\_\_\_. et al. A management perspective on risk of security threats to information systems. Journal of Information Technology &amp; Management , v. 6, p. 203-225, 2005.
- FAYYAD, U. et al. Advances in knowledge discovery and data mining . MIT Press, 1997.
- FELLBAUM, C. (Ed.). WordNet : An electronic lexical database. MIT Press, 1998.
- FENSEL, D. The semantic Web and its languages. IEEE Intelligent Systems , v. 15, n. 6, p. 67-73, nov./dez. 2000.
- \_\_\_\_\_\_. Ontologies :  Silver  bullet  for  knowledge  management  and electronic commerce. 2. ed. Springer-Verlag, Berlim, 2003.
- FERNANDEZ, E.; SUMMERS, R.; WOOD, C. Database  security and integrity . Addison-Wesley, 1981.
- FERRIER, A.; STANGRET, C. Heterogeneity in the distributed database management system SIRIUS-DELTA. In: VLDB , 1982.
- FISHMAN, D. et al. IRIS: An object-oriented DBMS. TOIS , v. 5, n. 1, p. 48-69, 1987.
- FLICKNER, M. et al. Query by image and video content: The QBIC system. IEEE Computer , v. 28, n. 9, p. 23-32, set. 1995.
- FLYNN, J.; PITTS, T. Inside ArcINFO 8 . 2. ed. On Word Press, 2000.
- FOLK, M. J.; ZOELLICK, B.; RICCARDI, G. File structures : An object oriented approach with C++. 3. ed. Addison-Wesley, 1998.
- FONSECA, F. et al. Semantic granularity in ontology-driven geographic information systems. In: Annals of Mathematics and Artificial Intelligence , v. 36, n. 1-2, p. 121-151, 2002.

- FORD, D.; CHRISTODOULAKIS, S. Optimizing random retrievals from CLV format optical disks. In: VLDB , 1991.
- \_\_\_\_\_\_.;  BLAKELEY,  J.;  BANNON,  T.  Open  OODB:  A  modular object-oriented DBMS. In: SIGMOD , 1993.
- FOREMAN, G.; ZAHORJAN, J. The challenges of mobile computing. IEEE Computer , abril 1994.
- FOTOUHI, F.; GROSKY, W.; STANCHEV, P. (Eds.). Proc. of the First ACM Workshop on Many Faces of the Multimedia Semantics, MS 2007 . Augsburg, Alemanha, set. 2007.
- FOWLER, M.; SCOTT, K. UML Distilled . 2. ed. Addison-Wesley, 2000. FRANASZEK, P.; ROBINSON, J.; THOMASIAN, A. Concurrency control for high contention environments. TODS , v. 17, n. 2, jun. 1992.
- FRANK, A. A linguistically justified proposal for a spatio-temporal ontology. Um artigo em Proc. COSIT03 Int. Conf. on Spatial In--formation Theory. LNCS 2825. Ittingen, Su√≠√ßa , set. 2003.
- FRANKLIN, F. et al. Crash recovery in client-server EXODUS. In: SIGMOD , 1992.
- FRATERNALI, P. Tools and approaches for data intensive Web applications: A survey. ACM Computing Surveys , v. 31, n. 3, set. 1999. FRENKEL, K. The human genome project and informatics. CACM , nov. 1991.
- FRIESEN, O. et al. Applications of deductive object-oriented databases using DEL . In: RAMAKRISHNAN, 1995.
- FRIIS-CHRISTENSEN,  A.;  TRYFONA,  N.;  JENSEN,  C.  S.  Requirements and research issues in geographic data modeling. Proc. 9th ACM International Symposium on Advances in Geographic Information Systems , 2001.

FUGINI, M. et al. Database security . ACM Press e Addison-Wesley, 1995. FURTADO, A. Formal aspects of the relational model. Information Systems , v. 3, n. 2, 1978.

- GADIA, S. A homogeneous relational model and query language for temporal databases. TODS , v. 13, n. 4, dez. 1988.
- GAIT,  J.  The  optical  file  cabinet:  A  random-access  file  system  for write-once optical disks. IEEE Computer , v. 21, n. 6, jun. 1988.
- GALLAIRE, H.; MINKER, J. (Eds.). Logic and databases .  Plenum Press, 1978.
- \_\_\_\_\_\_.;  \_\_\_\_\_\_\_.;  NICOLAS, J. Logic and databases: A deductive approach. ACM Computing Surveys , v. 16, n. 2, jun. 1984.
- \_\_\_\_\_\_.; \_\_\_\_\_\_.; \_\_\_\_\_\_. (Eds.). Advances in database theory . v. 1. Plenum Press, 1981.
- GAMAL-ELDIN, M.; THOMAS, G.; ELMASRI, R. Integrating relational  databases  with  support  for  updates. Proc.  International Symposium  on  Databases  in  Parallel  and  Distributed  Systems. IEEE CS, dez. 1988.
- GANE, C.; SARSON, T. Structured systems analysis : Tools and techniques, improved systems technologies, 1977.
- GANGOPADHYAY, A.; ADAM, N. Database issues in geographic information systems . Kluwer Academic Publishers, 1997.
- GARCIA-MOLINA, H. Elections in distributed computing systems. IEEE Transactions on Computers , v. 31, n. 1, jan. 1982.
- \_\_\_\_\_\_. Using semantic knowledge for transaction processing in a distributed database. TODS , v. 8, n. 2, jun. 1983.
- \_\_\_\_\_\_.; ULLMAN, J.; WIDOM, J. Database system implementation . Prentice-Hall, 2000.
- \_\_\_\_\_\_.; \_\_\_\_\_\_.; \_\_\_\_\_\_. Database systems : The complete book. 2. ed. Prentice-Hall, 2009.
- GEDIK, B.; LIU, L. Location privacy in mobile systems: A personalized anonymization model. In: ICDCS, p. 620-629, 2005.
- GEHANI, N.; JAGDISH, H.; SHMUELI, O. Composite event specification in active databases: Model and implementation. In: VLDB , 1992. GEORGAKOPOULOS, D.; RUSINKIEWICZ, M.; SHETH, A. On serializability of multidatabase transactions through forced local con-
- flicts. In: ICDE , 1991.
- GERRITSEN, R. A preliminary system for the design of DBTG data structures. CACM , v. 18, n. 10, out. 1975.
- GHOSH, S. An application of statistical databases in manufacturing testing. In: ICDE , 1984.
- \_\_\_\_\_\_.  Statistical  data  reduction  for  manufacturing  testing.  In: ICDE , 1986.
- GIFFORD, D. Weighted voting for replicated data. SOSP , 1979.
- GLADNEY,  H.  Data  replicas  in  distributed  information  services. TODS , v. 14, n. 1, mar. 1989.
- GOGOLLA, M.; HOHENSTEIN, U. Towards a semantic view of an extended entity-relationship model. TODS , v. 16, n. 3, set. 1991. GOLDBERG, A.; ROBSON, D. Smalltalk-80 :  The  language. Addison-Wesley, 1989.
- GOLDFINE, A.; KONIG, P. A technical overview of the information resource dictionary system  IRDS ( ). 2. ed. NBS IR 88-3700. National Bureau of Standards, 1988.
- GOODCHILD, M. F. Geographical information science. International Journal of Geographical Information Systems , p. 31-45, 1992.
- \_\_\_\_\_\_. Geographical data modeling. Computers &amp; Geosciences , v. 18, n. 4, p. 401-408, 1992a.
- GORDILLO, S.; BALAGUER, F. Refining an object-oriented GIS design model: Topologies and field data. Proc. 6th ACM International Symposium on Advances in Geographic Information Systems , 1998.
- GOTLIEB, L. Computing joins of relations. In: SIGMOD , 1975.
- GRAEFE, G. Query evaluation techniques for large databases. ACM Computing Surveys , v. 25, n. 2, jun. 1993.
- \_\_\_\_\_\_.;  DeWITT, D. The EXODUS optimizer generator. In: SIGMOD , 1987.
- GRAVANO, L.; GARCIA-MOLINA, H. Merging ranks from heterogeneous sources. In: VLDB , 1997.
- GRAY,  J. Notes  on  data  base  operating  systems . In: BAYER; GRAHAM; SEEGMULLER, 1978.
- \_\_\_\_\_\_. The transaction concept: Virtues and limitations. In: VLDB , 1981.
- \_\_\_\_\_\_.; REUTER, A. Transaction processing : Concepts and techniques. Morgan Kaufmann, 1993.
- \_\_\_\_\_\_.  et  al.  The  dangers  of  replication  and  a  solution.  In: SIGMOD , 1993.
- \_\_\_\_\_\_.;  HORST, B.; WALKER, M. Parity striping of disk arrays: Low-cost reliable storage with acceptable throughput. In: VLDB , p. 148-161, 1990.
- \_\_\_\_\_\_.; LORIE, R.; PUTZOLU, G. Granularity of locks and degrees of consistency in a shared data base . In: NIJSSEN, 1975.
- \_\_\_\_\_\_.; McJONES, P.; BLASGEN, M. The recovery manager of the system R database manager. ACM Computing Surveys , v. 13, n. 2, jun. 1981.
- GRIFFITHS, P.; WADE, B. An authorization mechanism for a relational database system. TODS , v. 1, n. 3, set. 1976.
- GROCHOWSKI, E.; HOYT, R. F. Future trends in hard disk drives. IEEE Transactions on Magnetics , v. 32, n. 3, maio 1996.
- GROSKY, W. Multimedia information systems. In: IEEE Multimedia , v. 1, n. 1, Spring, 1994.
- \_\_\_\_\_\_. Managing multimedia information in database systems. In: CACM , v. 40, n. 12, dez. 1997.
- \_\_\_\_\_\_.; JAIN, R.; MEHROTRA, R. (Eds.). The handbook of multimedia information management . Prentice-Hall PTR, 1997.
- GRUBER, T. Toward principles for the design of ontologies used for knowledge  sharing. International  Journal  of  Human-Computer Studies , v. 43, n. 5-6, p. 907-928, nov./dez. 1995.
- GUPTA, R.; HOROWITZ E. Object oriented databases with applications to case, networks and VLSI CAD . Prentice-Hall, 1992.
- G√úTING, R. An introduction to spatial database systems. In: VLDB , 1994.

GUTTMAN, A. R-Trees: A dynamic index structure for spatial searching. In: SIGMOD , 1984.

- GWAYER, M. Oracle designer/2000 Web server generator technical overview (version  1.3.2).  Technical  Report,  Oracle  Corporation, set. 1996.

GYSSENS, M.; PAREDAENS, J.; Van GUCHT, D. A graph-oriented object model for database end-user interfaces. In: SIGMOD , 1990. HAAS, P.; SWAMI, A. Sampling-based selectivity estimation for joins

- using augmented frequent value statistics. In: ICDE , 1995.
- \_\_\_\_\_\_. et al.  Sampling-based estimation of the number of distinct values of an attribute. In: VLDB , 1995.

HACHEM, N.; BERRA, P. New order preserving access methods for very large files derived from linear hashing.

TKDE

,  v.  4,  n.  1,  fev.  1992.

HADZILACOS, V. An operational model for database system reliabi- lity. In:

Proceedings of SIGACT-SIGMOD Conference

, mar. 1983.

\_\_\_\_\_\_. (1988). A theory of reliability in database systems.

JACM

, v.

35, n. 1, 1986.

HAERDER, T.; REUTER, A. Principles of transaction oriented database recovery - A taxonomy. ACM Computing Surveys , v. 15, n. 4, p. 287-318, set. 1983.

\_\_\_\_\_\_.; ROTHERMEL, K. Concepts for transaction recovery in nested transactions. In: SIGMOD , 1987.

HAKONARSON, H.; GULCHER, J.; STEFANSSON, K. deCODE genetics, Inc. Pharmacogenomics Journal , p. 209-215, 2003.

HALFOND, W.; ORSO. A. AMNESIA: Analysis and monitoring for neutralizing  SQL-injection  attacks.  In: Proc.  IEEE  and  ACM Int. Conf. on Automated Software Engineering  ASE 2005 , ( ) p. 174-183, nov. 2005.

- \_\_\_\_\_\_.; VIEGAS, J.; ORSO, A. A classification of SQL injection attacks and countermeasures. In: Proc. Int. Symposium on Secure Software Engineering , mar. 2006.
- HALL, P. Optimization of a single relational expression in a relational data base system. IBM Journal of Research and Development , v. 20, n. 3, maio 1976.

HAMILTON, G.; CATTELI, R.; FISHER, M. JDBC database access with Java - A tutorial and annotated reference. Addison-Wesley, 1997.

- HAMMER, M.; McLEOD, D. Semantic integrity in a relational data base system. In: VLDB , 1975.
- \_\_\_\_\_\_.; \_\_\_\_\_\_. Database description with SDM: A semantic data model. TODS , v. 6, n. 3, set. 1981.
- \_\_\_\_\_\_.; SARIN, S. Efficient monitoring of database assertions. In: SIGMOD , 1978.
- HAN, J.; KAMBER, M.; PEI, J. Data mining : Concepts and techniques. 2. ed. Morgan Kaufmann, 2005.
- \_\_\_\_\_\_.; JIANG, C.; LUO, X. A study of concurrency control in Web-based distributed real-time database system using extended time petri nets. Proc. Int. Symposium on Parallel Architectures, Algorithms, and Networks , p. 67-72, 2004.
- \_\_\_\_\_\_.; PEI, J. e YIN, Y. Mining frequent patterns without candidate generation. In: SIGMOD , 2000.

HANSON, E. Rule condition testing and action execution in Ariel. In: SIGMOD , 1992.

HARDGRAVE,  W.  Ambiguity  in  processing  boolean  queries  on TDMS tree structures: A study of four different philosophies. TSE , v. 6, n. 4, jul. 1980.

\_\_\_\_\_\_. BOLT: A retrieval language for tree-structured database systems . In: TOU, 1984.

HAREL, D. Statecharts: A visual formulation for complex systems. In: Science of Computer Programming , v. 8, n. 3, p. 231-274, jun. 1987. HARMAN, D. Evaluation issues in information retrieval. Information Processing and Management , v. 28, n. 4, p. 439-440, 1992.

- HARRINGTON, J. Relational database management for microcomputer : Design and implementation. Holt, Rinehart, and Winston, 1987.
- HARRIS, L. The ROBOT system: Natural language processing applied to data base query. Proc. ACM National Conference , dez. 1978.
- HASKIN, R.; LORIE, R. On extending the functions of a relational database system. In: SIGMOD , 1982.
- HASSE,  C.;  WEIKUM,  G.  A  performance  evaluation  of  multi-level transaction management. In: VLDB , 1991.
- HAYES-ROTH, F.; WATERMAN, D.; LENAT, D. (Eds.). Building expert systems . Addison-Wesley, 1983.
- HAYNE, S.; RAM, S. Multi-user view integration system: An expert system for view integration. In: ICDE , 1990.
- HEILER, S.; ZDONICK, S. Object views: Extending the vision. In: ICDE , 1990.
- \_\_\_\_\_\_. et al. A flexible framework for transaction management in engineering environment . In: ELMAGARMID, 1992.
- HELAL, A. et al. Adaptive transaction scheduling. CIKM , nov. 1993. HELD, G.; STONEBRAKER, M. B-Trees reexamined. CACM , v. 21, n. 2, fev. 1978.

HENRIKSEN, C.; LAUZON, J. P.; MOREHOUSE, S. Open geodata access through standards. Standard View Archive , v. 2, n. 3, p. 169-174, 1994.

HENSCHEN, L.; NAQVI, S. On compiling queries in recursive first-order databases. JACM , v. 31, n. 1, jan. 1984.

- HERNANDEZ, H.; CHAN, E. Constraint-time-maintainable BCNF database schemes. TODS , v. 16, n. 4, dez. 1991.

HEROT, C. Spatial management of data. TODS , v. 5, n. 4, dez. 1980. HEVNER, A.; YAO, S. Query processing in distributed database systems. TSE , v. 5, n. 3, maio 1979.

HINNEBURG, A.; GABRIEL, H.-H. DENCLUE 2.0: Fast clustering based on Kernel density estimation. In: Proc. IDA'2007: Advances in Intelligent Data Analysis VII, 7th International Symposium on Intelligent  Data Analysis. LNCS 4723. Ljubljana, Eslov√™nia, set. 2007, Springer, 2007.

HOFFER, J. An empirical investigation with individual differences in database models. Proc.  Third  International  Information  Systems Conference , dez. 1982.

- \_\_\_\_\_\_.; PRESCOTT, M.; TOPI, H. Modern database management . 9. ed. Prentice-Hall, 2009.
- HOLLAND, J. Adaptation in natural and artificial systems . University of Michigan Press, 1975.
- HOLSAPPLE, C.; WHINSTON, A. (Eds.). Decision support systems theory and application . Springer-Verlag, 1987.

HOLT, R. C. Some deadlock properties of computer systems. ACM Computing Surveys , v. 4, n. 3, p. 179-196, 1972.

- HOLTZMAN J. M.; GOODMAN D. J. (Eds.). Wireless communications : Future directions. Kluwer, 1993.
- HOROWITZ, B. A run-time execution model for referential integrity maintenance. In: ICDE , p. 548-556, 1992.
- HOWSON, C. and P.; URBACH, P. Scientific reasoning : The Bayesian approach. Open Court Publishing, dez. 1993.
- HSIAO, D.; KAMEL, M. Heterogeneous databases: Proliferation, issues, and solutions. TKDE , v. 1, n. 1, mar. 1989.
- HSU, A.; IMIELINSKY, T. Integrity checking for multiple updates. In: SIGMOD , 1985.

HSU, M.; ZHANG, B. Performance evaluation of cautious waiting. TODS , v. 17, n. 3, p. 477-512, 1992.

- HULL, R.; KING, R. Semantic database modeling: Survey, applications, and research issues. ACM Computing Surveys ,  v.  19, n. 3, set. 1987.
- HUXHOLD, W. An introduction to urban geographic information systems . Oxford University Press, 1991.
- IBM. QBE Terminal Users Guide . Form Number SH20-2078-0, 1978.
- IBM. Systems application architecture common programming interface database level 2 reference . Document Number SC26-4798-01, 1992.

- ICDE. Proc. IEEE CS International Conference on Data Engineering . In: SHUEY, R. (Ed.). Los Angeles, CA, abril 1984.
- ICDE. Proc. IEEE CS International Conference on Data Engineering . In: WIEDERHOLD, G. (Ed.). Los Angeles, fev. 1986.
- ICDE. Proc. IEEE CS International Conference on Data Engineering . In: WAH, B. (Ed.). Los Angeles, fev. 1987.
- ICDE. Proc. IEEE CS International Conference on Data Engineering . In: CARLIS, J. (Ed.). Los Angeles, fev. 1988.
- ICDE. Proc. IEEE CS International Conference on Data Engineering . In: SHUEY, R. (Ed.). Los Angeles, fev. 1989.
- ICDE. Proc. IEEE CS International Conference on Data Engineering . In: LIU, M. (Ed.). Los Angeles, fev. 1990.
- ICDE. Proc.  IEEE  CS  International  Conference  on  Data  Engineering. In:  CERCONE, N.;  TSUCHIYA, M. (Eds.). Kobe, Jap√£o, abril 1991.
- ICDE. Proc. IEEE CS International Conference on Data Engineering . In: GOLSHANI, F. (Ed.). Phoenix, AZ, fev. 1992.
- ICDE. Proc. IEEE CS International Conference on Data Engineering. In:  ElMAGARMID, A.; NEUHOLD, E. (Eds.). Vienna, √Åustria, abril 1993.
- ICDE. Proc. IEEE CS International Conference on Data Engineering . Houston, TX, fev. 1994.
- ICDE. Proc. IEEE CS International Conference on Data Engineering. In: YU, P. S.; CHEN, A. L. A. (Eds.). Taipei, Taiwan, 1995.
- ICDE. Proc. IEEE CS International Conference on Data Engineering . In: SU, S. Y. W. (Ed.). Nova Orleans, 1996.
- ICDE. Proc. IEEE CS International Conference on Data Engineering. In: GRAY, W. A.; LARSON, P. A. (Eds.). Birmingham, Inglaterra, 1997.
- ICDE. Proc. IEEE CS International Conference on Data Engineering . Orlando, FL, fev. 1998.
- ICDE. Proc. IEEE CS International Conference on Data Engineering . Sydney, Austr√°lia, mar. 1999.
- ICDE. Proc. IEEE CS International Conference on Data Engineering . San Diego, CA, fev.-mar. 2000.
- ICDE. Proc. IEEE CS International Conference on Data Engineering . Heidelberg, Alemanha, abril 2001.
- ICDE. Proc. IEEE CS International Conference on Data Engineering . San Jose, CA, fev.-mar. 2002.
- ICDE. Proc. IEEE CS International Conference on Data Engineering. In: DAYAL, U.; RAMAMRITHAM, K.; VIJAYARAMAN, T. M. (Eds.). Bangalore, India, mar. 2003.
- ICDE. Proc. IEEE CS International Conference on Data Engineering . Boston, MA, mar.-abril 2004.
- ICDE. Proc. IEEE CS International Conference on Data Engineering . Tokyo, Jap√£o, abril 2005.
- ICDE. Proc. IEEE CS International Conference on Data Engineering. In: LIU, L. et al. (Eds.). Atlanta, GA, abril 2006.
- ICDE. Proc. IEEE CS International Conference on Data Engineering . Istanbul, Turquia, abril 2007.
- ICDE. Proc. IEEE CS International Conference on Data Engineering . Cancun, M√©xico, abril 2008.
- ICDE. Proc. IEEE CS International Conference on Data Engineering . Shanghai, China, mar.-abril 2009.
- ICDE. Proc. IEEE CS International Conference on Data Engineering . Long Beach, CA, mar. 2010.
- IGES. International graphics exchange specification version 2 . National Bureau of Standards, U.S. Department of Commerce, jan. 1983.
- IMIELINSKI, T.; BADRINATH, B. Mobile wireless computing: Challenges in data management. CACM , v. 37, n. 10, out. 1994.
- \_\_\_\_\_\_.; LIPSKI, W. On representing incomplete information in a relational database. In: VLDB , 1981.
- INDULSKA, M.; ORLOWSKA, M. E. On aggregation issues in spatial data management. (ACM International Conference Proceeding Series). Proc. Thirteenth Australasian Conference on Database Technologies , p. 75-84. Melbourne, 2002.

INFORMIX. Web integration option for informix dynamic server , 1998. Dispon√≠vel em: &lt;www.informix.com&gt;. Acesso em: 07 nov. 2010.

INMON, W. H. Building the data warehouse . Wiley, 1992.

- INMON, W.; STRAUSS, D.; NEUSHLOSS, G. DW 2.0 : The architecture for the next generation of data warehousing. Morgan Kaufmann, 2008.
- INTEGRIGY. An introduction to SQL injection attacks for oracle developers .  Integrigy, abril 2004. Dispon√≠vel em: &lt;www.net-security. org/dl/articles/IntegrigyIntrotoSQLInjectionAttacks.pdf&gt;. Acesso em: 07 nov. 2010.
- IETF (Internet Engineering Task Force). An architecture framework for high speed mobile ad hoc network. In: Proc. 45th IETF Meeting. Oslo, Norway, jul. 1999. Dispon√≠vel em: &lt;www.ietf.org/proceeings/ 99jul/&gt;. Acesso em: 07 nov. 2010.
- IOANNIDIS, Y.; KANG, Y. Randomized algorithms for optimizing large join queries. In: SIGMOD , 1990.
- \_\_\_\_\_\_.; \_\_\_\_\_\_. Left-deep vs. bushy trees: An analysis of strategy spaces and its implications for query optimization. In: SIGMOD , 1991.
- \_\_\_\_\_\_.; WONG, E. Transforming non-linear recursion to linear recursion. In: EDS , 1988.
- IOSSOPHIDIS, J. A translator to convert the DDL of ERM to the DDL of system 2000. In: ER Conference , 1979.
- IRANI, K.; PURKAYASTHA, S.; TEOREY, T. A designer for DBMS-processable logical database structures. In: VLDB , 1979.
- IYER et al. A framework for efficient storage security in RDBMSs. In: EDBT , p. 147-164, 2004.
- JACOBSON, I.; BOOCH, G.; RUMBAUGH, J. The unified software development process . Addison-Wesley, 1999.
- \_\_\_\_\_\_. et al. Object-oriented software engineering : A use case driven approach. Addison-Wesley, 1992.
- JAGADISH, H. Incorporating hierarchy in a relational model of data. In: SIGMOD , 1989.
- \_\_\_\_\_\_. Content-based indexing and retrieval. In: GROSKY et al., 1997. JAJODIA, S.; AMMANN, P.; McCOLLUM, C. D. Surviving information warfare attacks. IEEE Computer , v. 32, n. 4, p. 57-63, abril 1999.
- \_\_\_\_\_\_.; KOGAN, B. Integrating an object-oriented data model with multilevel  security. Proc.  IEEE  Symposium on Security and Privacy , p. 76-85, maio 1990.
- \_\_\_\_\_\_.; MUTCHLER, D. Dynamic voting algorithms for maintaining the consistency of a replicated database. TODS , v. 15, n. 2, jun. 1990.
- \_\_\_\_\_\_.; SANDHU, R. Toward a multilevel secure relational data model. In: SIGMOD , 1991.
- \_\_\_\_\_\_.; NG, P.; SPRINGSTEEL, F. The problem of equivalence for entity-relationship diagrams. TSE , v. 9, n. 5, set. 1983.
- JARDINE,  D.  (Ed.). The  ANSI/SPARC  DBMS  model . North-Holland, 1977.
- JARKE, M.; KOCH, J. Query optimization in database systems. ACM Computing Surveys , v. 16, n. 2, jun. 1984.
- JENSEN, C. et al. A glossary of temporal database concepts. ACM SIGMOD Record , v. 23, n. 1, mar. 1994.
- \_\_\_\_\_\_.; SNODGRASS, R. Temporal specialization. In: ICDE , 1992.
- \_\_\_\_\_\_. et al. Location-based services: A database perspective. Proc. ScanGIS Conference , p. 59-68, 2001.
- JHINGRAN, A.; KHEDKAR, P. Analysis of recovery in a database system using a write-ahead log protocol. In: SIGMOD , 1992.
- JING, J.; HELAL, A.; ELMAGARMID, A. Client-server computing in mobile environments. ACM Computing Surveys , v. 31, n. 2, jun. 1999.

JOHNSON, T.; SHASHA, D. The performance of current B-tree algorithms. TODS , v. 18, n. 1, mar. 1993.

JOSHI, J. et al. Security models for Web-based applications. CACM , v. 44, n. 2, p. 38-44, fev. 2001.

- JUNG, I.Y.; YEOM, H.Y. An efficient and transparent transaction management based on the data workflow of HVEM DataGrid. Proc. Challenges of Large Applications in Distributed Environments ,  p. 35-44, 2008.

KAEFER, W.; SCHOENING, H. Realizing a temporal complex-object data model. In: SIGMOD , 1992.

KAMEL, I.; FALOUTSOS, C. On packing R-trees. CIKM , nov. 1993. KAMEL, N.; KING, R. A model of data distribution based on texture analysis. In: SIGMOD , 1985.

KAPPEL, G.; SCHREFL, M. Object/behavior diagrams. In: ICDE , 1991. KARLAPALEM, K.; NAVATHE, S. B.; AMMAR, M. Optimal redesign policies to support dynamic processing of applications on a distributed relational database system. Information Systems , v. 21, n. 4, p. 353-367, 1996.

- KAROLCHIK, D. et al. The UCSC genome browser database. In: Nucleic Acids Research , v. 31, n. 1, jan. 2003.
- KATZ, R. Information management for engineering design :  Surveys in computer science. Springer-Verlag, 1985.
- \_\_\_\_\_\_.;  WONG, E. Decompiling CODASYL DML into relational queries. TODS , v. 7, n. 1, mar. 1982.
- KDD. Proc. Second International Conference on Knowledge Discovery in Databases and Data Mining. Portland, Oregon, ago. 1996.
- KE, Y.; SUKTHANKAR, R. PCA-SIFT: A more distinctive representation for local image descriptors. In: Proc. IEEE Conf. on Computer Vision and Pattern Recognition , 2004.

KEDEM, Z.; SILBERSCHATZ, A. Non-two phase locking protocols with shared and exclusive locks. In: VLDB , 1980.

- KELLER, A. Updates to relational database through views involving joins . In: SCHEUERMANN, 1982.
- KEMP, K. Spatial databases: Sources and issues. In: Environmental Modeling with GIS . Oxford University Press. New York, 1993.
- KEMPER, A.; WALLRATH, M. An analysis of geometric modeling in database systems. ACM Computing Surveys , v. 19, n. 1, mar. 1987.
- \_\_\_\_\_\_.;  LOCKEMANN, P.;  WALLRATH, M. An object-oriented database system for engineering applications. In: SIGMOD , 1987.
- \_\_\_\_\_\_.; MOERKOTTE, G.; STEINBRUNN, M. Optimizing boolean expressions in object bases. In: VLDB , 1992.
- KENT, W. Data and reality . North-Holland, 1978.
- \_\_\_\_\_\_. Limitations of record-based information models. TODS ,  v. 4, n. 1, mar. 1979.
- \_\_\_\_\_\_. Object-oriented database programming languages. In: VLDB , 1991.
- KERSCHBERG, L.; TING, P.; YAO, S. Query optimization in star computer networks. TODS , v. 7, n. 4, dez. 1982.
- KETABCHI, M. A. et al. Comparative analysis of RDBMS and OODBMS: A case study. IEEE International Conference on Manufacturing , 1990.
- KHAN, L. Ontology-based information selection . Ph.D. dissertation - University of Southern California, ago. 2000.
- KHOSHAFIAN, S.; BAKER A. Multimedia and imaging databases . Morgan Kaufmann, 1996.
- \_\_\_\_\_\_. et  al. Developing client server applications .  Morgan Kaufmann, 1992.
- KHOURY, M. Epidemiology and the continuum from genetic research to genetic testing. In: American Journal of Epidemiology, p. 297-299, 2002.
- KIFER, M.; LOZINSKII, E. A framework for an efficient implementation of deductive databases. Proc. Sixth Advanced Database Symposium. T√≥quio, ago. 1986.
- KIM, W . Modern database systems : The object model, interoperability, and beyond. ACM Press, Addison-Wesley, 1995.
- KIM, P. A taxonomy on the architecture of database gateways for the Web . Working paper TR-96-U-10 - Chungnam National University,  Taejon, Korea, 1996. Dispon√≠vel em: &lt;http://grigg.chungnam. ac.kr/ projects/UniWeb&gt;. (n√£o consegui acessar em 07/11/10)
- KIM, S.-H.; YOON, K.-J.; KWEON, I.-S. Object recognition using a generalized robust invariant feature and gestalt's law of proximity and similarity.  In: Proc.  Conf.  on  Computer  Vision  and  Pattern Recognition Workshop  CVPRW '06 ( ), 2006.
- KIM, W. On optimizing an SQL-like nested query. TODS , v. 3, n. 3, set. 1982.
- \_\_\_\_\_\_. A model of queries for object-oriented databases. In: VLDB , 1989.
- \_\_\_\_\_\_.  Object-oriented  databases:  Definition  and  research  directions. TKDE , v. 2, n. 3, set. 1990.
- \_\_\_\_\_\_. et al. Features of the ORION object-oriented database system . Microelectronics and Computer Technology Corporation. Technical Report ACA-ST-308-87, set. 1987.
- \_\_\_\_\_\_.; LOCHOVSKY, F. (Eds.). Object-oriented concepts, databases, and applications . ACM Press, Frontier Series, 1989.
- \_\_\_\_\_\_. et al. Architecture of the ORION next-generation database system. TKDE , v. 2, n. 1, p. 109-124, 1990.
- \_\_\_\_\_\_.; REINER, D. S.; BATORY, D. (Eds.). Query processing in database systems . Springer-Verlag, 1985.
- KIMBALL, R. The data warehouse toolkit . Wiley, Inc. 1996.
- KING, J. QUIST: A system for semantic query optimization in relational databases. In: VLDB , 1981.
- KITSUREGAWA, M.; NAKAYAMA, M.; TAKAGI, M. The effect of bucket size tuning in the dynamic hybrid GRACE Hash Join method. In: VLDB , 1989.

KLEINBERG, J. M. Authoritative sources in a hyperlinked environment. JACM , v. 46, n. 5, p. 604-632, set. 1999.

- KLIMBIE, J.; KOFFEMAN, K. (Eds.). Data base management . North-Holland, 1974.
- KLUG, A. Equivalence of relational algebra and relational calculus query  languages  having  aggregate  functions. JACM ,  v.  29,  n.  3, jul. 1982.
- KNUTH, D. The art of computer programming :  Sorting  and  searching. v. 3. 2. ed. Addison-Wesley, 1998.
- KOGELNIK, A. Biological  information  management  with  application to human genome data . Disserta√ß√£o de Ph.D. - Georgia Institute of Technology and Emory University, 1998.
- \_\_\_\_\_\_. et al. MITOMAP: A human mitochondrial genome database - 1998 update. Nucleic Acids Research , v. 26, n. 1, jan. 1998.
- \_\_\_\_\_\_.;  NAVATHE,  S.;  WALLACE,  D.  GENOME:  A  system  for managing  human  genome  project  data. Proceedings  of  Genome Informatics '97, Eighth Workshop on Genome Informatics. Patrocinador: Human Genome Center, Universidade de T√≥quio. T√≥quio, Jap√£o, dez. 1997.
- KOHLER, W. A survey of techniques for synchronization and recovery in decentralized computer systems. ACM Computing Surveys , v. 13, n. 2, jun. 1981.
- KONSYNSKI, B.; BRACKER, L.; BRACKER, W. A model for specification of office communications. IEEE Transactions on Communications , v. 30, n. 1, jan. 1982.
- KOOI, R. P. The optimization of queries in relational databases . Disserta√ß√£o de Ph.D. - Case Western Reserve University, p. 1-159, 1980.
- KOPERSKI, K.; HAN, J. Discovery of spatial association rules in geographic information databases. In: Proc. SSD'1995, 4th Int. Symposium on Advances in Spatial Databases. LNCS 951. Portland, Maine, Springer, 1995.
- KORFHAGE, R. To see, or not to see: Is that the query?' In: Proc. ACM SIGIR International Conference , jun. 1991.

- KORTH, H. Locking primitives in a database system. JACM , v. 30, n. 1, jan. 1983.
- \_\_\_\_\_\_.; LEVY, E.; SILBERSCHATZ, A. A formal approach to recovery by compensating transactions. In: VLDB , 1990.
- KOSALA, R.; BLOCKEEL, H. Web mining research: a survey. SIGKDD Explorations , v. 2, n. 1, p. 1-15, jun. 2000.
- KOTZ, A.; DITTRICH, K.; MULLE, J. Supporting semantic rules by a generalized event/Trigger mechanism. In: VLDB , 1988.
- KRISHNAMURTHY, R.; NAQVI, S. Non-deterministic choice in datalog. Proceeedings of the 3rd International Conference on Data and Knowledge Bases. Jerusal√©m, jun. 1989.
- \_\_\_\_\_\_.; LITWIN, W.; KENT, W. Language features for interoperability of databases with semantic discrepancies. In: SIGMOD , 1991. KROVETZ, R.; CROFT B. Lexical ambiguity and information retrieval. In: TOIS , v. 10, abril 1992.
- KUHN, R. M. et al. The UCSC genome browser database: update 2009. Nucleic Acids Research , v. 37, n. 1, jan. 2009.
- KULKARNI K. et al. Introducing reference  types  and  cleaning  Up SQL3's object model. ISO WG3 Report X3H2-95-456 , nov. 1995.
- KUMAR, A. Performance measurement of some main memory recovery algorithms. In: ICDE , 1991.
- \_\_\_\_\_\_.; SEGEV, A. Cost and availability tradeoffs in replicated concurrency control. TODS , v. 18, n. 1, mar. 1993.
- \_\_\_\_\_\_.; STONEBRAKER, M. Semantics based transaction management techniques for replicated data. In: SIGMOD , 1987.
- KUMAR, D. Genomic medicine: A new frontier of medicine in the twenty first century. Genomic Medicine, p. 3-7, 2007a.
- \_\_\_\_\_\_. Genome mirror - 2006. Genomic Medicine, p. 87-90, 2007b.
- KUMAR, V.; HAN, M. (Eds.). Recovery mechanisms in database systems . Prentice-Hall, 1992.
- \_\_\_\_\_\_.; HSU, M. Recovery mechanisms in database systems . Prentice-Hall (PTR), 1998.
- \_\_\_\_\_\_.; SONG, H. S. Database recovery . Kluwer Academic, 1998.
- KUNG, H.; ROBINSON, J. Optimistic concurrency control. TODS , v. 6, n. 2, jun. 1981.
- LACROIX, M.; PIROTTE, A. Domain-oriented relational languages. In: VLDB , 1977a.
- \_\_\_\_\_\_.; \_\_\_\_\_\_. ILL : An english structured query language for relational data bases. In: NIJSSEN, 1977b.
- LAI,  M.-Y.;  WILKINSON, W. K. Distributed transaction management in Jasmin. In: VLDB , 1984.
- LAMB, C. The objectstore database system. In: CACM , v. 34, n. 10, p. 50-63, out. 1991.
- LAMPORT, L. Time, clocks, and the ordering of events in a distributed system. CACM , v. 21, n. 7, jul. 1978.
- LANDER, E. Initial sequencing and analysis of the genome. Nature , v. 409, n. 6822, 2001.
- LANGERAK, R. View updates in relational databases with an independent scheme. TODS , v. 15, n. 1, mar. 1990.
- LANKA, S.; MAYS, E. Fully persistent B1-trees. In: SIGMOD , 1991.
- LARSON, J. Bridging the gap between network and relational database management systems. IEEE Computer , v. 16, n. 9, set. 1983.
- \_\_\_\_\_\_.; NAVATHE, S.; ELMASRI, R. Attribute equivalence and its use in schema integration. TSE , v. 15, n. 2, abril 1989.
- LARSON, P. Dynamic hashing. BIT , v. 18, 1978.
- \_\_\_\_\_\_.  Analysis  of  Index-sequential  files  with  overflow  chaining. TODS , v. 6, n. 4, dez. 1981.
- LASSILA, O. Web metadata: A matter of semantics. IEEE Internet Computing , v. 2, n. 4, p. 30-37, jul./ago. 1998.
- LAURINI, R.; THOMPSON, D. Fundamentals of spatial information systems . Academic Press, 1992.
- LAUSEN G.; VOSSEN, G. Models and languages of object oriented databases . Addison-Wesley, 1997.
- LAZEBNIK, S.; SCHMID, C.; PONCE, J. Semi-local affine parts for object  recognition.  In: Proc.  British  Machine  Vision  Conference . Kingston University, The Institution of Engineering and Technology, U.K., 2004.
- LEE, J.; ELMASRI, R.; WON, J. An integrated temporal data model incorporating time series concepts. DKE , v. 24, p. 257-276, 1998.
- LEHMAN, P.; YAO, S. Efficient locking for concurrent operations on B-Trees. TODS , v. 6, n. 4, dez. 1981.
- LEHMAN, T.; LINDSAY, B. The Starburst long field manager. In: VLDB , 1989.
- LEISS, E. Randomizing: A practical method for protecting statistical databases against compromise. In: VLDB , 1982.

\_\_\_\_\_\_.

- Principles of data security . Plenum Press, 1982a.
- LENAT, D. CYC: A large-scale investment in knowledge infrastructure. CACM , v. 38, n. 11, p. 32-38, nov. 1995.
- LENZERINI, M.; SANTUCCI, C. Cardinality constraints in the entity relationship model. In: ER Conference , 1983.
- LEUNG, C.; HIBLER, B.; MWARA, N. Picture retrieval by content description. In: Journal of Information Science , p. 111-119, 1992.
- LEVESQUE, H. The logic of incomplete knowledge bases . In: BRODIE et al., cap. 7, 1984.
- LI, W.-S. et al. Hierarchical image modeling for object-based media retrieval. In: DKE , v. 27, n. 2, p. 139-176, set. 1998.
- LIEN, E.; WEINBERGER, P. Consistency, concurrency, and crash recovery. In: SIGMOD , 1978.
- LIEUWEN, L.; DeWITT, D. A transformation-based approach to optimizing loops in database programming languages. In: SIGMOD , 1992.
- LILIEN,  L.;  BHARGAVA,  B.  Database  integrity  block  construct: Concepts and design issues. TSE , v. 11, n. 9, set. 1985.
- LIN, J.; DUNHAM, M. H. Mining association rules. In: ICDE , 1998.
- LINDSAY, B. et al. Computation and communication in R*: A distributed database manager. TOCS , v. 2, n. 1, jan. 1984.
- LIPPMAN R. An introduction to computing with Neural Nets. IEEE ASSP Magazine , abril 1987.
- LIPSKI, W. On semantic issues connected with incomplete information. TODS , v. 4, n. 3, set. 1979.
- LIPTON, R.; NAUGHTON, J.; SCHNEIDER, D. Practical selectivity estimation through adaptive sampling. In: SIGMOD , 1990.
- LISKOV, B.;  ZILLES,  S.  Specification  techniques  for  data  abstractions. TSE , v. 1, n. 1, mar. 1975.
- LITWIN, W. Linear hashing: A new tool for file and table addressing. In: VLDB , 1980.
- LIU, B. Web data mining : Exploring hyperlinks, contents, and usage data (Data-centric systems and applications). Springer, 2006.
- \_\_\_\_\_\_.;  CHEN-CHUAN-CHANG,  K.  Editorial:  Special  issue  on Web content mining. SIGKDD Explorations Newsletter ,  v.  6,  n. 2, p. 1-4, dez. 2004.
- LIU, K.; SUNDERRAMAN, R. On representing indefinite and maybe information in relational databases. In: ICDE , 1988.
- LIU, L.; MEERSMAN, R. Activity model: A declarative approach for capturing  communication  behavior  in  object-oriented  databases. In: VLDB , 1992.
- LOCKEMANN, P.; KNUTSEN, W. Recovery of disk contents after system failure. CACM , v. 11, n. 8, ago. 1968.
- LONGLEY, P. et al. Geographic information systems and science . John Wiley, 2001.
- LORIE, R. Physical integrity in a large segmented database. TODS , v. 2, n. 1, mar. 1977.
- \_\_\_\_\_\_.; PLOUFFE, W. Complex objects and their use in design transactions. In: SIGMOD , 1983.

LOWE, D. Distinctive image features from scale-invariant keypoints. Int. Journal of Computer Vision , v. 60, p. 91-110, 2004.

LOZINSKII,  E.  A  problem-oriented  inferential  database  system. TODS , v. 11, n. 3, set. 1986.

LU, H.; MIKKILINENI, K.; RICHARDSON, J. Design and evaluation of algorithms to compute the transitive closure of a database relation. In: ICDE , 1987.

LUBARS, M.; POTTS, C.; RICHTER, C. A review of the state of practice in requirements modeling. Proc. IEEE International Symposium on Requirements Engineering . San Diego, CA, 1993.

LUCYK, B. Advanced topics in DB2 . Addison-Wesley, 1993.

LUHN, H. P. A statistical approach to mechanized encoding and searching of literary information. IBM Journal of Research and Development , v. 1, n. 4, p. 309-317, out. 1957.

LUNT, T.; FERNANDEZ, E. Database security. In: SIGMOD Record , v. 19, n. 4, p. 90-97, 1990.

- \_\_\_\_\_\_. et al. The seaview security model. IEEE TSE , v. 16, n. 6, p. 593-607, 1990.

LUO, J.; NASCIMENTO, M. Content-based sub-image retrieval via hierarchical tree matching. In: Proc. ACM Int Workshop on Multimedia Databases , p. 63-69  New Orleans, 2003. .

MADRIA, S. et al. Research issues in Web data mining. In: MOHANIA, M.; TJOA, A. (Eds.). Proc. First Int. Conf. on Data Warehousing and Knowledge Discovery. LNCS 1676. p. 303-312. Springer, 1999.

\_\_\_\_\_\_. et al. A transaction model and multiversion concurrency control for mobile database systems. Distributed and Parallel Databases  DPD ( ), v. 22, n. 2-3, p. 165-196, 2007.

MAGUIRE, D.; GOODCHILD, M.; RHIND, D. (Eds.). Geographical information systems : Principles and applications. v. 1-2. Longman Scientific and Technical. New York, 1997.

MAHAJAN, S. et al. Grouping techniques for update propagation in intermittently connected databases. In: ICDE , 1998.

- MAIER, D. The  theory  of  relational  databases .  Computer  Science Press, 1983.
- \_\_\_\_\_\_.; WARREN, D. S. Computing with logic .  Benjamin Cummings, 1988.

\_\_\_\_\_\_. et al. Development of an object-oriented DBMS. OOPSLA , 1986. MALLEY, C.; ZDONICK, S. A knowledge-based approach to query optimization. In: EDS , 1986.

MANNILA,  H.;  TOIVONEN,  H.;  VERKAMO,  A.  Efficient  algorithms  for  discovering  association  rules.  In: KDD-94,  AAAI Workshop on Knowledge Discovery in Databases. Seattle, 1994.

MANNING, C.; SCH√úTZE, H. Foundations  of  statistical  natural language processing . MIT Press, 1999.

- \_\_\_\_\_\_.; RAGHAVAN, P.; SCHUTZE, H. Introduction to information retrieval . Cambridge University Press, 2008.

MANOLA. F. Towards a Richer Web object model. In: ACM SIGMOD Record , v. 27, n. 1, mar. 1998.

MANOLOPOULOS,  Y.  et  al. R-Trees :  Theory  and  applications. Springer, 2005.

- MARCH, S.; SEVERANCE, D. The determination of efficient record segmentations and blocking factors for shared files. TODS , v. 2, n. 3, set. 1977.

MARK, L. et al. Incrementally maintained network to relational mappings. Software Practice &amp; Experience , v. 22, n. 12, dez. 1992.

MARKOWITZ, V.; RAZ, Y. ERROL: An entity-relationship,  role oriented, Query language. In: ER Conference, 1983.

- MARTIN, J.; ODELL, J. Principles of object-oriented analysis and design . Prentice-Hall, 2008.
- \_\_\_\_\_\_.; CHAPMAN, K.; LEBEN, J. DB2-Concepts, design, and programming . Prentice-Hall, 1989.
- MARYANSKI, F. Backend database machines. ACM Computing Surveys , v. 12, n. 1, mar. 1980.
- MASUNAGA, Y. Multimedia databases: A formal framework. Proc. IEEE Office Automation Symposium , abril 1987.
- MATTISON, R. Data warehousing : Strategies, technologies, and techniques. McGraw-Hill, 1996.
- MAUNE, D. F. Digital elevation model technologies and applications : The DEM users manual. ASPRS, 2001.
- McCARTY, C. et al. Marshfield clinic personalized medicine research project (PMRP): design, methods and recruitment for a large population-based biobank. Personalized Medicine , p. 49-70, 2005.
- MCCLURE, R.; KR√úGER, I. SQL DOM: Compile time checking of dynamic SQL statements. Proc. 27th Int. Conf. on Software Engineering , maio 2005.
- McLEISH, M. Further results on the security of partitioned dynamic statistical databases. TODS , v. 14, n. 1, mar. 1989.
- McLEOD, D.; HEIMBIGNER, D. A federated architecture for information systems. TOOIS , v. 3, n. 3, jul. 1985.
- MEHROTRA, S. et al. The concurrency control problem in multidatabases: Characteristics and solutions. In: SIGMOD , 1992.
- MELTON, J. Advanced SQL : 1999 - Understanding object-relational and other advanced features. Morgan Kaufmann, 2003.
- \_\_\_\_\_\_.; MATTOS, N. An overview of SQL3 - The emerging new generation of the SQL standard. Tutorial n. T5. In: VLDB , Bombaim, √çndia, set. 1996.
- \_\_\_\_\_\_.; SIMON, A. R. Understanding the New SQL :  A  complete guide. Morgan Kaufmann, 1993.
- \_\_\_\_\_\_.;  \_\_\_\_\_\_. SQL :  1999  -  Understanding  relational  language components. Morgan Kaufmann, 2002.
- \_\_\_\_\_\_.; BAUER, J.; KULKARNI, K. Object ADTs (with improvements for value ADTs). ISO WG3 Report X3H2-91-083 , abril 1991.
- MENASCE, D.; POPEK, G.; MUNTZ, R. A locking protocol for resource coordination in distributed databases. TODS , v. 5, n. 2, jun. 1980.
- MENDELZON, A.; MAIER, D. Generalized  mutual  dependencies and the decomposition of database relations. In: VLDB , 1979.
- \_\_\_\_\_\_.; MIHAILA, G.; MILO, T. Querying the world wide Web. Journal of Digital Libraries , v. 1, n. 1, abril 1997.
- METAIS, E. et al. Using linguistic knowledge in view integration: Toward a third generation of tools. DKE , v. 23, n. 1, jun. 1998.

MIKKILINENI, K.; SU, S. An evaluation of relational join algorithms in a pipelined query processing environment. TSE , v. 14, n. 6, jun. 1988. MIKOLAJCZYK, K.; SCHMID, C. A performance evaluation of local descriptors. IEEE Transactions on PAMI , v. 10, n. 27, p. 16151630, 2005.

MILLER, G. A. Nouns in WordNet: a lexical inheritance system. International Journal of Lexicography , v. 3, n. 4, p. 245-264, 1990.

- MILLER, H. J. Tobler's first law and spatial analysis. Annals of the Association  of  American  Geographers ,  v.  94,  n.  2,  p.  284-289, 2004.

MILOJICIC, D. et al. Peer-to-Peer  computing ,  HP  laboratories  technical  report  n.  HPL-2002-57,  HP  Labs.  Palo  Alto,  2002.  Dispon√≠vel em: &lt;www.hpl.hp.com/techreports/2002/HPL-2002-57R1. html&gt;. Acesso em: 08 nov. 2010.

MINOURA,  T.;  WIEDERHOLD,  G.  Resilient  extended  true-copy token scheme for a distributed database. TSE , v. 8, n. 3, maio 1981. MISSIKOFF, M.; WIEDERHOLD, G. Toward a unified approach for expert and database systems. In: EDS , 1984.

MITCHELL, T. Machine learning . McGraw-Hill, 1997.

MITSCHANG, B. Extending the relational algebra to capture complex objects. In: VLDB , 1989.

- MOHAN, C. IBM's relational database products: Features and technologies. In: SIGMOD , 1993.
- \_\_\_\_\_\_. et al. ARIES: A transaction recovery method supporting fine-granularity  locking  and  partial  rollbacks  using  write-ahead  logging. TODS , v. 17, n. 1, mar. 1992.

- \_\_\_\_\_\_.; LEVINE, F. ARIES/IM: An efficient and high-concurrency index management method using write-ahead logging. In: SIGMOD , 1992.
- \_\_\_\_\_\_.; NARANG, I. Algorithms for creating indexes for very large tables without quiescing updates. In: SIGMOD , 1992.
- \_\_\_\_\_\_. et al. ARIES: A transaction recovery method supporting fine-granularity locking and partial rollbacks using write-ahead logging. TODS , v. 17, n. 1, mar. 1992.
- MORRIS, K. et  al.  YAWN!  (Yet  another  window  on  NAIL!).  In: ICDE , 1987.
- \_\_\_\_\_\_.; ULLMAN, J.; VANGELDEN, A. Design overview of the NAIL! System. Proc. Third International Conference on Logic Programming . Springer-Verlag, 1986.
- MORRIS, R. Scatter storage techniques. CACM , v. 11, n. 1, jan. 1968. MORSI, M.; NAVATHE, S.; KIM, H. An extensible object-oriented database testbed. In: ICDE , 1992.
- MOSS, J. Nested transactions and reliable distributed computing. Proc. Symposium on Reliability in Distributed Software and Database Systems, IEEE CS, jul. 1982.
- MOTRO, A. Superviews: Virtual integration of multiple databases. TSE , v. 13, n. 7, jul. 1987.
- MOURATIDIS, K. et al. Continuous nearest  neighbor  monitoring  in road networks. In: VLDB , p. 43-54, 2006.
- MUKKAMALA, R. Measuring the effect of data distribution and replication models on performance evaluation of distributed systems. In: ICDE , 1989.

MUMICK, I. et al. Magic is relevant. In: SIGMOD , 1990a.

- \_\_\_\_\_\_. et al. The magic of duplicates and aggregates. In: VLDB , 1990b. MURALIKRISHNA, M. Improved unnesting algorithms for join and aggregate SQL queries. In: VLDB , 1992.
- \_\_\_\_\_\_.; DeWITT, D. Equi-depth histograms for estimating selectivity factors for multi-dimensional queries. In: SIGMOD , 1988.
- MYLOPOLOUS, J.; BERNSTEIN, P.; WONG, H. A language facility for designing database-intensive applications. TODS ,  v.  5, n. 2, jun. 1980.
- NAEDELE, M. Standards for XML and Web services security. IEEE Computer , v. 36, n. 4, p. 96-98, abril 2003.
- NAISH, L.; THOM, J. The MU-PROLOG deductive database. Technical Report 83/10 ,  Department of Computer Science, University of Melbourne, 1983.
- NATAN, R. Implementing database security and auditing :  Includes examples from Oracle, SQL Server, DB2 UDB, and Sybase. Digital Press, 2005.
- NAVATHE, S. An intuitive approach to normalize network-structured data. In: VLDB , 1980.
- \_\_\_\_\_\_.; BALARAMAN, A. A transaction architecture for a general purpose semantic data model. In: ER, p. 511-541, 1991.
- NAVATHE, S. B.; KARLAPALEM, K.; RA, M. Y. A mixed fragmentation methodology for the initial distributed database design. Journal of Computers and Software Engineering , v. 3, n. 4, 1996.
- \_\_\_\_\_\_. et al. Object modeling using classification in CANDIDE and its application . In: DOGAC et al., 1994.
- NAVATHE, S.; AHMED, R. A temporal relational model and Query language. Information Sciences , v. 47, n. 2, p. 147-175, mar. 1989.
- \_\_\_\_\_\_.; GADGIL, S. A methodology for view integration in logical database design. In: VLDB , 1982.
- \_\_\_\_\_\_.; KERSCHBERG, L. Role of data dictionaries in database design. Information and Management , v. 10, n. 1, jan. 1986.
- \_\_\_\_\_\_.; SAVASERE, A. A practical schema integration facility using an object oriented approach. In: ELMAGARMID, A.; BUKHRES, O. (Eds). Multidatabase Systems . Prentice-Hall, 1996.
- \_\_\_\_\_\_.; SCHKOLNICK, M. View representation in logical database design. In: SIGMOD , 1978.
- \_\_\_\_\_\_.  et  al.  Vertical  partitioning  algorithms  for  database  design. TODS , v. 9, n. 4, dez. 1984.
- \_\_\_\_\_\_.; ELMASRI, R.; LARSON, J. Integrating user views in database design. IEEE Computer , v. 19, n. 1, jan. 1986.
- \_\_\_\_\_\_.; PATIL, U.; GUAN, W. Genomic and proteomic databases: Foundations, current status and future applications. In: Journal of Computer Science and Engineering ,  Korean Institute of Information Scientists and Engineers (KIISE), v. 1, n. 1, p. 1-30, 2007.
- \_\_\_\_\_\_.;  SASHIDHAR,  T.;  ELMASRI,  R.  Relationship  merging  in schema integration. In: VLDB , 1984a.
- NEGRI, M.; PELAGATTI, S.; SBATELLA, L. Formal semantics of SQL queries. TODS , v. 16, n. 3, set. 1991.
- NG, P. Further analysis of the entity-relationship approach to database design. TSE , v. 7, n. 1, jan. 1981.
- NGU, A. Transaction modeling. In: ICDE , p. 234-241, 1989.
- NICOLAS, J. Mutual dependencies and some results on undecomposable relations. In: VLDB , 1978.
- \_\_\_\_\_\_.  Deductive  object-oriented  databases,  technology,  products, and applications: Where are we? Proc. Symposium on Digital Media Information Base  DMIB '97 ( ). Nara, Jap√£o, nov. 1997.
- \_\_\_\_\_\_.  et  al.  Glue-NAIL!:  A  deductive  database  system.  In: SIGMOD , 1991.
- NIEMIEC, R. Oracle database 10g performance tuning tips &amp; techniques . 967 p. McGraw Hill Osborne Media, 2008.
- NIEVERGELT, J.  Binary  search  trees  and  file  organization. ACM Computing Surveys , v. 6, n. 3, set. 1974.
- \_\_\_\_\_\_.; HINTERBERGER, H.; SEVEIK, K. The grid file: An adaptable symmetric multikey file structure. TODS , v. 9, n. 1, p. 38-71, mar. 1984.
- NIJSSEN,  G.  (Ed.). Modelling  in  data  base  management  systems . North-Holland, 1976.
- \_\_\_\_\_\_. (Ed.). Architecture and models in data base management systems . North-Holland, 1977.
- NWOSU,  K.;  BERRA,  P.;  THURAISINGHAM,  B.  (Eds.). Design and implementation of multimedia database management systems . Kluwer Academic, 1996.
- O'NEIL, P.; O'NEIL, P. (2001) Database :  Principles,  programming, performance. Morgan Kaufmann, 1994.
- OBERMARCK,  R.  Distributed deadlock detection algorithms. TODS , v. 7, n. 2, jun. 1982.
- OH, Y.-C. Secure database modeling and design . Ph.D. dissertation College of Computing, Georgia Institute of Technology, mar. 1999.
- OHSUGA, S. Knowledge based systems as a new interactive computer system of the next generation. In: Computer Science and Technologies . North-Holland, 1982.
- OLKEN,  F.;  JAGADISH,  J.  Management  for  integrative  biology. OMICS: A Journal of Integrative Biology , v. 7, n. 1, jan. 2003.
- OLLE, T. The CODASYL approach to data base management . Wiley, 1978.
- \_\_\_\_\_\_.; SOL, H.; VERRIJN-STUART, A. (Eds.). Information system design methodology . North-Holland, 1982.
- OMIECINSKI, E.; SCHEUERMANN, P. A parallel algorithm for record clustering. TODS , v. 15, n. 4, dez. 1990.
- OMURA, J. K. Novel applications of cryptography in digital communications. IEEE Communications Magazine , v. 28, n. 5, p. 21-29, maio 1990.
- OPEN GIS CONSORTIUM, INC. OpenGIS  simple features specifi-¬Æ cation for SQL . Revision 1.1, OpenGIS Project Document 99-049, maio 1999.
- \_\_\_\_\_\_. OpenGIS  Geography markup language  GML  implemen-¬Æ ( ) tation specification . Version 3, OGC 02-023r4., 2003.
- ORACLE. Oracle 10 . Introduction to LDAP and Oracle Internet Directory 10g Release 2. Oracle Corporation, 2005.

- \_\_\_\_\_\_. Oracle  label  security  administrator's  guide , 11g  (release 11.1).  Part  n.  B28529-01.  Oracle,  2007.  Dispon√≠vel  em:  &lt;http:// download.oracle.com/docs/cd/ B28359\_01/network.111/b28529/ intro.htm&gt;. (n√£o consegui acessar a p√°gina em 09/11/10)
- \_\_\_\_\_\_. Oracle 11 distributed database concepts , 11g release 1. Oracle Corporation, 2008.
- \_\_\_\_\_\_. An Oracle white paper : Leading practices for driving down the costs of managing your Oracle identity and access management suite. Oracle, abril 2009.
- OSBORN, S. L. Normal forms for relational databases . Disserta√ß√£o de Ph.D. - University of Waterloo, 1977.
- \_\_\_\_\_\_.  The  role  of  polymorphism  in  schema  evolution  in  an  object-oriented database. TKDE , v. 1, n. 3, set. 1989.
- \_\_\_\_\_\_. Towards a universal relation interface. In: VLDB , 1979.
- OZSOYOGLU, G.; OZSOYOGLU, Z.; MATOS, V. (1985) Extending relational algebra and relational calculus with set valued attributes and aggregate functions. TODS , v. 12, n. 4, dez. 1987.
- OZSOYOGLU, Z.; YUAN, L. A new normal form for Nested relations. TODS , v. 12, n. 1, mar. 1987.
- OZSU, M. T.; VALDURIEZ, P. Principles of distributed database systems . 2. ed. Prentice-Hall, 1999.

PAPADIAS, D. et al. Query processing in spatial network databases. In: VLDB , p. 802-813, 2003.

- PAPADIMITRIOU,  C.  The  serializability  of  concurrent  database updates. JACM , v. 26, n. 4, out. 1979.
- \_\_\_\_\_\_. The  theory  of  database  concurrency  control . Computer Science Press, 1986.
- \_\_\_\_\_\_.; KANELLAKIS, P. (1979) On concurrency control by multiple versions. TODS , v. 9, n. 1, mar. 1974.
- PAPAZOGLOU, M.; VALDER, W. Relational database management : A systems programming approach. Prentice-Hall, 1989.

PAREDAENS, J.; Van GUCHT, D. Converting Nested algebra expressions into Flat algebra expressions. TODS , v. 17, n. 1, mar. 1992. PARENT, C.; SPACCAPIETRA, S. An algebra for a general entity-relationship model. TSE , v. 11, n. 7, jul. 1985.

PARIS, J. Voting with witnesses: A consistency scheme for replicated files. In: ICDE , 1986.

PARK, J.; CHEN, M.; YU, P. An effective hash-based algorithm for mining association rules. In: SIGMOD , 1995.

- PATON, A. W. (Ed.). Active rules in database systems . Springer-Verlag, 1999.
- PATON, N. W.; DIAZ, O. Survey of active database systems. ACM Computing Surveys , v. 31, n. 1, p. 63-103, 1999.
- PATTERSON, D.; GIBSON, G.; KATZ, R. A case for redundant arrays of inexpensive disks (RAID). In: SIGMOD , 1988.

PAUL, H. et al. Architecture and implementation of the Darmstadt Database Kernel System. In: SIGMOD , 1987.

PAZANDAK, P.;  SRIVASTAVA,  J.  Evaluating  Object  DBMSs  for Multimedia. IEEE Multimedia , v. 4, n. 3, p. 34-49.

PAZOS-RANGEL, R. et. al. Least likely to use: A new page replacement strategy for improving database management system response time. In: Proc. CSR 2006: Computer Science ¬æ Theory and Applications. LNCS, v. 3967, p. 314-323. St. Petersburg, Russia, Springer, 2006.

PDES A high-lead architecture for implementing a PDES/STEP data sharing environment. Publication Number PT 1017.03.00. PDES Inc., maio 1991.

PEARSON, P. et al. The status of Online Mendelian Inheritance in Man (OMIM) Medio 1994. Nucleic Acids Research , v. 22, n. 17, 1994.

- PECKHAM, J.; MARYANSKI, F. Semantic data models. ACM Computing Surveys , v. 20, n. 3, p. 153-189, set. 1988.
- PENG, T.; TSOU, M. Internet GIS : Distributed geographic information services for the internet and wireless network. Wiley, 2003.
- PFLEEGER, C. P.; PFLEEGER, S. Security in computing . 4. ed. Prentice-Hall, 2007.
- PHIPPS, G.; DERR, M.; ROSS, K. Glue-NAIL!: A Deductive database system. In: SIGMOD , 1991.
- PIATETSKY-SHAPIRO, G.; FRAWLEY, W. (Eds.). Knowledge discovery in databases. AAAI Press/MIT Press , 1991.
- PISTOR P.; ANDERSON, F. Designing a generalized NF2 model with an SQL-type language interface. In: VLDB , p. 278-285, 1986.
- PITOURA, E.; BHARGAVA, B. Maintaining consistency of data in mobile distributed environments. In: 15th ICDCS , p. 404-413, maio 1995.
- \_\_\_\_\_\_.;  SAMARAS,  G. Data  management  for  mobile  computing . Kluwer, 1998.
- \_\_\_\_\_\_.; BUKHRES, O.; ELMAGARMID, A. Object orientation in multidatabase systems. ACM Computing Surveys , v. 27, n. 2, jun. 1995.
- POLAVARAPU,  N.  et  al.  Investigation  into  biomedical  literature screening using support vector machines. In: Proc. 4th Int. IEEE Computational  Systems  Bioinformatics  Conference ( CSB'05 ),  p. 366-374, ago. 2005.
- PONCELEON D. et al. CueVideo: Automated multimedia indexing and retrieval. Proc. 7th ACM Multimedia Conf ., p. 199. Orlando, Fl., out. 1999.
- PONNIAH, P. Data  warehousing  fundamentals :  A  comprehensive guide for IT professionals. Wiley Interscience, 2002.
- POOSALA, V. et al. Improved histograms for selectivity estimation of range predicates. In: SIGMOD , 1996.
- PORTER, M. F. An algorithm for suffix stripping. Program , v. 14, n. 3, p. 130-137, 1980.
- POTTER, B.; SINCLAIR, J.; TILL, D. An introduction to formal specification and Z . 2. ed. Prentice-Hall, 1996.
- PRABHAKARAN,  B. Multimedia  database  management  systems . Springer-Verlag, 1996.
- PRASAD, S. et al. SyD: A middleware testbed for collaborative applications over small heterogeneous devices and data stores. Proc. ACM/IFIP/USENIX  5th  International  Middleware  Conference ( MW-04 ). Toronto, Canad√°, out. 2004.
- PRICE, B. ESRI systems integrationtechnical Brief - ArcSDE high-availability overview. ESRI, Rev 2, 2004. Dispon√≠vel em: &lt;www. lincoln.ne.gov/city/pworks/gis/pdf/arcsde.pdf&gt;. (n√£o consegui acessar a p√°gina em 09/11/10)
- RABITTI, F. et al. A model of authorization for next-generation database systems. TODS , v. 16, n. 1, mar. 1991.
- RAMAKRISHNAN, R.; GEHRKE, J. Database management systems . 3. ed. McGraw-Hill, 2003.
- \_\_\_\_\_\_.; ULLMAN, J. Survey of research in deductive database systems. Journal of Logic Programming , v. 23, n. 2, p. 125-149, 1995.
- \_\_\_\_\_\_. (Ed.). Applications of logic databases . Kluwer Academic, 1995.
- \_\_\_\_\_\_.; SRIVASTAVA, D.; SUDARSHAN, S. {CORAL} : {C} ontrol, {R} elations and {L} ogic. In: VLDB , 1992.
- \_\_\_\_\_\_.  et  al.  Implementation  of  the  {CORAL}  deductive  database system. In: SIGMOD , 1993.
- RAMAMOORTHY, C.; WAH, B. The placement of relations on a distributed relational database. Proc. First International Conference on Distributed Computing Systems . IEEE CS, 1979.
- RAMESH, V.; RAM, S. Integrity constraint integration in heterogeneous databases an enhanced methodology for schema integration. Information Systems , v. 22, n. 8, p. 423-446, dez. 1997.
- RATNASAMY, S. et al. A scalable content-addressable network. SIGCOMM , 2001.
- REED,  D.  P.  Implementing  atomic  actions  on  decentralized  data. TOCS , v. 1, n. 1, p. 3-23, fev. 1983.

REESE, G.

Database programming with JDBC and Java

. O'Reilley, 1997.

- REISNER, P. Use of psychological experimentation as an aid to development of a Query language. TSE , v. 3, n. 3, maio 1977.

- \_\_\_\_\_\_. Human factors studies of database query languages: A survey and assessment. ACM Computing Surveys , v. 13, n. 1, mar. 1981.
- REITER, R. Towards a logical reconstruction of relational database theory . In: BRODIE et al., cap. 8, 1984.
- REUTER, A. A fast transaction oriented logging scheme for UNDO recovery. TSE , v. 6, n. 4, p. 348-356, 1980.
- RIES, D.; STONEBRAKER, M. Effects of locking granularity in a database management system. TODS , v. 2, n. 3, set. 1977.
- RISSANEN, J. Independent components of relations. TODS , v. 2, n. 4, dez. 1977.
- RIVEST, R. et al. A method for obtaining digital signatures and public-key cryptosystems. CACM , v. 21, n. 2, p. 120-126, fev. 1978.

ROBBINS,  R.  Genome  informatics:  Requirements  and  challenges. Proc. Second International Conference on Bioinformatics, Supercomputing and Complex Genome Analysis .  World  Scientific  Publishing, 1993.

ROBERTSON, S. The probability ranking principle in IR. In: JONES, K. S.; WILLETT, P. (Eds.). Readings in information retrieval . Morgan Kaufmann Multimedia Information and Systems Series, p. 281286, 1997.

- \_\_\_\_\_\_.; WALKER, S.; HANCOCK-BEAULIEU, M. Large test collection experiments on an operational, interactive system: Okapi at TREC. Information Processing and Management , v. 31, p. 345360, 1995.

ROCCHIO, J. Relevance feedback in information retrieval. In: SALTON, G. (Ed.). The SMART retrieval system : Experiments in automatic document processing, p. 313-323. Prentice-Hall, 1971.

ROSENKRANTZ, D.; STEARNS, D.; LEWIS, P. System-level concurrency control for distributed database systems. TODS , v. 3, n. 2, p. 178-198, 1978.

ROTEM, D. Spatial join indices. In: ICDE , 1991.

- ROTH, M. A.; KORTH, H. F.; SILBERSCHATZ, A. Extended algebra and calculus for Non-1NF relational databases. TODS , v. 13, n. 4, p. 389-417, 1988.
- ROTH, M.; KORTH, H. The design of Non-1NF relational databases into Nested normal form. In: SIGMOD , 1987.
- ROTHNIE, J. et al. Introduction to a system for distributed databases (SDD-1). TODS , v. 5, n. 1, mar. 1980.
- ROUSSOPOULOS, N. An incremental access method for view-cache: Concept, algorithms, and cost analysis. TODS , v. 16, n. 3, set. 1991.
- \_\_\_\_\_\_.;  KELLEY,  S.;  VINCENT,  F.  Nearest  neighbor  queries.  In: SIGMOD , p. 71-79, 1995.
- ROZEN, S.; SHASHA, D. A framework for automating physical database design. In: VLDB , 1991.
- RUDENSTEINER, E. Multiview: A methodology for supporting multiple views in object-oriented databases. In: VLDB , 1992.
- RUEMMLER, C.; WILKES, J. An introduction to disk drive modeling. IEEE Computer , v. 27, n. 3, p. 17-27, mar. 1994.
- RUMBAUGH, J. et al. Object oriented modeling and design . Prentice-Hall, 1991.
- \_\_\_\_\_\_.; JACOBSON, I.; BOOCH, G. The unified modeling language reference manual . Addison-Wesley, 1999.
- RUSINKIEWICZ, M. et al. OMNIBASE - A loosely coupled: Design and implementation of a multidatabase system. IEEE Distributed Processing Newsletter , v. 10, n. 2, nov. 1988.
- RUSTIN, R. (Ed.). Data base systems . Prentice-Hall, 1972.
- \_\_\_\_\_\_. (Ed.). Proc. BJNAV2 , 1974.
- SACCA, D.; ZANIOLO, C. (1987) Implementation of recursive queries for a data language based on pure horn clauses. Proc. Fourth International Conference on Logic Programming . MIT Press, 1986.
- SADRI, F.; ULLMAN, J. Template dependencies: A large class of dependencies in relational databases and its complete axiomatization. JACM , v. 29, n. 2, abril 1982.

SAGIV, Y.; YANNAKAKIS, M. Equivalence among relational expressions with the union and difference operators. JACM , v. 27, n. 4, nov. 1981. SAHAY, S. et al. Discovering semantic biomedical relations utilizing the Web. In: Journal of ACM Transactions on Knowledge Discovery from Data ( TKDD ). Special issue on Bioinformatics, v. 2, n. 1, 2008.

- SAKAI,  H.  Entity-relationship  approach  to  conceptual  schema  design. In: SIGMOD , 1980.
- SALEM, K.; GARCIA-MOLINA, H. Disk striping. In: ICDE , p. 336342, 1986.
- SALTON, G. Automatic information organization and retrieval . McGraw Hill, 1968.
- \_\_\_\_\_\_. The SMART retrieval system - Experiments in automatic document processing. Prentice-Hall, 1971.
- \_\_\_\_\_\_.  Full  text  information  processing  using  the  smart  system. IEEE Data Engineering Bulletin , v. 13, n. 1, p. 2-9, 1990.
- \_\_\_\_\_\_.; BUCKLEY, C. Global text matching for information retrieval. In: Science , v. 253, ago. 1991.
- \_\_\_\_\_\_.;  YANG, C. S.; YU, C. T. A theory of term importance in automatic text analysis. Journal of the American Society for Information Science , v. 26, p. 33-44, 1975.
- SALZBERG, B. File structures : An analytic approach. Prentice-Hall, 1988. \_\_\_\_\_\_. et al. FastSort: A distributed single-input single-output external sort. In: SIGMOD , 1990.
- SAMET, H. The design and analysis of spatial data structures . Addison-Wesley, 1990.
- \_\_\_\_\_\_. Applications of spatial data structures :  Computer graphics, image processing, and GIS. Addison-Wesley, 1990a.
- SAMMUT, C.; SAMMUT, R. The implementation of UNSW-PROLOG. The Australian Computer Journal , maio 1983.
- SANTUCCI, G. Semantic schema refinements for multilevel schema integration. DKE , v. 25, n. 3, p. 301-326, 1998.
- SARASUA, W.; O'NEILL, W. GIS in Transportation. In: Taylor and Francis , 1999.
- SARAWAGI, S.; THOMAS, S.; AGRAWAL, R. Integrating association rules mining with relational database systems: Alternatives and implications. In: SIGMOD , 1998.
- SAVASERE, A.; OMIECINSKI, E.; NAVATHE, S. An efficient algorithm for mining association rules. In: VLDB , 1995.
- \_\_\_\_\_\_.; \_\_\_\_\_\_.; \_\_\_\_\_\_. Mining for strong negative association in a large database of customer transactions. In: ICDE , 1998.
- SCHATZ, B.  Information  analysis  in  the  Net:  The  interspace  of  the twenty-first century. Keynote Plenary Lecture at American Society for Information Science  ASIS  Annual Meeting ( ) . Chicago, 11 out. 1995.
- \_\_\_\_\_\_. Information retrieval in digital libraries: Bringing search to the Net. Science , v. 275, n. 17, jan. 1997.
- SCHEK, H. J.; SCHOLL, M. H. The relational model with relation-valued attributes. Information Systems , v. 11, n. 2, 1986.
- \_\_\_\_\_\_. et al. The DASDBS project: Objects, experiences, and future projects. TKDE , v. 2, n. 1, 1990.
- SCHEUERMANN, P.;  SCHIFFNER,  G.;  WEBER,  H.  Abstraction capabilities  and  invariant  properties  modeling  within  the  entity-relationship approach. In: ER Conference , 1979.
- SCHLIMMER, J.; MITCHELL, T.; MCDERMOTT, J. Justification based refinement of expert knowledge . In: PIATETSKY-SHAPIRO; FRAWLEY, 1991.

SCHLOSSNAGLE, G. Advanced PHP programming . Sams, 2005.

- SCHMIDT, J.; SWENSON, J. On the semantics of the relational model. In: SIGMOD , 1975.
- SCHNEIDER, R. D. MySQL database design and tuining .  MySQL Press, 2006.
- SCHOLL, M. O.; VOISARD, A.; RIGAUX, P. Spatial database management systems . Morgan Kauffman, 2001.

- SCIORE, E. A complete axiomatization for full join dependencies. JACM , v. 29, n. 2, abril 1982.
- SCOTT, M.; FOWLER, K. UML distilled : Applying the standard object modeling language. Addison-Wesley, 1997.
- SELINGER, P. et al. Access path selection in a relational database management system. In: SIGMOD , 1979.
- SENKO, M. Specification of stored data structures and desired output in DIAM II with FORAL. In: VLDB , 1975.
- \_\_\_\_\_\_. A Query maintenance language for the data independent accessing Model II. Information Systems , v. 5, n. 4, 1980.
- SHAPIRO, L. Join processing in database systems with large main memories. TODS , v. 11, n. 3, 1986.
- SHASHA, D.; BONNET, P. Database tuning : Principles, experiments, and troubleshooting techniques. Ed. rev. Morgan Kaufmann, 2002.
- \_\_\_\_\_\_.;  GOODMAN, N. Concurrent search structure  algorithms. TODS , v.13, n. 1, mar. 1988.
- SHEKHAR, S.; CHAWLA, S. Spatial Databases ,  A  Tour. Prentice-Hall, 2003.
- \_\_\_\_\_\_.; XONG, H. Encyclopedia of GIS . Springer Link (Online service), 2008.
- SHEKITA, E.; CAREY, M. Performance enhancement through replication in an object-oriented DBMS. In: SIGMOD , 1989.
- SHENOY, S.; OZSOYOGLU, Z. Design and implementation of a semantic Query optimizer. TKDE , v. 1, n. 3, set. 1989.
- SHETH, A. P.; LARSON, J. A. Federated database systems for managing distributed, heterogeneous, and autonomous databases. ACM Computing Surveys , v. 22, n. 3, p. 183-236, set. 1990.
- SHETH, A.; GALA, S.; NAVATHE, S. On automatic reasoning for schema integration. In: International Journal of Intelligent Co-operative Information Systems , v. 2, n. 1, mar. 1993.
- \_\_\_\_\_\_.  et  al.  A  tool  for  integrating  conceptual  schemas  and  user views. In: ICDE , 1988.
- SHIPMAN, D. The functional data model and the data language DAPLEX. TODS , v. 6, n. 1, mar. 1981.
- SHLAER, S.; MELLOR, S. Object-oriented system analysis : Modeling the world in data. Prentice-Hall, 1988.
- SHNEIDERMAN, B. (Ed.). Databases : Improving usability and responsiveness. Academic Press, 1978.
- SIBLEY,  E.;  KERSCHBERG, L.  Data  architecture  and  data  model considerations. NCC, AFIPS , v. 46, 1977.
- SIEGEL, M.; MADNICK, S. A metadata approach to resolving semantic conflicts. In: VLDB , 1991.
- \_\_\_\_\_\_.; SCIORE, E.; SALVETER, S. A method for automatic rule derivation to support semantic query optimization. TODS , v. 17, n. 4, dez. 1992.
- SIGMOD. Proc.  ACM  SIGMOD-SIGFIDET  Conference  on  Data Description, Access, and Control . In: RUSTIN, R. (Ed.)., maio 1974.

SIGMOD.

Proc. 1975 ACM SIGMOD International Conference on

Management of Data

. In: KING, F. (Ed.). San Jose, CA, maio 1975.

- SIGMOD. Proc.  1976  ACM  SIGMOD  International  Conference  on Management of Data . In: ROTHNIE, J. (Ed.). Washington, jun. 1976.
- SIGMOD. Proc. 1977 ACM SIGMOD International Conference on Management of Data . In: SMITH, D. (Ed.). Toronto, ago. 1977.
- SIGMOD. Proc.  1978  ACM  SIGMOD  International  Conference  on Management of Data . In: LOWENTHAL, E.; DALE, N. (Eds.). Austin, TX, maio/jun. 1978.
- SIGMOD. Proc.  1979  ACM  SIGMOD  International  Conference on Management of Data . In: BERNSTEIN, P. (Ed.). Boston, MA, maio/jun. 1979.
- SIGMOD. Proc. 1980 ACM SIGMOD International Conference on Management of Data . In: CHEN, P.; SPROWLS, R. (Eds.). Santa Monica, CA, maio 1980.
- SIGMOD. Proc. 1981 ACM SIGMOD International Conference on Management of Data .  In:  LIEN, Y. (Ed.). Ann Arbor, MI, abril/ maio 1981.
- SIGMOD. Proc. 1982 ACM SIGMOD International Conference on Management of Data . In: SCHKOLNICK, M. (Ed.). Orlando, FL, jun. 1982.
- SIGMOD. Proc. 1983 ACM SIGMOD International Conference on Management of Data .  In:  DeWITT,  D.;  GARDARIN, G. (Eds.). San Jose, CA, maio 1983.
- SIGMOD. Proc. 1984 ACM SIGMOD International Conference on Management of Data . In: YORMARK, E. (Ed.). Boston, MA, jun. 1984.
- SIGMOD. Proc. 1985 ACM SIGMOD International Conference on Management of Data . In: NAVATHE, S. (Ed.). Austin, TX, maio 1985.
- SIGMOD. Proc. 1986 ACM SIGMOD International Conference on Management of Data . In: ZANIOLO, C. (Ed.). Washington, maio 1986.
- SIGMOD. Proc. 1987 ACM SIGMOD International Conference on Management of Data .  In:  DAYAL, U.; TRAIGER, I. (Eds.). San Francisco, CA, maio 1987.
- SIGMOD. Proc. 1988 ACM SIGMOD International Conference on Management of Data . In: BORAL, H.; LARSON, P. (Eds.). Chicago, jun. 1988.
- SIGMOD. Proc. 1989 ACM SIGMOD International Conference on Management of Data. In: CLIFFORD, J.; LINDSAY, B.; MAIER, D. (Eds.). Portland, OR, jun. 1989.
- SIGMOD. Proc. 1990 ACM SIGMOD International Conference on Management of Data. In: GARCIA-MOLINA, H.; JAGADISH, H. (Eds.). Atlantic City, NJ, jun. 1990.
- SIGMOD. Proc. 1991 ACM SIGMOD International Conference on Management of Data . In: CLIFFORD, J.; KING, R. (Eds.). Denver, CO, jun. 1991.
- SIGMOD. Proc. 1992 ACM SIGMOD International Conference on Management of Data . In: STONEBRAKER, M. (Ed.). San Diego, CA, jun. 1992.
- SIGMOD. Proc. 1993 ACM SIGMOD International Conference on Management of Data . In: BUNEMAN, P.; JAJODIA, S. (Eds.). Washington, jun. 1993.
- SIGMOD. Proceedings of 1994 ACM SIGMOD International Conference on Management of Data . In: SNODGRASS, R. T.; WINSLETT, M. (Eds.). Minneapolis, MN, jun. 1994.
- SIGMOD. Proceedings of 1995 ACM SIGMOD International Conference on Management of Data . In: CAREY, M.; SCHNEIDER, D. A. (Eds.). Minneapolis, MN, jun. 1995.
- SIGMOD. Proceedings of 1996 ACM SIGMOD International Conference on Management of Data .  In:  JAGADISH, H. V.; MUMICK, I. P. (Eds.). Montreal, jun. 1996.
- SIGMOD. Proceedings of 1997 ACM SIGMOD International Conference on Management of Data . In: PECKHAM, J. (Ed.). Tucson, AZ, maio 1997.
- SIGMOD. Proceedings of 1998 ACM SIGMOD International Conference on Management of Data . In: HAAS, L.; TIWARY, A. (Eds.). Seattle, WA, jun. 1998.
- SIGMOD. Proceedings of 1999 ACM SIGMOD International Conference on Management of Data . In: FALOUTSOS, C. (Ed.). Filad√©lfia, PA, maio 1999.
- SIGMOD. Proceedings of 2000 ACM SIGMOD International Conference on Management of Data . In: CHEN, W.; NAUGHTON J.; BERNSTEIN, P. (Eds.). Dallas, TX, maio 2000.
- SIGMOD. Proceedings of 2001 ACM SIGMOD International Conference on Management of Data . In: AREF, W. (Ed.). Santa Barbara, CA, maio 2001.
- SIGMOD. Proceedings of 2002 ACM SIGMOD International Conference on Management of Data . In: FRANKLIN, M.; MOON, B.; AILAMAKI, A. (Eds.). Madison, WI, jun. 2002.

- SIGMOD. Proceedings of 2003 ACM SIGMOD International Conference on Management of Data . In: HALEVY, Y.; ZACHARY, G.; DOAN, A. (Eds.). San Diego, CA, jun. 2003.
- SIGMOD. Proceedings of 2004 ACM SIGMOD International Conference on Management of Data . In: WEIKUM, G.; CHRISTIAN K√ñNIG, A.; DeBLOCH, S. (Eds.). Paris, Fran√ßa, jun. 2004.
- SIGMOD. Proceedings of 2005 ACM SIGMOD International Conference on Management of Data . In: WIDOM, J. (Ed.). Baltimore, MD, jun. 2005.
- SIGMOD. Proceedings of 2006 ACM SIGMOD International Conference on Management of Data . In: CHAUDHARI, S.; HRISTIDIS, V.; POLYZOTIS, N. (Eds.). Chicago, IL, jun. 2006.
- SIGMOD. Proceedings of 2007 ACM SIGMOD International Conference on Management of Data. In:  CHAN, C.-Y.; OOI, B.-C.; ZHOU, A. (Eds.). Beijing, China, jun. 2007.
- SIGMOD. Proceedings of 2008 ACM SIGMOD International Conference on Management of Data . In: WANG, J. T.-L. (Ed.). Vancouver, Canad√°, jun. 2008.
- SIGMOD. Proceedings of 2009 ACM SIGMOD International Conference on Management of Data. In: CETINTEMEL, U. et al. (Eds.). Providence, RI, jun.-jul. 2009.
- SIGMOD. Proceedings of 2010 ACM SIGMOD International Conference on Management of Data . Indianapolis, IN, jun. 2010.
- SILBERSCHATZ, A.; KORTH, H.; SUDARSHAN, S. Database system concepts . 5. ed. McGraw-Hill, 2006.
- \_\_\_\_\_\_.;  STONEBRAKER,  M.;  ULLMAN,  J.  Database  systems: Achievements and opportunities. In: ACM SIGMOD Record ,  v. 19, n. 4, dez. 1990.
- SIMON,  H.  A.  Designing  organizations  for  an  information-rich world.  In:  GREENBERGER,  M.  (Ed.). Computers,  communications and the public interest, p. 37-72. The Johns Hopkins University Press, 1971.
- SION, R.; ATALLAH, M.; PRABHAKAR, S. Protecting rights proofs for relational data using watermarking. TKDE , v. 16, n. 12, p. 1509-1525, 2004.
- SKLAR, D. Learning PHP5 . O'Reilly Media, Inc., 2005.
- SMITH, G. The semantic data model for security: Representing the security semantics of an application. In: ICDE , 1990.
- SMITH, J. et al. MULTIBASE: Integrating distributed heterogeneous database systems. NCC, AFIPS , v. 50, 1981.
- \_\_\_\_\_\_.; CHANG, P. Optimizing the performance of a relational algebra interface. CACM , v. 18, n. 10, out. 1975.
- \_\_\_\_\_\_.; SMITH, D. Database abstractions: Aggregation and generalization. TODS , v. 2, n. 2, jun. 1977.
- SMITH, J. R.; CHANG, S.-F. VisualSEEk: A fully automated content-based image query system. Proc. 4th ACM Multimedia Conf ., p. 8798. Boston, MA, nov. 1996.
- SMITH, K.; WINSLETT, M. Entity modeling in the MLS relational model. In: VLDB , 1992.
- SMITH, P.; BARNES, G. Files and databases : An introduction. Addison-Wesley, 1987.
- SNODGRASS, R. The temporal query language TQuel. TODS , v. 12, n. 2, jun. 1987.
- \_\_\_\_\_\_; AHN, I. A taxonomy of time in databases. In: SIGMOD , 1985.
- \_\_\_\_\_\_. (Ed.). The TSQL2 temporal Query language . Springer, 1995. SOUTOU,  G.  Analysis  of  constraints  for  N-ary  relationships.  In: ER98 , 1998.
- SPACCAPIETRA,  S.;  JAIN,  R. (Eds.). Proc. Visual Database Workshop. Lausanne, Su√≠√ßa, out. 1995.
- SPILIOPOULOU,  M.  Web  usage  mining  for  Web  site  evaluation. CACM , v. 43, n. 8, p. 127-134, ago. 2000.
- SPOONER D.; MICHAEL, A.; DONALD, B. Modeling CAD data with data abstraction and object-oriented technique. In: ICDE , 1986.
- SRIKANT, R.; AGRAWAL, R. Mining generalized association rules. In: VLDB , 1995.
- SRINIVAS,  M.;  PATNAIK,  L.  Genetic  algorithms:  A  survey. IEEE Computer , v. 27, n. 6, p.17-26, jun. 1994.
- SRINIVASAN, V.; CAREY, M. Performance of B-Tree concurrency control algorithms. In: SIGMOD , 1991.
- SRIVASTAVA, D. et al. Coral++: Adding object-orientation to a logic database language. In: VLDB , 1993.
- SRIVASTAVA, J. et al. Web usage mining: Discovery and applications of usage patterns from Web data. SIGKDD Explorations , v. 1, n. 2, 2000.
- STACHOUR, P.; THURAISINGHAM, B. The design and implementation of INGRES. TKDE , v. 2, n. 2, jun. 1990.
- STALLINGS, W. Data and computer communications . 5. ed. Prentice-Hall, 1997.
- \_\_\_\_\_\_. Network security essentials, applications and standards .  4. ed. Prentice-Hall, 2010.
- STEVENS, P.; POOLEY, R. Using UML : Software engineering with objects and components. Ed. rev. Addison-Wesley, 2003.
- STOESSER, G. et al. The EMBL nucleotide sequence database: Major new developments. Nucleic Acids Research , v. 31, n. 1, p. 17-22, jan. 2003.
- STOICA, I. et al. Chord: A Scalable peer-to-peer lookup service for internet applications. SIGCOMM , 2001.
- STONEBRAKER, M. et al. Mariposa: A wide-Area distributed database system. VLDB J , v. 5, n. 1, p. 48-63, 1996.
- \_\_\_\_\_\_. et al. C-store: A column oriented DBMS. In: VLDB , 2005.
- \_\_\_\_\_\_. Implementation of integrity constraints and views by query modification. In: SIGMOD , 1975.
- \_\_\_\_\_\_. The Miro DBMS. In: SIGMOD , 1993.
- \_\_\_\_\_\_.; ROWE, L. The design of POSTGRES. In: SIGMOD , 1986.
- \_\_\_\_\_\_.  (Ed.). Readings  in  database  systems .  2.  ed.  Morgan  Kaufmann, 1994.
- \_\_\_\_\_\_.;  HANSON, E.; HONG, C. The design of the POSTGRES rules system. In: ICDE , 1987.
- \_\_\_\_\_\_.;  MOORE,  D. Object-relational  DBMSs : The  next  great wave. Morgan Kaufmann, 1996.
- \_\_\_\_\_\_. et al. The design and implementation of INGRES. TODS , v. 1, n. 3, set. 1976.
- STROUSTRUP, B. The C++ programming language : Special edition. Pearson, 1997.
- SU, S. A semantic association model for corporate and scientific-statistical databases. Information Science , v. 29, 1985.
- \_\_\_\_\_\_. Database computers . McGraw-Hill, 1988.
- \_\_\_\_\_\_.; KRISHNAMURTHY, V.; LAM, H. An object-oriented semantic association model (OSAM*). In: AI in industrial engineering and manufacturing : Theoretical issues and applications. American Institute of Industrial Engineers, 1988.
- SUBRAHMANIAN, V. S.; JAJODIA, S. (Eds.). Multimedia database systems : Issues and research directions. Springer-Verlag, 1996.
- SUBRAHMANIAN, V. Principles of multimedia databases systems . Morgan Kaufmann, 1998.
- SUNDERRAMAN, R. ORACLE 10g programming : A primer. Addison-Wesley, 2007.
- SWAMI, A.; GUPTA, A. Optimization of large join queries: Combining heuristics and combinatorial techniques. In: SIGMOD , 1989.
- SYBASE. System administration guide : v. 1-2 (Adaptive server enterprise 15.0). Sybase, 2005.
- TAN, P.; STEINBACH, M.; KUMAR, V. Introduction to data mining . Addison-Wesley, 2006.
- TANENBAUM, A. Computer networks . 4. ed. Prentice-Hall PTR, 2003.
- TANSEL, A. et al. (Eds.). Temporal databases : Theory, design, and implementation. Benjamin Cummings, 1993.

TEOREY, T. Database modeling and design : The fundamental principles. 2. ed. Morgan Kaufmann, 1994.

- \_\_\_\_\_\_.; YANG, D.; FRY, J. A logical design methodology for relational databases using the extended entity-relationship model. ACM Computing Surveys , v. 18, n. 2, jun. 1986.
- THOMAS, J.; GOULD, J. A psychological study of query by example. NCC AFIPS , v. 44, 1975.
- THOMAS, R. A majority consensus approach to concurrency control for multiple copy data bases. TODS , v. 4, n. 2, jun. 1979.
- THOMASIAN,  A.  Performance  limits  of  two-phase  locking.  In: ICDE , 1991.
- THURAISINGHAM, B. Managing and mining multimedia databases . CRC Press, 2001.
- \_\_\_\_\_\_. et al. Directions for Web and E-commerce applications security. Proc. 10th IEEE International Workshops on Enabling Technologies: Infrastructure for Collaborative Enterprises , p. 200-204, 2001.
- TODD, S. The Peterlee relational test vehicle - A system overview. IBM Systems Journal , v. 15, n. 4, dez. 1976.
- TOIVONEN, H. Sampling large databases for association rules. In: VLDB , 1996.

TOU, J. (Ed.). Information systems COINS-IV . Plenum Press, 1984.

- TSANGARIS,  M.;  NAUGHTON,  J.  On  the  performance  of  object clustering techniques. In: SIGMOD , 1992.
- TSICHRITZIS, D. Forms management. CACM , v. 25, n. 7, jul. 1982.
- \_\_\_\_\_\_.; KLUG, A. (Eds.). The ANSI/X3/SPARC DBMS framework . AFIPS Press, 1978.
- \_\_\_\_\_\_.; LOCHOVSKY, F. Hierarchical database management: A survey. ACM Computing Surveys , v. 8, n. 1, mar. 1976.
- \_\_\_\_\_\_.; \_\_\_\_\_\_. Data models . Prentice-Hall, 1982.
- TSOTRAS, V.; GOPINATH, B. Optimal versioning of object classes. In: ICDE , 1992.
- TSOU, D. M.; FISCHER, P. C. Decomposition of a relation scheme into Boyce codd normal form. SIGACT News , v. 14, n. 3, p. 23-29, 1982.
- U.S. CONGRESS. Office of technology report, appendix D: Databases, repositories, and informatics. In: Mapping our genes : Genome projects: How big, how fast? John Hopkins University Press, 1988.
- U.S. DEPARTMENT OF COMMERCE. TIGER/Line files . Bureau of Census, Washington, 1993.
- ULLMAN, J. Principles of database systems . 2. ed. Computer Science Press, 1982.
- \_\_\_\_\_\_.  Implementation  of  logical  Query  languages  for  databases. TODS , v. 10, n. 3, set. 1985.
- \_\_\_\_\_\_. Principles  of  database  and  knowledge-base  systems .  v.  1. Computer Science Press, 1988.
- \_\_\_\_\_\_. Principles  of  database  and  knowledge-base  systems .  v.  2. Computer Science Press, 1989.
- ULLMAN, J.  D.;  WIDOM,  J. A  first  course  in  database  systems . Prentice-Hall, 1997.
- USCHOLD, M.; GRUNINGER, M. Ontologies: Principles, methods and applications. Knowledge Engineering Review , v. 11, n. 2, jun. 1996.
- VADIVELU, V. et al. A backup mechanism with concurrency control for multilevel secure distributed database systems. Proc. Int. Conf. on Digital Information Management , p. 57-62, 2008.
- VAIDYA,  J.;  CLIFTON,  C.  Privacy-preserving  data  mining:  Why, how, and what for? IEEE Security &amp; Privacy  IEEESP ( ), p. 19-27, nov.-dez. 2004.
- VALDURIEZ, P.; GARDARIN, G. Analysis and comparison of relational database systems . Addison-Wesley, 1989.
- Van RIJSBERGEN, C. J. Information retrieval . Butterworths, 1979.
- VASSILIOU, Y. Functional dependencies and incomplete information. In: VLDB , 1980.
- V√âLEZ, F.; BERNARD, G.; DARNIS, V. The O2 object manager: An overview. In: VLDB , p. 357-366, 1989.
- VERHEIJEN, G.; Van BEKKUM, J. NIAM : An information analysis method. In: OLLE et al., 1982.
- VERHOFSTAD, J. Recovery techniques for database systems. ACM Computing Surveys , v. 10, n. 2, jun. 1978.
- VIELLE,  L.  Recursive  axioms  in  deductive  databases:  The  Query-subquery approach. In: EDS , 1986.
- \_\_\_\_\_\_. Database complete proof production based on SLD-resolution. In: Proc. Fourth International Conference on Logic Programming , 1987.
- \_\_\_\_\_\_. From QSQ towards QoSaQ: Global optimization of recursive queries. In: EDS , 1988.
- \_\_\_\_\_\_. VALIDITY: Knowledge independence for electronic mediation. Practical  Applications  of  Prolog/Practical  Applications  of Constraint Technology  PAP/PACT '98 ( ). Londres, mar. 1998.
- VIN, H. et al. Multimedia conferencing in the etherphone environment. IEEE Computer , Special Issue on Multimedia Information Systems , v. 24, n. 10, out. 1991.
- VLDB. Proc. First International Conference on Very Large Data Bases . In: KERR, D. (Ed.). Framingham, MA, set. 1975.
- VLDB.Systems for large databases. In: LOCKEMANN, P.; NEUHOLD, E. (Eds.). Proc. Second International Conference on Very Large Data Bases . Brussels, Belgium, jul. 1976; North-Holland, 1976.
- VLDB. Proc. Third International Conference on Very Large Data Bases . In: MERTEN, A. (Ed.). T√≥quio, Jap√£o, out. 1977.
- VLDB. Proc. Fourth International Conference on Very Large Data Bases. In:  BUBENKO, J.; YAO, S. (Eds.). Berlim Ocidental, Alemanha, set. 1978.
- VLDB. Proc.  Fifth  International  Conference  on  Very  Large  Data Bases. In: FURTADO, A.; MORGAN, H. (Eds.). Rio de Janeiro, Brasil, out. 1979.
- VLDB. Proc. Sixth International Conference on Very Large Data Bases . In: LOCHOVSKY, F.; TAYLOR, R. (Eds.). Montreal, Canad√°, out. 1980.
- VLDB. Proc. Seventh International Conference on Very Large Data Bases. In:  ZANIOLO, C.; DELOBEL, C. (Eds.). Cannes, Fran√ßa, set. 1981.
- VLDB. Proc.  Eighth International Conference on Very Large Data Bases. In: McLEOD, D.; VILLASENOR, Y. (Eds.). Cidade do M√©xico, set. 1982.
- VLDB. Proc. Ninth International Conference on Very Large Data Bases. In: SCHKOLNICK, M.; THANOS, C. (Eds.). Floren√ßa, It√°lia, out./nov. 1983.
- VLDB. Proc.  Tenth  International  Conference  on  Very  Large  Data Bases. In: DAYAL, U.; SCHLAGETER, G.; SENG, L. (Eds.). Cingapura, ago. 1984.
- VLDB. Proc. Eleventh International Conference on Very Large Data Bases. In: PIROTTE, A.; VASSILIOU, Y. (Eds.). Estocolmo, Su√©cia, ago. 1985.
- VLDB. Proc. Twelfth International Conference on Very Large Data Bases. In: CHU, W.; GARDARIN, G.; OHSUGA, S. (Eds.). Kyoto, Jap√£o, ago. 1986.
- VLDB. Proc. Thirteenth International Conference on Very Large Data Bases. In: STOCKER, P.; KENT, W.; HAMMERSLEY, P. (Eds.). Brighton, Inglaterra, set. 1987.
- VLDB. Proc.  Fourteenth  International  Conference  on  Very  Large Data Bases. In: BANCILHON, F.; DeWITT, D. (Eds.). Los Angeles, ago./set. 1988.
- VLDB. Proc. Fifteenth International Conference on Very Large Data Bases . In: APERS, P.; WIEDERHOLD, G. (Eds.). Amsterd√£, ago. 1989.
- VLDB. Proc. Sixteenth International Conference on Very Large Data Bases. In:  MCLEOD, D.; SACKS-DAVIS, R.; SCHEK, H. (Eds.). Brisbane, Austr√°lia, ago. 1990.

- VLDB. Proc.  Seventeenth  International  Conference  on  Very  Large Data Bases. In:  LOHMAN, G.; SERNADAS, A.; CAMPS, R. (Eds.). Barcelona, Catalunha, Espanha, set. 1991.
- VLDB. Proc.  Eighteenth  International  Conference  on  Very  Large Data Bases . In: YUAN, L. (Ed.). Vancouver, Canad√°, ago. 1992.
- VLDB. Proc.  Nineteenth  International  Conference  on  Very  Large Data Bases . In: AGRAWAL, R.; BAKER, S.; BELL, D. A. (Eds.). Dublin, Irlanda, ago. 1993.
- VLDB. Proc. 20th International Conference on Very Large Data Bases. In: BOCCA, J.; JARKE, M.; ZANIOLO, C. (Eds.). Santiago, Chile, set. 1994.
- VLDB. Proc. 21st International Conference on Very Large Data Bases. In: DAYAL, U.; GRAY, P. M. D.; NISHIO, S. (Eds.). Zurich, Su√≠√ßa, set. 1995.
- VLDB. Proc. 22nd International Conference on Very Large Data Bases. In: VIJAYARAMAN, T. M. et al. (Eds.). Bombaim, √çndia, set. 1996.
- VLDB. Proc. 23rd International Conference on Very Large Data Bases. In: JARKE, M. et al. (Eds.). Zurich, Su√≠√ßa, set. 1997.
- VLDB. Proc. 24th International Conference on Very Large Data Bases. In: GUPTA, A.; SHMUELI, O.; WIDOM, J. (Eds.). Nova York, set. 1998.
- VLDB. Proc. 25th International Conference on Very Large Data Bases . In: ZDONIK, S. B.; VALDURIEZ, P.; ORLOWSKA, M. (Eds.). Edimburgo, Esc√≥cia, set. 1999.
- VLDB. Proc. 26th International Conference on Very Large Data Bases. In: ABBADI, A. et al. (Eds.). Cairo, Egito, set. 2000.
- VLDB. Proc. 27th International Conference on Very Large Data Bases . In: APERS, P. et al. (Eds.). Roma, It√°lia, set. 2001.
- VLDB. Proc. 28th International Conference on Very Large Data Bases. In:  BERNSTEIN, P.; IONNIDIS, Y.; RAMAKRISHNAN, R. (Eds.). Hong Kong, China, ago. 2002.
- VLDB. Proc. 29th International Conference on Very Large Data Bases. In: FREYTAG, J. et al. (Eds.). Berlim, Alemanha, set. 2003.
- VLDB. Proc. 30th International Conference on Very Large Data Bases. In: NASCIMENTO, M. et al. (Eds.). Toronto, Canad√°, set. 2004.
- VLDB. Proc. 31st International Conference on Very Large Data Bases. In: B√ñHM, K. et al. (Eds.). Trondheim, Noruega, ago.-set. 2005.
- VLDB. Proc. 32nd International Conference on Very Large Data Bases . In: DAYAL, U. et al. (Eds.). Seoul, Coreia, set. 2006.
- VLDB. Proc. 33rd International Conference on Very Large Data Bases. In: KOCH, C. et al. (Eds.). Vienna, √Åustria, set. 2007.
- VLDB. Proc. 34th International Conference on Very Large Data Bases. Proceedings of the VLDB endowment, v. 1. Auckland, Nova Zel√¢ndia, ago. 2008.
- VLDB. Proc. 35th International Conference on Very Large Data Bases. Proceedings of the VLDB Endowment, v. 2. Lyon, Fran√ßa, ago. 2009.
- VLDB. Proc. 36th International Conference on Very Large Data Bases. Proceedings of the VLDB Endowment, v. 3. Cingapura, ago. 2010.
- VOORHEES, E.; HARMAN, D. (Eds.). TREC experiment and evaluation in information retrieval . MIT Press, 2005.
- VORHAUS, A.; MILLS, R. The time-shared data management system : A new approach to data management. System Development Corporation, Report SP-2634, 1967.
- WALLACE,  D.  1994  William  Allan  award  address:  Mitochondrial DNA variation in human evolution, degenerative disease, and aging. American Journal of Human Genetics , v. 57, p. 201-223, 1995.
- WALTON, C.; DALE, A.; JENEVEIN, R. A taxonomy and performance model of data skew effects in parallel joins. In: VLDB , 1991.
- WANG, K. Polynomial time designs toward both BCNF and efficient data manipulation. In: SIGMOD , 1990.
- WANG, Y.; MADNICK, S. The inter-database instance identity problem in integrating autonomous systems. In: ICDE , 1989.
- \_\_\_\_\_\_.; ROWE, L. Cache consistency and concurrency control in a client/server DBMS architecture. In: SIGMOD , 1991.
- WARREN, D. Memoing for  logic  programs. CACM ,  v.  35,  n.  3, ACM, mar. 1992.
- WEDDELL, G. Reasoning about functional dependencies generalized for semantic data models. TODS , v. 17, n. 1, mar. 1992.
- WEIKUM, G. Principles and realization strategies of multilevel transaction management. TODS , v. 16, n. 1, mar. 1991.
- WEISS, S.; INDURKHYA, N. Predictive data mining : A practical guide. Morgan Kaufmann, 1998.
- WHANG, K. Query optimization in office by example. IBM Research Report RC 11571 , dez. 1985.
- \_\_\_\_\_\_.; NAVATHE, S. An extended disjunctive normal form approach for processing recursive logic queries in loosely coupled environments. In: VLDB , 1987.
- \_\_\_\_\_\_.; \_\_\_\_\_\_. Integrating expert systems with database management systems - An extended disjunctive normal form approach. Information Sciences , v. 64, mar. 1992.
- \_\_\_\_\_\_. et al. Supporting universal quantification in a two-dimensional database Query language. In: ICDE , 1990.
- \_\_\_\_\_\_.;  WIEDERHOLD,  G.;  SAGALOWICZ,  D.  Physical  design of network model databases using the property of separability. In: VLDB , 1982.
- WIDOM, J. Research problems in data warehousing. CIKM , nov. 1995. \_\_\_\_\_\_.; CERI, S. Active database systems . Morgan Kaufmann, 1996.
- \_\_\_\_\_\_.; FINKELSTEIN, S. Set oriented production rules in relational database systems. In: SIGMOD , 1990.
- WIEDERHOLD, G.  Knowledge  and  database  management. IEEE Software , jan. 1984.

\_\_\_\_\_\_.

- File organization for database design . McGraw-Hill, 1987.
- \_\_\_\_\_\_. Digital libraries, value, and productivity. CACM , abril 1995.
- \_\_\_\_\_\_.; ELMASRI, R. The structural model for database design. In: ER Conference , 1979.
- \_\_\_\_\_\_.; BEETEM, A.; SHORT, G. A database approach to communication in VLSI design. IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems , v. 1, n. 2, abril 1982.
- WILKINSON, K.; LYNGBAEK, P.; HASAN, W. The IRIS architecture and implementation. TKDE , v. 2, n. 1, mar. 1990.
- WILLSHIRE, M. How spacey can they get? Space overhead for storage and indexing with object-oriented databases. In: ICDE , 1991.
- WILSON, B.; NAVATHE, S. An analytical framework for limited redesign of distributed databases. Proc. Sixth Advanced Database Symposium. T√≥quio, ago. 1986.
- WIORKOWSKI, G.; KULL, D. DB2 : Design and development guide. 3. ed. Addison-Wesley, 1992.
- WIRTH, N. Algorithms and data structures . Prentice-Hall, 1985.
- WITTEN, I.  H.;  BELL,  T.  C.;  MOFFAT,  A.  Managing  gigabytes: Compressing and indexing documents and images. Wiley, 1994.
- WOLFSON, O. et al. Modeling moving objects for location based services . NSF workshop on infrastructure for mobile and wireless systems. LNCS 2538, p. 46-58, 2001.
- WONG, E. Dynamic rematerialization: Processing distributed queries using redundant data. TSE , v. 9, n. 3, maio 1983.
- \_\_\_\_\_\_.; YOUSSEFI, K. Decomposition - A strategy for Query processing. TODS , v. 1, n. 3, set. 1976.
- WONG, H. Micro and macro statistical/Scientific database management. In: ICDE , 1984.
- WOOD, J.; SILVER, D. Joint application design : How to design quality systems in 40% less time. Wiley, 1989.
- WORBOYS, M.; DUCKHAM, M. GIS - A computing perspective. 2. ed. CRC Press, 2004.
- WRIGHT,  A.;  CAROTHERS,  A.;  CAMPBELL,  H.  Gene-environment interactions the BioBank UK study. Pharmacogenomics Journal , p. 75-82, 2002.

WU, X.; ICHIKAWA, T. KDA: A knowledge-based database assistant with a Query guiding facility. TKDE , v. 4, n. 5, out. 1992.

- &lt;www.oracle.com/ocom/groups/public/@ocompublic/documents/Webcontent/039544.pdf&gt;.

XIE, I. Interactive information retrieval in digital environments . IGI Publishing, Hershey, PA, 2008.

XIE, W. Supporting distributed transaction processing over mobile and heterogeneous platforms . Disserta√ß√£o de Ph.D. Georgia Tech, 2005.

- \_\_\_\_\_\_.; NAVATHE, S.; PRASAD, S. Supporting QoS-Aware transaction in the middleware for a system of mobile devices (SyD). Proc. 1st  Int.  Workshop on Mobile Distributed Computing in ICDCS '03 . Providence, RI, maio 2003.

XML. &lt;www.w3.org/XML/&gt;. 2005.

YANNAKAKIS, Y. Serializability by locking. JACM , v. 31, n. 2, 1984. YAO, S. Optimization of Query evaluation algorithms. TODS , v. 4, n. 2, jun. 1979.

- \_\_\_\_\_\_. (Ed.). Principles of database design ,  v.  1:  Logical organizations. Prentice-Hall, 1985.

YEE, K.-P. et al. Faceted metadata for image search and browsing. Proc.ACM CHI 2003  Conference on Human Factors in Compu-( ting Systems ). Ft. Lauderdale, FL, p. 401-408, 2003.

YEE, W. et al. Efficient data allocation over multiple channels at broadcast servers. IEEE Transactions on Computers, Special Issue on Mobility and Databases , v. 51, n. 10, 2002.

- \_\_\_\_\_\_.; DONAHOO, M.; NAVATHE, S. Scaling replica maintenance in intermittently synchronized databases. In: CIKM , 2001.
- YOSHITAKA, A.; ICHIKAWA, K. A survey on content-based retrieval for multimedia databases. TKDE , v. 11, n. 1, jan. 1999.
- YOUSSEFI, K.; WONG, E. Query processing in a relational database management system. In: VLDB , 1979.

ZADEH, L. The role of fuzzy logic in the management of uncertainty  in  expert  systems.  In: Fuzzy  Sets  and  Systems ,  v.  11.  North-Holland, 1983.

ZANIOLO, C. [1976] 'Analysis and Design of Relational Schemata for Database Systems', Ph.D. dissertation, University of California, Los Angeles, 1976.

- \_\_\_\_\_\_. Design and implementation of a logic based language for data intensive applications. ICLP/SLP 1988 , p. 1666-1687, 1988.
- \_\_\_\_\_\_. Deductive databases: Theory meets practice. In: EDBT ,  p. 1-15, 1990.
- \_\_\_\_\_\_. et al. (1986) Object-oriented database systems and knowledge systems. In: EDS , 1984.
- \_\_\_\_\_\_. Advanced database systems . Morgan Kaufmann, 1997.
- ZANTINGE, D.; ADRIAANS, P. Managing client server .  Addison-Wesley, 1996.
- ZAVE, P. Classification of research efforts in requirements engineering. ACM Computing Surveys , v. 29, n. 4, dez. 1997.
- ZEILER, Michael. Modeling our world - The ESRI guide to geodatabase design, 1999.
- ZHANG, T.; RAMAKRISHNAN, R.; LIVNY, M. Birch: An efficient data clustering method for very large databases. In: SIGMOD , 1996.
- ZHAO, R.; GROSKY, W. Bridging the semantic Gap in image retrieval. In: SHIH, T. K. (Ed.). Distributed multimedia databases : Techniques and applications. Idea Publishing, 2002.

ZHOU, X.; PU, P. Visual and multimedia information management. In: ZHOU, X.; PU, P. (Eds.). Proc. Sixth Working Conf. on Visual Database Systems . Brisbane, Austr√°lia, IFIP Conference Proceedings 216, Kluwer, 2002.

ZICARI, R. A framework for schema updates in an object-oriented database system. In: ICDE , 1991.

ZLOOF, M. Query by example. NCC, AFIPS , v. 44, 1975.

\_\_\_\_\_\_. Office by example: A business language that unifies data, word processing, and electronic mail. IBM Systems Journal , v. 21, n. 3, 1982. ZOBEL, J.; MOFFAT, A.; SACKS-DAVIS, R. An efficient indexing

- technique for full-text database systems. In: VLDB , 1992.

ZVIELI, A. A Fuzzy relational calculus. In: EDS , 1986.

- √© (asterisco), para recuperar todos os valores de atributo das tuplas selecionadas, 67
- √© (s√≠mbolo de curinga) tipos de consultas em sistemas de RI, 679-680

. (operador de concatena√ß√£o), em PHP , 328

- || (operador de concatena√ß√£o), em SQL, 60, 70

1FN (primeira forma normal), 42, 328,

349-353

2FN (segunda forma normal)

2PC (commit em duas fases), protocolo defini√ß√£o geral, 348

gerenciamento de transa√ß√£o em bancos de dados distribu√≠dos, 611-612

recupera√ß√£o em multibanco de dados,

543

vis√£o geral, 352

3FN (terceira forma normal).

Ver terceira

forma normal (3FN)

3PC (commit em tr√™s fases), protocolo,

612

5FN (quinta forma normal), 348, 359-

360

## A

| Abstra√ß√£o agrega√ß√£o e,                                |
|-------------------------------------------------------|
| 178                                                   |
| conceitos em modelos de dados sem√¢nticos, 177         |
| da associa√ß√£o, 178                                    |
| identifica√ß√£o e, 178                                  |
| Abstra√ß√£o de dados                                    |
| bancos de dados relacionais e, 15                     |
| isolamento entre programas e dados, 6, 7-8            |
| ACID, propriedades das transa√ß√µes, 500, 508, 520, 611 |

## √çndice remissivo

| A√ß√µes no modelo ECA, 627                                                                           |
|----------------------------------------------------------------------------------------------------|
| Adleman, eLen, 582                                                                                 |
| Administradores de banco de dados. Ver DBAs (administradores de banco de                           |
| dados) Advanced Encryption Standard (AES), 580 AFIM (after image), 545                             |
| Agrega√ß√£o temporal, 644 Agrega√ß√£o conceito de abstra√ß√£o, 178-179 em diagramas de classe UML, 154   |
| QBE (Query-By-Example), 97, 123, 124, 309, 737-743 temporal, 644 Agrupamento agrega√ß√£o e, 91, 125  |
| cl√°usulas GROUP BY e HAVING, 70                                                                    |
| Agrupamento f√≠sico dos tipos de objetos, 414                                                       |
| √Ålgebra opera√ß√µes da √°lgebra relacional, 50, 82, 96, 101-105 traduzindo consultas SQL para √°lgebra |
| 57,                                                                                                |
| relacional, 459-461 √Ålgebra relacional                                                             |
| condi√ß√£o EQUIJUN√á√ÉO, 81 conjunto completo de opera√ß√µes da √°lgebra relacional, 107-108              |
| exemplos de consultas, 115-116                                                                     |
| fun√ß√µes agregadas e agrupamento, 92 nota√ß√£o para √°rvores de consulta, 109-110                      |
| opera√ß√£o DIVIS√ÉO, 108-109 opera√ß√£o JUN√á√ÉO, 106, 107                                                |
| opera√ß√£o PRODUTO CARTESIANO, 82, 102-105                                                           |
| opera√ß√£o PROJE√á√ÉO, 98-100                                                                          |

| opera√ß√£o RENOMEAR, 151-152 opera√ß√£o SELE√á√ÉO, 100-101 opera√ß√µes JUN√á√ÉOEXTERNA,113-114 opera√ß√µes UNI√ÉO, INTERSEC√á√ÉO e SUBTRA√á√ÉO, 101-102      |
|---------------------------------------------------------------------------------------------------------------------------------------------|
| proje√ß√£o generalizada, 111 refer√™ncias bibliogr√°ficas, 280                                                                                  |
| regras de transforma√ß√£o para opera√ß√µes, 706-708 resumo e exerc√≠cios, 185-194 sequ√™ncias de opera√ß√µes, 100-101                               |
| Algoritmo de agrupamento espacial, 649                                                                                                      |
| Algoritmo de amostragem na minera√ß√£o de dados, 703-704                                                                                      |
| Algoritmo de parti√ß√£o, 706-707                                                                                                              |
| Algoritmo sem espera, 530 Algoritmos                                                                                                        |
| agrupamento de k-mean, 712 Apriori, 702-703 √°rvore de padr√£o frequente (FP), 704-706 chave p√∫blica (assim√©trica), 581-583                   |
| de amostragem, 703-704 de chave sim√©trica, 581. 586 de crescimento FP, 704-706 de pontua√ß√£o HITS, 688 de recupera√ß√£o, 510, 546, , 549, 550, |
| 551, 552, 553-556 gen√©ticos (GAs), 715                                                                                                      |
| mapeamento ER para relacional, otimiza√ß√£o alg√©brica heur√≠stica, 477                                                                         |
| 189-195 PageRank, 688 para indu√ß√£o da √°rvore de decis√£o, 709 parti√ß√£o, 706-707                                                              |
| recupera√ß√£o de ARIES, 553-556                                                                                                               |
| de chave p√∫blica 581-582 Algoritmos de chave sim√©trica, 581                                                                                 |
| Algoritmos                                                                                                                                  |
| (assim√©trica),                                                                                                                              |

| Algoritmos de crescimento FP, 704-706 Algoritmos de criptografia de chave assim√©trica, 581 Algoritmos de criptografia de conte√∫do, Algoritmos de indexa√ß√£o B+-tree, 424, 435-445 √≠ndice prim√°rio multin√≠vel n√£o denso, Algoritmos de normaliza√ß√£o fechamento de X sob F, 367 preserva√ß√£o de depend√™ncia e a propriedade de jun√ß√£o n√£o aditiva, preserva√ß√£o de depend√™ncia em esquemas 3FN, 374-375 para determinar a chave de uma rela√ß√£o, 369 conjuntos m√≠nimos de depend√™ncias funcionais, 368-369 decomposi√ß√£o de jun√ß√£o n√£o aditiva para rela√ß√µes 4FN, 382-383   |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 581 434                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| decomposi√ß√£o de jun√ß√£o n√£o aditiva para esquemas FNBC, 375 problemas com os, 379 s√≠ntese relacional para a 3FN com preserva√ß√£o de depend√™ncia, 374 resumo dos, 380                                                                                                                                                                                                                                                                                                                                                                                                   |
| 365                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| testando a propriedade de jun√ß√£o                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| aditiva, 371                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| gen√©ticos (GAs), 715                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| n√£o Algoritmos Algoritmos relacionados a arquivo chave de ordena√ß√£o para o arquivo,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 404 hashing, 389-423 hashing linear, 410, 412, 414, 459, √°lgebra de, 642                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 481                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Allen, Aloca√ß√£o e replica√ß√£o de dados, 601, 603                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| ALTER TABLE, comando, 59, 92                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| ALTER, comando, 91-92                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Ambiente do sistema de banco de                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| utilit√°rios do sistema de banco                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| dados de dados, 28-29 m√≥dulos de componentes do 26-28                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| SGBD, ferramentas, ambientes de aplica√ß√£o e                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| facilidades de comunica√ß√µes, 29                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| Ambientes ambiente de sistema de banco de dados, 4, 9 SQL, 50                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| National Standards Institute (ANSI), 36, 57                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| American Analisador sint√°tico, verifica a sintaxe                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| consulta, 457 An√°lise autom√°tica das fontes de                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| multim√≠dia, 650                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| An√°lise autom√°tica de imagens, 627                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| An√°lise de conte√∫do Web, baseada                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| agente, 690                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| An√°lise de fluxo, 646                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| no                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| da                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |

An√°lise de viabilidade, 204

| An√°lise digital de terreno, 646                                                                                                                                                                                                                                         |
|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| An√°lise espacial, 647 An√°lise estat√≠stica, 687 An√°lise morfol√≥gica no modelo sem√¢ntico para RI, 678                                                                                                                                                                     |
| An√°lise orientada a objeto, 208, 732                                                                                                                                                                                                                                    |
| An√°lise sint√°tica no modelo para RI, 678                                                                                                                                                                                                                                |
| sem√¢ntico                                                                                                                                                                                                                                                               |
| Anomalias de atualiza√ß√£o, informa√ß√µes redundantes nas tuplas, 341                                                                                                                                                                                                       |
| Anomalias de exclus√£o, informa√ß√µes redundantes nas tuplas, 341                                                                                                                                                                                                          |
| Anomalias de inser√ß√£o, informa√ß√µes redundantes nas tuplas, 341 Anomalias de modifica√ß√£o, prevenindo                                                                                                                                                                     |
| Anomalias, informa√ß√µes redundante nas tuplas e, 341-343 ANSI (American National Standards Institute), 36, 57                                                                                                                                                            |
| Antimonotonicidade, propriedade algoritmo Apriori, 702-703 regras de associa√ß√£o, 649, 692, 699,                                                                                                                                                                         |
| 701-709                                                                                                                                                                                                                                                                 |
| orientada a objeto), 208,                                                                                                                                                                                                                                               |
| AOO(an√°lise 732 API (Application Programming Interface), 31, 277, 285, 304, 314, 584, 716                                                                                                                                                                               |
| para programa√ß√£o de banco de dados, 303                                                                                                                                                                                                                                 |
| Aplica√ß√µes cient√≠ficas, 16 Aplica√ß√µes de banco de dados programa de aplica√ß√£o acessa o banco de dados, 4                                                                                                                                                                |
| como transa√ß√µes programadas, 303 projetando, 105 ambiente, 26 estendendo capacidades, 16-17 flexibilidade, relacionais, 15-16 ciclo de vida do sistema de, 204-205 orientadas a objeto, 12 programas de software que implementam, 302 dados espaciais, 58, 415, 645-646 |
| Aplica√ß√µes Web, 32 Aprendizado n√£o supervisionado agrupamento, 711 redes neurais, 714                                                                                                                                                                                   |
| Aprendizado supervisionado                                                                                                                                                                                                                                              |
| classifica√ß√£o, 709                                                                                                                                                                                                                                                      |
| redes neurais, 714                                                                                                                                                                                                                                                      |
| tradicionais, 2                                                                                                                                                                                                                                                         |
| usando sistemas hier√°rquicos e                                                                                                                                                                                                                                          |
| de espaciais, 16                                                                                                                                                                                                                                                        |
| Aplica√ß√µes                                                                                                                                                                                                                                                              |
| Apriori, algoritmo, 702-703                                                                                                                                                                                                                                             |
| rede,                                                                                                                                                                                                                                                                   |
| Arestas                                                                                                                                                                                                                                                                 |
| an√°lise autom√°tica de imagens,                                                                                                                                                                                                                                          |
| 627                                                                                                                                                                                                                                                                     |

| ARIES, algoritmo de recupera√ß√£o, 553-556                                                          |
|---------------------------------------------------------------------------------------------------|
| Aritm√©tica fun√ß√µes e procedimentos, 322 operadores em SQL, 89                                     |
| Armazenamento refer√™ncias bibliogr√°ficas, 280 gerenciamento de buffer, 26, 28, 455,               |
| 545 armazenamento de rela√ß√µes baseado em                                                          |
| coluna, 451-452 armazenamento de banco de dados,                                                  |
| 28, 418                                                                                           |
| reorganiza√ß√£o do armazenamento do banco de dados, 29                                              |
| cabe√ßalhos de arquivo, 401 arquivos, registros de tamanho fixo e                                  |
| registros de tamanho vari√°vel, 398-400 iSCSI (Internet SCSI), 389                                 |
| hierarquias de mem√≥ria, 398-391 NAS (Network-Attached Storage),                                   |
| 389, 418                                                                                          |
| bloqueio de registro, 537 registros e tipos de registro, 397-398                                  |
| SANs (Storage Area Networks), 418                                                                 |
| dispositivos de armazenamento                                                                     |
| secund√°rios, 392-396                                                                              |
| Armazenamento de disco, 389                                                                       |
| Armazenamento de fita magn√©tica, 389, 396 de rela√ß√µes baseado em coluna, 451-452 n√£o vol√°til, 391 |
| Armazenamento Armazenamento                                                                       |
| Armazenamento persistente para objetos do programa, 12                                            |
| Armazenamento prim√°rio, 390 Armazenamento secund√°rio, 390 Armazenamento terci√°rio, 390            |
| Armazenamento vol√°til, 391                                                                        |
| Armstrong, regras de infer√™ncia, 381 Arquitetura cliente/servidor de                              |
| 367, camadas, 31, 598                                                                             |
| duas Arquitetura cliente/servidor para                                                            |
| SGBDs, 30-32                                                                                      |
| arquitetura cliente/servidor de tr√™s camadas, 598-601 arquiteturas cliente/servidor de duas       |
| camadas, 31-32 de banco de dados                                                                  |
| Arquitetura distribu√≠do                                                                           |
| esquema de banco de dados 597-598                                                                 |
| federado, bancos de dados distribu√≠dos puros,                                                     |
| 586-597 arquitetura cliente-servidor de tr√™s                                                      |
| camadas, 598-601 de banco de dados                                                                |
| arquitetura centralizada, 30                                                                      |
| arquitetura cliente/servidor,                                                                     |
| Arquitetura                                                                                       |
| arquitetura de tr√™s camadas e n                                                                   |
| 30-31                                                                                             |

| arquitetura cliente/servidor de duas                                                           |
|------------------------------------------------------------------------------------------------|
| camadas, 31 Arquitetura de tr√™s esquemas independ√™ncia de dados, n√≠veis, 22-23 vis√£o geral, 22 |
| 22-24                                                                                          |
| distribu√≠da e paralela, 728                                                                    |
| Arquitetura                                                                                    |
| Arquitetura Label Security, 584-585                                                            |
| Arquitetura nada compartilhado, 586                                                            |
| Arquiteturas de N camadas, 32                                                                  |
| Arquiteturas de tr√™s camadas arquitetura cliente/servidor, 598-601 para aplica√ß√µes Web, 32 303 |
| Arquivo de comandos, Arquivo de hash, 406                                                      |
| Arquivo sequencial, 392 Arquivos (de registros)                                                |
| t√©cnica de banco de dados, 14 hashing din√¢mico, 412                                            |
| hashing extens√≠vel, 412                                                                        |
| hashing externo, 412 registros de tamanho                                                      |
| tamanho vari√°vel,                                                                              |
| fixo e registros 398-400 t√©cnicas de hashing, 406 cabe√ßalhos, 493                              |
| de                                                                                             |
| hashing interno, 406-408 hashing linear, 412 de registros mistos, 414 registros ordenados, 461 |
| organiza√ß√£o, 480                                                                               |
| pesquisa simples, 420 de registros desordenados                                                |
| (arquivos de heap), 403-404 de grade, 648                                                      |
| Arquivos Arquivos din√¢micos, 409, 412 Arquivos est√°ticos, 420                                  |
| Arrays de texels, 651                                                                          |
| Arrays, construtor, 240                                                                        |
| √Årvore FP (√°rvore de padr√£o 704                                                                |
| frequente), √Årvores bin√°rias, 437 √Årvores de consulta                                          |
| convertendo, em planos de execu√ß√£o de consulta, 478-479 nota√ß√£o, 109-110, 472-474              |
| otimiza√ß√£o, 474-479                                                                            |
| de decis√£o, 700                                                                                |
| de pesquisa, 436 √Årvores TV(√°rvores de vetor telesc√≥pico), 651 qualificador, 81                |
| palavra-chave para ordem crescente,                                                            |
| 70                                                                                             |
| especificando restri√ß√µes como, 87-88 digitais, 564, 582                                        |
| Asser√ß√µes Assinaturas Associa√ß√µes bidirecionais nos diagramas de classe UML, 150               |
| Associa√ß√µes bin√°rias nos diagramas de                                                          |
| ASC,                                                                                           |
| AS,                                                                                            |
| √Årvores √Årvores                                                                                |
| classe UML, 150                                                                                |

| Associa√ß√µes multidimensionais, 707-708 Associa√ß√µes negativas, 708-709 qualificadas nos diagramas                                                                                                                                                                           |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Associa√ß√µes de classe UML, 150 Associa√ß√µes, 140, 148, 150, 178, 220, 230, 253                                                                                                                                                                                              |
| autonomia nos sistemas de bancos dados federados, 590                                                                                                                                                                                                                      |
| de espaciais, 649                                                                                                                                                                                                                                                          |
| Asterisco ( √© ) para recuperar todos os valores de atributo das tuplas selecionadas, 67 Ataque de inje√ß√£o, 576                                                                                                                                                             |
| √Åtomos, c√°lculo nas f√≥rmulas de c√°lculo de dom√≠nio, 123 vis√£o geral, 118 valores verdade, 123 Atraso rotacional (rd), 736                                                                                                                                                  |
| Atributo de defini√ß√£o da especializa√ß√£o, 166 Atributo-chave, 137                                                                                                                                                                                                           |
| Atributos                                                                                                                                                                                                                                                                  |
| sem√¢ntica clara, 338, 339 tags HTML, 281                                                                                                                                                                                                                                   |
| modelo de objeto ODMG, 252, 257 relacionamentos, 134 renomeando, 101 recuperar todos os valores de tuplas selecionadas, 167 sem√¢ntica, 346 especificando restri√ß√µes de, 61-62 subconjuntos de, 44 condi√ß√µes de tempo, 644 diagramas de classe UML, 151 documentos XML, 284 |
| decis√µes de projeto sobre indexa√ß√£o, 492 √≠ndice ordenado em m√∫ltiplos, 446 registros, 392 √≠ndices secund√°rios, 218, 403, 438-431 √≠ndices de √∫nico n√≠vel, 424, 425, 452 complexos, 136                                                                                      |
| de agrupamento, 83, 85                                                                                                                                                                                                                                                     |
| Atributos de jun√ß√£o, 106 de proje√ß√£o, comando SELECT e, 64, 66, 100 derivados no modelo ER, 146                                                                                                                                                                            |
| Atributos Atributos Atributos espec√≠ficos, 163                                                                                                                                                                                                                             |
| Atributos no modelo ER complexos, 136 compostos versus simples, 135                                                                                                                                                                                                        |
| restri√ß√µes, 165-170 valores NULL, 136 valor √∫nico versus multivalorados, 135                                                                                                                                                                                               |
| armazenados versus derivados, 136                                                                                                                                                                                                                                          |
| Atributos de classifica√ß√£o no controle acesso obrigat√≥rio, 699                                                                                                                                                                                                             |
| de                                                                                                                                                                                                                                                                         |
| Atributos Atributos                                                                                                                                                                                                                                                        |

| Atributos no modelo relacional defini√ß√£o, 238 esquema de rela√ß√£o e, 41                     |
|--------------------------------------------------------------------------------------------|
| Atributos simples ou at√¥micos, 135 Atributos vis√≠veis e ocultos, 241                       |
| Atualiza√ß√£o retroativa, 639                                                                |
| Atualiza√ß√£o simult√¢nea, 639 Atualiza√ß√µes perdidas, 508                                     |
| Auditorias de banco de dados,                                                              |
| 565                                                                                        |
| Autentica√ß√£o ataque de inje√ß√£o de SQL, 576 pontos fracos, 577                              |
| Autonomia grau de autonomia local, 620                                                     |
| nos sistemas de bancos de dados federados, 590                                             |
| Autonomia da comunica√ß√£o em bancos de dados federados, 590 Autonomia da execu√ß√£o em bancos |
| dados federados, 590 Autonomia de projeto em bancos de                                     |
| dados federados, 590                                                                       |
| identificadores, 178 privil√©gios, 562, 593 12                                              |
| Avalia√ß√£o materializada, 479 Avalia√ß√£o pipeline, 479                                       |
| AVG, fun√ß√£o agrupamento e, 83                                                              |
| Axiomas de base, 657                                                                       |
| Axiomas dedutivos, 657                                                                     |
| AVG, fun√ß√£o em SQL,                                                                        |
| 83                                                                                         |
| obrigat√≥rio, 699                                                                           |
| subsistema em SGBDs, Autoriza√ß√£o, no controle                                              |
| Autoridades, hubs e, Autoriza√ß√£o                                                           |
| 688                                                                                        |
| de acesso                                                                                  |

## B

| B + -trees (√°rvores B + ) pesquisa, inser√ß√£o e exclus√£o com, 441 varia√ß√£o das, 436                                                                                                              |
|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Bachman, diagramas de, 732                                                                                                                                                                      |
| Backup e recupera√ß√£o. Ver tamb√©m t√©cnicas de recupera√ß√£o de banco de dados em bancos de dados, 17 m√≥dulos componentes do SGBD, 26 para fita magn√©tica, 557 recupera√ß√£o de banco de dados contra |
| Backup, utilit√°rio, 28                                                                                                                                                                          |
| Bag (multiconjunto) de tuplas, 64, 99                                                                                                                                                           |
| Bag, construtor, 240                                                                                                                                                                            |
| Banco de dados Universidade, 6                                                                                                                                                                  |
| Banco de dados, arquitetura. Ver arquitetura de banco de dados                                                                                                                                  |
| Banco de dados de back-end, 17                                                                                                                                                                  |
| Banco de dados, projeto. Ver projeto de banco de dados                                                                                                                                          |

| Banco de dados, seguran√ßa. Ver seguran√ßa do banco de dados                |
|---------------------------------------------------------------------------|
| Bancos de dados bitemporais, 640                                          |
| Bancos de dados de multim√≠dia                                             |
| an√°lise de fontes de dados de √°udio, 653                                  |
| an√°lise de imagens, 715 reconhecimento de objeto, 664                     |
| marca√ß√£o sem√¢ntica de imagens,                                            |
| 627 tipos de arquivos, 2                                                  |
| Bancos de dados de objeto. Ver ODBs                                       |
| (bancos de dados de objetos)                                              |
| Bancos de dados espaciais                                                 |
| aplica√ß√µes de dados espaciais,                                            |
| 649-650 indexa√ß√£o de dados, 667 minera√ß√£o de dados, 626                   |
| operadores, 647                                                           |
| de dados                                                                  |
| Bancos estat√≠sticos, 562                                                  |
| Bancos de dados grandes, 605 Bancos de dados                              |
| heterog√™neos SGBDDs, 33                                                   |
| de dados l√≥gicos,                                                         |
| 627                                                                       |
| Bancos Bancos de dados muito                                              |
| grandes, 699 Bancos de dados orientados a objeto. BDOOs (bancos de dados  |
| Ver orientados a objeto)                                                  |
| de dados pessoais, 10, 203                                                |
| Bancos Bancos de dados temporais                                          |
| vers√£o de atributo, 642 constru√ß√µes de consulta                           |
| temporal e linguagem TSQL2, 642-644                                       |
| a representa√ß√£o de tempo, calend√°rios e dimens√µes de tempo, 636-637       |
| dados de s√©rie temporais, 644-645                                         |
| rela√ß√µes de tempo de transa√ß√£o, 630-640                                   |
| rela√ß√µes bitemporais, 640-641                                             |
| de dados transacionais, 721 de dados, introdu√ß√£o                          |
| Bancos Bancos atores em cena, 9-10                                        |
| vantagens de usar a                                                       |
| abordagem de SGBD, 11-15 backup e recupera√ß√£o, 13                         |
| cole√ß√£o de itens de dados                                                 |
| nomeados, 502                                                             |
| defini√ß√£o, 2 projeto, 6                                                   |
| dedu√ß√£o e a√ß√µes usando recupera√ß√£o de informa√ß√µes                         |
| regras,                                                                   |
| 14 (RI), isolamento entre programas e                                     |
| 669 dados, e abstra√ß√£o de dados, 7-8 restri√ß√µes de integridade, 13-14     |
| interc√¢mbio de dados na Web XML, 16 m√∫ltiplas interfaces dos usu√°rios, 13 |
| usando m√∫ltiplas vis√µes de dados, 8                                       |
| orientados a objeto, 8 armazenamento persistente de                       |
| do programa, 12                                                           |
| pessoais, 10, 203                                                         |
| objetos                                                                   |
| processamento eficiente de consulta, 12-13                                |

| redund√¢ncia controlada, 11                                                                                                                                                                                                             |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| oferecendo abstra√ß√£o de dados e flexibilidade de aplica√ß√£o com, 15 natureza de autodescri√ß√£o, 6-7 compartilhamento de dados e processamento de transa√ß√£o multiusu√°rio, 8-9 armazenando e extraindo XML de, 291 resumo e exerc√≠cios, 18 |
| documentos                                                                                                                                                                                                                             |
| restringindo o acesso n√£o autorizado,                                                                                                                                                                                                  |
| um exemplo, 4-6                                                                                                                                                                                                                        |
| usar a abordagem de SGBD, 11-15                                                                                                                                                                                                        |
| trabalhadores nos bastidores, 10-11                                                                                                                                                                                                    |
| BDDs (bancos de dados distribu√≠dos)                                                                                                                                                                                                    |
| vantagens, 592 arquitetura, 596 autonomia, 592                                                                                                                                                                                         |
| gerenciamento de cat√°logo, computa√ß√£o de nuvem,                                                                                                                                                                                        |
| 615 615                                                                                                                                                                                                                                |
| controle de concorr√™ncia, 613 fragmenta√ß√£o de dados,                                                                                                                                                                                   |
| replica√ß√£o e aloca√ß√£o de                                                                                                                                                                                                               |
| dados,                                                                                                                                                                                                                                 |
| 601-603 custos de transfer√™ncia de dados                                                                                                                                                                                               |
| 603 do processamento de consulta                                                                                                                                                                                                       |
| distribu√≠do, 607                                                                                                                                                                                                                       |
| defini√ß√£o, 589                                                                                                                                                                                                                         |
| exemplo de fragmenta√ß√£o, aloca√ß√£o e replica√ß√£o, 603-605 fun√ß√µes, 593                                                                                                                                                                   |
| sistemas multiprocessador, 590                                                                                                                                                                                                         |
| em Oracle, 617-620 arquitetura paralelas versus                                                                                                                                                                                        |
| distribu√≠das, 596 sistemas de banco de dados                                                                                                                                                                                           |
| peer, 616                                                                                                                                                                                                                              |
| processamento de consulta, 605                                                                                                                                                                                                         |
| peer-to-                                                                                                                                                                                                                               |
| processamento de consulta                                                                                                                                                                                                              |
| distribu√≠do usando semijun√ß√£o, 608 recupera√ß√£o, 613                                                                                                                                                                                    |
| confiabilidade e disponibilidade, 592                                                                                                                                                                                                  |
| arquitetura cliente/servidor de tr√™s                                                                                                                                                                                                   |
| camadas, 598-601                                                                                                                                                                                                                       |
| gerenciamento de transa√ß√µes, 612                                                                                                                                                                                                       |
| transpar√™ncia, 591                                                                                                                                                                                                                     |
| tipos, 593                                                                                                                                                                                                                             |
| (bancos de dados a objeto)                                                                                                                                                                                                             |
| vers√£o de atributo, 642                                                                                                                                                                                                                |
| complexidade de dados, 204 armazenamento persistente, 575                                                                                                                                                                              |
| transaction, tipos de                                                                                                                                                                                                                  |
| transa√ß√£o, opera√ß√£o, 506, 509                                                                                                                                                                                                          |
| 519 modelo, 570                                                                                                                                                                                                                        |
| BEGIN_TRANSACTION,                                                                                                                                                                                                                     |
| Match 25 (BM25), 678                                                                                                                                                                                                                   |
| Begin                                                                                                                                                                                                                                  |
| BDOOs orientados                                                                                                                                                                                                                       |
| (before image), item de                                                                                                                                                                                                                |
| dados                                                                                                                                                                                                                                  |
| BFIM                                                                                                                                                                                                                                   |
| da atualiza√ß√£o de, 545                                                                                                                                                                                                                 |
| Bell-LaPadula, Best                                                                                                                                                                                                                    |
| antes                                                                                                                                                                                                                                  |

| bfr. Ver fator de bloco (bfr)                                                                                                                        |
|------------------------------------------------------------------------------------------------------------------------------------------------------|
| bibliotecas de fun√ß√µes. Ver chamadas de fun√ß√£o, programa√ß√£o de banco de dados com                                                                    |
| bibliotecas digitais e a Web, 699 B-link, √°rvore, 539                                                                                                |
| BLOBs (objetos bin√°rios grandes), 398                                                                                                                |
| Blocos de consulta, 459                                                                                                                              |
| Blocos de dados gerenciamento de buffer, 26, 28, 455, 545 ponteiros, 34, 218, 400, 409, 430 ordem sequencial para o acesso, 396 Blocos de disco, 552 |
| Bloqueio. Ver tamb√©m bloqueio em                                                                                                                     |
| duas fases para controle de concorr√™ncia, 538 n√≠vel de granularidade, 536                                                                            |
| bloqueio de √≠ndice, 539 granularidade m√∫ltiplo, 536 Bloqueio de certifica√ß√£o, 524                                                                    |
| Bloqueio de predicado, 540                                                                                                                           |
| Bloqueio em duas fases                                                                                                                               |
| bloqueios b√°sicos, 529                                                                                                                               |
| bloqueios bin√°rios, 524 convers√£o de bloqueios, 527                                                                                                  |
| serializa√ß√£o garantida pelo,                                                                                                                         |
| 527-529 bloqueios compartilhados e exclusivos, varia√ß√µes do, 529                                                                                     |
| estrito em duas fases, 549                                                                                                                           |
| Bloqueio Bloqueios                                                                                                                                   |
| bin√°rios, 524 certifica√ß√£o, 534                                                                                                                      |
| convers√£o, 527                                                                                                                                       |
| compartilhados e 538                                                                                                                                 |
| em duas fases, 549                                                                                                                                   |
| exclusivos, (Best Match 25), 678 148                                                                                                                 |
| BM25 Bottom-up,                                                                                                                                      |
| Bottom-up, t√©cnica para o projeto de esquema,                                                                                                        |
| 210 Bra√ßo mec√¢nico em discos r√≠gidos,                                                                                                                |
| B-trees (√°rvores B) organiza√ß√£o de arquivo, 414                                                                                                      |
| varia√ß√£o(√µes) da, 436, 443 Buckets, 408, 409, 411                                                                                                    |
| Buffering duplo, 397 Buffers de dados, 480                                                                                                           |
| Buffers                                                                                                                                              |
| espa√ßo de buffer do                                                                                                                                  |
| SGBD, em SGBDs, 10                                                                                                                                   |
| 459                                                                                                                                                  |
| jun√ß√µes de loop aninhado, 464                                                                                                                        |
| 398                                                                                                                                                  |
| Bytes,                                                                                                                                               |

## C

| C, linguagem                         |
|--------------------------------------|
| SQL embutida, 72, 302, 303, 305-314  |
| linguagem hospedeira em SQL/CLI, 314 |

| C++, v√≠nculo da linguagem, 252 Cabe√ßalho nos documentos, 281                                                                                                                                                     |
|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Cabe√ßas de leitura/grava√ß√£o, 395                                                                                                                                                                                 |
| Cache de SGBD, 460                                                                                                                                                                                               |
| Caching                                                                                                                                                                                                          |
| cache do banco de dados, 502 na recupera√ß√£o de banco de dados, 543 em SGBDs, 13                                                                                                                                  |
| C√°lculo de dom√≠nio (relacional), 123                                                                                                                                                                             |
| C√°lculo relacional de tuplas                                                                                                                                                                                     |
| exemplos de consultas, 119 quantificadores existenciais e                                                                                                                                                        |
| universais, 118-119 express√µes e f√≥rmulas, 118 nota√ß√£o para grafos de consulta, 120-121 express√µes seguras, 122 transformando os quantificadores universais e existenciais, 121 vari√°veis de tupla e rela√ß√µes de |
| usando o quantificador universal consultas, 121-122 C√°lculo relacional c√°lculo de dom√≠nio (relacional),                                                                                                          |
| nas                                                                                                                                                                                                              |
| Calend√°rios bancos de dados temporais, 626                                                                                                                                                                       |
| 123-124                                                                                                                                                                                                          |
| Call, instru√ß√£o em SQL, 321 Camada de aplica√ß√£o (l√≥gica de neg√≥cios), 599 Camada de apresenta√ß√£o (cliente), na                                                                                                   |
| arquitetura cliente-servidor de camadas, 598                                                                                                                                                                     |
| tr√™s Camada do cliente PHP, 600 Camada intermedi√°ria, arquitetura                                                                                                                                                |
| de tr√™s                                                                                                                                                                                                          |
| Caminhos de acesso classificamos os SGBDs por, 35 em modelos f√≠sicos de dados, 21                                                                                                                                |
| Campo hash, 406 Campo de ordena√ß√£o, organiza√ß√£o arquivo, 406                                                                                                                                                     |
| de                                                                                                                                                                                                               |
| Campo-chave, arquivos classificados, 404                                                                                                                                                                         |
| Campos                                                                                                                                                                                                           |
| campo hash, 406 refer√™ncias de campo l√≥gicas entre                                                                                                                                                               |
| registros de arquivo, 414                                                                                                                                                                                        |
| ordena√ß√£o e campos chave, 404 de conex√£o, 414                                                                                                                                                                    |
| Campos opcionais, 398 Canais ocultos controle de fluxo, 562 controle de acesso obrigat√≥rio, 562                                                                                                                  |
| Canal de fibra over Ethernet (FCoE),                                                                                                                                                                             |
| Cardinalidade de sele√ß√£o, 480                                                                                                                                                                                    |
| camadas, 32                                                                                                                                                                                                      |
| os                                                                                                                                                                                                               |
| Campos                                                                                                                                                                                                           |
| Cardinalidade em um dom√≠nio, 41                                                                                                                                                                                  |
| 419 Carga de banco de dados, 28                                                                                                                                                                                  |

| CASE (Computer Aided Software Engineering), 218, 230                                                                   |
|------------------------------------------------------------------------------------------------------------------------|
| Cat√°logos centralizados, 615                                                                                           |
| Cat√°logos parcialmente replicados, 615                                                                                 |
| Cat√°logos totalmente replicados, 615                                                                                   |
| Cat√°logos                                                                                                              |
| informa√ß√£o de cat√°logo usada nas fun√ß√µes de custo, 480-481 do SGBD, 6 em SQL, 58 gerenciamento de transa√ß√£o nos bancos |
| de dados distribu√≠dos, 593 Categoria parcial, 172                                                                      |
| Categoria total, 171                                                                                                   |
| Categorias no modelo EER defini√ß√£o, 161 modelagem, 170-172                                                             |
| Certificados digitais, 562                                                                                             |
| Chamadas de fun√ß√£o, programa√ß√£o de                                                                                     |
| banco de dados com t√©cnicas para programa√ß√£o de banco de dados, 303-304 JDBC para programa√ß√£o Java,                    |
| 316-320 SQL/CLI usando C como linguagem hospedeira, 314-316                                                            |
| de ordena√ß√£o para o arquivo, 404                                                                                       |
| parcial, 144, 145, 178, 192, 351                                                                                       |
| Chave Chave Chaves candidatas                                                                                          |
| defini√ß√£o, 349 depend√™ncia funcional, 338 restri√ß√µes do modelo relacional,                                             |
| 96 Chaves compostas, 158, 446 Chaves hash, 491                                                                         |
| Chaves estrangeiras depend√™ncias de inclus√£o, 383                                                                      |
| Chaves no modelo de objeto                                                                                             |
| ODMG, 252-267 Chaves prim√°rias                                                                                         |
| defini√ß√£o, 349 formas normais baseadas em, √≠ndices prim√°rios, 425 restri√ß√µes do modelo relacional, 189                 |
| secund√°rias, 190, 349                                                                                                  |
| substitutas, 56                                                                                                        |
| Chaves √∫nicas, 45, 189 CHECK, cl√°usula                                                                                 |
| limitar valores de                                                                                                     |
| dom√≠nio usando a, 62 especificando restri√ß√µes sobre tuplas, Check points algoritmo de recupera√ß√£o ARIES,               |
| 63 533-536                                                                                                             |
| de vida de macro, 204 de vida do sistema de aplica√ß√£o de banco de dados, 204 um grafo com c√≠rculos em uma              |
| Ciclos, estrutura hier√°rquica, 299 Cilindros, 393                                                                      |
| Ciclo                                                                                                                  |
| Ciclo                                                                                                                  |
| atributo                                                                                                               |
| Chaves Chaves                                                                                                          |
| ou                                                                                                                     |
| Classe/subclasse, relacionamentos,                                                                                     |
| 161,                                                                                                                   |
| 167, 386                                                                                                               |
| 347-353                                                                                                                |

| Classes embutidas no modelo de objetos ODMG, 257-259 modelo EER, 162 modelos de dados de objeto, 21 controle de acesso obrigat√≥rio, 567 defini√ß√µes de tipo, 238 base, 175 folha, 169 Classifica√ß√£o minera√ß√£o de dados e, 700   |
|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Clientes                                                                                                                                                                                                                       |
| Having, 82 arquitetura cliente/servidor de duas camadas, 31-32 arquitetura cliente/servidor, 30 de √°udio em bancos de dados multim√≠dia, 627 de v√≠deo, conceitos de banco de dados multim√≠dia, 650                              |
| Classes                                                                                                                                                                                                                        |
| Classes                                                                                                                                                                                                                        |
| esquema de classifica√ß√£o facetada, 693 objetivos da minera√ß√£o de dados, 699 descoberta de conhecimento, 699 no controle de acesso obrigat√≥rio, 562                                                                             |
| espacial, 649                                                                                                                                                                                                                  |
| de                                                                                                                                                                                                                             |
| Cl√°usula                                                                                                                                                                                                                       |
| Clipes Clustering hierarquias de conceito e, descoberta de conhecimento Codd, Ted, 38 Cole√ß√µes criando tabelas baseadas nos extraindo elementos isolados persistentes, 243, 245 transientes, 245 Coleta de lixo, 451           |
| Clipes                                                                                                                                                                                                                         |
| 653 e, 699 UDTs,                                                                                                                                                                                                               |
| Comando de leitura, 395                                                                                                                                                                                                        |
| Comandos remotos, 577 Combina√ß√£o de esquema, 689 Combina√ß√£o de padr√£o, 716                                                                                                                                                     |
| COMMIT_TRANSACTION,opera√ß√£o, 506 comparando bancos de dados com, Componentes anal√≠ticos das                                                                                                                                    |
| 26 ferramentas de projeto, 231                                                                                                                                                                                                 |
| Componentes heur√≠sticos de ferramentas de projeto, 231                                                                                                                                                                         |
| Comportamentos de aplica√ß√µes de banco de dados, 226 252                                                                                                                                                                        |
| no modelo de objeto ODMG, clientes servidores especializados, 30                                                                                                                                                               |
| Computadores Concedendo privil√©gios, 568                                                                                                                                                                                       |
| Conceitualiza√ß√£o, 179                                                                                                                                                                                                          |
| Concorr√™ncia intercalada, 501                                                                                                                                                                                                  |
| Condi√ß√£o booleana, 118, 273                                                                                                                                                                                                    |
| Condi√ß√£o de preserva√ß√£o de atributo de                                                                                                                                                                                         |
| uma decomposi√ß√£o, 370                                                                                                                                                                                                          |

| Condi√ß√£o qualificadora em XPath, 292                                                                                                                       |
|------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Condi√ß√µes (f√≥rmulas). Ver f√≥rmulas Condi√ß√µes conjuntivas, opera√ß√µes SELE√á√ÉO, 477                                                                           |
| Condi√ß√µes de jun√ß√£o no c√°lculo de dom√≠nio, jun√ß√£o de interse√ß√£o                                                                                            |
| 123 temporal, 641                                                                                                                                          |
| Condi√ß√µes de sele√ß√£o disjuntivas, 462                                                                                                                      |
| Condi√ß√µes de sele√ß√£o no c√°lculo de dom√≠nio, 123 opera√ß√£o SELE√á√ÉO, 98                                                                                       |
| Condi√ß√µes no modelo ECA defini√ß√£o, 627                                                                                                                     |
| do STARBURST, 632 Conectando ao banco de dados, 306                                                                                                        |
| Conectivos AND,OR,NOT,f√≥rmulas, 119 Confiabilidade nos sistemas distribu√≠dos, 623 Confidencialidade, perda de, 563                                         |
| dos schedules da transa√ß√£o, 513 dedutivo, 700 indutivo, 700 de construtores, 246 677                                                                       |
| Conflitos Conhecimento Conhecimento                                                                                                                        |
| Conjunto Conjuntos de documentos n√£o relevantes,                                                                                                           |
| Conjuntos de documentos                                                                                                                                    |
| Conjuntos de entidade, 134                                                                                                                                 |
| relevantes, 677 Conjuntos de itens                                                                                                                         |
| algoritmo Apriori, 702-703 regras de associa√ß√£o, 707 algoritmos de crescimento FP, 704-706 algoritmos de √°rvore FP, 704-706 algoritmo de parti√ß√£o, 706-707 |
| algoritmo de amostragem, 703-704                                                                                                                           |
| Conjuntos m√≠nimos de depend√™ncias funcionais, 368-369 Conjuntos equival√™ncia de, 368 expl√≠citos de atributos em SQL, 80                                    |
| tabela SQL, de tuplas, 64 tabelas como, 67-69                                                                                                              |
| Considera√ß√£o adiada, 631 Considera√ß√£o da regra, 631 Considera√ß√£o imediata, 631 Constela√ß√£o de fatos, 725                                                   |
| Constru√ß√£o de bancos de defini√ß√£o, 4                                                                                                                       |
| exemplo de banco de dados UNIVERSIDADE, 4                                                                                                                  |
| dados                                                                                                                                                      |
| Constru√ß√µes do esquema, 22, 23,                                                                                                                            |
| 146 Constru√ß√µes em PHP, 328 Construtor list, 240 Construtores de tipo de cole√ß√£o                                                                           |
| (multivalorados), 240                                                                                                                                      |
| Construtores de tipo                                                                                                                                       |
| Conjuntos de valores, 136-139                                                                                                                              |
| construtor √°tomo, 239, 240                                                                                                                                 |
| defini√ß√£o, 239                                                                                                                                             |

| ODL e, 359-360                                                                                                                                 |
|------------------------------------------------------------------------------------------------------------------------------------------------|
| construtor struct, 240                                                                                                                         |
| Construtores struct (tupla), 240 Consulta de recupera√ß√£o SQL simples, 73                                                                       |
| Consulta ocasional, 726                                                                                                                        |
| Consultas. Ver tamb√©m OQL (Object Query Language); SQL (Structured                                                                             |
| Query Language) baseadas em conte√∫do, 691                                                                                                      |
| defini√ß√£o, 4                                                                                                                                   |
| consultas n√£o recursivas, 663                                                                                                                  |
| recupera√ß√£o de informa√ß√µes, 670 interface interativa, 303, 321                                                                                 |
| sistemas RI, 669                                                                                                                               |
| baseadas em projeto f√≠sico do banco                                                                                                            |
| palavra-chave, 695 de dados, 206, 207 consultas de recupera√ß√£o de tabelas                                                                      |
| 203, de banco de dados, 334-335 espaciais, 626, 645, 647, 664 estat√≠sticas, 111, 578 TSQL2, 644                                                |
| aninhadas correlacionadas                                                                                                                      |
| SQL, 79 aninhadas, correlacionadas,                                                                                                            |
| Consultas em 79                                                                                                                                |
| Consultas                                                                                                                                      |
| Consultas booleanas, 679 Consultas de intervalo, 446, 462, 492                                                                                 |
| Consultas de linguagem natural, 680                                                                                                            |
| Consultas de palavra-chave vis√£o geral, 695                                                                                                    |
| tipos de consultas em sistemas                                                                                                                 |
| RI,                                                                                                                                            |
| 669 Consultas estat√≠sticas, 111, 578                                                                                                           |
| Consultas externas, 77, 78, 79, 80, 83 Consultas n√£o recursivas, 663                                                                           |
| Consultas nomeadas em OQL, Consultas por proximidade,                                                                                          |
| 272 Contas do usu√°rio, 564, 565, 567,                                                                                                          |
| 679-680                                                                                                                                        |
| Contexto organizacional para o uso                                                                                                             |
| 568 sistemas de banco de dados,                                                                                                                |
| 202-203 Controle de acesso seguran√ßa de banco de dados,                                                                                        |
| MAC(Mandatory Access Control), obrigat√≥rio, 570-578                                                                                            |
| 570 pol√≠ticas de, para e-commerce e a Web, 575 RBAC, 572, 573, 586 restringindo o acesso n√£o autorizado, controle de acesso em n√≠vel de linha, |
| 12 573-574 medidas apropriadas do controle de                                                                                                  |
| seguran√ßa, 588 autoriza√ß√£o do usu√°rio, 610 por XML, 574                                                                                        |
| 573-574 Controle de acesso obrigat√≥rio. Ver (Mandatory Access Control) Controle de concorr√™ncia de valida√ß√£o,                                  |
| Controle de concorr√™ncia multivers√£o,                                                                                                          |
| 533-535                                                                                                                                        |
| Controle de acesso em n√≠vel de                                                                                                                 |
| de                                                                                                                                             |
| 562-588                                                                                                                                        |
| linha,                                                                                                                                         |
| MAC                                                                                                                                            |
| 533                                                                                                                                            |

| Controle de concorr√™ncia m√≥dulos componentes do SGBD, 26 protocolos, 541                             |
|------------------------------------------------------------------------------------------------------|
| software, 8                                                                                          |
| gerenciamento de transa√ß√£o em bancos de dados distribu√≠dos, 593                                      |
| Controle de fluxo canais secretos, 579-580 introdu√ß√£o ao, 579-580                                    |
| medidas de controle, 563 de qualidade, data warehousing, de nomea√ß√£o                                 |
| Controle 729 Conven√ß√µes restri√ß√µes em SQL, 61-63 para rela√ß√µes, 195                                  |
| Convers√£o de aplica√ß√£o no ciclo de vida do sistema de aplica√ß√£o de banco de dados, 204 COUNT, fun√ß√£o |
| fun√ß√µes agregadas em SQL, 82-83 agrupamento, 83-85 implementando, 470                                |
| Crawlers                                                                                             |
| vis√£o geral, 693 Web crawlers, 693                                                                   |
| CREATE ASSERTION, comando, 49, 76, 87 CREATE INDEX, comando, 73                                      |
| CREATE SCHEMA, comando, 58 CREATE TABLE, comando especificando, sobre tuplas                         |
| usando CHECK, 63 especificando restri√ß√µes de chave integridade referencial, 62-63                    |
| e SQL (Structured Query Language),                                                                   |
| 57 CREATE TRIGGER, comando, 49, 76, 87, 88 CREATE VIEW, comando, 59, 89                              |
| Credenciais, controle de acesso e, Criptografia de chave p√∫blica                                     |
| (assim√©trica), 864, 581                                                                              |
| 575                                                                                                  |
| Criptografia de dados. Ver                                                                           |
| criptografia Criptografia vis√£o geral, 580                                                           |
| de chave p√∫blica (assim√©trica), 581-582 algoritmo de criptografia de chave                           |
| p√∫blica RSA, 582 algoritmos de chave sim√©trica, 581                                                  |
| CRM (Customer Relationship Management), 17, 32 CS (Conversational Search), 694                       |
| Cubos de dados (hipercubos), 722                                                                     |
| Curinga ( √© )                                                                                        |
| tipos de consultas em sistemas de RI, 669                                                            |
| comando, 58                                                                                          |
| CREATE,                                                                                              |

| Cursores recuperando                                     |
|----------------------------------------------------------|
| Custo de pessoal, escolha de um SGBD, 216                |
| Custo operacional, escolha de umSGBD,216                 |
| Customer Relationship Management (CRM), 17, 32           |
| Custos de aquisi√ß√£o do software, escolha de um SGBD, 216 |
| Custos de treinamento, escolha de um SGBD, 216           |

## D

| DAC (Discretionary Access Control), 585 Dados                                                                                                  |
|------------------------------------------------------------------------------------------------------------------------------------------------|
| qualidade dos dados, desafios da seguran√ßa do banco de dados, 583 defini√ß√£o, 2 isolamento entre programas e, 6, 7-8 m√∫ltiplas vis√µes dos, 6, 8 |
| normaliza√ß√£o, 11 sensibilidade, 565 tipos de dados na recupera√ß√£o de                                                                           |
| informa√ß√µes, 671 de evento v√°lidos, 644                                                                                                        |
| Dados estruturados                                                                                                                             |
| Dados extra√ß√£o de, 689 vis√£o geral, 279 e n√£o estruturados,                                                                                    |
| 616 Dados semiestruturados, 280-283 Dados, blocos. Ver blocos de                                                                               |
| dados                                                                                                                                          |
| Data Encryption Standard (DES), 580                                                                                                            |
| Data marts, 722 Data Surveyor, 716                                                                                                             |
| Data warehouse corporativo, 722                                                                                                                |
| Data warehouses construindo um, 726-728 caracter√≠sticas, 721-722 modelagem de dados para, 722-726 dificuldades de implementa√ß√£o de, 729-730    |
| funcionalidade t√≠pica de um, vis√£o geral, 720-721 versus vis√µes, 729                                                                           |
| warehouses virtuais, 722                                                                                                                       |
| Data                                                                                                                                           |
| forma clausular de cl√°usulas de Horn, 656-657 consultas n√£o recursivas, 661-663 nota√ß√£o, 655-663                                               |
| programas e seguran√ßa, 659 DATE, tipo de dados em SQL, 61                                                                                      |
| DB/DC sistema, ferramentas de                                                                                                                  |
| SGBD,                                                                                                                                          |
| DBAs (administradores de banco de atores em cena, 9                                                                                            |
| interface para o, 26                                                                                                                           |
| DCT (Discrete Cosine Transform),                                                                                                               |
| 650                                                                                                                                            |
| 728-729                                                                                                                                        |
| linguagem                                                                                                                                      |
| Datalog,                                                                                                                                       |
| 29                                                                                                                                             |
| dados)                                                                                                                                         |

| DDL (Data Definition Language) linguagens de SGBD, 24 conceitos de esquema, 58 SQL, 47                                                            |
|---------------------------------------------------------------------------------------------------------------------------------------------------|
| Deadlock detec√ß√£o de, 623 em bancos de dados distribu√≠dos, 480                                                                                    |
| Depend√™ncia Depend√™ncia multivalorada. Ver MVD Depend√™ncias de dados, restri√ß√µes do modelo relacional, 44 Depend√™ncias de inclus√£o, 234, 365, 383 |
| 662 de exist√™ncia, 143, 144, 148, 732 funcional, 338                                                                                              |
| Decomposi√ß√£o de consulta, 609-611 Decomposi√ß√£o. Ver propriedades das decomposi√ß√µes relacionais                                                    |
| Decomposi√ß√µes bin√°rias, 359, 372                                                                                                                  |
| Defini√ß√£o de dados em QBE, 740-743                                                                                                                |
| em SQL, 58                                                                                                                                        |
| DELETE, comando, 71-72 Delete, opera√ß√£o                                                                                                           |
| t√©cnicas de controle de concorr√™ncia, 501, 505, 523-542 opera√ß√µes do modelo de dados                                                              |
| relacional, 42, 50 Depend√™ncia. Ver tamb√©m depend√™ncias funcionais descoberta de padr√£o, 692 grafo de depend√™ncia de predicado, Depend√™ncia       |
| Depend√™ncias de jun√ß√£o (JD), 348, 359-360 Depend√™ncias funcionais baseadas em fun√ß√µes aritm√©ticas e                                               |
| procedimentos, 384-385 equival√™ncia de conjuntos, 368 depend√™ncia de exist√™ncia, 143, 144, 148, 732 depend√™ncia funcional, 338 383                |
| depend√™ncias de inclus√£o, 234, 365, regras de infer√™ncia, 347, 365 JD (depend√™ncias de jun√ß√£o), 348, 359-360                                      |
| conjuntos m√≠nimos de, 368-369                                                                                                                     |
| MVD(depend√™ncia multivalorada), 361                                                                                                               |
| restri√ß√µes do modelo relacional, 96                                                                                                               |
| depend√™ncias de modelo, 365, 384                                                                                                                  |
| depend√™ncias transitivas, 352                                                                                                                     |
| tipos de restri√ß√µes, 49                                                                                                                           |
| parciais, 352                                                                                                                                     |
| Depend√™ncias Depend√™ncias transitivas, 352                                                                                                        |
| DES (Data Encryption Standard),                                                                                                                   |
| Descoberta de conhecimento nos                                                                                                                    |
| 580 de dados (KDD), 699                                                                                                                           |
| Desempenho                                                                                                                                        |
| bancos                                                                                                                                            |
| vantagens de bancos de dados                                                                                                                      |
| distribu√≠dos, 592                                                                                                                                 |
| utilit√°rios do sistema de banco de                                                                                                                |

| Desempenho de E/S, 494                                                                                                                                         |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Desenvolvedores de software, 219                                                                                                                               |
| Desenvolvimento de aplica√ß√£o                                                                                                                                   |
| vantagens dos bancos de dados distribu√≠dos, 592-593 tempo reduzido para, 14                                                                                    |
| Desnormaliza√ß√£o defini√ß√£o, 349 agilizar as consultas, 493                                                                                                      |
| DFT (Discrete Fourier Transform), 650                                                                                                                          |
| Diagrama de esquema, 21                                                                                                                                        |
| Diagramas                                                                                                                                                      |
| ferramentas automatizadas, 204 diagrama de esquema, 21 UML. Ver UML (Unified Modeling Language) Diagramas de atividade, UML, 223 Diagramas de caso de uso, 223 |
| Diagramas de classes                                                                                                                                           |
| nota√ß√£o, 146                                                                                                                                                   |
| UML, 151, 154                                                                                                                                                  |
| Diagramas de componentes, 220 Diagramas de estado, 223 Diagramas de implanta√ß√£o, 220                                                                           |
| Diagramas de intera√ß√£o, 221                                                                                                                                    |
| Diagramas de objeto, 220                                                                                                                                       |
| Diagramas de pacotes, 220 Diagramas de sequ√™ncia, 221                                                                                                          |
| Diagramas estruturais, 220 Dicion√°rios de dados (ou                                                                                                            |
| reposit√≥rios de                                                                                                                                                |
| dados) ferramentas de SGBD, 17                                                                                                                                 |
| Dimens√µes de tempo em temporais, 636                                                                                                                           |
| bancos de dados Directory Information Tree (DIT),                                                                                                              |
| 619 Direitos de propriedade intelectual, 583                                                                                                                   |
| Diret√≥rio ativo, 552 Diret√≥rios on-line, 619 Discos de cabe√ßa fixa, 395                                                                                        |
| Discos de cabe√ßa m√≥vel, 395                                                                                                                                    |
| Discos de dupla face, 421                                                                                                                                      |
| Discos r√≠gidos, 392 Discrete Cosine                                                                                                                            |
| Transform                                                                                                                                                      |
| Discrete Fourier Transform                                                                                                                                     |
| (DCT), 650 (DFT), 650 Discretionary Access Control                                                                                                             |
| (DAC), 585 Disjun√ß√£o, restri√ß√£o de, 166 Disk packs, 393                                                                                                        |
| Disponibilidade                                                                                                                                                |
| de dados, 566                                                                                                                                                  |
| perda de, 563                                                                                                                                                  |
| de informa√ß√µes atualizadas,                                                                                                                                    |
| 14 DISTINCT, palavra-chave com SELECT, 68                                                                                                                      |
| comando                                                                                                                                                        |
| DIT (Directory Information Tree), 619                                                                                                                          |
| DIVIS√ÉO, opera√ß√£o na √°lgebra                                                                                                                                   |

| DML (Data Manipulation Language) linguagens de SGBD, 24 SQL, 58 DMLs de um conjunto de cada vez,                                                                    |
|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 25 DMLs n√£o procedurais, 36                                                                                                                                         |
| DMLs procedurais, 36                                                                                                                                                |
| Document Object Model (DOM), 285                                                                                                                                    |
| Document Type Definition (DTD), 285                                                                                                                                 |
| Documenta√ß√£o do esquema XML, 290                                                                                                                                    |
| Documentos                                                                                                                                                          |
| documentos de hipertexto, 279 recupera√ß√£o de informa√ß√µes, 669 bancos de dados multim√≠dia, 626                                                                       |
| Semantic Network, 681                                                                                                                                               |
| de hipertexto, 279                                                                                                                                                  |
| Documentos XML centrados no                                                                                                                                         |
| Documentos documento, 284 Documentos XML centrados nos                                                                                                              |
| dados, 284, 292, 300                                                                                                                                                |
| Documentos XML de streaming, 423                                                                                                                                    |
| Documentos XML h√≠bridos, 284 Documentos XML que n√£o seguem um esquema, 284                                                                                          |
| Documentos XML v√°lidos, 284-286                                                                                                                                     |
| Documentos XML extraindo de bancos de dados,                                                                                                                        |
| 291-292 tipos de, 284                                                                                                                                               |
| bem formados e v√°lidos, 284-286 DOM(Document Object Model), 285 Dom√≠nios cardinalidade, 41 restri√ß√µes de, 44                                                        |
| esquema de rela√ß√£o, 40 DOS (Denial of Service), ataques, 575 DROP SCHEMA, comando, 91 DROP TABLE, comando, 91 DROP VIEW, comando, 93 DSML (Linguagem de Marca√ß√£o do |
| Servi√ßo de Diret√≥rios), 575 DSS, 721                                                                                                                                |
| DTD (Document Type                                                                                                                                                  |
| Definitions), E                                                                                                                                                     |
| ECA(Event-Condition-Action), modelo, ECG (esquema conceitual global), 209                                                                                           |
| 664 pol√≠ticas de controle de acesso para, 575                                                                                                                       |
| interc√¢mbio de dados na Web para, usando XML, 16                                                                                                                    |
| de escala, 14                                                                                                                                                       |
| (Entity-Category-Relationship),                                                                                                                                     |
| modelo, 170                                                                                                                                                         |
| Economias ECR                                                                                                                                                       |
| EER(Enhanced Entity-Relationship), modelo                                                                                                                           |
| E-commerce                                                                                                                                                          |
| 279                                                                                                                                                                 |

| conceitos de abstra√ß√£o de dados, representa√ß√£o de conhecimento e ontologia, 176-177 escolhas de projeto para especializa√ß√£o/ generaliza√ß√£o, 174 defini√ß√µes formais para os conceitos, 174 generaliza√ß√£o, 164-165 hierarquias e reticulados da especializa√ß√£o e generaliza√ß√£o, 167-169 identifica√ß√£o, 178 modelagem dos tipos de uni√£o usando categorias, 170-172 ontologias e a Web sem√¢ntica, 179-181 refinamento de esquemas conceituais, 169-170 especializa√ß√£o, 163-164 subclasses, superclasses e heran√ßa, 162-163   |
|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| EIS (Sistemas de informa√ß√µes executivas), 721                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Eixos de express√µes XPath, 293 raiz, 284 de dados no documento, 284                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| elemento de dados, 566 linguagem de esquema XML, 286 Elementos vazios, linguagem de esquema XML, 290 para tr√°s, 645                                                                                                                                                                                                                                                                                                                                                                                                       |
| Encadeamento 241 transaction, tipos de transa√ß√£o, 506 opera√ß√£o, 506                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| de exemplo QBE, 737 documentos XML nota√ß√£o para especificar, 215                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| de software auxiliada por                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| exemplo de outra nota√ß√£o, 175-176 um exemplo de esquema UNIVERSIDADE,172-174                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Elemento                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Elementos Elementos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| Elementos,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Encapsulamento, End END_TRANSACTION,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| Engenharia                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| computador (CASE), 732                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Engenharia direta, Rational Rose, 226                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Engenharia reversa, Rational Rose, 226 Engenheiros de software, atores em cena,                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Enterprise Resource Planning. Ver ERP                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| (Enterprise Resource Planning)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Entity-Category-Relationship                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| modelo, 170                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Entrada e sa√≠da de voz, 26 Equival√™ncia de conjuntos de depend√™ncias funcionais, 368                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| Equival√™ncia de schedules, 513,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Equival√™ncia de vis√£o, 513                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| (Entidade-Relacionamento), modelo atributos de tipos de relacionamento, 143 refer√™ncias bibliogr√°ficas, 280 relacionamento bin√°rio, 141                                                                                                                                                                                                                                                                                                                                                                                   |
| entidades e atributos, 132 para relacional, mapeamento                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| algoritmo para, 189                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| mapeamento de tipos de                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| relacionamento bin√°rio 1:l, 192                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| ER                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| (ECR),                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 518                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| ER                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |

| mapeamento de tipos de relacionamento bin√°rio l:N, 192 mapeamento de tipos de relacionamento bin√°rio M:N, 193 mapeamento de atributos multivalorados, 193 mapeamento de tipos de relacionamento n -√°rios, 194 mapeamento de tipos de entidade                                                                                                                                                                                        |
|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| regular, 182 mapeamentodetiposdeentidadefraca, 190 ER, diagramas diagramas de classe, 148 defini√ß√£o, 131 nota√ß√£o, 146                                                                                                                                                                                                                                                                                                                |
| ER, nota√ß√£o do diagrama, 146 atributos chave, 239 exerc√≠cios de laborat√≥rio, 387 conven√ß√µes de nomes, 146 conjuntos e inst√¢ncias, 140 relacionamentos como atributos, 141 nomes de papel, 146 aplica√ß√£o de banco de dados de exemplo, 131 conjuntos de valores, 136-139 tipos de entidade fraca, 144 (Enterprise Resource Planning) banco de dados de back-end, 17 bancos de dados federados, 590 SANs (Storage Area Networks) , 389 |
| Erro(s) Java, 311 modelo de objeto ODMG, 258 recupera√ß√£o √© necess√°ria, 505 592                                                                                                                                                                                                                                                                                                                                                       |
| ERP                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| confiabilidade e disponibilidade e,                                                                                                                                                                                                                                                                                                                                                                                                  |
| do campo hash, 408 atributo de                                                                                                                                                                                                                                                                                                                                                                                                       |
| definida por                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Espa√ßo Especializa√ß√£o superclasse, 166                                                                                                                                                                                                                                                                                                                                                                                               |
| Especializa√ß√£o parcial, 166 Especializa√ß√£o/generaliza√ß√£o                                                                                                                                                                                                                                                                                                                                                                             |
| restri√ß√µes, 165-167 defini√ß√µes, 163                                                                                                                                                                                                                                                                                                                                                                                                  |
| escolhas de projeto, 174                                                                                                                                                                                                                                                                                                                                                                                                             |
| generaliza√ß√£o, 164                                                                                                                                                                                                                                                                                                                                                                                                                   |
| hierarquias, 167 representa√ß√£o do conhecimento, esquemas conceituais, 209                                                                                                                                                                                                                                                                                                                                                            |
| especializa√ß√£o, 163 UML (Unified Modeling Language), de uma conceitualiza√ß√£o, n√∫cleo, SQL, 58 (sombreamento)                                                                                                                                                                                                                                                                                                                         |
| Especifica√ß√£o Especifica√ß√£o Espelhamento 530                                                                                                                                                                                                                                                                                                                                                                                         |
| Esperar-morrer, Esquema projeto conceitual, 169                                                                                                                                                                                                                                                                                                                                                                                      |
| tipo de entidade, 169                                                                                                                                                                                                                                                                                                                                                                                                                |
| inst√¢ncias e estado do banco                                                                                                                                                                                                                                                                                                                                                                                                         |

21-22

| ontologias, 179                                                                                                                 |
|---------------------------------------------------------------------------------------------------------------------------------|
| relacional. Ver esquemas de bancos de dados relacionais modelo de dados relacional, 38-56                                       |
| arquitetura de tr√™s esquemas. Ver                                                                                               |
| arquitetura de tr√™s esquemas conceitual global (ECG), 596                                                                       |
| Esquema                                                                                                                         |
| Esquema conceitual local (ECL), 596                                                                                             |
| Esquema conceitual projeto de banco de dados, 132 na arquitetura de tr√™s esquemas, 23                                           |
| Esquema de aloca√ß√£o, 602                                                                                                        |
| Esquema de componente, 598                                                                                                      |
| Esquema de estrela, 725                                                                                                         |
| Esquema de exporta√ß√£o, 598 Esquema de fragmenta√ß√£o de de dados, 602                                                             |
| um banco                                                                                                                        |
| Esquema de rela√ß√£o universal, 346 Esquema externo, arquitetura de esquemas, 22                                                  |
| tr√™s Esquema floco de neve, 725                                                                                                 |
| Esquema interno local (EIL), 596                                                                                                |
| Esquema interno, arquitetura de                                                                                                 |
| tr√™s esquemas, 22                                                                                                               |
| Esquema local, arquitetura do                                                                                                   |
| esquema de banco de dados federado, 597 Esquemas de banco de dados. Ver                                                         |
| tamb√©m esquema inst√¢ncias e estado do banco de dados e, 21-22 ontologias, 179                                                   |
| relacional. Ver projeto de banco de dados relacional arquitetura de tr√™s esquemas. Ver                                          |
| arquitetura de tr√™s esquemas Esquemas de bancos de dados relacionais algoritmos para projeto de                                 |
| esquema, 274 sem√¢ntica clara aos atributos, 338 reprovar a possibilidade de gerar tuplas falsas, 338 depend√™ncia funcional, 338 |
| valores NULL nas tuplas, 343                                                                                                    |
| ativo, transa√ß√µes, 506                                                                                                          |
| atual da rela√ß√£o, 22                                                                                                            |
| Estado Estado confirmado, 506                                                                                                   |
| Estado Estado inicial, 514                                                                                                      |
| Estado inv√°lido, 46 Estado parcialmente transa√ß√µes, 506                                                                         |
| Estado terminado, transa√ß√µes,                                                                                                   |
| confirmado das Estrat√©gia balanceada bin√°ria                                                                                    |
| 506 para integra√ß√£o de vis√£o, 233                                                                                               |
| Estrat√©gia de dentro para fora, 210                                                                                             |
| a                                                                                                                               |
| Estrat√©gia mista para projeto de esquema, 210                                                                                   |
| Estruturas complexas                                                                                                            |
| vers√£o de atributo, 642                                                                                                         |
| para objetos, 247                                                                                                               |

| Estruturas de arquivo, banco de dados                                                                                                                                                            |
|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| f√≠sico, 73 Estruturas em √°rvore. Ver tamb√©m B+- trees (√°rvores B) √°rvore de padr√£o frequente, 703 √°rvores de pesquisa, 436 hierarquia de especializa√ß√£o, 167 √°rvores TV (vetor telesc√≥pico), 651 |
| ETL, ferramentas de, 693 Event-Condition-Action (ECA), modelo, 664 Eventos de dura√ß√£o, 636                                                                                                       |
| Eventos no modelo ECA defini√ß√£o, 664                                                                                                                                                             |
| exemplo STARBURST, 664 Evolu√ß√£o do esquema, 22 Exce√ß√µes. Ver erro(s) EXCEPT, opera√ß√£o 68                                                                                                         |
| opera√ß√µes de conjunto Exibi√ß√£o de roll-up, 723                                                                                                                                                   |
| SQL, Exibi√ß√£o do drill-down, 723                                                                                                                                                                 |
| EXISTS, fun√ß√£o da SQL, 79-80 Expans√£o ou crescimento                                                                                                                                             |
| novos bloqueios, 527                                                                                                                                                                             |
| Express√£o FLWR, 293                                                                                                                                                                              |
| (primeira),                                                                                                                                                                                      |
| Express√µes de caminho nota√ß√£o de ponto para montar, em OQL, 270                                                                                                                                  |
| Express√µes relacionais, 126 Express√µes seguras, 122 Extends, palavra-chave heran√ßa, 276                                                                                                          |
| estendendo Extens√£o da rela√ß√£o, 40                                                                                                                                                               |
| Extensible Stylesheet Language 279 Extensible Stylesheet Language                                                                                                                                |
| Transformations (XSLT),                                                                                                                                                                          |
| Extra√ß√£o de informa√ß√£o, 695                                                                                                                                                                      |
| Extra√ß√£o, transforma√ß√£o,                                                                                                                                                                         |
| F Facetas, 29, 693 Facilidades de comunica√ß√µes, 29                                                                                                                                               |
| Falha catastr√≥fica, t√©cnicas de de banco de dados para, 577                                                                                                                                      |
| Falha do computador (falha do sistema),                                                                                                                                                          |
| Falhas, confiabilidade e disponibilidade,                                                                                                                                                        |
| Fan-out de √≠ndice multin√≠vel, 433                                                                                                                                                                |
| Fantasmas, suporte para transa√ß√£o                                                                                                                                                                |
| 279 carga                                                                                                                                                                                        |
| (XSL),                                                                                                                                                                                           |
| ferramentas, 583                                                                                                                                                                                 |
| (ETL),                                                                                                                                                                                           |
| recupera√ß√£o em SQL, 519 Fase de an√°lise do algoritmo de                                                                                                                                          |
| recupera√ß√£o ARIES, 554                                                                                                                                                                           |
| 505 592                                                                                                                                                                                          |
| Fase de encolhimento (segunda), 527                                                                                                                                                              |

| Fase de levantamento de requisitos e an√°lise no projeto de banco de dados, 134 do ciclo de vida dos sistema, 205       |
|------------------------------------------------------------------------------------------------------------------------|
| Fase de projeto do ciclo de vida do sistema, 205                                                                       |
| Fase de valida√ß√£o, controle de concorr√™ncia de valida√ß√£o (otimista), 535                                               |
| Fase, projeto conceitual do banco de dados, 206                                                                        |
| Fator de bloco (bfr) para o arquivos, 427 √≠ndices multin√≠veis, 433                                                     |
| Fatos do bancos de dados, 659                                                                                          |
| FCoE (canal de fibra over Ethernet), 419                                                                               |
| Fechamento de X sob F, 367                                                                                             |
| Ferir-esperar, 530                                                                                                     |
| Ferramentas, 29                                                                                                        |
| Ferramentas automatizadas para projeto de banco de dados, 209                                                          |
| Ferramentas comerciais de minera√ß√£o de dados, 716-717                                                                  |
| Finan√ßas, aplica√ß√µes de minera√ß√£o de dados, 715 Find, opera√ß√µes em arquivos, 401                                       |
| FindAll, opera√ß√µes em arquivos, 402                                                                                    |
| FindNext, opera√ß√µes em arquivos, 402                                                                                   |
| FindOrdered, opera√ß√µes em arquivos, 402 Fita magn√©tica                                                                 |
| backup e recupera√ß√£o, 557 dispositivos de armazenamento de,                                                            |
| 389, 396                                                                                                               |
| Fita magn√©tica, 557, 389, 396                                                                                          |
| FNBC (Forma Normal de decomposi√ß√£o de jun√ß√£o n√£o                                                                       |
| Boyce-Codd) aditiva para, 359, 375                                                                                     |
| Fontes de dados de √°udio, 653 Fontes de dados acessadas pelo programa Java,                                            |
| bancos de dados como, 279 FOREIGN KEY, cl√°usula, 62 Forma clausular                                                    |
| em Datalog, 653 em sistemas de banco de dedutivos, 664                                                                 |
| dados Forma Normal de Boyce-Codd                                                                                       |
| (BCNF), 345, 355-357 Forma normal temporal, 641                                                                        |
| Forma, an√°lise autom√°tica de imagens, 651 normais baseadas em chaves prim√°rias, 347-353 quinta forma normal (5FN), 359 |
| Formas primeira forma normal (1FN), 349 quarta forma normal (4FN), 357                                                 |
| insufici√™ncia de, 369 normaliza√ß√£o de rela√ß√µes, 348 uso pr√°tico das, 349                                               |
| segunda forma normal (2FN), 352                                                                                        |
| 317                                                                                                                    |

| terceira forma normal (3FN), 352                                                                               |
|----------------------------------------------------------------------------------------------------------------|
| Formul√°rios                                                                                                    |
| coletando dados de, e inserindo registro, 333-334 PHP, 329                                                     |
| Formul√°rios Web, 333                                                                                           |
| F√≥rmulas no c√°lculo de dom√≠nio, 123 no c√°lculo relacional de tupla, 118-119                                    |
| Fragmenta√ß√£o                                                                                                   |
| bancos de dados distribu√≠dos puros, exemplo, 603 transpar√™ncia, 591                                            |
| Fragmenta√ß√£o de dados, 601. Ver fragmenta√ß√£o                                                                   |
| Fragmenta√ß√£o horizontal, 591                                                                                   |
| mista, 602                                                                                                     |
| Fragmenta√ß√£o                                                                                                   |
| Fragmenta√ß√£o vertical, 602                                                                                     |
| Frase ou uma pergunta em linguagem natural, 673 FROM, cl√°usula do comando SELECT, 81 consultas SQL b√°sicas, 64 |
| F-score, 686 Fun√ß√£o de dist√¢ncia para                                                                          |
| comparar a imagem, 651                                                                                         |
| Fun√ß√£o hash, 392 Fun√ß√£o de regress√£o, 714                                                                      |
| Fun√ß√µes de agrega√ß√£o agrupamento, 72                                                                           |
| implementando opera√ß√µes agregadas, 470-471                                                                     |
| processamento e otimiza√ß√£o de                                                                                  |
| em SQL, 82-83 c√°lculo relacional de tupla, 116-122 Ver tamb√©m opera√ß√µes atributos e opera√ß√µes, 175             |
| Fun√ß√µes. comportamento funcional, no de transa√ß√µes, 215                                                        |
| PHP, 325                                                                                                       |
| projeto QBE (Query-By-Example), 737                                                                            |
| SQL/PSM (Persistent Stored                                                                                     |
| Modules),                                                                                                      |
| √°lgebra relacional,                                                                                            |
| consulta, 458                                                                                                  |
| 82                                                                                                             |

72, 303

## G

| GAs (algoritmos gen√©ticos), 1698                        |
|---------------------------------------------------------|
| Generaliza√ß√£o. Ver especializa√ß√£o/ generaliza√ß√£o        |
| Gerador de c√≥digo para execu√ß√£o de consulta, 457        |
| Gerador de tipo, 240                                    |
| Gerenciador de transa√ß√£o global, 597                    |
| Gerenciamento de buffer m√≥dulos componentes do SGBD, 26 |
| Gerenciamento de recupera√ß√£o global, 556                |

| GIF, formato de imagem, 650                                                                                                         |
|-------------------------------------------------------------------------------------------------------------------------------------|
| GIS (sistemas de informa√ß√µes geogr√°ficas) bancos de dados espaciais, 645                                                            |
| tipos de bancos de dados, 16                                                                                                        |
| Grafo de depend√™ncia de predicado, 663                                                                                              |
| Grafo de preced√™ncia, 514                                                                                                           |
| Grafos. Ver tamb√©m diagramas criando vis√µes XML hier√°rquicas sobre planos ou baseados em grafos, 295                                |
| hierarquias (grafos ac√≠clicos), 34 grafo de depend√™ncia de predicado, 663 grafos de consulta, 120-121, 472-474 grafo de espera, 541 |
| Grafos ac√≠clicos (hierarquias), em modelos de dados de objeto, 21                                                                   |
| Grafos de consulta, nota√ß√£o, 120-121, 472-474                                                                                       |
| Grafos de espera, 541                                                                                                               |
| Grafos de serializa√ß√£o, 521                                                                                                         |
| GRANT OPTION, 564                                                                                                                   |
| Grau de autonomia local, 593                                                                                                        |
| Grau de homogeneidade do software de SGBDD, 593                                                                                     |
| Group by, cl√°usula, 619 GUIs (interfaces gr√°ficas do usu√°rio), 13                                                                   |

## H

| Handle, vari√°vel de ponteiro C, 314                                                                                      |
|--------------------------------------------------------------------------------------------------------------------------|
| Hardware, 4                                                                                                              |
| Hashing din√¢mico, 410                                                                                                    |
| Hashing est√°tico, 410                                                                                                    |
| Hashing extens√≠vel, 410                                                                                                  |
| Hashing externo, 420                                                                                                     |
| Hashing interno, 406                                                                                                     |
| Hashing linear, 410                                                                                                      |
| Hashing m√∫ltiplo na resolu√ß√£o de colis√£o, 6408                                                                           |
| Hashing particionado, 446                                                                                                |
| HAVING, cl√°usula em SQL fun√ß√µes de agrega√ß√£o, 82                                                                         |
| Heran√ßa m√∫ltipla, 257 no modelo de objeto ODMG, 252 seletiva, 246, 277 subclasses compartilhadas, 169 especificando, 251 |
| m√∫ltipla em ODBs (bancos de dados de objetos), 257                                                                       |
| ODL (Object Definition Language), 240                                                                                    |
| Heran√ßa seletiva, 246                                                                                                    |
| Hierarquia estrita,                                                                                                      |
| 167                                                                                                                      |
| heran√ßa de tabela, 251                                                                                                   |
| hierarquias de tipo, 244                                                                                                 |
| de tabela, 251                                                                                                           |
| Heran√ßa                                                                                                                  |
| Heran√ßa                                                                                                                  |

| Hierarquias regras de associa√ß√£o em modelos de dados de                                 |
|-----------------------------------------------------------------------------------------|
| entre, 707 objeto, 21                                                                   |
| hierarquias de especializa√ß√£o, 167, 169, 178, 181                                       |
| hierarquias de tipo, 238, 244                                                           |
| Hierarquias de classe. Ver hierarquias de tipo (classe)                                 |
| Hierarquias de conceito, 653                                                            |
| Hierarquias de mem√≥ria e dispositivos de armazenamento, 390-391                         |
| Hierarquias de tipo (classe)                                                            |
| restri√ß√µes sobre extens√µes correspondentes a uma, 245                                   |
| heran√ßa e, 244 sistemas OO, 238                                                         |
| H√≠fens, pr√©-processamento:, 682                                                         |
| Hiperlinks p√°gina de destino e umtextode√¢ncora, 688 Histogramas, 651                    |
| HITS, algoritmo de pontua√ß√£o, 688                                                       |
| HSV (matiz, satura√ß√£o e valor), 651                                                     |
| Language) documentos de hipertexto, 691 strings de texto longas em um arquivo HTML, 327 |
| dados n√£o estruturados, 281 linguagem de publica√ß√£o na Web,                             |
| 16                                                                                      |
| HyperText Markup Language. Ver                                                          |
| HTML (HyperText Markup                                                                  |
| Language)                                                                               |
| Hubs de p√°ginas Web ou Websites, 688                                                    |
| HTML (HyperText Markup                                                                  |
| Horn, cl√°usulas, 655                                                                    |

## I

| Identifica√ß√£o objetivos da minera√ß√£o de dados, 699-700                                              |
|-----------------------------------------------------------------------------------------------------|
| Identificadores de objeto. Ver OIDs (identificadores de objeto)                                     |
| Identificadores, 283, 286, 451                                                                      |
| IE (extra√ß√£o de informa√ß√£o), 695                                                                    |
| Implanta√ß√£o, opera√ß√£o e manuten√ß√£o, fases do ciclo de vida, 204                                     |
| Implementa√ß√£o                                                                                       |
| ciclo de vida da aplica√ß√£o de banco de dados, 204 projeto de banco de dados e o processo de,205-219 |
| de opera√ß√µes de banco de dados, 12 sistema de banco de dados, 204                                   |
| Implementa√ß√£o do banco de dados. Ver implementa√ß√£o                                                  |
| Impress√£o digital do banco de dados, 577                                                            |
| Inani√ß√£o, controle de concorr√™ncia e, 524, 529, 531                                                 |
| Independ√™ncia de dados, arquitetura de tr√™s esquemas e, 22-24                                       |
| Independ√™ncia f√≠sica de dados, 23                                                                   |
| Independ√™ncia l√≥gica de dados, 23                                                                   |

| Indexa√ß√£o de jun√ß√£o, 726                                                                                                                                           |
|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Indexa√ß√£o invertida, 674 Indexed Sequential Access Method (ISAM), 424                                                                                              |
| √çndice composto, 450                                                                                                                                               |
| √çndice denso, 431, 434, 470, 495                                                                                                                                   |
| √çndice esparso, 295                                                                                                                                                |
| √çndices                                                                                                                                                            |
| armazenamento de banco de dados, 28                                                                                                                                |
| armazenamento de rela√ß√µes baseado em coluna, 451-452 arquivos de grade, 455 √°rvores de pesquisa e B-trees, 436 B-trees,437 B + -trees, 439 baseados em fun√ß√£o, 450 |
| bitmap, 663-666                                                                                                                                                    |
| chaves m√∫ltiplas, 424                                                                                                                                              |
| clustering, 425                                                                                                                                                    |
| consulta do SGBD, 13                                                                                                                                               |
| f√≠sicos versus l√≥gicos, 450-451                                                                                                                                    |
| hash, 12 hashing particionado,                                                                                                                                     |
| 446-447                                                                                                                                                            |
| implementados para melhorar o desempenho, 626 multin√≠veis din√¢micos, 435 multin√≠veis, 178                                                                          |
| outros tipos de √≠ndices, 447-450 pesquisa, inser√ß√£o e exclus√£o, 441 pesquisas simples, 420 prim√°rios, 425, 451 problemas como, 503                                 |
| projeto de banco de dados f√≠sico                                                                                                                                   |
| e, refer√™ncias bibliogr√°ficas, 280                                                                                                                                 |
| 458 secund√°rios, 462 √∫nico n√≠vel, 538                                                                                                                              |
| varia√ß√µes das B-trees e B + -trees, 443                                                                                                                            |
| √çndices bitmap, 447-448-449 √çndices de agrupamento (clustering)-451, fun√ß√µes de custo para opera√ß√µes SELE√á√ÉO, 479 outros tipos de √≠ndice, 447-450                  |
| tipos de √≠ndices ordenados, 424                                                                                                                                    |
| vis√£o geral, 487                                                                                                                                                   |
| de √∫nico n√≠vel √≠ndices prim√°rios, 425, 451                                                                                                                         |
| √çndices 452,                                                                                                                                                       |
| √≠ndices secund√°rios, 428, 451, 462                                                                                                                                 |

| versus l√≥gicos, 450-451                                                                                 |
|---------------------------------------------------------------------------------------------------------|
| √çndices l√≥gicos versus √≠ndices f√≠sicos, 450-451                                                         |
| √çndices multin√≠veis √°rvores de pesquisa e B-trees, 436 B-trees, 437                                     |
| B + -trees, 439                                                                                         |
| din√¢micos, 435                                                                                          |
| pesquisa, inser√ß√£o e exclus√£o, 441                                                                      |
| varia√ß√µes das B-trees e B + -trees, 443                                                                 |
| √çndices multin√≠vel din√¢micos, 435                                                                       |
| √çndices prim√°rios                                                                                       |
| √≠ndice prim√°rio multin√≠vel n√£o denso, 434                                                               |
| para registros ordenados (arquivos classificados), 392                                                  |
| tipos de √≠ndices ordenados, 424 secund√°rios                                                             |
| √çndices tipos de √≠ndices ordenados, 424                                                                 |
| Infer√™ncia, 563 em bancos de dados, 584                                                                 |
| representa√ß√£o do conhecimento, 161 INFORMATION_SCHEMA, SQL, 59 Inje√ß√£o de c√≥digo, ataques de inje√ß√£o de |
| SQL, 576 Inner joins (jun√ß√µes internas), 107 em SQL, 107                                                |
| versus jun√ß√µes externas, 107 INSERT, comando SQL, 334                                                   |
| Instancia√ß√£o √© o como inverso da classifica√ß√£o, 177 Inst√¢ncias                                          |
| conjunto atual de ocorr√™ncias 21                                                                        |
| ou, de especializa√ß√£o, 196                                                                              |
| relacional, 188                                                                                         |
| de esquema (view), 210                                                                                  |
| Integridade de entidade, 571                                                                            |
| Interface de consulta interativa-27                                                                     |
| Interfaces amig√°veis ao usu√°rio, 742 Interfaces baseadas em                                             |
| formul√°rio,                                                                                             |
| SGBD, 25 Interfaces baseadas em menu, 25                                                                |
| Interfaces de banco de dados. Ver interfaces                                                            |
| Interfaces de linguagem natural, 26 Interfaces de usu√°rio baseadas na                                   |
| Web, do usu√°rio, 13-14                                                                                  |
| Interfaces GUIs (Graphical User Interfaces), 13                                                         |
| multiusu√°rios, 500                                                                                      |
| Integra√ß√£o                                                                                              |

| Interfaces gr√°ficas do usu√°rio                                                                                                                                                                                                                           |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| (GUIs),13 Interface(s) DBA, 18 de consultas interativas, 27 de opera√ß√µes, 252 ferramentas de projeto, 38 GUIs (interfaces gr√°ficas do usu√°rio), 19 linguagens de consulta de alto n√≠vel, 15 m√∫ltiplos usu√°rios, 08 no modelo de objeto ODMG252 SGBDs, 18 |
| Standards Organization                                                                                                                                                                                                                                   |
| International (ISO), 57                                                                                                                                                                                                                                  |
| Internet SCSI (iSCSI), 389 Interpola√ß√£o de vari√°veis nas strings, 328                                                                                                                                                                                    |
| INTERSEC√á√ÉO, opera√ß√£o na teoria dos conjuntos, 101                                                                                                                                                                                                       |
| opera√ß√£o                                                                                                                                                                                                                                                 |
| INTERSEC√á√ÉO, de √°lgebra relacional, 101                                                                                                                                                                                                                  |
| INTERVAL, tipo de dados SQL                                                                                                                                                                                                                              |
| IS-A (E-UM), relacionamentos, 163 no modelo EER, 161 relacionamentos de classe/subclasse                                                                                                                                                                 |
| modelo EER, 167                                                                                                                                                                                                                                          |
| Method), 435 INSTANCIA_DE, √â_UMA, 177 MEMBRO_DE, √â_UMA, 177                                                                                                                                                                                              |
| PARTE_DE, √â_UMA, 178                                                                                                                                                                                                                                     |
| SUBCLASSE_DE, √â_UMA, 178                                                                                                                                                                                                                                 |
| ISCSI (Internet SCSI), 419                                                                                                                                                                                                                               |
| ISO (International Standards                                                                                                                                                                                                                             |
| Organization), 57                                                                                                                                                                                                                                        |
| 501-503                                                                                                                                                                                                                                                  |
| Itens de banco de dados,                                                                                                                                                                                                                                 |
| Iterador posicional, 312                                                                                                                                                                                                                                 |
| Iteradores, 312-313                                                                                                                                                                                                                                      |
| J                                                                                                                                                                                                                                                        |
| Java Database Connectivity. Ver (Java Database Connectivity)                                                                                                                                                                                             |
| JDBC                                                                                                                                                                                                                                                     |
| Java-28 embutindo comandos SQL em,                                                                                                                                                                                                                       |
| 310- 311-312                                                                                                                                                                                                                                             |
| programa√ß√£o JDBC, 314 SQLJ e, 310                                                                                                                                                                                                                        |
| (Java Database Connectivity)                                                                                                                                                                                                                             |
| JDBC                                                                                                                                                                                                                                                     |

| biblioteca de fun√ß√µes, 325 para programa√ß√£o Java,316   |         |
|--------------------------------------------------------|---------|
| JDBC, bibliotecas de classes, 318                      |         |
| JDBC, driver, 318                                      |         |
| JOIN, opera√ß√µes                                        |         |
| fator de sele√ß√£o de jun√ß√£o, 467                        |         |
| fun√ß√µes de custo, 479                                  |         |
| hash-join h√≠brido, 489                                 |         |
| implementando, 461                                     |         |
| junc√£o de loop aninhado, 467                           |         |
| jun√ß√£o de parti√ß√£o-hash, 468 vis√£o geral, 464          |         |
| Joins de √∫nico loop                                    |         |
| fun√ß√µes de custo, 479 Jukeboxes de fita, 391           |         |
| Jun√ß√£o de loop aninhado, implementando, 461            |         |
| 485                                                    |         |
| Jun√ß√µes de parti√ß√£o-hash                               |         |
| M√©todos para implementar jun√ß√µes,                      |         |
| 464                                                    |         |
| sort-merge                                             |         |
| M√©todos para implementar                               |         |
| jun√ß√µes,                                               |         |
| fun√ß√µes de custo,                                      |         |
| vis√£o geral, 464                                       |         |
| 479                                                    |         |
|                                                        | Jun√ß√µes |

464

## K

| KR (raciocinar sobre)               |
|-------------------------------------|
| agrega√ß√£o e associa√ß√£o, 177         |
| classifica√ß√£o e instancia√ß√£o, 177   |
| especializa√ß√£o e generaliza√ß√£o, 177 |
| identifica√ß√£o, 177                  |

## L

| Lacunas entre blocos, 394                                           |
|---------------------------------------------------------------------|
| LANs (redes locais), 419                                            |
| Lat√™ncia. Ver atraso rotacional (rd)                                |
| Leituras sujas, 508                                                 |
| Liga√ß√µes diverg√™ncia de imped√¢ncia,                                 |
| LIKE, operador de compara√ß√£o,                                       |
| 69                                                                  |
| Linguagem de defini√ß√£o de dados. Ver DDL (Data Definition Language) |
| Linguagem de defini√ß√£o de vis√µes (VDL), 24                          |
| Linguagem de especifica√ß√£o de restri√ß√£o, 49                         |
| Linguagem de esquema XML, 286                                       |

| Linguagem de manipula√ß√£o de dados. Ver DML (Data Manipulation Language)     |
|-----------------------------------------------------------------------------|
| Linguagem de Marca√ß√£o do Servi√ßo de Diret√≥rios (DSML), 575                  |
| Linguagem de programa√ß√£o de banco de dados. Ver linguagens de programa√ß√£o   |
| Linguagens de consulta de alto n√≠vel, 15                                    |
| Linguagens de consulta, 15                                                  |
| DML, 24                                                                     |
| SQL. Ver tamb√©m SQL (Structured Query Language) TSQL2. Ver tamb√©m SQL       |
| (Structured Query Language) de especifica√ß√£o de                             |
| Linguagens formul√°rios, 25                                                  |
| Linguagens de programa√ß√£o bancos de dados da Web.                           |
| Ver PHP diverg√™ncia de imped√¢ncia, 304 Linguagens de scripting, PHP         |
| como, 325 SGBD, 303                                                         |
| t√©cnicas para programa√ß√£o de banco de dados, 303 vantagens/desvantagens, 56 |
| XML, 325                                                                    |
| Linguagens declarativas linguagens de SGBD, 25                              |
| SQL como, 60 Linguagem de programa√ß√£o                                       |
| hospedeira C como linguagem hospedeira                                      |
| na CLI, 314 DML, 25                                                         |
| na programa√ß√£o de banco de dados, 335                                       |
| da vida do objeto, diagramas de                                             |
| Linha sequ√™ncia 221                                                         |
| Linhas, 86                                                                  |
| Linhas. Ver tuplas (linhas)                                                 |
| Literais (valores), 239                                                     |
| literais at√¥micos, 253                                                      |
| literais de cole√ß√£o, 253 literais estruturados,                             |
| 239 tipos complexos para,                                                   |
| 291 at√¥micos, 253                                                           |
| Literais                                                                    |
| Literais de cole√ß√£o, 253                                                    |
| Literais estruturados, 239                                                  |
| L√≥gica de tr√™s valores, 343                                                 |
| LPOOs, 237                                                                  |
| OO,                                                                         |
| conceitos de                                                                |
| 238                                                                         |

| declara√ß√µes de classe, 237       |
|----------------------------------|
| ODBs acoplados de perto com, 363 |
| vari√°veis de inst√¢ncia, 238      |
| v√≠nculos com, 306                |

## M

| MAC (Mandatory Access Control) classes de seguran√ßa em, 580                                                 |
|-------------------------------------------------------------------------------------------------------------|
| Mai√∫sculas/min√∫sculas, pr√©- processamento, 682                                                              |
| Mandatory Access Control, 570                                                                               |
| Manuten√ß√£o                                                                                                  |
| banco de dados, 6 custos de manuten√ß√£o                                                                      |
| Mapeamento de atributos multivalorados, 193-194                                                             |
| Mapeamento de modelo. Ver mapeamento do modelo de dados                                                     |
| Mapeamento do modelo de dados fase do projeto, 208, 218 ferramentas automatizadas, 204,                     |
| 209, 232 projeto de banco de dados e, 218                                                                   |
| 218 independente do sistema,                                                                                |
| 218                                                                                                         |
| Mapeamento                                                                                                  |
| mapeamento do modelo de dados tuplas, 64 Marcadores de condi√ß√£o em diagramas de sequ√™ncia, 222              |
| Marcadores de exclus√£o e a reorganiza√ß√£o                                                                    |
| peri√≥dica, 405 Materializa√ß√£o de view, 90                                                                   |
| MAX, fun√ß√£o agrupamento e, 91 fun√ß√µes de agrega√ß√£o em SQL, implementa√ß√£o da, 133 Mecanismo de nomea√ß√£o, 242 |
| Mecanismos de racioc√≠nio, 177                                                                               |
| Mem√≥ria cache, 390                                                                                          |
| Mem√≥ria flash, 390                                                                                          |
| Mem√≥ria principal, 430 Mem√≥rias de jukebox √≥ptico,                                                          |
| Mensagens, passagem de, 237                                                                                 |
| 391                                                                                                         |

| Metaclasses, representa√ß√£o do conhecimento, 178                                                                                                                           |
|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Metadados defini√ß√£o, 35 no cat√°logo do SGBD, 609                                                                                                                          |
| Metadados de neg√≥cios, 728                                                                                                                                                |
| Metodologia de projeto de banco de dados, 202                                                                                                                             |
| ciclo de vida do sistema de aplica√ß√£o de banco de dados, 204-205                                                                                                          |
| ciclo de vida do sistema de informa√ß√£o, 203-204 contexto organizacional para o uso de sistemas de banco de dados, escolha do SGBD, 206, 208, 216                          |
| 202-203 exemplo do banco de dados Universidade, 172-173 fase de levantamento e an√°lise de                                                                                 |
| requisitos, 207-208 ferramentas automatizadas, 204,                                                                                                                       |
| 209                                                                                                                                                                       |
| implementa√ß√£o e ajuste do sistema, 206, 207, 219                                                                                                                          |
| mapeamento do modelo de dados (projeto l√≥gico do banco de dados), 132, 133, 205, 206, 218, 229 processo de implementa√ß√£o, 205-219 projeto de esquema conceitual, 22, 148, |
| 177, 189, 209, 348 projeto de transa√ß√£o, 208, 215-216 projeto f√≠sico do banco de dados, 203, 206, 207, 215, 218-219, 490, 491                                             |
| UML como um padr√£o de especifica√ß√£o de projeto, 219 UML para o projeto de aplica√ß√£o de                                                                                    |
| banco de dados, 220 UML, tipos de diagrama, 131, 148, 202, 220                                                                                                            |
| vis√£o geral, 201 conceitual, 178                                                                                                                                          |
| Projeto de banco de dados, Projeto de esquema, 374                                                                                                                        |
| M√©todos. Ver tamb√©m de classes de objetos, 220                                                                                                                            |
| M√©todos de acesso, organiza√ß√£o                                                                                                                                            |
| arquivo e, 402                                                                                                                                                            |
| software SGBDDs heterog√™neos, 33                                                                                                                                          |
| MIN, fun√ß√£o agrupamento e, 82                                                                                                                                             |
| Middleware,                                                                                                                                                               |
| de                                                                                                                                                                        |
| refer√™ncias bibliogr√°ficas, 280                                                                                                                                           |
| 217 opera√ß√µes                                                                                                                                                             |
| Refinamento                                                                                                                                                               |

| fun√ß√µes de agrega√ß√£o em SQL, 82                                                                                                                                                                                            |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| implementando opera√ß√µes de agrega√ß√£o, 470                                                                                                                                                                                  |
| Minera√ß√£o de dados, Data mining aplica√ß√£o de banco de dados espec√≠fica,                                                                                                                                                    |
| Minimundo, 6                                                                                                                                                                                                               |
| Modelo booleano, 674-675                                                                                                                                                                                                   |
| Modelo de dados relacional caracter√≠sticas das rela√ß√µes, 41-42-43 conceitos, 41                                                                                                                                            |
| correspond√™ncias entre os modelos ER, 194                                                                                                                                                                                  |
| Dom√≠nios, atributos, tuplas e rela√ß√µes, 39                                                                                                                                                                                 |
| esquemas, 58 integridade, integridade referencial e chaves estrangeiras, 47-48-49                                                                                                                                          |
| linguagem pr√°tica para. Ver SQL (Structured Query Language)                                                                                                                                                                |
| linguagens formais para. Ver √°lgebra relacional nota√ß√£o, 60 opera√ß√£o de exclus√£o, 51 opera√ß√£o de inser√ß√£o, 539 opera√ß√µes de atualiza√ß√£o, 401 outros tipos de restri√ß√µes, 47 refer√™ncias bibliogr√°ficas, 280 restri√ß√µes, 41 |
| transa√ß√µes e, 203 vis√£o geral, 58                                                                                                                                                                                          |
| Modelo de dados, 414 Modelo de matriz de acesso, 547                                                                                                                                                                       |
| Modelo objeto-relacional criando tabelas baseadas nos 250                                                                                                                                                                  |
| UDTs,                                                                                                                                                                                                                      |
| encapsulamento de opera√ß√µes, 247                                                                                                                                                                                           |
| Modelo relacional plano, 280                                                                                                                                                                                               |
| Modelos de dados abstra√ß√£o de dados, 6, 7-8, 15                                                                                                                                                                            |
| categorias, 20-21                                                                                                                                                                                                          |
| hier√°rquicos para XML. Ver                                                                                                                                                                                                 |
| modelos de dados hier√°rquicos para XML objeto. Ver modelos de dados de                                                                                                                                                     |
| objeto Rational Rose, 159, 160, 187, 118, 200, 202, 219, 220, 225-229                                                                                                                                                      |
| rede. Ver modelos de dados de rede regras inerentes, 14                                                                                                                                                                    |
| sem√¢nticos, 161, 177, 179, 188,                                                                                                                                                                                            |
| 234                                                                                                                                                                                                                        |
| de dados avan√ßados, 627-668                                                                                                                                                                                                |
| Modelos                                                                                                                                                                                                                    |

| bancos de dados ativos. Ver sistemas de banco de dados ativos                                                                |
|------------------------------------------------------------------------------------------------------------------------------|
| bancos de dados de multim√≠dia. Ver bancos de dados de multim√≠dia                                                             |
| bancos de dados espaciais. Ver bancos de dados espaciais                                                                     |
| sistemas de banco de dados dedutivos. Ver sistemas de banco de dados dedutivos                                               |
| Modelos de dados baseados em registro-20 Modelos de dados conceituais, 20                                                    |
| Modelos de dados de alto n√≠vel, 20                                                                                           |
| Modelos de dados de baixo n√≠vel, 20                                                                                          |
| Modelos de dados de objeto modelagem de objeto, 131                                                                          |
| Modelos de dados em √°rvore. Ver modelos de dados hier√°rquicos Modelos de dados funcionais, 141                               |
| Modelos de dados hier√°rquicos para XML                                                                                       |
| criando vis√µes XML hier√°rquicas sobre dados planos ou baseados em grafos, 295                                                |
| Modelos de dados legados, 20 Modelos de dados representativos (ou de implementa√ß√£o), 20                                      |
| Modelos de dados sem√¢nticos 161 agrega√ß√£o e associa√ß√£o, 177 classifica√ß√£o e instancia√ß√£o, 177 conceitos de abstra√ß√£o de, 176 |
| especializa√ß√£o e generaliza√ß√£o, 181 identifica√ß√£o, 177 de consulta, 90                                                       |
| SQL, 519 cliente, 19 gerenciador de dados                                                                                    |
| armazenados, SGBD, 26 M√≥dulos cliente e servidor, 31                                                                         |
| componentes do SGBD, 26-28                                                                                                   |
| SGBD, 31 M√≥dulos componentes do SGBD,                                                                                        |
| 26-28 Multiconjunto de tuplas, 78 Multiplicidades nos diagramas de classe                                                    |
| UML, 227                                                                                                                     |
| Multiprograma√ß√£o, 501                                                                                                        |
| MVD (Depend√™ncia                                                                                                             |
| 4FN, 348                                                                                                                     |
| multivalorada) defini√ß√£o formal, 129                                                                                         |
| de acesso, transa√ß√£o em                                                                                                      |
| Modifica√ß√£o Modo M√≥dulo M√≥dulo                                                                                               |

| regras de infer√™ncia, 365-366       |
|-------------------------------------|
| restri√ß√µes do modelo relacional, 96 |

## N

| Namespaces XML, 286                                                                                                                                                                                    |
|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| N -√°rios, 153 processo de integra√ß√£o de vis√£o, 213 tipos de relacionamento, 154 (Network-Attached Storage), 389                                                                                        |
| NAS                                                                                                                                                                                                    |
| JUN√á√ÉO NATURAL, opera√ß√µes, 106 Navega√ß√£o. Ver tamb√©m navegadores                                                                                                                                       |
| Web interfaces, 24 modos de intera√ß√£o em sistemas de RI,                                                                                                                                               |
| 673-674 Navegadores Web, 598 Network-Attached Storage (NAS), 389                                                                                                                                       |
| N√≠vel de conta, privil√©gios discricion√°rios,                                                                                                                                                           |
| 567 Nomes de fun√ß√£o e relacionamentos                                                                                                                                                                  |
| recursivos, 140 Normaliza√ß√£o algoritmos. Ver algoritmos de                                                                                                                                             |
| normaliza√ß√£o de rela√ß√µes, 364 depend√™ncias funcionais, 347 do projeto de esquema relacional, 346 ferramentas automatizadas, 204 projeto de banco de dados relacional baseado em, 360 de dados, 11, 348 |
| N√≥s de constante em grafos de consulta, 120 nota√ß√£o para √°rvores de consulta e grafos de consulta, 472 N√≥s de rela√ß√£o em grafos de consulta, 120                                                       |
| N√≥s descendentes, 537 N√≥s filhos de estruturas de √°rvore, 110, 436                                                                                                                                     |
| N√≥s folha, 478 NOT EXISTS, fun√ß√µes,                                                                                                                                                                    |
| NOT NULL, restri√ß√£o, 53                                                                                                                                                                                |
| Nota√ß√£o Datalog, 655-656                                                                                                                                                                               |
| Nota√ß√£o de ponto, 242                                                                                                                                                                                  |
| express√µes de caminho, 252                                                                                                                                                                             |
| Normaliza√ß√£o                                                                                                                                                                                           |
| nota√ß√£o, 502 de √°rvore, 488                                                                                                                                                                            |
| N√≥s                                                                                                                                                                                                    |
| N√≥s folha de √°rvores, 110                                                                                                                                                                              |
| 748                                                                                                                                                                                                    |

| modelo de objeto ODMG, 252 opera√ß√µes, 242                                                                          |
|--------------------------------------------------------------------------------------------------------------------|
| Nota√ß√£o p√© de galinha, 732                                                                                         |
| Nota√ß√£o                                                                                                            |
| diagram√°tica, 138 e grafos de consulta, 472 em diagramas de classes em diagramas ER, 143 para √°rvores de consulta, |
| UML,                                                                                                               |
| 148                                                                                                                |
| 472                                                                                                                |
| NULL, valores                                                                                                      |
| defaults de atributo, 61                                                                                           |
| em tuplas, 197                                                                                                     |
| exemplos ilustra, 91                                                                                               |
| no modelo ER, 156                                                                                                  |
| restri√ß√µes, 143                                                                                                    |
| tuplas com, 77                                                                                                     |

## O

| Object Data Management Group. Ver ODMG(Object Data Management Group)                                                                                                             |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Object Data Management Systems. Ver ODMS (Object Data Management Systems)                                                                                                        |
| Objetos at√¥micos no modelo de objeto ODMG, 252, 257 tempo de vida do objeto, 223                                                                                                 |
| Objetos bin√°rios grandes (BLOBs), 398 Objetos de exce√ß√£o, 177                                                                                                                    |
| Objetos de itera√ß√£o, 258                                                                                                                                                         |
| Objetos atributos vis√≠veis e ocultos, 241 no modelo de objeto ODMG, 257 objetos at√¥micos (definidos pelo usu√°rio), 259-261 opera√ß√µes, 259 persist√™ncia, 253 tipos complexos, 291 |
| Ocorr√™ncias, conjunto atual de, 21 ODBC (Open Database Connectivity) API da, 31 biblioteca de fun√ß√µes, 314                                                                       |
| ODBs (bancos de dados de objetos) encapsulamento de opera√ß√µes, extens√µes √† SQL, 320                                                                                              |
| 237 heran√ßa m√∫ltipla, 165                                                                                                                                                        |
| heran√ßa seletiva, 246                                                                                                                                                            |
| hierarquias de tipo e heran√ßa, 244-245                                                                                                                                           |
| identificadores de objetos, 648                                                                                                                                                  |

| persist√™ncia de objetos, 241-243                                |
|-----------------------------------------------------------------|
| polimorfismo (sobrecarga de operador), 245                      |
| ODL (linguagem de defini√ß√£o de objeto)                          |
| constru√ß√µes sem√¢nticas do modelo de                             |
| objeto ODMG, 263                                                |
| constru√ß√µes, 263                                                |
| construtores de tipo, 276                                       |
| exemplo de esquema, UNIVERSIDADE, 276                           |
| heran√ßa e, 16                                                   |
| no padr√£o ODMG,                                                 |
| 247                                                             |
| ODMG(Object Data Management                                     |
| Group)                                                          |
| OQL (Object Query Language), 252                                |
| padr√µes, 237                                                    |
| v√≠nculo da linguagem C++,                                       |
| 252                                                             |
| at√¥micos (definidos pelo                                        |
| usu√°rio), 259-261                                               |
| extens√µes, chaves e f√°brica de objetos, 261                     |
| heran√ßa, 247                                                    |
| interfaces e classes embutidas, 257                             |
| literais, 257 objetos, 275                                      |
| ODL (linguagem                                                  |
| de objeto), 263                                                 |
| defini√ß√£o de                                                    |
| ODMS (Object Data Management Systems). Ver tamb√©m ODBs          |
| (bancos de dados de objetos)                                    |
| linguagem de consulta de alto n√≠vel, 457                        |
| OIDs, 239 padr√£o, 292                                           |
| tipos                                                           |
| complexos, 291 v√≠nculo antecipado                               |
| (ou est√°tico), 246                                              |
| 390                                                             |
| Off-line, OIDs (identificadores de                              |
| objetos) no modelo de objeto ODMG, 252 tipos de refer√™ncia, 250 |
| (processamento de transa√ß√£o on- line), 721                      |
| OLTP                                                            |
| Ontologias, 653                                                 |
| conceitos, 653                                                  |
| defini√ß√£o, 4                                                    |
| Web sem√¢ntica                                                   |
| e,                                                              |
| 179                                                             |
| 237                                                             |
| OO (orientado a objeto),                                        |

| Open Database Connectivity. Ver ODBC (Open Database Connectivity)                                                                 |
|-----------------------------------------------------------------------------------------------------------------------------------|
| Opera√ß√£o de inser√ß√£o, 539 sobre arquivos, 423                                                                                     |
| Opera√ß√µes. Ver tamb√©m fun√ß√µes; m√©todos banco de dados, 540 em diagramas de classe, 131 encapsulamento de, 237 modelos de dados, 8 |
| relacional, 389 Opera√ß√µes de conjunto, 470 processamento e otimiza√ß√£o de consulta, 457-489                                        |
| Opera√ß√µes de modifica√ß√£o sobre arquivos, 600. Ver tamb√©m opera√ß√µes de                                                             |
| atualiza√ß√£o Opera√ß√µes modificadoras de objeto,                                                                                    |
| 242 de recupera√ß√£o, 557 das tabelas do banco de dados, 334                                                                        |
| objetos, 528 sobre arquivos, 423                                                                                                  |
| tipos de opera√ß√µes do modelo de relacional, 389 em arquivos, reset, 401                                                           |
| dados no modelo de dados relacional                                                                                               |
| Opera√ß√µes Opera√ß√µes                                                                                                               |
| Opera√ß√µes                                                                                                                         |
| SQL, 470                                                                                                                          |
| de destruidor, 242                                                                                                                |
| Opera√ß√£o                                                                                                                          |
| opera√ß√£o Delete, 276                                                                                                              |
| opera√ß√£o Insert, 630                                                                                                              |
| opera√ß√£o Update (Modify),                                                                                                         |
| 630                                                                                                                               |
| vis√£o geral, 694                                                                                                                  |
| relacionais bin√°rias                                                                                                              |
| Opera√ß√µes                                                                                                                         |

| opera√ß√£o JUN√á√ÉO, 82, 107                                                                                                                                                                                                            |
|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| opera√ß√µes EQUIJUN√á√ÉO e JUN√á√ÉO NATURAL, 81 vis√£o geral, 97                                                                                                                                                                           |
| Opera√ß√µes relacionais un√°rias opera√ß√£o PRODUTO CASTESIANO, 155-157 opera√ß√£o PROJETO, 149-150 opera√ß√£o SELE√á√ÉO, 147-149                                                                                                              |
| SUBTRA√á√ÉO, 152-155 de concatena√ß√£o (||), 60 de decremento, 70 de elemento, 273 de incremento, 70 operador de concatena√ß√£o, 60 operador SELE√á√ÉO, 97 operadores de cole√ß√£o em OQL, 273                                                |
| de cole√ß√£o, 273 de compara√ß√£o dom√≠nios s√£o valores ordenados, 98 SQL, 64 (Object Query Language) consultas OQL simples, 260 express√µes de cole√ß√£o ordenada (indexada), 274 extraindo elementos isolados de cole√ß√µes singulares, 273 |
| no padr√£o ODMG, 247, 275 operadores de cole√ß√£o e, 273                                                                                                                                                                               |
| sobrecarga. Ver polimorfismo (sobrecarga de operador) operadores aritm√©ticos em SQL, 106 operadores, trabalhadores de dados nos bastidores, 17                                                                                      |
| opera√ß√µes UNI√ÉO, INTERSEC√á√ÉO e                                                                                                                                                                                                      |
| Operador Operador Operador                                                                                                                                                                                                          |
| Operador                                                                                                                                                                                                                            |
| Operadores 105- banco de Operadores Operadores OQL                                                                                                                                                                                  |
| resultados de consulta e express√µes de caminho, 270-272 Ordem sequencial, os blocos de dados em, 396 Ordena√ß√£o,480 externa, 77                                                                                                      |

| resultados da consulta, 599                                                                   |
|-----------------------------------------------------------------------------------------------|
| Ordenados, arquivos de registros, 404 ORDER BY, cl√°usula SQL, 459 resultados da consulta, 599 |
| Organiza√ß√£o de arquivo prim√°ria,414 B-trees, 389 organiza√ß√£o de dados, 18                     |
| Orientado a objeto (OO), 237                                                                  |
| Otimiza√ß√£o de consulta baseada em custo informa√ß√µes de cat√°logo, 615 JOIN, 661 SELECT, 663    |
| Otimiza√ß√£o sem√¢ntica, 488                                                                     |
| Otimizador de consulta, 27                                                                    |
| Otimizando consultas. Ver processamento e otimiza√ß√£o de consulta                              |
| UNI√ÉO EXTERNA, opera√ß√£o, 612                                                                  |
| Overflow ou transa√ß√£o, arquivo de, 405                                                        |

## P

| Padr√µes, 29                                                           |
|-----------------------------------------------------------------------|
| especifica√ß√£o de projeto de banco de dados, 219 PostgreSQL, 33        |
| Pagina√ß√£o de sombra, 543                                              |
| P√°ginas Web din√¢micas, 687 defini√ß√£o, 4                               |
| P√°ginas Web est√°ticas, 279                                            |
| Par√¢metro de disco, 735-743                                           |
| Par√¢metros, 304                                                       |
| SQL/PSM (Persistent Stored Modules),                                  |
| 72                                                                    |
| Participa√ß√£o total, 143                                               |
| PEAR (PHP Extension and Application Repository), 332 Persist√™ncia,238 |
| cole√ß√µes, 271 dados, 271                                              |
| Persistent Stored Modules (PSM), 72 Pesquisa linear                   |
| algoritmo de for√ßa bruta, 461                                         |
| blocos de arquivo no disco, 400                                       |
| fun√ß√µes de custo para SELE√á√ÉO, 481 no arquivo, 431                    |
| Pesquisas m√©todos para sele√ß√£o complexa,                              |
| 687                                                                   |
| m√©todos para sele√ß√£o simples,                                         |
| 685-686                                                               |
| 686-                                                                  |
| objetos, 275                                                          |

| Pessoal de manuten√ß√£o, 17 PHP Extension and Application Repository (PEAR), 491       |
|--------------------------------------------------------------------------------------|
| PHP, 302                                                                             |
| arrays, 389                                                                          |
| caracter√≠sticas, 282                                                                 |
| coletando dados de formul√°rios e                                                     |
| inserindo registros, 333                                                             |
| fun√ß√µes, 314 refer√™ncias bibliogr√°ficas, 280                                         |
| vari√°veis, tipos de dados e constru√ß√µes, 328                                         |
| 325 nomes de vari√°vel, 328                                                           |
| PHP, PHP,                                                                            |
| compartilhado, 596                                                                   |
| escopo, 330 programa, 580                                                            |
| tupla, 640                                                                           |
| servidor, 331                                                                        |
| PHP,                                                                                 |
| Pipelining, 390 PL/SQL, 25                                                           |
| cria√ß√£o do sistema de banco de do zero, 216                                          |
| dados diverg√™ncia de imped√¢ncia, 304 Planos de execu√ß√£o de consulta, 472             |
| Polimorfismo (sobrecarga de operador) conceito de OO, 238 Ponteiros de registro, 409 |
| Ponteiros para os blocos de dados e,                                                 |
| 597 Pontos de entrada, 243 em OQL, 274                                               |
| no modelo de objeto ODMG, 252                                                        |
| Precis√£o m√©dia, 685 comandos DML e, 28 SQL embutida e, 449                           |
| 165                                                                                  |
| Predicado de defini√ß√£o da subclasse, Predicados,122 esquemas relacionais e, 360      |
| Pr√©-processador de hipertexto, SQL embutida e, 449                                   |
| 325 Pr√©-processamento: d√≠gitos, 682                                                  |
| Pressuposto do mundo fechado, 43 PRIMARY KEY, cl√°usula, 62                           |
| Primeira forma normal (lFN), 348 Privil√©gios, 73                                     |
| Problema de diverg√™ncia de 12                                                        |
| imped√¢ncia,                                                                          |
| Procedimentos armazenados, 320                                                       |

| OLTP (On-line                                                                                                                                                                                                                                    |
|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Transaction Processing) Processamento e otimiza√ß√£o de consulta Fun√ß√µes de custo para JUN√á√ÉO, 483- 484-485 fun√ß√µes de custo para SELE√á√ÉO, 481- 482-483 informa√ß√µes de cat√°logo, 615 jun√ß√£o de loop aninhado, 485 m√©todos de pesquisa para sele√ß√£o |
| simples, 461                                                                                                                                                                                                                                     |
| opera√ß√µes, 488                                                                                                                                                                                                                                   |
| Processamento paralelo, 501                                                                                                                                                                                                                      |
| Processo de classifica√ß√£o, 177                                                                                                                                                                                                                   |
| Processos, 181 no projeto de banco de dados, 175                                                                                                                                                                                                 |
| Produto cartesiano, 41                                                                                                                                                                                                                           |
| PRODUTO CARTESIANO, opera√ß√£o √°lgebra relacional, 67                                                                                                                                                                                              |
| Programa e dados, 390                                                                                                                                                                                                                            |
| Programa e opera√ß√£o,                                                                                                                                                                                                                             |
| 22 Programadores de                                                                                                                                                                                                                              |
| aplica√ß√£o, 13, 26, 28, 219 Programas clientes, 31                                                                                                                                                                                                |
| Programas de aplica√ß√£o, 3, 4, 6, 7, 8, 14, 19, 23, 29, 30, 31, 32, 44, 49, 50, 131, 132, 133, 204, 207, 303, 304, 307, 321                                                                                                                       |
| Programas, isolamento entre, 6 Projetistas de banco de dados                                                                                                                                                                                     |
| atores em cena, 9-10                                                                                                                                                                                                                             |
| teste dos programas de                                                                                                                                                                                                                           |
| aplica√ß√£o, 131                                                                                                                                                                                                                                   |
| Projeto com perda, 374                                                                                                                                                                                                                           |
| conceitual                                                                                                                                                                                                                                       |
| Projeto de alto n√≠vel, 132                                                                                                                                                                                                                       |
| de bancos de dados, 6                                                                                                                                                                                                                            |
| em nota√ß√£o UML, 226-227                                                                                                                                                                                                                          |
| exemplo de aplica√ß√£o de                                                                                                                                                                                                                          |
| banco de dados, 133-134                                                                                                                                                                                                                          |
| refinando o projeto de ER para o banco de dados EMPRESA, 145-146                                                                                                                                                                                 |
| sincronismo entre o, e o banco                                                                                                                                                                                                                   |
| de dados real, 227                                                                                                                                                                                                                               |
| controlado pelo                                                                                                                                                                                                                                  |
| Projeto departamento, 610                                                                                                                                                                                                                        |
| Projeto de banco de dados relacional                                                                                                                                                                                                             |
| conjuntos m√≠nimos de depend√™ncias                                                                                                                                                                                                                |
| funcionais, 368-369                                                                                                                                                                                                                              |
| defini√ß√£o geral da segunda forma                                                                                                                                                                                                                 |
| normal, 384-385                                                                                                                                                                                                                                  |
| defini√ß√£o geral da terceira forma                                                                                                                                                                                                                |
| normal, 354-355                                                                                                                                                                                                                                  |

| depend√™ncia multivalorada e quarta forma normal, 357-358-359                                       |
|----------------------------------------------------------------------------------------------------|
| depend√™ncias de inclus√£o, 386 depend√™ncias de modelo, 365                                          |
| depend√™ncias funcionais baseadas em fun√ß√µes aritm√©ticas e                                          |
| procedimentos, 384-385                                                                             |
| segunda forma normal (2FN), 354                                                                    |
| terceira forma normal (3FN), 348                                                                   |
| Projeto de banco de dados ciclo de vida do sistema de aplica√ß√£o banco de dados, 204-205            |
| decis√µes de projeto sobre indexa√ß√£o, 492-493                                                       |
| desnormaliza√ß√£o como decis√£o de projeto para agilizar as consultas, 493                            |
| escolhas de projeto para o projeto conceitual, 147-148                                             |
| especializa√ß√£o e generaliza√ß√£o, 163-165 fatores que influenciam o projeto                          |
| f√≠sico do banco de dados, 490-491                                                                  |
| pr√°tico. Ver metodologia de projeto de banco de dados                                              |
| relacional. Ver projeto de banco de dados relacional                                               |
| verifica√ß√£o, 231 Projeto de esquema centralizado (uma √∫nica tentativa), t√©cnica de, 209            |
| Projeto de esquema conceitual, 209 estrat√©gias para, 210                                           |
| identificar correspond√™ncias e conflitos entre os esquemas, 210-211 integra√ß√£o de esquema (vis√£o), |
| 210, 233                                                                                           |
| modelo de dados de alto n√≠vel usado no, 206                                                        |
| t√©cnicas, 209 do conte√∫do de dados, 206 f√≠sico de banco de dados. Ver                              |
| Projeto tamb√©m projeto de banco de dados                                                           |
| Projeto organiza√ß√£o de dados, 18                                                                   |
| l√≥gico, 233                                                                                        |
| Projeto Projeto orientado a objetos, 217                                                           |
| Projeto relacional por an√°lise, 364                                                                |
| Projeto relacional por s√≠ntese,                                                                    |
| PROJETO, opera√ß√µes                                                                                 |
| algoritmos para, 696-697                                                                           |
| na √°lgebra relacional, 149-150                                                                     |
| 377                                                                                                |

consulta, 696-697

Prolog, linguagem.

Ver tamb√©m

Datalog, linguagem

Propriedade de atomicidade, 9, 508, 577

Propriedade de durabilidade, 508

Propriedade de isolamento, 508

Propriedade de jun√ß√£o n√£o aditiva (ou sem perdas), 345

formas normais e, 345

sucessiva 360

testando decomposi√ß√µes bin√°rias para,

557

Propriedade de jun√ß√£o sem perdas (n√£o aditiva)

decomposi√ß√£o em rela√ß√µes da 3FN,

560-563

decomposi√ß√£o em rela√ß√µes da 4FN, 570

formas normais e, 518

sucessiva, 557

testando decomposi√ß√µes bin√°rias para,

557

Propriedade de preserva√ß√£o de depend√™ncia

decomposi√ß√£o para terceira forma normal (3FN), 560-563

formas normais e, 518

Propriedade imut√°vel das OIDs, 239

Propriedades das decomposi√ß√µes relacionais

decomposi√ß√£o da jun√ß√£o n√£o aditiva para esquemas FNBC, 380

decomposi√ß√µes sucessivas, 364

jun√ß√£o n√£o aditiva, 338

preserva√ß√£o da depend√™ncia, 338

testando decomposi√ß√µes bin√°rias, 372

Propriedades de classe, 177

PSM (Persistent Stored Modules), 72, 303

## Q

| QBE (Query-By-Example) c√°lculo de dom√≠nio, 123, 737                                                                |
|--------------------------------------------------------------------------------------------------------------------|
| QMF (Query Management Facility), 124, 737                                                                          |
| Quantificadores existenciais e universais, 118 operadores de cole√ß√£o em OQL, 273 transformando os, 121 usando, 121 |
| Quantificadores existenciais no c√°lculo relacional de tupla, 119                                                   |

| transformando, 121                                                                            |
|-----------------------------------------------------------------------------------------------|
| Quantificadores universais no c√°lculo relacional de tupla, 119 transformando, 121 usando, 121 |
| Quarta forma normal (4FN) defini√ß√£o formal, 381 depend√™ncia multivalorada, 357                |
| Query Management Facility (QMF), 124                                                          |
| Query-By-Example. Ver QBE (Query-By- Example)                                                 |
| Quinta forma normal (5FN), 348                                                                |

## R

| RAID (Redundant Array of Inexpensive Disks) melhor confiabilidade, 416 melhoria de desempenho, 415 n√≠veis, 415 Ra√≠zes, 680       |
|----------------------------------------------------------------------------------------------------------------------------------|
| RAM (Random Access Memory), 390                                                                                                  |
| Rational Rose ferramentas e op√ß√µes, 226 modeladores de dados, 219 projeto de banco de dados com, 228 Raz√£o de cardinalidade para |
| relacionamento bin√°rio, 142                                                                                                      |
| Raz√£o, seletividade de jun√ß√£o, 106, 483, 484                                                                                     |
| RDF (Resource Description Framework), 295                                                                                        |
| Read (ou Get), opera√ß√£o sobre arquivos, 401                                                                                      |
| Recupera√ß√£o de informa√ß√µes. Ver RI (recupera√ß√£o de informa√ß√µes)                                                                  |
| Recupera√ß√£o. Ver tamb√©m backup e recupera√ß√£o; t√©cnicas de recupera√ß√£o banco de dados                                             |
| Redes locais (LANs), 419                                                                                                         |
| Redundant Array of Inexpensive Disks (RAID). Ver RAID (Redundant Array                                                           |
| REF, palavra-chave especificando relacionamentos via refer√™ncia, 248                                                             |
| chave estrangeira, 252 especificando relacionamentos por                                                                         |
| refer√™ncia, 252                                                                                                                  |
| Refer√™ncias                                                                                                                      |
| of Inexpensive Disks)                                                                                                            |
| Redund√¢ncia de dados, 217,                                                                                                       |

| Refer√™ncias de valor, 268 Registro de √¢ncora (√¢ncora de bloco), 425                                                                                                                                                                                                                                                                      |
|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Registro de conex√£o em SQL/CLI, 315                                                                                                                                                                                                                                                                                                      |
| Registros. Ver tamb√©m arquivos (de registros) de conex√£o SQL/CLI, 315                                                                                                                                                                                                                                                                    |
| Registros desordenados heap), 403-404 Regras ativas, 626 Regras de associa√ß√£o                                                                                                                                                                                                                                                            |
| em blocos, 403 (arquivos de algoritmo Apriori, 702-703 algoritmo de amostragem, 703-704 algoritmo de √°rvore de padr√£o frequente (FP), 704-706 algoritmo de parti√ß√£o, 706-707 algoritmos de crescimento FP, 704-706                                                                                                                       |
| associa√ß√µes multidimensionais, 707 associa√ß√µes negativas, 708                                                                                                                                                                                                                                                                            |
| fun√ß√µes de custo, 480 inserindo, 333 mistos, 389 ordenados (arquivos classificados), 389 registro de √¢ncora (√¢ncora de bloco), 425 tamanho fixo e tamanho vari√°vel, 306 tipos, 314 de ambiente em SQL/CLI, 315 de descri√ß√£o em SQL/CLI, 314 de instru√ß√£o em SQL/CLI, 314 Registros de tamanho fixo, 595-597 de tamanho vari√°vel, 595-597 |
| Registros Registros                                                                                                                                                                                                                                                                                                                      |
| Registros                                                                                                                                                                                                                                                                                                                                |
| Registros Registros                                                                                                                                                                                                                                                                                                                      |
| descoberta de padr√£o e an√°lise de                                                                                                                                                                                                                                                                                                        |
| padr√£o uso da Web, 691 entre hierarquias, 707 exemplo de uma, 649                                                                                                                                                                                                                                                                        |
| de infer√™ncia                                                                                                                                                                                                                                                                                                                            |
| de Armstrong, 367 para depend√™ncias funcionais e multivaloradas, 381                                                                                                                                                                                                                                                                     |
| para depend√™ncias funcionais,                                                                                                                                                                                                                                                                                                            |
| de neg√≥cios                                                                                                                                                                                                                                                                                                                              |
| 365 restri√ß√µes de integridade, 13                                                                                                                                                                                                                                                                                                        |
| Regras                                                                                                                                                                                                                                                                                                                                   |
| Regras restri√ß√µes do modelo relacional, 96                                                                                                                                                                                                                                                                                               |

| Regras dedutivas. Ver regras em bancos de dados dedutivos                                                                                                                           |
|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Regras heur√≠sticas, 682 Regras inerentes do modelo de dados, 14                                                                                                                     |
| Rela√ß√£o do relacionamento (tabela de pesquisa) mapeamento de tipos de relacionamento bin√°rio 1:1, 192 mapeamento de tipos de relacionamento bin√°rio 1:N, 192 mapeamento de tipos de |
| restri√ß√µes, 132                                                                                                                                                                     |
| relacionamento bin√°rio M:N, 193 Relacionamento de identifica√ß√£o do tipo de entidade fraca, 144                                                                                      |
| Relacionamentos banco de dados UNIVERSIDADE, 6                                                                                                                                      |
| especificando, por refer√™ncia, 252 na modelagem de dados,131 no modelo de objeto ODMG, 252 s√≠mbolos de, 733 sistemas OO, 258                                                        |
| Relacionamentos bin√°rios escolhendo entre relacionamentos bin√°rio e tern√°rio, 151-153 grau de relacionamento, 140, 141 mapeamento do modelo de dados,                               |
| 132 mapeamento para um esquema relacional, 138                                                                                                                                      |
| Relacionamentos complexos entre dados, 13 f√≠sicos entre registros de                                                                                                                |
| Relacionamentos arquivo, 617                                                                                                                                                        |
| Relacionamentos no modelo ER atributos dos tipos de relacionamento,                                                                                                                 |
| 146                                                                                                                                                                                 |
| grau maior que dois, 145                                                                                                                                                            |
| relacionamentos como atributos, 141 relacionamentos recursivos, 140 restri√ß√µes sobre tipos de relacionamento                                                                        |
| bin√°rios, 142                                                                                                                                                                       |
| tipos de relacionamento, 142                                                                                                                                                        |
| tipos, conjuntos e inst√¢ncias                                                                                                                                                       |
| de relacionamento, 140                                                                                                                                                              |
| recursivos, 140, 141                                                                                                                                                                |
| sem                                                                                                                                                                                 |
| identifica√ß√£o, Rational Rose, 226                                                                                                                                                   |
| Relacionamentos tern√°rios escolhendo entre relacionamentos                                                                                                                          |
| bin√°rios e tern√°rios, 228-231                                                                                                                                                       |
| Relacionamentos                                                                                                                                                                     |
| Relacionamentos                                                                                                                                                                     |

| no modelo ER (Entidade- Relacionamento), 213-214                                                                                        |
|-----------------------------------------------------------------------------------------------------------------------------------------|
| restri√ß√µes, 232 Rela√ß√µes (estados de rela√ß√£o). Ver tamb√©m tabelas armazenamento baseado em coluna, 669-670 defini√ß√£o alternativa, 64-65 |
| interpreta√ß√£o (significado), 66                                                                                                         |
| legalidade, 514                                                                                                                         |
| normaliza√ß√£o, 517-518 ordenando tuplas, 63                                                                                              |
| ordenando valores dentro de tuplas, 64                                                                                                  |
| valores e NULLS nas tuplas, 65-66 Rela√ß√µes aninhadas 1FN, 351 Rela√ß√µes compat√≠veis no tipo, 470                                         |
| Rela√ß√µes de intervalo das vari√°veis de tupla, 175-176 Rela√ß√µes de resultado, 75                                                         |
| Rela√ß√µes matem√°ticas, 59, 63 Rela√ß√µes m√∫ltiplas                                                                                         |
| consultas e ordena√ß√£o JUN√á√ÉO, 718- 719 op√ß√µes para mapeamento de                                                                        |
| especializa√ß√£o ou generaliza√ß√£o, 295 Rela√ß√µes universais, 544 Rela√ß√µes virtuais, especificando com                                      |
| comando CREATE VIEW, 90 RENOMEAR, opera√ß√£o na √°lgebra                                                                                   |
| relacional, 151-152                                                                                                                     |
| Repetidor nomeado em SQLJ, Repetindo campo ou grupos nos                                                                                |
| de arquivo, 595                                                                                                                         |
| Reposit√≥rio de informa√ß√µes ferramentas de SGBD, 43                                                                                      |
| organiza√ß√µes usando, 306 Representa√ß√£o bin√°ria do resultado                                                                             |
| Representa√ß√£o conceitual de dados, 7 Requisitos de dados, projeto de banco                                                              |
| Requisitos funcionais durante o de banco de dados, 131-132                                                                              |
| projeto                                                                                                                                 |
| Resource Description Framework 295                                                                                                      |
| Restri√ß√£o de cardinalidade m√≠nima, 143                                                                                                  |
| Restri√ß√£o de completude (ou totalidade), 166                                                                                            |
| (RDF),                                                                                                                                  |
| dados, 495                                                                                                                              |
| 461                                                                                                                                     |
| registros                                                                                                                               |
| fun√ß√£o de hashing, 410                                                                                                                  |

| de dom√≠nio, 44                                                             |
|----------------------------------------------------------------------------|
| depend√™ncias de inclus√£o, 571 em relacionamentos bin√°rios e tern√°rios, 151 |
| em relacionamentos bin√°rios, 142 especializa√ß√£o e generaliza√ß√£o, 163-165   |
| integridade, integridade referencial e chaves estrangeiras, 47-49          |
| outros tipos, 49-50                                                        |
| restri√ß√µes de chave, restri√ß√µes sobre NULL, 44                             |
| restri√ß√µes de estado , 50                                                  |
| sobre extens√µes correspondentes a uma                                      |
| hierarquia de tipos, 245                                                   |
| Restri√ß√µes baseadas em tupla, 63 baseadas na aplica√ß√£o,                    |
| Restri√ß√µes 44                                                              |
| Restri√ß√µes de chave especificando em SQL, 95-96                            |
| restri√ß√µes de integridade em                                               |
| bancos dados, 21                                                           |
| de sobre atributos de entidade, 208-209                                    |
| Restri√ß√µes sobre especializa√ß√£o, 165                                       |
| Restri√ß√µes de estado, 75 Restri√ß√µes de integridade referencial             |
| depend√™ncias de inclus√£o, 571                                              |
| especificando em SQL, 95-96 modelos de dados relacionais,                  |
| 73-74 restri√ß√µes de integridade nos bancos                                 |
| de dados, 21                                                               |
| Restri√ß√µes de integridade em bancos de dados, 20-21                        |
| esquema de banco de dados                                                  |
| relacional e, 70 no modelo de dados relacional, 73-74                      |
| restri√ß√£o de integridade de entidade, 73 Restri√ß√µes de participa√ß√£o em     |
| relacionamentos bin√°rios, 217                                              |
| Restri√ß√µes de transi√ß√£o, 75                                                |
| Restri√ß√µes de unicidade                                                    |
| especificando em SQL, 95-96                                                |
| fatores influenciando o projeto f√≠sico banco de dados, 729                 |
| de restri√ß√µes de integridade em bancos de dados, 21                        |
| sobre atributos de entidade, 208-209                                       |
| em SQL                                                                     |
| comando CREATE TABLE, 59-60                                                |
| Restri√ß√µes                                                                 |
| especificando asser√ß√µes, 87-88                                             |

| defaults de atributo, 61-62                                                                                     |
|-----------------------------------------------------------------------------------------------------------------|
| especificando restri√ß√µes de chave e integridade referencial, 62-63                                              |
| especificando, sobre tuplas usando CHECK, 63                                                                    |
| Restri√ß√µes estruturais dos relacionamentos, 140                                                                 |
| Restri√ß√µes sem√¢nticas depend√™ncias de modelo e, 572 restri√ß√µes do modelo relacional, 68 tipos de restri√ß√µes, 74 |
| Resultados de consulta consultas de recupera√ß√£o de tabelas de                                                   |
| banco de dados, 334-335                                                                                         |
| cursores para o looping sobre tuplas, 450                                                                       |
| express√µes de caminho, 252 ordena√ß√£o, 106-107                                                                   |
| RI (recupera√ß√£o de informa√ß√µes), 699 opera√ß√£o, 506                                                              |
| Rollback, 506                                                                                                   |
| em cascata (ou propaga√ß√£o de cancelamento)                                                                      |
| de transa√ß√µes, 519 ordena√ß√£o de r√≥tulo de tempo, 532                                                            |
| dados semiestruturados, 691                                                                                     |
| R√≥tulos,                                                                                                        |
| (ou ABORT),                                                                                                     |
| ROLLBACK                                                                                                        |
| Rollback                                                                                                        |

## S

| SANs (Storage Area Networks), 418                                                                                         |
|---------------------------------------------------------------------------------------------------------------------------|
| SAX (Simple API for XML), 285 SBDFs, 594                                                                                  |
| Schedules (hist√≥ricos) de transa√ß√µes, 509                                                                                 |
| SCSI (Small Computer System Interface), 389                                                                               |
| SDL (Storage Definition Language), 24                                                                                     |
| Seguran√ßa do banco de dados algoritmos de chave p√∫blica, 581 algoritmos de chave sim√©trica, 581 assinaturas digitais, 564 |
| ataques de inje√ß√£o de SQL, 577, 587 certificados digitais, 562                                                            |
| controle de acesso baseado em papel, 587                                                                                  |
| controle de acesso obrigat√≥rio, 570-575                                                                                   |
| controle de acesso, contas do usu√°rio e auditorias, 565 controle de fluxo, 564                                            |
| criptografia, 564                                                                                                         |
| desafios, 583                                                                                                             |
| medidas de controle,                                                                                                      |
| 563-564                                                                                                                   |

| Oracle Label Security, 584                                                                     |
|------------------------------------------------------------------------------------------------|
| pol√≠ticas de controle de acesso para e-commerce e a Web, 575 sensibilidade dos dados, 573, 585 |
| tipos de seguran√ßa, 562                                                                        |
| Sele√ß√£o conjuntiva, 462                                                                        |
| SELEC√ÉO, comando SQL                                                                           |
| atributos a serem recuperados, 70                                                              |
| atributos de proje√ß√£o, 100                                                                     |
| cl√°usula FROM, 64                                                                              |
| consultas de recupera√ß√£o b√°sicas em SQL, 63-70                                                 |
| forma b√°sica, 64                                                                               |
| fun√ß√µes de agrega√ß√£o,                                                                          |
| 70                                                                                             |
| SELE√á√ÉO, opera√ß√µes                                                                             |
| condi√ß√µes de sele√ß√£o disjuntivas, 463 em arquivos, 401                                         |
| fun√ß√µes de custo, 479                                                                          |
| implementando, 461-463                                                                         |
| m√©todos de pesquisa para sele√ß√£o                                                               |
| complexa, 462                                                                                  |
| m√©todos de pesquisa para sele√ß√£o                                                               |
| simples, 461                                                                                   |
| na √°lgebra relacional, 119 seletividade da condi√ß√£o, 98                                        |
| SELE√á√ÉO, operador, 97                                                                          |
| Seletividade da condi√ß√£o, 98                                                                   |
| Seletividade e estimativas de na                                                               |
| custo otimiza√ß√£o de consulta                                                                   |
| componentes de custo para execu√ß√£o consulta, 480                                               |
| consultas de m√∫ltiplas rela√ß√µes e ordena√ß√£o de JUN√á√ÉO, 484-485                                 |
| fun√ß√µes de custo para JUN√á√ÉO, 483- 484                                                         |
| fun√ß√µes de custo para SELE√á√ÉO, 481-483                                                         |
| nas                                                                                            |
| informa√ß√£o de cat√°logo usada fun√ß√µes de custo, 480                                             |
| Sem√¢ntica de atributos, 360                                                                    |
| restri√ß√µes de integridade, 13                                                                  |
| S√©ries temporais, 17                                                                           |
| Servidor de banco de dados,                                                                    |
| 28, 32, 203 Servidor de consulta (transa√ß√£o) na arquitetura cliente/servidor de duas           |
| camadas, 31                                                                                    |
| m√≥dulo componente do SGBD, 26                                                                  |
| n√≠vel do servidor na arquitetura cliente/                                                      |
| Servidores                                                                                     |

| servidor de duas camadas, 31                                                            |
|-----------------------------------------------------------------------------------------|
| programa cliente, 28 servidores de banco de dados, 19                                   |
| servidores especializados na arquitetura cliente/servidor, 30 vari√°vel PHP, 327         |
| Servidores de aplica√ß√£o                                                                 |
| bancos de dados federados e, 594                                                        |
| camada intermedi√°ria na arquitetura de tr√™s camadas, 32 m√≥dulos componentes do SGBD, 26 |
| Servidores de arquivo na arquitetura cliente/servidor, 30                               |
| Servidores de banco de dados, m√≥dulos componente do SGBD, 26-28                         |
| Servidores de correio (e-mail), 30 Servidor de impress√£o na                             |
| arquitetura cliente/servidor, 30                                                        |
| Servidores especializados na arquitetura cliente/servidor, 30                           |
| Servidores Web, 30                                                                      |
| Set null ou set default, 51                                                             |
| Unidades de disco r√≠gido, 390 SGBDDs (SGBDs distribu√≠dos) classificar os SGBDs, 32      |
| SGBDDs homog√™neos, 33                                                                   |
| SGBDF, 598 236                                                                          |
| SGBDOR, SGBD (sistema                                                                   |
| gerenciador de banco de dados) armazenando e extraindo documentos                       |
| XML, 291-292 arquitetura centralizada, 30                                               |
| arquitetura cliente/servidor de duas                                                    |
| camadas, 31 arquitetura cliente/servidor, 30-31                                         |
| backup e recupera√ß√£o, 13 cach√™ de, 460                                                  |
| cat√°logo do, 6                                                                          |
| classifica√ß√£o, 49-52                                                                    |
| ferramentas, ambientes de facilidades de comunica√ß√µes, 29                               |
| aplica√ß√£o interfaces, 13, 24                                                            |
| linguagens, 24                                                                          |
| m√≥dulo de processamento e otimiza√ß√£o de consulta, 13                                    |
| m√≥dulos componentes, 26-28                                                              |
| m√≥dulos, 10                                                                             |
| projetistas de banco de                                                                 |
| dados,                                                                                  |
| 9-10,392,490                                                                            |

| projeto de banco de dados, 323-325 quando n√£o usar um, 17-18 representa√ß√£o conceitual dos dados, 7 subsistema de seguran√ßa e autoriza√ß√£o, 12 utilit√°rios do sistema, 28-29 vantagens, 11   |
|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| SGBDs distribu√≠dos. Ver                                                                                                                                                                    |
| SGBDs centralizados, 30, 33 SGBDs de uso especial, 33                                                                                                                                      |
| SGBDDs (SGBDs distribu√≠dos)                                                                                                                                                                |
| SI (sistema de informa√ß√£o) ciclo de vida do, 202                                                                                                                                           |
| Simple API for XML (SAX), 285 Simple Object Access Protocol (SOAP), 295                                                                                                                    |
| Sistema cat√°logo, 28                                                                                                                                                                       |
| defini√ß√£o no ciclo de vida do sistema de aplica√ß√£o de banco de dados, 204 de gerenciamento de banco de                                                                                     |
| Sistema dados objeto-relacional (SGBDOR),                                                                                                                                                  |
| ciclo de vida de, 307-308 Sistemas de banco de dados ativos aplica√ß√µes em potencial, 634 exemplos de regras ativas em n√≠vel de comando no STARBURST, 632-634                               |
| gatilhos (ou triggers), 14, 76-95, 627- 635 infer√™ncia e a√ß√µes usando regras, 14 modelo generalizado, 627-631 tecnologia, 2 de banco de dados dedutivos                                    |
| Sistemas interpreta√ß√µes de regras, 657 Sistemas de banco de dados legados, 33                                                                                                              |
| Sistemas de informa√ß√µes executivas 721                                                                                                                                                     |
| (GIS), 2 Sistemas de informa√ß√µes                                                                                                                                                           |
| Ver GIS (sistemas de informa√ß√µes geogr√°ficas)                                                                                                                                              |
| Sistemas de processamento de                                                                                                                                                               |
| SGBD multiusu√°rio, 8                                                                                                                                                                       |
| 33                                                                                                                                                                                         |
| Sistema gerenciamento de banco de                                                                                                                                                          |
| dados de objeto (SGBDOO), 236                                                                                                                                                              |
| geogr√°ficas.                                                                                                                                                                               |
| de informa√ß√µes geogr√°ficas                                                                                                                                                                 |
| (EIS),                                                                                                                                                                                     |
| Sistemas                                                                                                                                                                                   |
| transa√ß√£o,                                                                                                                                                                                 |

| Sistemas monousu√°rio, 33                                                                      |
|-----------------------------------------------------------------------------------------------|
| Sistemas objeto-relacional (relacional estendido), 34                                         |
| Sistemas operacionais. Ver SOs (sistemas operacionais)                                        |
| Small Computer System Interface (SCSI), 389                                                   |
| SOAP (Simple Object Access Protocol), 295 Sobreposi√ß√£o                                        |
| Software de comunica√ß√µes, 29                                                                  |
| Software privilegiado, 12                                                                     |
| SOs (sistemas operacionais)                                                                   |
| JUN√á√ÉO EXTERNA, opera√ß√µes implementando, 479-471                                              |
| leitura/escrita em disco, 26                                                                  |
| SQL (Structured Query Language), extens√µes ODB                                                |
| encapsulamento de opera√ß√µes, 16, 237,                                                         |
| especificando relacionamentos por refer√™ncia, 252 OIDs, 239, 240, 243                         |
| SQL (Structured Query Language), recursos avan√ßados                                           |
| cl√°usula GROUP BY, 83 cl√°usula HAVING, 85                                                     |
| comando ALTER, 91-92                                                                          |
| comando CREATE comando CREATE                                                                 |
| ASSERTION, 87 TRIGGER, 76, 92 comando DROP, 71, 72                                            |
| 87,                                                                                           |
| compara√ß√µes envolvendo NULL e l√≥gica de tr√™s valores, 76-77 conjuntos expl√≠citos e renomea√ß√£o |
| atributos, 80                                                                                 |
| consultas aninhadas                                                                           |
| 79 consultas aninhadas, 92, 94 fun√ß√µes agregadas, 273                                         |
| fun√ß√µes EXISTS e NOT EXISTS, 740                                                              |
| implementa√ß√£o e atualiza√ß√£o de view, 135-137 views (vis√µes), 568                              |
| views em linha, 89                                                                            |
| correlacionadas,                                                                              |
| de                                                                                            |

| CHECK, cl√°usulas, especificando restri√ß√µes sobre tuplas usando, 63 cl√°usula WHERE n√£o especificadas, 67 comando CREATE TABLE, 59 comando DELETE, 71 comando INSERT, 70-71   |
|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| defini√ß√£o de dados, 58 √© (asterisco) para recupera√ß√£o de todos os valores de atributo das tuplas selecionadas, 67 embutindo comandos SQL em Java,                           |
| comando UPDATE, 72                                                                                                                                                          |
| combina√ß√£o de padr√£o de subcadeias e operadores aritm√©ticos, 69-70                                                                                                          |
| conceitos de esquema e cat√°logo, 58                                                                                                                                         |
| consulta de recupera√ß√£o SQL simples, 73                                                                                                                                     |
| 310 especificando restri√ß√µes de atributo defaults de atributo, 61-62 especificando restri√ß√µes de chave e                                                                    |
| e                                                                                                                                                                           |
| integridade referencial, 62-63 nomes de atributos amb√≠guos, 66                                                                                                              |
| ordena√ß√£o externa, 459 recursos objeto-relacional, 247 resultados de consulta, 270-272                                                                                      |
| tipos de dados comuns, 646 traduzindo consultas SQL para √°lgebra relacional, 459 73                                                                                         |
| UDTs (tipos definidos pelo usu√°rio),                                                                                                                                        |
| din√¢mica                                                                                                                                                                    |
| defini√ß√£o, 303 especificando consultas em tempo de                                                                                                                          |
| execu√ß√£o usando a, 309                                                                                                                                                      |
| embutida                                                                                                                                                                    |
| comunica√ß√£o entre o programa e SGBD, 306                                                                                                                                    |
| o conectando ao banco de dados, 306                                                                                                                                         |
| exemplo de programa√ß√£o, 307                                                                                                                                                 |
| lendo tuplas isoladas com, 305                                                                                                                                              |
| recuperando m√∫ltiplas tuplas com,                                                                                                                                           |
| SQLJ, 310                                                                                                                                                                   |
| t√©cnica de programa√ß√£o de banco                                                                                                                                             |
| de                                                                                                                                                                          |
| dados est√°tica, 314                                                                                                                                                         |
| t√©cnicas para programa√ß√£o de banco de                                                                                                                                       |
| 307                                                                                                                                                                         |

| dados, 303                                                                                   |
|----------------------------------------------------------------------------------------------|
| SQL, t√©cnicas de programa√ß√£o                                                                 |
| chamadas de fun√ß√£o. Ver chamadas de fun√ß√£o, programa√ß√£o de de dados com diverg√™ncia de       |
| banco imped√¢ncia, 12, 304 programa√ß√£o de banco de dados: t√©cnicas e problemas, 448-449       |
| refer√™ncias bibliogr√°ficas, 280 sequ√™ncia de intera√ß√µes, 565 SQL din√¢mica, 303, 305, 309,    |
| 310, 314                                                                                     |
| SQL embutida. Ver SQL embutida SQL/PSM (SQL/Persistent Stored Modules). Ver SQL/PSM (SQL/    |
| Persistent Stored Modules) t√©cnicas para programa√ß√£o de banco dados, 322                     |
| de                                                                                           |
| SQL/CLI (Call Level Interface) biblioteca de fun√ß√µes, 314 programa√ß√£o de banco de dados com, |
| 314                                                                                          |
| (SQL/Persistent Stored                                                                       |
| SQL/PSM Modules) m√≥dulos armazenados persistentes,                                           |
| procedimentos armazenados e fun√ß√µes, 321                                                     |
| SQLJ embutindo comandos SQL em Java, 310                                                     |
| recuperando m√∫ltiplas tuplas com, vari√°vel de                                                |
| 307 SQLCODE, comunica√ß√£o, 307                                                                |
| SQLSTATE, vari√°vel de comunica√ß√£o, 307                                                       |
| Storage Area Networks (SAN), 389                                                             |
| Storage Definition Language (SDL), 24                                                        |
| Strings                                                                                      |
| combina√ß√£o de padr√£o, 69                                                                     |
| processamento de textos,                                                                     |
| 328 Strings com aspas duplas, 328                                                            |
| Strings de texto longas em um arquivo HTML, 327                                              |
| Striping de dados em n√≠vel de bit, 416                                                       |
| de dados, RAID, 415, 416,                                                                    |
| Striping 417 Striping em n√≠vel de bloco, RAID, 416                                           |
| Sub√°rvores, 436                                                                              |
| RAID,                                                                                        |

| atributos espec√≠ficos, 172 compartilhadas, 169                            |
|---------------------------------------------------------------------------|
| definidas por predicado ou definidas por condi√ß√£o, 165 folha, 169         |
| mapeamento da especializa√ß√£o ou generaliza√ß√£o, 194 no modelo EER, 132     |
| superclasses, 162 tipos de relacionamento espec√≠ficos, 181                |
| tipos ou categorias de uni√£o, 132 Subclasses compartilhadas (heran√ßa      |
| m√∫ltipla), 256, 297 Subclasses definidas pelo usu√°rio,                    |
| 166, 181                                                                  |
| Subclasses definidas por atributo, 167 Subclasses definidas por condi√ß√£o, |
| 165                                                                       |
| Subclasses definidas por predicado (ou definidas por condi√ß√£o), 165       |
| Subconjunto do produto cartesiano, 41 Subconjuntos de atributos, 44       |
| Sublinguagem de dados, 25, 302                                            |
| de seguran√ßa e SGBD, 563                                                  |
| Subsistema autoriza√ß√£o,                                                   |
| Subtipos, 62                                                              |
| Superchaves 349 Defini√ß√£o, 349                                            |
| restri√ß√µes do modelo relacional, 96                                       |
| Superclasse/subclasse, relacionamentos 181 especializa√ß√£o e, 727          |
| generaliza√ß√£o, 257 no modelo EER, 181                                     |
| Op√ß√µes para mapeamento da especializa√ß√£o ou generaliza√ß√£o,                |
| 195 Superclasses 198                                                      |
| Supertipos, 246                                                           |
| Suposi√ß√£o de rela√ß√£o universal,                                           |
| Sistemas                                                                  |
| Ferramentas, ambientes de e                                               |
| aplica√ß√£o                                                                 |
| facilidades de comunica√ß√£o, 29-30                                         |
| no modelo EER, 242                                                        |
| 369                                                                       |

## T

| Tabelas                 |
|-------------------------|
| comando ALTER TABLE, 59 |
| comando DROP TABLE, 71  |

| em SQL, 250                                                               |
|---------------------------------------------------------------------------|
| no modelo relacional, 238 virtuais. Ver views (tabelas                    |
| virtuais), SQL                                                            |
| Tabelas derivadas, vis√µes SQL, 58                                         |
| Tabelas virtuais                                                          |
| especifica√ß√£o das, 89 views e, 88                                         |
| Tabelas virtuais. Ver views virtuais), SQL                                |
| (tabelas                                                                  |
| Tag raiz de documentos, 285 Tags HTML, 300                                |
| Taxa de transfer√™ncia em massa (btr), 395                                 |
| Taxonomias, 653                                                           |
| T√©cnica de hashing,                                                       |
| 410-414 T√©cnica de integra√ß√£o de                                          |
| view no projeto do esquema conceitual, 232 de hashing, arquivos           |
| T√©cnicas expans√£o din√¢mica de arquivo, 410- 414                           |
| hashing din√¢mico, 410 hashing extens√≠vel, 410 hashing externo, 412        |
| hashing interno, 406-408 hashing linear,410                               |
| de programa√ß√£o de banco de                                                |
| T√©cnicas dados din√¢mico                                                   |
| SQL din√¢mica, 303 SQL/CLI (Call Level                                     |
| de recupera√ß√£o de                                                         |
| Interface), 303 T√©cnicas banco de                                         |
| ARIES, algoritmo de recupera√ß√£o, 553-556 caching (buffering) de blocos de |
| disco, 544-545                                                            |
| falha catastr√≥fica, 543, 557                                              |
| logging write-ahead, 545-546                                              |
| m√∫ltiplos banco de dados, 556 pagina√ß√£o de sombra, 543,                   |
| recupera√ß√£o NO-UNDO/REDO baseada em atualiza√ß√£o                           |
| adiada, 549-550                                                           |
| rollbacks, 507 steal/no-steal e force/no-force,                           |
| t√©cnicas de atualiza√ß√£o adiadas e                                         |
| 545-546 imediatas, 544                                                    |
| Tempo de busca, 395                                                       |
| dados                                                                     |
| 552-553                                                                   |

| Tempo de resposta, 203                                                                                    |
|-----------------------------------------------------------------------------------------------------------|
| Teoria l√≥gica, 180 Terceira forma normal (3FN) decomposi√ß√£o de depend√™ncia em                             |
| preserva√ß√£o de esquemas, 374-377 preserva√ß√£o de depend√™ncia e propriedade de jun√ß√£o n√£o aditiva, 348-349  |
| ontologias, 675 219 Texto, 220 cifrado, 580. Ver tamb√©m criptografia de √¢ncora, componente de             |
| Tesauro                                                                                                   |
| Testando,                                                                                                 |
| Texto                                                                                                     |
| Texto hyperlink, 688 TIMESTAMP, tipo de dados,                                                            |
| 61 de entidade de                                                                                         |
| Tipo identifica√ß√£o (ou propriet√°rio), 144                                                                 |
| Tipos complexos especificando as de elementos complexos por meio de, 291 para objetos e literais, 239-241 |
| Tipos de conjunto, 35                                                                                     |
| Tipos de dados at√¥micos (definidos pelo usu√°rio), 259-261 conjunto de valores espec√≠fico, 123             |
| construtores. Ver construtores de                                                                         |
| tipo dom√≠nios, 39-41, 59-61 gerador de tipo, 240 hierarquias de classe. Ver                               |
| de tipo (classe)                                                                                          |
| no exemplo de banco de dados                                                                              |
| UNIVERSIDADE, 6                                                                                           |
| hierarquias PHP, 325-335                                                                                  |
| rela√ß√µes compat√≠veis com o tipo,                                                                          |
| tipos complexos, 291                                                                                      |
| tipos de entidade, 146                                                                                    |
| 470                                                                                                       |

| tipos de entidade fraca, 178                                                                                          |
|-----------------------------------------------------------------------------------------------------------------------|
| Tipos de entidade fortes, 144                                                                                         |
| Tipos de entidade regulares, 144                                                                                      |
| Tipos de entidades fracas, 63                                                                                         |
| Tipos de relacionamento espec√≠ficos, subclasses e, 163                                                                |
| Tipos de uni√£o (categorias)                                                                                           |
| mapeamento ER-para-Relacional, 189-195                                                                                |
| Topologias de rede, 590                                                                                               |
| Projeto para especializa√ß√£o,174                                                                                       |
| Transa√ß√£o ativa no processo de recupera√ß√£o, 547                                                                       |
| Transa√ß√µes comandos de controle de transa√ß√£o SQL, 73 modelo de dados relacional e, 6 multiusu√°rio, 6 programadas, 303 |
| Transa√ß√µes abortadas, tipos de transa√ß√µes, 207, 549 Transa√ß√µes confirmadas                                            |
| ponto de confirma√ß√£o, 506 problemas com a                                                                             |
| confirma√ß√£o distribu√≠da, 613                                                                                          |
| Transa√ß√µes de atualiza√ß√£o, 491 de recupera√ß√£o, 215                                                                    |
| mistas, 215                                                                                                           |
| processo de recupera√ß√£o, 614                                                                                          |
| Transa√ß√µes                                                                                                            |
| Transa√ß√µes                                                                                                            |
| Transa√ß√µes programadas, 10 Triggers                                                                                   |
| comando CREATE TABLE, criando em SQL, 111                                                                             |
| 333 especificando restri√ß√µes, 87                                                                                      |
| em discos r√≠gidos, Tuplas (linhas) 304                                                                                |
| cl√°usula WHERE n√£o 67-68-69 tuplas de hip√≥tese 384                                                                    |
| valores e NULLS nas                                                                                                   |
| Tuplas de hip√≥tese, 384                                                                                               |
| Tuplas suspensas, Tuplas, vari√°veis                                                                                   |
| apelidos em, 67                                                                                                       |
| range relations and, 175-176                                                                                          |
| 42                                                                                                                    |
| Trilhas                                                                                                               |
| 393                                                                                                                   |
| especificada                                                                                                          |
| 377-381                                                                                                               |

## U

| criando,106                                                                                                                                     |
|-------------------------------------------------------------------------------------------------------------------------------------------------|
| Em SQL, 107                                                                                                                                     |
| UML (Unified Modeling Language) diagramas de classe, 131 modelagem de objeto com, 161 nota√ß√£o para diagramas ER, 132 padr√£o de especifica√ß√£o de |
| projeto, 219 projeto de aplica√ß√£o de banco de                                                                                                   |
| dados, 220 Unified Modeling Language. Ver UML (Unified Modeling Language)                                                                       |
| UNI√ÉO, opera√ß√£o 250-251 algoritmos para, 338 em √°lgebra relacional, 488                                                                         |
| SQL, opera√ß√µes de conjunto, 68                                                                                                                  |
| UoD (Universe of Discourse), 3                                                                                                                  |
| Uso de mem√≥ria, custo de, 480                                                                                                                   |
| Usu√°rios, 3                                                                                                                                     |
| Usu√°rios finais, 10                                                                                                                             |
| Usu√°rios param√©tricos, e interfaces, 13                                                                                                         |
| Utilit√°rio de carga √© usado para carregar arquivos de dados existentes, 28                                                                      |
| Utilit√°rios de SGBD, 35                                                                                                                         |
| Utilit√°rios do sistema de banco de dados, 28-29                                                                                                 |
| Utiliza√ß√£o de espa√ßo, 218                                                                                                                       |

## V

| Valida√ß√£o, 204 de consultas,                    |
|-------------------------------------------------|
| 215                                             |
| Valores, 218 em tuplas 268                      |
| Valores (literais), 329                         |
| literais at√¥micas, 253                          |
| literais de cole√ß√£o 253                         |
| Literais estruturadas, 253 nos sistemas OO, 238 |
| tipos complexos para, 291                       |
| Valores at√¥micos 1FN e, 349                     |
| Valores componentes de tuplas, 43               |
| Valores do corpo de hash de um registro, 406    |
| Vari√°veis, 66-67 dom√≠nio, 709                   |
| Vari√°veis compartilhadas, SQL embutida, 305     |
| Vari√°veis de comunica√ß√£o, 306                   |

| Vari√°veis de dom√≠nio, 123                                                                                    |
|--------------------------------------------------------------------------------------------------------------|
| Vari√°veis de inst√¢ncia, 238                                                                                  |
| Vari√°veis de itera√ß√£o em OQL, 270                                                                            |
| Vari√°veis de liga√ß√£o (usando comandos parametrizados), t√©cnicas de prote√ß√£o contra inje√ß√£o de SQL, 577       |
| Vari√°veis do programa, 305                                                                                   |
| VDL (View Definition Language), 24                                                                           |
| Views (tabelas virtuais), SQL                                                                                |
| especificando como consultas nomeadas em OQL, 272 m√∫ltiplas views de dados, 8 projetistas de banco de dados, |
| V√≠nculo adiantado (est√°tico), 246                                                                            |
| V√≠nculo din√¢mico (adiado), 246                                                                               |
| V√≠nculo est√°tico (precoce) em, 246                                                                           |
| V√≠nculo tardio (din√¢mico), 246                                                                               |

## W

Web

| documentos de hipertexto e, 279 troca de dados pela, 279     |
|--------------------------------------------------------------|
| Web Services Description Language                            |
| (WSDL), 295                                                  |
| Web, clientes, 25                                            |
| Web, programa√ß√£o de bancos de dados. Ver PHP                 |
| Web, servidores camada intermedi√°ria, arquitetura            |
| de tr√™s camadas, 32 servidores especializados na arquitetura |
| cliente/servidor, 30                                         |
| WHERE, cl√°usula comando DELETE, 72                           |
| comando UPDATE, 72-73                                        |
| conjuntos expl√≠citos, 72                                     |
| faltando ou n√£o especificada, 102                            |
| nas consultas de recupera√ß√£o SQL, 129-130                    |
| WITH CHECK OPTION, cl√°usula,                                 |
| 91                                                           |
| (Web Services Description Language),                         |

## X

| XML (Extensible Markup Language) 279                         |
|--------------------------------------------------------------|
| dados estruturados, semiestruturados e n√£o estruturados, 300 |
| Modelo de dados hier√°rquico (√°rvore), 283-284                |
| XPath, 279                                                   |
| XQuery, 292                                                  |
| XML bem formado, 285-286                                     |
| XML, declara√ß√£o, 284                                         |
| XML no, formato nativo 300 armazenando 291-292               |
| linguagem de esquema XML, 286 SGBDs, 24                      |
| XQuery, 292 XSL (Extensible Stylesheet                       |
| Language), 279                                               |
| XSLT (Extensible Stylesheet Language Transformations), 279   |

## Elmasri ¬∑ Navathe

## Sistemas de banco de dados

6 a edi√ß√£o

Refer√™ncia acad√™mica tanto te√≥rica como pr√°tica, Sistemas de banco de dados apresenta os aspectos mais importantes n√£o apenas dos sistemas, mas tamb√©m das aplica√ß√µes de banco de dados, al√©m de diversas tecnologias relacionadas ao assunto. Atualizada, a obra aborda:

- ‚Ä¢   Conceitos fundamentais para projetar e usar os sistemas de banco de dados.
- ‚Ä¢   Fundamentos de modelagem e de projeto de banco de dados.
- ¬∑   Linguagens e modelos fornecidos pelos sistemas de gerenciamento de banco de dados.
- ‚Ä¢   T √©cnicas de implementa√ß√£o do sistema de banco de dados, com exemplos pr√°ticos.

Indicado para os cursos de ci√™ncia e engenharia da computa√ß√£o, desenvolvimento de sistemas e sistemas de informa√ß√£o, este livro √© tamb√©m bibliografi  a b√°sica para cursos de an√°lise de redes, an√°lise de sistemas e processamento de dados.



sv.pearson.com.br

A Sala Virtual oferece: para professores, apresenta√ß√µes em PowerPoint, banco de imagens, manual de solu√ß√µes (em ingl√™s); para estudantes, ap√™ndices D e E (em ingl√™s), manual de laborat√≥rio (em ingl√™s).



## (a) PROJETO\_DEP

| Projnome       |   Projnumero | Projlocal   |   Dnum | Dnome         |   Cpf_gerente | Data_inicio_gerente   |
|----------------|--------------|-------------|--------|---------------|---------------|-----------------------|
| ProdutoX       |            1 | Santo Andr√© |      5 | Pesquisa      |   33344555587 | 22-05-1988            |
| ProdutoY       |            2 | Itu         |      5 | Pesquisa      |   33344555587 | 22-05-1988            |
| ProdutoZ       |            3 | S√£o Paulo   |      5 | Pesquisa      |   33344555587 | 22-05-1988            |
| Informatiza√ß√£o |           10 | Mau√°        |      4 | Administra√ß√£o |   98765432168 | 01-01-1995            |
| Reorganiza√ß√£o  |           20 | S√£o Paulo   |      1 | Matriz        |   88866555576 | 19-06-1981            |
| Benef√≠cios     |           30 | Mau√°        |      4 | Administra√ß√£o |   98765432168 | 01-01-1995            |

## (b) LOCAL\_DEP

| Dnome         |   Dnumero |   Cpf_gerente | Data_inicio_gerente   | Dlocal      |
|---------------|-----------|---------------|-----------------------|-------------|
| Matriz        |         1 |   88866555576 | 19-06-1981            | S√£o Paulo   |
| Administra√ß√£o |         4 |   98765432168 | 01-01-1995            | Mau√°        |
| Pesquisa      |         5 |   33344555587 | 22-05-1988            | Santo Andr√© |
| Pesquisa      |         5 |   33344555587 | 22-05-1988            | Itu         |
| Pesquisa      |         5 |   33344555587 | 22-05-1988            | S√£o Paulo   |

Figura 6.7

Resultados de duas opera√ß√µes JUN√á√ÉO NATURAL. (a) PROJETO\_DEP ‚Üê PROJETO   DEP. (b) LOCAL\_DEP ÔÇ´ ‚Üê DEPARTAMENTO   LOCALIZACAO\_DEP. ÔÇ´

Se n√£o houver condi√ß√£o de jun√ß√£o, todas as combina√ß√µes de tuplas se qualificam e a JUN√á√ÉO se degenera em um PRODUTO CARTESIANO , chamado PRODUTO CRUZADO ou JUN√á√ÉO CRUZADA .

cion√°rio que √© o gerente de departamento. O resultado disso √© uma rela√ß√£o consolidada em que cada tupla cont√©m essa informa√ß√£o combinada de projeto-departamento-gerente.

Como podemos ver, uma √∫nica opera√ß√£o JOIN √© usada para combinar dados de duas rela√ß√µes de modo que a informa√ß√£o relacionada possa ser apresentada em  uma  √∫nica  tabela.  Essas  opera√ß√µes  tamb√©m  s√£o conhecidas como jun√ß√µes internas ( inner joins ), para distingui-las de uma varia√ß√£o de jun√ß√£o diferente, chamada jun√ß√µes externas ( outer joins ; ver Se√ß√£o 6.4.4). Informalmente, uma jun√ß√£o interna √© um tipo de opera√ß√£o de correspond√™ncia e combina√ß√£o definida de maneira formal como uma combina√ß√£o de PRODUTO CARTESIANO e SELE√á√ÉO . Observe que, √†s vezes, uma jun√ß√£o pode ser especificada entre uma rela√ß√£o e si mesma, conforme ilustraremos na Se√ß√£o 6.4.3. A opera√ß√£o JUN√á√ÉO NATURAL ou EQUIJUN√á√ÉO tamb√©m pode ser especificada entre m√∫ltiplas tabelas, levando a uma jun√ß√£o de n vias . Por exemplo, considere a jun√ß√£o de tr√™s vias a seguir:

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

Isso combina cada tupla de projeto com sua tupla de departamento de controle em uma √∫nica tupla, e depois combina essa tupla com uma tupla de fun-

Em  SQL,  a JUN√á√ÉO pode  ser  realizada  de  diversas maneiras. O primeiro m√©todo √© especificar as &lt;condi√ß√µes  jun√ß√£o&gt;  na  cl√°usula WHERE ,  junto  com quaisquer outras condi√ß√µes de sele√ß√£o. Isso √© muito comum, e est√° ilustrado pelas consultas C1 C1A C1B , , , C2 e C8 nas se√ß√µes 4.3.1 e 4.3.2, bem como por muitos outros exemplos de consulta nos cap√≠tulos 4 e 5. A segunda maneira √© usar uma rela√ß√£o aninhada, conforme ilustrado pelas consultas C4A e C16 na Se√ß√£o 5.1.2. Outra maneira √© utilizar o conceito de tabelas de  jun√ß√£o,  conforme  ilustrado  pelas  consultas C1A , C1B C8B , e C2A na Se√ß√£o 5.1.6. A constru√ß√£o das tabelas de jun√ß√£o foi acrescentada √† SQL2 para permitir ao usu√°rio especificar explicitamente todos os diversos tipos de jun√ß√µes, pois os outros m√©todos eram mais limitados. Isso tamb√©m permite que o usu√°rio fa√ßa a distin√ß√£o clara das condi√ß√µes de jun√ß√£o com base nas condi√ß√µes de sele√ß√£o na cl√°usula WHERE .

## 6.3.3 Um conjunto completo de opera√ß√µes da √°lgebra relacional

J√°  se  mostrou  que  o  conjunto  de  opera√ß√µes  da √°lgebra  relacional  { ùõî , ùõë , ‚à™ , ùõí ,  -, √ó }  √©  um  conjunto

completo ;  ou  seja,  qualquer  uma  das  outras  opera√ß√µes originais da √°lgebra relacional pode ser expressa como uma sequ√™ncia de opera√ß√µes desse conjunto . Por exemplo, a opera√ß√£o INTERSEC√á√ÉO pode ser expressa usando UNI√ÉO e SUBTRA√á√ÉO da seguinte forma:

<!-- formula-not-decoded -->

Embora, estritamente falando, a INTERSEC√á√ÉO n√£o seja exigida, √© inconveniente especificar essa express√£o  complexa  toda  vez  que  quisermos  especificar uma interse√ß√£o. Outro exemplo: uma opera√ß√£o JUN√á√ÉO pode ser especificada como um PRODUTO CARTESIANO seguido por uma opera√ß√£o SELE√á√ÉO , conforme discutimos:

<!-- formula-not-decoded -->

se√ß√£o.

## 6.3.4 A opera√ß√£o DIVIS√ÉO

A opera√ß√£o DIVIS√ÉO , indicada por √∑ , √© √∫til para um tipo especial de consulta que √†s vezes ocorre nas aplica√ß√µes de banco de dados. Um exemplo √© Recuperar os nomes dos funcion√°rios que trabalham em todos os projetos em que 'Jo√£o Silva' trabalha . Para expressar essa consulta usando a opera√ß√£o DIVIS√ÉO , prossiga da seguinte forma. Primeiro, recupere a lista dos n√∫meros de projeto em que 'Jo√£o Silva' trabalha na rela√ß√£o intermedi√°ria SILVA\_PNRS :

<!-- formula-not-decoded -->

De  modo  semelhante,  uma JUN√á√ÉO  NATURAL pode ser especificada como um PRODUTO CARTESIANO precedido por RENOMEAR e seguido por opera√ß√µes SELE√á√ÉO   PROJE√á√ÉO e .  Logo, as diversas opera√ß√µes JUN√á√ÉO tamb√©m n√£o  s√£o  estritamente  necess√°rias para o poder expressivo da √°lgebra relacional. No entanto, elas s√£o importantes para inclus√£o como opera√ß√µes separadas, pois s√£o convenientes de se usar e bastante utilizadas em aplica√ß√µes de banco de dados. Outras opera√ß√µes foram inseridas na √°lgebra relacional b√°sica por conveni√™ncia, em vez de necessidade. Discutimos uma delas - a opera√ß√£o DIVIS√ÉO - na pr√≥xima

Em seguida,  crie  uma  rela√ß√£o  que  inclua  uma tupla &lt; Pnr , Fcpf &gt; sempre que um funcion√°rio, cujo Cpf √© Fcpf, trabalha no projeto cujo n√∫mero √© Pnr na rela√ß√£o intermedi√°ria CPF\_PNRS :

<!-- formula-not-decoded -->

Finalmente, aplique a opera√ß√£o DIVIS√ÉO √†s duas rela√ß√µes, o que gera os n√∫meros de Cadastro de Pessoa F√≠sica dos funcion√°rios desejados:

<!-- formula-not-decoded -->

|        Fcpf |   Pnr |
|-------------|-------|
| 12345678966 |     1 |
| 12345678966 |     2 |
| 66688444476 |     3 |
| 45345345376 |     1 |
| 45345345376 |     2 |
| 33344555587 |     2 |
| 33344555587 |     3 |
| 33344555587 |    10 |
| 33344555587 |    20 |
| 99988777767 |    30 |
| 99988777767 |    10 |
| 98798798733 |    10 |
| 98798798733 |    30 |
| 98765432168 |    30 |
| 98765432168 |    20 |
| 88866555576 |    20 |



As opera√ß√µes anteriores aparecem na Figura 6.8(a).

Em geral, a opera√ß√£o DIVIS√ÉO √© aplicada √†s duas rela√ß√µes R Z ( ) √∑ S X ( ), em que os atributos de R s√£o um subconjunto dos atributos de S ; ou seja, X ‚äÜ Z . Considere que Y seja  o  conjunto de atributos de R que n√£o s√£o atributos de S ;  ou seja, Y = Z -X (e, portanto, Z = X ‚à™ Y ). O resultado da DIVIS√ÉO √© uma rela√ß√£o T Y ( )  que  inclui  uma  tupla t se  as  tuplas t R aparecerem em R com t R [ Y ] = t ,  e  com t R [ X ] = t S para cada tupla t S em S .  Isso  significa  que,  para uma tupla   aparecer no resultado t T da DIVIS√ÉO , os valores em   dever√£o aparecer em t R em combina√ß√£o com cada tupla em S . Observe que, na formula√ß√£o da opera√ß√£o DIVIS√ÉO , as tuplas na rela√ß√£o do denominador S restringem a rela√ß√£o do numerador R, selecionando aquelas tuplas no resultado que combinam com todos os valores presentes no denominador. N√£o √© necess√°rio saber quais s√£o esses valores, pois eles podem ser calculados por outra opera√ß√£o, conforme ilustrado na rela√ß√£o SILVA\_PNRS no  exemplo anterior.

A Figura 6.8(b)  ilustra  uma  opera√ß√£o DIVIS√ÉO onde X = { A }, Y = { B } e Z = { A B , }. Observe que as tuplas (valores) b 1 e b 4 aparecem em R em combina√ß√£o com todas as tr√™s tuplas em S ; √© por isso que elas aparecem na rela√ß√£o resultante T .  Todos os outros valores de B em R n√£o aparecem com todas as tuplas em  , e n√£o s√£o selecionados: S b 2 n√£o aparece com a 2 , e b 3 n√£o aparece com a 1 .

A  opera√ß√£o DIVIS√ÉO pode  ser  expressa  como uma sequ√™ncia de opera√ß√µes ùõë , √ó e - da seguinte forma:

<!-- formula-not-decoded -->

A opera√ß√£o DIVIS√ÉO √© definida por conveni√™ncia para lidar com consultas que envolvem quantifica√ß√£o universal (ver Se√ß√£o 6.6.7) ou a condi√ß√£o all . A maioria das implementa√ß√µes de SGBDR com SQL como linguagem de consulta prim√°ria n√£o implementa a divis√£o diretamente. A SQL tem um modo indireto de lidar com o tipo de consulta ilustrado anteriormente (ver Se√ß√£o 5.1.4, consultas C3A e C3B ). A Tabela 6.1 lista as diversas opera√ß√µes b√°sicas da √°lgebra relacional que discutimos.

## 6.3.5 Nota√ß√£o para √°rvores de consulta

Nesta se√ß√£o, descrevemos uma nota√ß√£o que costuma ser usada em sistemas relacionais para representar consultas internamente. A nota√ß√£o √© chamada √°rvore de consulta ou, √†s vezes, √© conhecida como √°rvore de avalia√ß√£o de consulta ou √°rvore de execu√ß√£o de consulta .  Ela  inclui  as  opera√ß√µes  da  √°lgebra  relacional

Tabela 6.1 Opera√ß√µes de √°lgebra relacional.

| OPERA√á√ÉO           | FINALIDADE                                                                                                                                                                                          | NOTA√á√ÉO                                                                                                                                         |
|--------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------|
| SELE√á√ÉO            | Seleciona todas as tuplas que satisfazem a condi√ß√£o de sele√ß√£o de uma rela√ß√£o R .                                                                                                                   | ùõî <condi√ß√£o sele√ß√£o> ( R )                                                                                                                      |
| PROJE√á√ÉO           | Produz uma nova rela√ß√£o com apenas alguns dos atributos de R , e remove tuplas duplicadas.                                                                                                          | ùõë <lista atributos> ( R )                                                                                                                       |
| JUN√á√ÉO THETA       | Produz todas as combina√ß√µes de tuplas de R 1 e R 2 que satisfazem a condi√ß√£o de jun√ß√£o.                                                                                                             | R 1 /triangleleft /triangleright <condi√ß√£o jun√ß√£o> R 2                                                                                          |
| EQUIJUN√á√ÉO         | Produz todas as combina√ß√µes de tuplas de R 1 e R 2 que satisfazem uma condi√ß√£o de jun√ß√£o apenas com compara√ß√µes de igualdade.                                                                       | R 1 /triangleleft /triangleright <condi√ß√£o jun√ß√£o> R 2 , OR R 1 /triangleleft /triangleright (<atributos jun√ß√£o 1>), (<atributos jun√ß√£o 2>) R 2 |
| JUN√á√ÉO NATURAL     | O mesmo que EQUIJOIN, exceto que atributos de jun√ß√£o de R 2 n√£o s√£o inclu√≠dos na rela√ß√£o resultante; se os atributos de jun√ß√£o tiverem os mesmos nomes, eles nem sequer precisam ser especificados. | R 1 ÔÇ´ <condi√ß√£o jun√ß√£o> R 2 , OR R 1 ÔÇ´ (<atributos jun√ß√£o 1>), (<atributos jun√ß√£o 2>) R 2 OR R 1 ÔÇ´ R 2                                          |
| UNI√ÉO              | Produz uma rela√ß√£o que inclui todas as tuplas em R 1 ou R 2 ou tanto R 1 quanto R 2 ; R 1 e R 2 precisam ser compat√≠veis na uni√£o.                                                                  | R 1 ‚à™ R 2                                                                                                                                       |
| INTERSEC√á√ÉO        | Produz uma rela√ß√£o que inclui todas as tuplas em R 1 e R 2 ; R 1 e R 2 precisam ser compat√≠veis na uni√£o.                                                                                           | R 1 ‚à© R 2                                                                                                                                       |
| DIFEREN√áA          | Produz uma rela√ß√£o que inclui todas as tuplas em R 1 que n√£o est√£o em R 2 ; R 1 e R 2 precisam ser compat√≠veis na uni√£o.                                                                            | R 1 - R 2                                                                                                                                       |
| PRODUTO CARTESIANO | Produz uma rela√ß√£o que tem os atributos de R 1 e R 2 e inclui como tuplas todas as poss√≠veis combina√ß√µes de tuplas de R 1 e R 2 .                                                                   | R 1 √ó R 2                                                                                                                                       |
| DIVIS√ÉO            | Produz uma rela√ß√£o R ( X ) que inclui todas as tuplas t [ X ] em R 1 ( Z ) que aparecem em R 1 em combina√ß√£o com toda tupla de R 2 ( Y ), onde Z = X ‚à™ Y .                                          | R 1 ( Z ) √∑ R 2 ( Y )                                                                                                                           |

em execu√ß√£o e √© usada como uma estrutura de dados poss√≠vel para a representa√ß√£o interna da consulta em um SGBDR.

Uma √°rvore de consulta √© uma estrutura de dados em √°rvore que corresponde a uma express√£o da √°lgebra relacional. Ela representa as rela√ß√µes de entrada  da  consulta  como n√≥s  folha da  √°rvore,  e  representa  as  opera√ß√µes  da  √°lgebra  relacional  como n√≥s internos.  Uma execu√ß√£o da √°rvore de consulta consiste  em  executar  uma  opera√ß√£o  de  n√≥  interno sempre que seus operandos (representados por seus n√≥s filhos) estiverem dispon√≠veis, e depois substituir esse n√≥ interno pela rela√ß√£o que resulta da execu√ß√£o da opera√ß√£o. A execu√ß√£o termina quando o n√≥ raiz √© executado e produz a rela√ß√£o de resultado para a consulta.

A  Figura  6.9  mostra  uma  √°rvore  de  consulta para a Consulta 2 (ver Se√ß√£o 4.3.1): para cada projeto localizado em 'Mau√°', liste o n√∫mero do projeto, o n√∫mero do departamento que o controla e o √∫ltimo nome, endere√ßo e data de nascimento do gerente do departamento . Essa consulta √© especificada no esquema relacional da Figura 3.5 e corresponde √† seguinte express√£o da √°lgebra relacional:

Na Figura 6.9, os tr√™s n√≥s folha P , D e F representam as tr√™s rela√ß√µes PROJETO , DEPARTAMENTO e FUNCIONARIO . As opera√ß√µes da √°lgebra relacional na  express√£o  s√£o  representadas  pelos  n√≥s  de  √°rvore  internos.  A  √°rvore  de  consulta  significa  uma  ordem de execu√ß√£o expl√≠cita no seguinte sentido: para executar C2 ,  o  n√≥  marcado  com  (1)  na  Figura  6.9 precisa iniciar a execu√ß√£o antes do n√≥ (2), pois algumas tuplas resultantes da opera√ß√£o (1) devem estar dispon√≠veis antes de podermos iniciar a execu√ß√£o da opera√ß√£o (2). De modo semelhante, o n√≥ (2) precisa come√ßar a executar e produzir resultados antes que o n√≥ (3) possa iniciar a execu√ß√£o, e assim por diante. Em geral, uma √°rvore de consulta oferece uma boa representa√ß√£o visual e compreens√£o da consulta em rela√ß√£o √†s opera√ß√µes relacionais que ela usa, e √© recomendada como um meio adicional para expressar consultas  na  √°lgebra  relacional.  Retornaremos  √†s √°rvores de consulta quando discutirmos o processamento e a otimiza√ß√£o da consulta no Cap√≠tulo 19.

## 6.4 Outras opera√ß√µes relacionais

<!-- formula-not-decoded -->

Algumas solicita√ß√µes comuns no banco de dados - que s√£o necess√°rias em aplica√ß√µes comerciais para SGBDRs - n√£o podem ser realizadas com as opera√ß√µes da √°lgebra relacional descritas nas se√ß√µes 6.1 a 6.3. Nesta se√ß√£o, definimos opera√ß√µes adicionais para expressar essas solicita√ß√µes. Essas opera√ß√µes melhoram o poder expressivo da √°lgebra relacional original.



Figura 6.9

√Årvore de consulta correspondente √† express√£o da √°lgebra relacional para C2.

## 6.4.1 Proje√ß√£o generalizada

A opera√ß√£o de proje√ß√£o generalizada estende a opera√ß√£o de proje√ß√£o, permitindo que as fun√ß√µes dos atributos sejam inclu√≠das na lista de proje√ß√£o. A forma generalizada pode ser expressa como:

<!-- formula-not-decoded -->

onde F 1 , F 2 , ..., F n s√£o fun√ß√µes sobre os atributos na rela√ß√£o R e podem envolver opera√ß√µes aritm√©ticas e valores  constantes.  Essa  opera√ß√£o  √©  √∫til  quando  se desenvolvem relat√≥rios em que os valores calculados precisam ser produzidos nas colunas de um resultado da consulta.

Como exemplo, considere a rela√ß√£o

FUNCIONARIO (Cpf, Salario, Deducao, Anos\_em\_ servico)

Um relat√≥rio pode ser exigido para mostrar

Salario l√≠quido = Salario -Deducao,

Bonus = 2.000 ÔÇ´ Anos\_em\_servico, e

Imposto = 0,25 ÔÇ´ Salario.

Ent√£o,  uma  proje√ß√£o  generalizada  combinada com a renomea√ß√£o pode ser usada da seguinte forma :

```
RELATORIO ‚Üê ùõí (Cpf, Salario_liquido, Bonus, Imposto) ( ùõë Cpf, Salario - Deducao, 2.000 ÔÇ´ Anos_em_servico, 0,25 ÔÇ´ Salario ( FUNCIONARIO )).
```

## 6.4.2 Fun√ß√µes de agrega√ß√£o e agrupamento

Outro tipo de solicita√ß√£o que pode ser expressa na √°lgebra relacional b√°sica √© especificar fun√ß√µes de agrega√ß√£o matem√°ticas sobre cole√ß√µes de valores do banco de dados. Alguns exemplos dessas fun√ß√µes incluem recuperar a m√©dia ou sal√°rio total de todos os funcion√°rios ou o n√∫mero total de tuplas de funcion√°rio. Essas fun√ß√µes s√£o usadas em consultas estat√≠sticas simples que resumem informa√ß√µes das tuplas do banco de dados. Fun√ß√µes comuns aplicadas a cole√ß√µes de valores num√©ricos s√£o SOMA M√âDIA , , M√ÅXIMO e M√çNIMO .  A  fun√ß√£o CONTA √©  usada  para contar tuplas ou valores.

funcion√°rios trabalhando no mesmo departamento. Podemos ent√£o listar cada valor de Dnr juntamente com, digamos, o sal√°rio m√©dio dos funcion√°rios no departamento, ou o n√∫mero de funcion√°rios que trabalham no departamento.

Podemos definir uma opera√ß√£o FUN√á√ÉO AGREGADA , usando o s√≠mbolo ‚Ñë (pronuncia-se F script ), 7 para especificar esses tipos de solicita√ß√µes da seguinte forma:

<!-- formula-not-decoded -->

onde &lt;atributos agrupamento&gt; √© uma lista de atributos da rela√ß√£o especificada em R , e &lt;lista fun√ß√µes&gt; √© uma lista de pares (&lt;fun√ß√£o&gt; &lt;atributo&gt;). Em cada par desse tipo, &lt;fun√ß√£o&gt; √© uma das fun√ß√µes permitidas - como SOMA M√âDIA M√ÅXIMO M√çNIMO CON-, , , , TA - e &lt;atributo&gt; √© um atributo da rela√ß√£o especificada por R . A rela√ß√£o resultante tem os atributos de agrupamento mais um atributo para cada elemento na lista de fun√ß√µes. Por exemplo, para recuperar cada n√∫mero de departamento, o n√∫mero de funcion√°rios no departamento e seu sal√°rio m√©dio, enquanto renomeia os atributos resultantes como indicado a seguir, escrevemos:

<!-- formula-not-decoded -->

O  resultado  dessa  opera√ß√£o  sobre  a  rela√ß√£o FUNCIONARIO da  Figura  3.6  √©  exibido  na  Figura 6.10(a).

No exemplo anterior, especificamos uma lista de nomes  de  atributo  -  entre  par√™nteses  na  opera√ß√£o RENOMEAR -  para  a  rela√ß√£o  resultante R .  Se  n√£o houver renomea√ß√£o, os atributos da rela√ß√£o resultante que correspondem √† lista de fun√ß√µes ser√£o a concatena√ß√£o do nome da fun√ß√£o com o nome do atributo, na forma &lt;fun√ß√£o&gt;\_&lt;atributo&gt;. 8  Por exemplo, a Figura 6.10(b) mostra o resultado da seguinte opera√ß√£o:

<!-- formula-not-decoded -->

Outro tipo comum de solicita√ß√£o envolve agrupar as tuplas em uma rela√ß√£o pelo valor de alguns de  seus  atributos  e,  depois,  aplicar  uma  fun√ß√£o  de agrega√ß√£o independentemente para cada grupo . Um exemplo  seria  agrupar  tuplas FUNCIONARIO por Dnr , de modo que cada grupo inclua as tuplas para

Se nenhum atributo de agrupamento for especificado, as fun√ß√µes s√£o aplicadas a todas as tuplas na rela√ß√£o, de modo que a rela√ß√£o resultante tenha apenas uma √∫nica tupla . Por exemplo, a Figura 6.10(c) mostra o resultado da seguinte opera√ß√£o:

<!-- formula-not-decoded -->

√â importante observar que, em geral, as duplicatas n√£o  s√£o  eliminadas quando  uma  fun√ß√£o  de

7 N√£o existe uma √∫nica nota√ß√£o combinada para especificar fun√ß√µes de agrega√ß√£o. Em alguns casos, √© usado um 'script A'.

8 Observe que estamos sugerindo uma nota√ß√£o arbitr√°ria. N√£o existe uma nota√ß√£o-padr√£o.

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

## R

|   Dnr |   Nr_de_funcionarios |   Media_sal |
|-------|----------------------|-------------|
|     5 |                    4 |       33.25 |
|     4 |                    3 |       31    |
|     1 |                    1 |       55    |

Figura 6.10



|   (c) |   Contador_cpf | Media_salario   |
|-------|----------------|-----------------|
|     8 |         35.125 |                 |

A opera√ß√£o de fun√ß√£o agregada.

agrega√ß√£o √© aplicada.  Desse  modo,  a  interpreta√ß√£o normal de fun√ß√µes como SOMA   M√âDIA e √©  calculada. 9 Vale a pena enfatizar que o resultado de aplicar uma fun√ß√£o de agrega√ß√£o √© uma rela√ß√£o, e n√£o um n√∫mero escalar - mesmo que ele tenha um √∫nico valor.  Isso  torna  a  √°lgebra  relacional  um  sistema matem√°tico fechado.

zes a pr√≥pria tabela. Por√©m, √© dif√≠cil especificar todos os supervisionados em todos os n√≠veis. Por exemplo, para especificar os Cpf s  de  todos os funcion√°rios f' supervisionados diretamente no n√≠vel um - pelo funcion√°rio f cujo  nome √© 'Jorge Brito' (ver Figura 3.6), podemos aplicar a seguinte opera√ß√£o:

## 6.4.3 Opera√ß√µes de fechamento recursivo

Outro tipo de opera√ß√£o que, em geral, n√£o pode ser especificada na √°lgebra relacional original b√°sica √© o fechamento recursivo . Essa opera√ß√£o √© aplicada a um relacionamento recursivo entre tuplas do mesmo tipo, como o relacionamento entre um funcion√°rio e um supervisor. Esse relacionamento √© descrito pela chave estrangeira Cpf\_supervisor da rela√ß√£o FUNCIONARIO nas figuras 3.5 e 3.6, e relaciona cada tupla de funcion√°rio (no papel de supervisionado) a outra tupla de funcion√°rio (no papel de supervisor). Um exemplo de opera√ß√£o recursiva √© recuperar todos os supervisionados de um funcion√°rio f em todos os n√≠veis - ou seja, todos os funcion√°rios f' supervisionados diretamente por  , f todos os funcion√°rios f' ‚Ñë supervisionados diretamente por cada funcion√°rio f' , todos os funcion√°rios f''' supervisionados diretamente por cada funcion√°rio f'' , e assim por diante.

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

Para  recuperar  todos  os  funcion√°rios  supervisionados por Brito no n√≠vel 2 - ou seja, todos os funcion√°rios f'' supervisionados  por  algum  funcion√°rio f' que √© supervisionado diretamente por Brito -, podemos aplicar outra JUN√á√ÉO ao resultado da primeira consulta, da seguinte forma:

<!-- formula-not-decoded -->

√â relativamente simples na √°lgebra relacional especificar todos os funcion√°rios supervisionados por f em um n√≠vel espec√≠fico juntando uma ou mais ve-

Para obter os dois conjuntos de funcion√°rios supervisionados nos n√≠veis 1 e 2 por 'Jorge Brito', podemos aplicar a opera√ß√£o UNI√ÉO aos dois resultados, da seguinte forma:

RESULTADO ‚Üê RESULTADO2 ‚à™ RESULTADO1

9 Em SQL, a op√ß√£o de eliminar duplicatas antes de aplicar a fun√ß√£o de agrega√ß√£o est√° dispon√≠vel ao incluir a palavra-chave DISTINCT (ver Se√ß√£o 4.4.4).

| (b)   |   Dnr |   Contador_cpf |   Media_salario |
|-------|-------|----------------|-----------------|
|       |     5 |              4 |           33.25 |
|       |     4 |              3 |           31    |
|       |     1 |              1 |           55    |

## RESULTADO1



(Supervisionado por Brito)

## SUPERVISAO (Cpf de Brito: 88866555576)

## (Cpf\_supervisor) (Cpf)

|        Cpf1 | Cpf2        |
|-------------|-------------|
| 12345678966 | 33344555587 |
| 33344555587 | 88866555576 |
| 99988777767 | 98765432168 |
| 98765432168 | 88866555576 |
| 66688444476 | 33344555587 |
| 45345345376 | 33344555587 |
| 98798798733 | 98765432168 |
| 88866555576 | null        |

## RESULTADO2

## RESULTADO



|         Cpf |
|-------------|
| 12345678966 |
| 99988777767 |
| 66688444476 |
| 45345345376 |
| 98798798733 |

(Supervisionado pelos subordinados de Brito)

## Figura 6.11

Uma consulta recursiva de dois n√≠veis.

Os resultados dessas consultas s√£o ilustrados na Figura 6.11. Embora seja poss√≠vel recuperar funcion√°rios em cada n√≠vel e depois obter sua UNI√ÉO , n√£o podemos, em geral, especificar uma consulta desse tipo como 'recuperar os supervisionados de 'Jorge Brito' em todos os n√≠veis' sem utilizar um mecanismo de looping, a menos que saibamos o n√∫mero m√°ximo de n√≠veis. 10 Uma opera√ß√£o chamada fechamento transitivo das rela√ß√µes foi proposta para calcular o relacionamento recursivo √† medida que a recurs√£o prossegue.

## 6.4.4 Opera√ß√µes OUTER JOIN (jun√ß√£o externa)

A seguir, discutimos algumas extens√µes adicionais  √†  opera√ß√£o JUN√á√ÉO que  s√£o  necess√°rias  para especificar  certos  tipos  de  consultas.  As  opera√ß√µes JUN√á√ÉO descritas anteriormente combinam com tuplas que satisfazem a condi√ß√£o de jun√ß√£o. Por exemplo,  para  uma  opera√ß√£o JUN√á√ÉO NATURAL R ÔÇ´ S , somente tuplas de R que possuem tuplas combinan-

10 O padr√£o SQL3 inclui sintaxe para fechamento recursivo.

|         Cpf |
|-------------|
| 12345678966 |
| 99988777767 |
| 66688444476 |
| 45345345376 |
| 98798798733 |
| 33344555587 |
| 98765432168 |

(RESULTADO1 ‚à™ RESULTADO2)

do em S - e vice-versa - aparecem no resultado. Logo, as tuplas sem uma tupla correspondente (ou relacionada )  s√£o  eliminadas  do  resultado  de JUN√á√ÉO .  As tuplas com valores NULL nos atributos de jun√ß√£o tamb√©m s√£o eliminadas. Esse tipo de jun√ß√£o, em que as tuplas sem correspond√™ncia s√£o eliminadas, √© conhecido como jun√ß√£o interna ( inner join ). As opera√ß√µes de jun√ß√£o que descrevemos anteriormente na Se√ß√£o 6.3 s√£o todas internas. Isso equivale √† perda de informa√ß√µes se o usu√°rio quiser que o resultado da JUN√á√ÉO inclua todas as tuplas em uma ou mais rela√ß√µes componentes.

Um conjunto de opera√ß√µes, chamadas jun√ß√µes externas ( outer joins ), foi desenvolvido para o caso em que o usu√°rio deseja manter todas as tuplas em R , ou todas em S , ou todas aquelas nas duas rela√ß√µes no resultado da JUN√á√ÉO , independentemente delas possu√≠rem ou n√£o tuplas correspondentes na outra rela√ß√£o. Isso satisfaz a necessidade de consultas em que  as  tuplas  das  duas  tabelas  devem  ser  combi-

nadas  por  linhas  correspondentes,  mas  sem  perda de quaisquer tuplas por falta de valores correspondentes. Por exemplo, suponha que queiramos uma lista de todos os nomes de funcion√°rio, bem como o nome dos departamentos que eles gerenciam, se eles  gerenciarem  um  departamento . Caso  n√£o  o fa√ßam, podemos indicar isso com um valor NULL . Podemos aplicar uma opera√ß√£o JUN√á√ÉO EXTERNA √Ä ESQUERDA ,  indicada por /triangleleft /triangleright ,  para recuperar o resultado da seguinte forma:

<!-- formula-not-decoded -->

A  opera√ß√£o JUN√á√ÉO  EXTERNA  √Ä  ESQUERDA mant√©m cada tupla na primeira rela√ß√£o, R , ou da esquerda , em R /triangleleft /triangleright S ; se nenhuma tupla correspondente for encontrada em S , ent√£o os atributos de S no resultado da jun√ß√£o s√£o preenchidos com valores NULL . O resultado dessas opera√ß√µes √© mostrado na Figura 6.12.

Uma opera√ß√£o semelhante, JUN√á√ÉO EXTERNA √Ä DIREITA , indicada por /triangleleft /triangleright , mant√©m cada tupla na segunda rela√ß√£o, S , ou da direita , no resultado de R /triangleleft /triangleright S . Uma terceira opera√ß√£o, JUN√á√ÉO EXTERNA COMPLETA , indicada por /triangleleft /triangleright , mant√©m todas as tuplas nas rela√ß√µes  da  esquerda  e  da  direita  quando  nenhuma tupla  correspondente  for  encontrada,  preenchendo-as com valores NULL conforme a necessidade. As tr√™s opera√ß√µes de jun√ß√£o externa fazem parte do padr√£o SQL2 (ver Se√ß√£o 5.1.6). Essas opera√ß√µes foram fornecidas mais tarde, como uma extens√£o da √°lgebra relacional em resposta √† necessidade t√≠pica nas aplica√ß√µes de  neg√≥cios  para  mostrar  informa√ß√µes  relacionadas de v√°rias tabelas exaustivamente. √Äs vezes, um relat√≥rio completo dos dados de v√°rias tabelas √© exigido havendo ou n√£o valores correspondentes.

## RESULTADO

| Pnome    | Minicial   | Unome   | Dnome         |
|----------|------------|---------|---------------|
| Jo√£o     | B          | Silva   | NULL          |
| Fernando | T          | Wong    | Pesquisa      |
| Alice    | J          | Zelaya  | NULL          |
| Jennifer | S          | Souza   | Administra√ß√£o |
| Ronaldo  | K          | Lima    | NULL          |
| Joice    | A          | Leite   | NULL          |
| Andr√©    | V          | Pereira | NULL          |
| Jorge    | E          | Brito   | Matriz        |

## Figura 6.12

O resultado de uma opera√ß√£o JUN√á√ÉO EXTERNA √Ä ESQUERDA.

## 6.4.5 A opera√ß√£o UNI√ÉO EXTERNA

A opera√ß√£o UNI√ÉO EXTERNA foi  desenvolvida para  fazer  a  uni√£o  de  tuplas  de  duas  rela√ß√µes  que possuem alguns atributos comuns, mas n√£o s√£o compat√≠veis na uni√£o (tipo) . Essa opera√ß√£o far√° a UNI√ÉO de  tuplas  nas  rela√ß√µes R X ( , Y )  e S X ( , Z )  que  s√£o parcialmente compat√≠veis , significando que somente alguns  de  seus  atributos,  digamos X ,  s√£o  compat√≠veis na uni√£o. Os atributos compat√≠veis na uni√£o s√£o representados apenas uma vez no resultado, e aqueles  atributos  que  n√£o  s√£o  compat√≠veis  na  uni√£o  de qualquer uma das rela√ß√µes tamb√©m s√£o mantidos na rela√ß√£o de resultado T X ( , Y Z , ). Portanto, √© o mesmo que uma JUN√á√ÉO EXTERNA COMPLETA sobre os atributos comuns.

Duas tuplas t 1 em R e t 2 em S s√£o ditas combinar se t 1 [ X ] = t 2 [ X ]. Estas ser√£o combinadas (unidas) em uma √∫nica tupla em  . As tuplas em qualquer rela√ß√£o t que  n√£o  tiverem  uma  tupla  correspondente  na  outra rela√ß√£o s√£o preenchidas com valores NULL .  Por exemplo,  uma UNI√ÉO  EXTERNA pode  ser  aplicada a duas rela√ß√µes cujos esquemas s√£o ALUNO  Nome ( , Cpf  Departamento  Orientador , , ) e PROFESSOR  Nome ( , Cpf  Departamento , , Classificacao ). As tuplas das duas rela√ß√µes s√£o combinadas com base na exist√™ncia da mesma combina√ß√£o de valores dos atributos compartilhados Nome , Cpf , Departamento .  A rela√ß√£o resultante, ALUNO\_OU\_PROFESSOR , ter√° os seguintes atributos:

ALUNO\_OU\_PROFESSOR(Nome, Cpf, Departamento, Orientador, Classificacao )

Todas as tuplas das duas rela√ß√µes s√£o inclu√≠das no resultado, mas as tuplas com a mesma combina√ß√£o  ( Nome , Cpf , Departamento )  aparecer√£o  apenas uma vez no resultado. As tuplas que aparecem apenas em ALUNO ter√£o um NULL para o atributo Classificacao , enquanto as tuplas que aparecem apenas em PROFESSOR ter√£o um NULL para o atributo Orientador . Uma tupla que existe nas duas rela√ß√µes, que representa um aluno que tamb√©m √© um professor, ter√° valores para todos os seus atributos. 11

Observe que a mesma pessoa pode ainda aparecer  duas  vezes  no  resultado.  Por  exemplo,  poder√≠amos ter um aluno formado no departamento de Matem√°tica que seja um professor no departamento de Ci√™ncia da Computa√ß√£o. Embora as duas tuplas representando essa pessoa em ALUNO e PROFESSOR tenham  os  mesmos  valores  ( Nome , Cpf ),  elas  n√£o combinar√£o no valor de Departamento ,  e,  por  isso, n√£o  ser√£o  combinadas.  Isso  porque Departamento tem  dois  significados  diferentes  em ALUNO (o  de-

11 Observe que UNI√ÉO EXTERNA √© equivalente a uma JUN√á√ÉO EXTERNA COMPLETA se os atributos de jun√ß√£o forem todos os atributos comuns das duas rela√ß√µes.

partamento onde a pessoa estuda) e PROFESSOR (o departamento onde a pessoa est√° empregada como professor). Se quis√©ssemos aplicar a UNI√ÉO EXTERNA com base apenas na mesma combina√ß√£o ( Nome Cpf , ), dever√≠amos trocar o nome do atributo Departamento em cada tabela para refletir que eles possuem significados diferentes e design√°-los como n√£o fazendo parte dos atributos compat√≠veis na uni√£o. Por exemplo, poder√≠amos renomear os atributos como DeptPrincipal em ALUNO e DeptTrabalho em PROFESSOR .

## 6.5 Exemplos de consultas na √°lgebra relacional

A seguir temos exemplos adicionais para ilustrar o uso das opera√ß√µes da √°lgebra relacional. Todos os exemplos  referem-se  ao  banco  de  dados  da  Figura 3.6. Em geral, a mesma consulta pode ser indicada de v√°rias maneiras usando as diversas opera√ß√µes. Declararemos cada consulta de uma maneira e deixaremos que o leitor apresente formula√ß√µes equivalentes.

Consulta 1. Recuperar o nome e o endere√ßo de todos os funcion√°rios que trabalham para o departamento 'Pesquisa'.

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

Como uma √∫nica express√£o em linha, esta consulta se torna:

<!-- formula-not-decoded -->

Esta consulta poderia ser especificada de outras maneiras. Por exemplo, a ordem das opera√ß√µes JUN√á√ÉO e SELE√á√ÉO poderia  ser  revertida,  ou  ent√£o  a JUN√á√ÉO poderia  ser  substitu√≠da  por  uma JUN√á√ÉO NATURAL ap√≥s renomear um dos atributos de jun√ß√£o para corresponder ao nome do outro atributo de jun√ß√£o.

Consulta  2. Para  cada  projeto  localizado  em 'Mau√°', liste o n√∫mero do projeto, o n√∫mero do departamento que o controla e o √∫ltimo nome, endere√ßo e data de nascimento do gerente do departamento.

<!-- formula-not-decoded -->

DEP\_CONTROLE ‚Üê (PROJ\_MAUA /triangleleft /triangleright Dnum = Dnumero DEPARTAMENTO)

GER\_DEP\_PROJ ‚Üê (DEP\_CONTROLE /triangleleft /triangleright Cpf\_gerente = Cpf FUNCIONARIO)

RESULTADO ‚Üê ùõë Projnumero, Dnum, Unome, Endereco, Datanasc (GER\_DEP\_PROJ)

Neste exemplo, primeiro selecionamos os projetos localizados em Mau√°, depois os juntamos a seus departamentos de controle, em seguida juntamos o resultado  com  os  gerentes  de  departamento.  Finalmente, aplicamos uma opera√ß√£o de projeto sobre os atributos desejados.

Consulta 3. Descobrir  os  nomes  dos  funcion√°rios que trabalham em todos os projetos controlados pelo departamento n√∫mero 5.

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

RESULTADO\_CPF\_FUNC ‚Üê FUNC\_PROJ PROJ\_DEP5

```
(Pnr) Projnumero Dnum = 5 (PROJETO))) (Cpf, Pnr) Fcpf, Pnr (TRABALHA_EM)) √∑
```

<!-- formula-not-decoded -->

Nesta  consulta,  primeiro  criamos  uma  tabela PROJ\_DEP5 que cont√©m os n√∫meros de projeto de todos aqueles controlados pelo departamento 5. Depois, criamos uma tabela FUNC\_PROJ que mant√©m tuplas ( Cpf , Pnr ), e aplicamos a opera√ß√£o de divis√£o. Observe que renomeamos os atributos de modo que eles sejam usados corretamente na opera√ß√£o de divis√£o. Por fim, acrescentamos  o  resultado  da  divis√£o,  que  mant√©m apenas valores Cpf , com a tabela FUNCIONARIO para recuperar os atributos desejados de FUNCIONARIO .

Consulta 4. Fazer uma lista dos n√∫meros de projeto para aqueles que envolvem um funcion√°rio cujo  √∫ltimo  nome  √©  'Silva',  seja  como  um  trabalhador ou como um gerente do departamento que controla o projeto.

<!-- formula-not-decoded -->

PROJ\_SILVA\_TRAB ‚Üê ùõë Pnr (TRABALHA\_EM   SILVA) ÔÇ´

GERENTES ‚Üê ùõë Unome, Dnumero (FUNCIONARIO /triangleleft /triangleright Cpf = Cpf\_gerente DEPARTAMENTO)

DEPS\_GERENCIADOS\_SILVA (Dnum) ‚Üê ùõë Dnumero ( ùõî Unome = 'Silva' (GERENTES))

PROJS\_SILVA\_GER(Pnr) ‚Üê ùõë Projnumero (DEPS\_GERENCIADOS\_SILVA   PROJETO) ÔÇ´

RESULTADO ‚Üê (PROJS\_SILVA\_TRAB ‚à™ PROJS\_SILVA\_GER)

Nesta  consulta,  recuperamos  os  n√∫meros  de projeto que envolvem um funcion√°rio chamado Silva como um trabalhador em PROJS\_SILVA\_TRAB .  Depois, recuperamos os n√∫meros de projeto que envolvem um funcion√°rio chamado Silva como gerente do departamento que controla o projeto em PROJS\_SIL-VA\_GER .  Por  √∫ltimo,  aplicamos  a  opera√ß√£o UNI√ÉO sobre PROJS\_SILVA\_TRAB e PROJS\_SILVA\_GER . Como uma √∫nica express√£o em linha, esta consulta torna-se:

<!-- formula-not-decoded -->

Consulta 5. Listar os nomes de todos os funcion√°rios com dois ou mais dependentes.

Estritamente falando, esta consulta n√£o pode ser feita  na √°lgebra relacional b√°sica ( original ).  Temos de usar a opera√ß√£o FUN√á√ÉO DE AGREGA√á√ÉO com a fun√ß√£o de agrega√ß√£o CONTA .  Consideramos que os dependentes do mesmo funcion√°rio t√™m valores distintos de Nome\_dependente .

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

Consulta 6. Recuperar os nomes dos funcion√°rios que n√£o possuem dependentes.

Este √© um exemplo do tipo de consulta que usa a opera√ß√£o SUBTRA√á√ÉO DIFEREN√áA DE CONJUNTO ( ).

<!-- formula-not-decoded -->

FUNCS\_COM\_DEPEND(Cpf) ‚Üê ùõë Fcpf (DEPENDENTE)

FUNCS\_SEM\_DEPEND ‚Üê (TODOS\_FUNCS -FUNCS\_COM\_DEPEND)

<!-- formula-not-decoded -->

PEND ,  e  finalmente  juntamos  isso  com FUNCIONARIO para  recuperar  os  atributos  desejados.  Como uma √∫nica express√£o em linha, esta consulta se torna:

<!-- formula-not-decoded -->

Consulta  7. Listar  os  nomes  dos  gerentes  que t√™m pelo menos um dependente.

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

GER\_COM\_DEPEND ‚Üê (GERS ‚à© FUNCS\_COM\_DEPEND)

<!-- formula-not-decoded -->

Nessa consulta, recuperamos os Cpf s dos gerentes  em GERS ,  e  os Cpf s  dos  funcion√°rios com pelo menos  um  dependente  em FUNCS\_COM\_DEPEND , depois  aplicamos  a  opera√ß√£o INTERSEC√á√ÉO para obter os Cpf s dos gerentes que t√™m pelo menos um dependente.

Conforme mencionamos anteriormente, a mesma consulta pode ser especificada de muitas maneiras diferentes na √°lgebra relacional. Em particular, as  opera√ß√µes  podem  ser  aplicadas  com  frequ√™ncia em diversas ordens. Al√©m disso, algumas delas podem ser usadas para substituir outras. Por exemplo, a opera√ß√£o INTERSEC√á√ÉO em C7 pode ser substitu√≠da  por  uma JUN√á√ÉO  NATURAL .  Como  exerc√≠cio, tente  fazer  cada  um  desses  exemplos  de  consulta usando  diferentes  opera√ß√µes. 12   Mostramos  como escrever consultas como express√µes isoladas da √°lgebra relacional para as consultas C1 C4 , e C6 . Tente  escrever as consultas restantes como express√µes isoladas. Nos cap√≠tulos 4 e 5 e nas se√ß√µes 6.6 e 6.7, mostramos como essas consultas s√£o escritas em outras linguagens relacionais.

## 6.6 O c√°lculo relacional de tupla

Primeiro, recuperamos uma rela√ß√£o com todos os Cpf s de funcion√°rios em TODOS\_FUNCS . Depois, criamos  uma  tabela  com  os Cpf s  dos  funcion√°rios que possuem pelo menos um dependente em FUNCS\_ COM\_DEPEND .  Ent√£o,  aplicamos  a  opera√ß√£o DIFEREN√áA  DE  CONJUNTO para  recuperar  os Cpf s  de funcion√°rios sem dependentes em FUNCS\_SEM\_DE-

Nesta  e  na  pr√≥xima  se√ß√£o,  apresentamos  outra  linguagem  de  consulta  formal  para  o  modelo relacional,  chamada c√°lculo  relacional .  Esta  se√ß√£o apresenta a linguagem conhecida como c√°lculo relacional de tupla , e a Se√ß√£o 6.7 apresenta uma varia√ß√£o chamada c√°lculo relacional de dom√≠nio . Nas duas  varia√ß√µes  do  c√°lculo  relacional,  escrevemos uma express√£o declarativa para especificar uma solicita√ß√£o de recupera√ß√£o; logo, n√£o existe descri√ß√£o

12 Quando as consultas s√£o otimizadas (ver Cap√≠tulo 19), o sistema escolher√° uma sequ√™ncia de opera√ß√µes em particular que corresponde a uma estrat√©gia de execu√ß√£o que pode ser executada de modo eficiente.

de como, ou em que ordem , avaliar uma consulta. Uma express√£o de c√°lculo especifica o que deve ser recuperado em vez de como recuper√°-lo. Portanto, o c√°lculo relacional √© considerado uma linguagem n√£o  procedimental .  Isso  difere  da  √°lgebra  relacional, na qual precisamos escrever uma sequ√™ncia de opera√ß√µes para  especificar  uma  solicita√ß√£o  de  recupera√ß√£o em uma ordem particular da  aplica√ß√£o das opera√ß√µes. Assim, ela pode ser considerada um modo procedimental de  indicar  uma  consulta.  √â poss√≠vel aninhar opera√ß√µes da √°lgebra para formar uma √∫nica express√£o, por√©m, certa ordem entre as opera√ß√µes √© sempre explicitamente especificada em uma  express√£o  da  √°lgebra  relacional.  Essa  ordem tamb√©m influencia a estrat√©gia para avaliar a consulta. Uma express√£o de c√°lculo pode ser escrita de maneiras diferentes, mas o modo como ela √© escrita n√£o tem rela√ß√£o com o modo como uma consulta deve ser avaliada.

Foi  mostrado  que  qualquer  recupera√ß√£o  que possa ser especificada na √°lgebra relacional b√°sica tamb√©m pode ser especificada no c√°lculo relacional e  vice-versa.  Em  outras  palavras,  o poder  expressivo das linguagens √© id√™ntico .  Isso  levou √† defini√ß√£o do conceito de uma linguagem relacionalmente completa . Uma linguagem de consulta relacional L √©  considerada relacionalmente  completa se  pudermos expressar em L qualquer consulta que possa ser expressa no c√°lculo relacional. A integralidade relacional se tornou uma base importante para comparar o poder expressivo das linguagens de consulta de alto n√≠vel. No entanto, como vimos na Se√ß√£o 6.4, certas consultas frequentemente exigidas nas aplica√ß√µes de banco de dados n√£o podem ser expressas na √°lgebra ou no c√°lculo relacional b√°sico. A maioria das linguagens de consulta relacional √© relacionalmente completa, mas possui mais poder expressivo do que a √°lgebra relacional ou o c√°lculo relacional, por  causa  de  opera√ß√µes  adicionais  como  fun√ß√µes de  agrega√ß√£o,  agrupamento  e  ordena√ß√£o.  Conforme  mencionamos  na  introdu√ß√£o  deste  cap√≠tulo,  o c√°lculo  relacional  √©  importante  por  dois  motivos. Primeiro,  ele  tem  uma  base  firme  na  l√≥gica  matem√°tica.  Segundo,  a  linguagem  de  consulta  padr√£o (SQL) para SGBDRs tem alguns de seus alicerces no c√°lculo relacional de tupla.

Nossos exemplos se referem ao banco de dados mostrado nas figuras 3.6 e 3.7. Usaremos as mesmas consultas da Se√ß√£o 6.5. As se√ß√µes 6.6.6, 6.6.7 e 6.6.8 discutem o tratamento com quantificadores universais e as quest√µes de seguran√ßa de express√£o. (Os alunos interessados em uma introdu√ß√£o b√°sica ao c√°lculo relacional de tupla podem pular essas se√ß√µes.)

## 6.6.1 Vari√°veis de tupla e rela√ß√µes de intervalo

O c√°lculo relacional de tupla √© baseado na especifica√ß√£o de uma s√©rie de vari√°veis de tupla . Cada vari√°vel  de  tupla  costuma percorrer determinada rela√ß√£o do banco de dados, significando que pode tomar como seu valor qualquer tupla individual dessa rela√ß√£o. Um c√°lculo relacional de tupla simples tem a forma:

## {    COND( )} t | t

onde   √© uma vari√°vel de tupla e t COND ( ) √© uma ext press√£o condicional (booleana) que envolve   e que √© t avaliada como TRUE ou FALSE para diferentes atribui√ß√µes de tuplas √† vari√°vel  . O resultado dessa cont sulta √© o conjunto de todas as tuplas   que avaliam t COND ( ) como t TRUE . Diz-se que essas tuplas satisfazem COND ( ). Por exemplo, para encontrar todos os t funcion√°rios cujo sal√°rio √© maior que R$50.000,00, podemos escrever a seguinte express√£o de c√°lculo de tupla:

## {    FUNCIONARIO( ) t | t AND t .Salario &gt; 50.000}

A condi√ß√£o FUNCIONARIO ( ) especifica que a t rela√ß√£o de intervalo da vari√°vel de tupla t √© FUNCIONARIO . Cada tupla de FUNCIONARIO t que satisfaz a condi√ß√£o  . t Salario &gt;50.000 ser√° recuperada. Observe que t .Salario referencia o atributo Salario da vari√°vel de tupla  . Tal nota√ß√£o √© semelhante ao modo como t os nomes de atributo s√£o qualificados com nomes de rela√ß√£o ou apelidos em SQL, como vimos no Cap√≠tulo 4. Na nota√ß√£o do Cap√≠tulo 3,  . t Salario √© o mesmo que escrever  [ t Salario ].

A consulta anterior recupera todos os valores de atributo para cada tupla   de t FUNCIONARIO selecionada. Para recuperar apenas alguns dos atributos digamos, o nome e o sobrenome -, escrevemos:

{ .Pnome,  .Unome   FUNCIONARIO( ) t t | t AND t .Salario &gt; 50.000}

Informalmente, precisamos especificar a seguinte informa√ß√£o em uma express√£o de c√°lculo relacional de tupla:

- ¬Ñ Para cada vari√°vel de tupla  , a t rela√ß√£o de intervalo R de t . Esse valor √© especificado por uma condi√ß√£o na forma R t ( ). Se n√£o especificarmos uma rela√ß√£o de intervalo, ent√£o a vari√°vel   oscilar√° por todas as tuplas poss√≠veis t 'no universo', pois ela n√£o √© restrita a nenhuma rela√ß√£o isolada.
- ¬Ñ Uma condi√ß√£o para selecionar combina√ß√µes de tuplas em particular. √Ä medida que as va-

- ri√°veis de tupla oscilam em suas respectivas rela√ß√µes de intervalo, a condi√ß√£o √© avaliada em cada combina√ß√£o poss√≠vel de tuplas, a fim de identificar as combina√ß√µes selecionadas para as quais a condi√ß√£o √© avaliada como TRUE .
- ¬Ñ Um conjunto de atributos a serem recuperados, os atributos solicitados . Os valores desses atributos s√£o recuperados para cada combina√ß√£o de tuplas selecionada.

Antes de discutirmos a sintaxe formal do c√°lculo relacional de tupla, considere outra consulta.

Consulta 0. Recuperar a data de nascimento e o endere√ßo do funcion√°rio (ou funcion√°rios) cujo nome √© Jo√£o B. Silva .

C0: { t. Datanasc, t. Endereco | FUNCIONARIO( ) t AND t. Pnome = 'Jo√£o' AND t. Minicial = 'B' AND t. Unome = 'Silva'}

No c√°lculo relacional de tupla, primeiro especificamos os atributos solicitados  . t Datanasc e t . Endereco para cada tupla   selecionada. Depois, especificamos t a condi√ß√£o para selecionar uma tupla ap√≥s a barra ( ) - a saber, que   seja uma tupla da rela√ß√£o | t FUNCIONARIO cujos valores de atributo Pnome Minicial , e Unome s√£o 'Jo√£o', 'B' e 'Silva', respectivamente.

## 6.6.2 Express√µes e f√≥rmulas no c√°lculo relacional de tupla

Uma express√£o geral do c√°lculo relacional de tupla tem a forma

<!-- formula-not-decoded -->

onde t 1 , t 2 , ..., t n , t n +1 , ..., t n m + s√£o vari√°veis de tupla, cada A i √©  um atributo da rela√ß√£o em que t i varia  e COND √© uma condi√ß√£o ou f√≥rmula 13 do c√°lculo relacional de tupla. Uma f√≥rmula √© composta de √°tomos de c√°lculo de predicado, que podem ser um dos seguintes:

- 1. Um √°tomo da forma R t ( i ), onde R √© um nome de rela√ß√£o e t i √©  uma  vari√°vel  de  tupla.  Esse √°tomo identifica o intervalo da vari√°vel de tupla t i como a rela√ß√£o cujo nome √© R . Ele √© avaliado como TRUE se t i for uma tupla na rela√ß√£o R , e como FALSE em caso contr√°rio.
- A √© um atributo da rela√ß√£o em que t i varia, e B √© um atributo da rela√ß√£o em que t j varia.
- 3. Um √°tomo da forma t i . A op c ou c op t j . B , onde op √© um dos operadores de compara√ß√£o no conjunto { =, &lt;, ‚â§, &gt;, ‚â•, ‚â† }, t i e t j s√£o vari√°veis de tupla, A √© um atributo da rela√ß√£o sobre a qual t i varia, B √© um atributo da rela√ß√£o em que t j varia e c √© um valor constante.

Cada um dos √°tomos anteriores √© avaliado como TRUE ou FALSE para uma combina√ß√£o espec√≠fica de tuplas, o que √© chamado de valor verdade do √°tomo. Em geral, uma vari√°vel de tupla   oscila em todas as t tuplas poss√≠veis no universo . Para √°tomos da forma R t ( ), se   for atribu√≠do a uma tupla que √© um t membro da rela√ß√£o especificada R , o √°tomo √© TRUE ; caso contr√°rio, ele √© FALSE . Em √°tomos dos tipos 2 e 3, se as vari√°veis de tupla forem atribu√≠das a tuplas de modo que os valores dos atributos especificados delas satisfa√ßam a condi√ß√£o, ent√£o o √°tomo √© TRUE .

Uma f√≥rmula (condi√ß√£o  booleana)  √©  composta de um ou mais √°tomos conectados por meio dos operadores l√≥gicos AND OR , e NOT e √© definida recursivamente pelas regras 1 e 2 da seguinte forma:

- ¬Ñ Regra 1 : todo √°tomo √© uma f√≥rmula.
- ¬Ñ Regra  2 :  se F 1 e F 2 s√£o  f√≥rmulas,  ent√£o  o mesmo ocorre para ( F 1 AND F 2 ), ( F 1 OR F 2 ), NOT ( F 1 ) e NOT ( F 2 ). Os valores verdade dessas f√≥rmulas s√£o derivados de suas f√≥rmulas componentes F 1 e F 2 , como se segue:
- a. ( F 1 AND F 2 )  √© TRUE se  tanto F 1 quanto F 2 forem TRUE ; caso contr√°rio, √© FALSE .
- b. ( F 1 OR F 2 ) √© FALSE se tanto F 1 quanto F 2 forem FALSE ; caso contr√°rio, √© TRUE .
- c. NOT ( F 1 ) √© TRUE se F 1 for FALSE ; √© FALSE se F 1 for TRUE .
- d. NOT ( F 2 ) √© TRUE se F 2 for FALSE ; √© FALSE se F 2 for TRUE .

## 6.6.3 Os quantificadores existenciais e universais

- 2. Um √°tomo da forma  . t i A op t j . B , onde op √© um dos  operadores  de  compara√ß√£o  no  conjunto { =, &lt;, ‚â§, &gt;, ‚â•, ‚â† }, t i e t j s√£o vari√°veis de tupla,

Al√©m disso, dois s√≠mbolos especiais, chamados quantificadores ,  podem  aparecem  nas  f√≥rmulas:  o quantificador  universal ( ‚àÄ )  e  o quantificador  existencial ( ‚àÉ ).  Os valores verdade para f√≥rmulas com quantificadores s√£o descritos nas regras 3 e 4 a seguir. Primeiro, definir os conceitos de vari√°veis de tupla livre e ligada em uma f√≥rmula. Informalmente, uma vari√°vel de tupla   √© ligada se for quantifit cada, significando que ela aparece em uma cl√°usula

13 Tamb√©m chamada de f√≥rmula bem formada , ou WFF  well-formed formula ( ) em l√≥gica matem√°tica.

( ‚àÉ t ) ou ( ‚àÄ t ); caso contr√°rio, ela √© livre. De maneira formal,  definimos  uma  vari√°vel  de  tupla  em  uma f√≥rmula como livre ou ligada de acordo com as seguintes regras:

- ¬Ñ Uma ocorr√™ncia de uma vari√°vel de tupla em uma f√≥rmula F que √© um √°tomo √© livre em F .
- ¬Ñ Uma ocorr√™ncia de uma vari√°vel de tupla   √© t livre ou vinculada em uma f√≥rmula composta de conectivos l√≥gicos - ( F 1 AND F 2 ), ( F 1 OR F 2 ), NOT ( F 1 )  e NOT ( F 2 )  - dependendo dela ser livre ou ligada em F 1 ou F 2 (se ocorrer em uma  delas).  Observe  que,  em  uma  f√≥rmula com a forma F = ( F 1 AND F 2 ) ou F = ( F 1 OR F 2 ), uma vari√°vel de tupla pode ser livre em F 1 e ligada em F 2 , ou vice-versa. Nesse caso, uma ocorr√™ncia da vari√°vel de tupla √© ligada e a outra √© livre em F .
- ¬Ñ Todas as ocorr√™ncias livres de  uma vari√°vel de tupla t em F s√£o ligadas em uma f√≥rmula F' da  forma F' = ‚àÉ ( t )( F )  ou F' = ‚àÄ ( t )( F ). A vari√°vel de tupla √© ligada ao quantificador especificado em F '. Por exemplo, considere as seguintes f√≥rmulas:

F 1 : d. Dnome = 'Pesquisa'

F 2 : ( ‚àÉ t )( d. Dnumero = t. Dnr )

- F 3 : ( ‚àÄ d )( d. Cpf\_gerente = '33344555587')

A vari√°vel de tupla d √© livre em F 1 e F 2 , embora seja ligada ao quantificador ( ‚àÄ ) em F 3 . A vari√°vel   √© t ligada ao quantificador ( ‚àÉ ) em F 2 .

Agora,  podemos  dar  as  regras  3  e  4  para  a defini√ß√£o de uma f√≥rmula que iniciamos anteriormente:

- ¬Ñ Regra 3 : se F √© uma f√≥rmula, ent√£o o mesmo vale para ( ‚àÉ t )( F ), onde   √© uma vari√°vel de tut pla. A f√≥rmula ( ‚àÉ t )( F ) √© TRUE se a f√≥rmula F √© avaliada como TRUE para alguma (pelo menos uma) tupla atribu√≠da a ocorr√™ncias livres de t em F ; caso contr√°rio, ( ‚àÉ t )( F ) √© FALSE .
- ¬Ñ Regra 4 : se F √© uma f√≥rmula, ent√£o o mesmo vale  para  ( ‚àÄ t )( F ),  onde t √©  uma  vari√°vel  de tupla. A f√≥rmula ( ‚àÄ t )( F ) √© TRUE se a f√≥rmula F √© avaliada como TRUE para cada tupla (no universo) atribu√≠da a ocorr√™ncias livres de t em F ; caso contr√°rio, ( ‚àÄ t )( F ) √© FALSE .

O quantificador ( ‚àÉ ) √© chamado de quantificador existencial  porque  uma  f√≥rmula  ( ‚àÉ t )( F )  √© TRUE se existir alguma tupla que torne F TRUE . Para o quantificador universal, ( ‚àÄ t )( F ) √© TRUE se cada tupla poss√≠vel  que  pode ser atribu√≠da a ocorr√™ncias livres de t em F for  substitu√≠da por t ,  e F √© TRUE para cada substitui√ß√£o desse tipo . Ele √© chamado quantificador universal ou para cada porque cada tupla no universo de tuplas precisa tornar F TRUE para tornar a f√≥rmula quantificada TRUE .

## 6.6.4 Exemplo de consultas no c√°lculo relacional de tupla

Usaremos algumas das mesmas consultas da Se√ß√£o 6.5 para dar uma ideia de como elas s√£o especificadas na √°lgebra relacional e no c√°lculo relacional. Observe  que  algumas  consultas  s√£o  mais  f√°ceis  de especificar  na  √°lgebra  relacional  do  que  no  c√°lculo relacional, e vice-versa.

Consulta 1. Listar o nome e o endere√ßo de todos os funcion√°rios que trabalham para o departamento 'Pesquisa'.

C1: { t. Pnome, t. Unome, t. Endereco | FUNCIONARIO( ) t AND ( ‚àÉ d )(DEPARTAMENTO( d ) AND d. Dnome='Pesquisa' AND d. Dnumero = t. Dnr)}

As √∫nicas vari√°veis de tupla livres em uma express√£o de c√°lculo relacional de tupla devem ser aquelas que aparecem √† esquerda da barra (|). Em C1 , t √© a √∫nica vari√°vel livre; depois, ela √© ligada sucessivamente a cada tupla. Se uma tupla satisfaz as condi√ß√µes especificadas ap√≥s a barra em C1 ,  os atributos Pnome  Unome , e Endereco s√£o recuperados para cada tupla desse tipo. As condi√ß√µes FUNCIONARIO ( ) t e DEPARTAMENTO ( d )  especificam as rela√ß√µes de intervalo para   e t d . A condi√ß√£o d . Dnome = 'Pesquisa' √© uma condi√ß√£o de sele√ß√£o e corresponde a uma opera√ß√£o SELE√á√ÉO na √°lgebra relacional, ao passo que a condi√ß√£o d . Dnumero = t . Dnr √© uma condi√ß√£o de jun√ß√£o e semelhante em finalidade √† opera√ß√£o JUN√á√ÉO INTERNA (ver Se√ß√£o 6.3).

Consulta 2. Para cada projeto localizado em 'Mau√°', listar o n√∫mero do projeto, o n√∫mero do departamento de controle e o sobrenome, data de nascimento e endere√ßo do gerente do departamento.

C2: { p .Projnumero, p. Dnum, g. Unome, g. Datanasc, g. Endereco | PROJETO(  ) p AND FUNCIONARIO( g ) AND p. Projlocalizacao = 'Mau√°' AND (( ‚àÉ d ) (DEPARTAMENTO( d ) AND p. Dnum = d. Dnumero AND d. Cpf\_gerente = g. Cpf))}

Em C2 , existem duas vari√°veis de tupla livres, p e g . A vari√°vel de tupla d √© ligada ao quantificador existencial. A condi√ß√£o de consulta √© avaliada para cada combina√ß√£o de tuplas atribu√≠das a p e g ,  e  de todas as combina√ß√µes poss√≠veis de tuplas √†s quais p e g est√£o ligadas, somente as combina√ß√µes que satisfazem a condi√ß√£o s√£o selecionadas.

Diversas  vari√°veis  de  tupla  em  uma  consulta podem oscilar na mesma rela√ß√£o. Por exemplo, para especificar C8 - para cada funcion√°rio,  recupere  o nome e √∫ltimo nome do funcion√°rio e o nome e sobrenome de seu supervisor imediato -, determinamos duas vari√°veis de tupla f e s que percorrem a rela√ß√£o FUNCIONARIO :

C8: { f. Pnome, f. Unome, s. Pnome, s. Unome | FUNCIONARIO( ) f AND FUNCIONARIO( ) s AND f. Cpf\_supervisor = s.Cpf}

Consulta 3'. Listar o nome do funcion√°rio que trabalha em algum projeto controlado pelo departamento n√∫mero 5. Essa √© uma varia√ß√£o de C3 em que todos √©  mudado para algum .  Neste caso, precisamos de duas condi√ß√µes de jun√ß√£o e dois quantificadores existenciais.

C0': { f. Unome, f. Pnome | FUNCIONARIO( ) f AND (( ‚àÉ p )( ‚àÉ t )(PROJETO( p ) AND TRABALHA\_ EM( ) t AND p .Dnum = 5 AND t .Fcpf = f. Cpf AND p. Projnumero = t. Pnr))}

Consulta 4. Fazer uma lista dos n√∫meros de projeto  que  envolvem um funcion√°rio cujo √∫ltimo nome  √©  'Silva',  seja  como  um  trabalhador  ou como um gerente do departamento de controle para o projeto.

C4: { p. Projnumero | PROJETO(  ) p AND ((( ‚àÉ f )( ‚àÉ t ) (FUNCIONARIO( ) f AND TRABALHA\_ EM( ) t AND t .Pnr = p. Projnumero AND f. Unome = 'Silva' AND f. Cpf = t. Fcpf))

OR

( ( ‚àÉ g )( ‚àÉ d )(FUNCIONARIO( g ) AND DEPARTAMENTO( ) d AND p .Dnum = d. Dnumero AND d. Cpf\_gerente = g. Cpf AND g. Unome = 'Silva')))}

Compare isso com a vers√£o da √°lgebra relacional dessa consulta na Se√ß√£o 6.5. A opera√ß√£o UNI√ÉO na √°lgebra relacional normalmente pode ser substitu√≠da por um conectivo OR no c√°lculo relacional.

## 6.6.5 Nota√ß√£o para grafos de consulta

Nesta  se√ß√£o,  descrevemos  uma  nota√ß√£o  que  foi proposta para representar as consultas do c√°lculo relacional  que  n√£o  envolvem  quantifica√ß√£o  complexa em uma forma gr√°fica. Esses tipos de consultas s√£o conhecidos  como consultas  sele√ß√£o-proje√ß√£o-jun√ß√£o , pois  envolvem  essas  tr√™s  opera√ß√µes  da  √°lgebra  relacional. A nota√ß√£o pode ser expandida para consultas mais gerais, mas n√£o vamos discutir essas extens√µes aqui.  Essa  representa√ß√£o  gr√°fica  de  uma  consulta  √© chamada de grafo de consulta . A Figura 6.13 mostra o grafo de consulta para C2 . As rela√ß√µes na consulta s√£o representadas por n√≥s de rela√ß√£o , que aparecem como c√≠rculos  isolados.  Valores  constantes,  normalmente das condi√ß√µes de sele√ß√£o de consulta, s√£o representados por n√≥s de constante , que aparecem como c√≠rculos ou ovais duplas. As condi√ß√µes de sele√ß√£o e jun√ß√£o s√£o representadas pelas arestas do grafo (as linhas que conectam os n√≥s), como mostra a Figura 6.13. Finalmente, os atributos a serem recuperados de cada rela√ß√£o s√£o exibidos entre colchetes acima de cada uma delas.

A representa√ß√£o do grafo de consulta n√£o indica uma ordem em particular para especificar quais opera√ß√µes realizar primeiro e, portanto, √© uma representa√ß√£o mais neutra de uma consulta sele√ß√£o-proje√ß√£o-jun√ß√£o do que a representa√ß√£o na √°rvore de consulta (ver Se√ß√£o 6.3.5), onde a ordem de execu√ß√£o √© especificada de maneira impl√≠cita. Existe apenas um grafo de consulta correspondente a cada consulta. Embora algumas t√©cnicas de otimiza√ß√£o de consulta fossem baseadas em grafos de consulta, agora as √°rvores de consulta s√£o prefer√≠veis porque, na pr√°tica, o otimizador de  consulta  precisa  mostrar  a  ordem  das  opera√ß√µes para a execu√ß√£o da consulta, o que n√£o √© poss√≠vel nos grafos de consulta.



Na pr√≥xima se√ß√£o, discutiremos o relacionamento entre os quantificadores universais e existenciais e mostraremos como um pode ser transformado no outro.

## 6.6.6 ransformando os quantificadores T universais e existenciais

Agora,  vamos  apresentar  algumas  transforma√ß√µes  bem  conhecidas  da  l√≥gica  matem√°tica  que  se relacionam aos quantificadores universais e existenciais.  √â  poss√≠vel  transformar  um  quantificador universal em um quantificador existencial, e vice-versa, para obter uma express√£o equivalente. Uma transforma√ß√£o geral pode ser descrita informalmente da seguinte forma: transformar um tipo de quantificador no outro com a nega√ß√£o (precedida por NOT ); AND e OR substituem  um  ao  outro;  uma  f√≥rmula  negada torna-se n√£o negada; e uma f√≥rmula n√£o negada torna-se negada. Alguns casos especiais dessa transforma√ß√£o podem ser declarados da seguinte forma, onde o s√≠mbolo ‚â° significa equivale a:

( ‚àÄ x ) ( P x ( )) ‚â° NOT ( ‚àÉ x ) ( NOT ( P x (

( ‚àÉ x ) ( P x ( )) ‚â° NOT ( ‚àÄ x ) ( NOT ( P x (

( ‚àÄ x ) ( P x ( ) AND Qx ( )) ‚â° NOT ( ‚àÉ x ) ( NOT ( P x ( )) NOT ( Qx ( )))

( ‚àÄ x ) ( P x ( ) OR Qx ( )) ‚â° NOT ( ‚àÉ x ) ( NOT ( P x ( )) NOT ( Qx ( )))

( ‚àÉ x ) ( P x ( ) OR Qx ( )) ‚â° NOT ( ‚àÄ x ) ( NOT ( P x ( )) NOT ( Qx ( )))

( ‚àÉ x ) ( P x ( ) AND Qx ( )) ‚â° NOT ( ‚àÄ x ) ( NOT ( P x ( )) NOT ( Qx ( )))

```
))) ))) OR AND AND OR
```

Observe tamb√©m que o seguinte √© TRUE , onde o s√≠mbolo ‚áí significa implica :

```
( ‚àÄ x )( P x ( )) ‚áí ‚àÉ ( x )( P x ( )) NOT ( ‚àÉ x )( P x ( )) ‚áí NOT ( ‚àÄ x )( P x ( ))
```

## 6.6.7 Usando o quantificador universal nas consultas

Sempre que usamos um quantificador universal, √© prudente seguir algumas regras para garantir que nossa express√£o fa√ßa sentido. Discutimos essas regras com rela√ß√£o √† consulta C3 .

Consulta  3. Listar  os  nomes  dos  funcion√°rios que  trabalham  em todos os  projetos  controlados pelo departamento n√∫mero 5. Um modo de especificar essa consulta √© usar o quantificador universal, conforme mostrado:

C3: { .Unome,  .Pnome   FUNCIONARIO( ) f f | f AND (( ‚àÄ p )( NOT (PROJETO( p )) OR NOT ( x .Dnum = 5) OR (( ‚àÉ t )(TRABALHA\_EM( ) t AND .Fcpf t = f .Cpf AND p .Projnumero = t .Pnr))))}

Podemos desmembrar C3 em seus componentes b√°sicos como se segue:

```
C3: { .Unome,  .Pnome   FUNCIONARIO( ) f f | f AND F '} F' = ‚àÄ (( p )( NOT (PROJETO( p )) OR F 1 )) F 1 = NOT ( p .Dnum = 5) OR F 2 F 2 = ‚àÉ (( t )(TRABALHA_EM( ) t AND t .Fcpf = f .Cpf AND p .Projnumero = t .Pnr))
```

Queremos garantir que um funcion√°rio selecionado   trabalha em f todos os projetos controlados pelo departamento 5, mas a defini√ß√£o de quantificador universal diz que, para tornar a f√≥rmula quantificada TRUE , a f√≥rmula interna precisa ser TRUE para todas as tuplas no universo . O truque √© excluir da quantifica√ß√£o universal todas as tuplas em que n√£o estamos interessados, tornando a condi√ß√£o TRUE para todas essas tuplas . Isso √©  necess√°rio  porque  uma  vari√°vel  de  tupla  universalmente quantificada, como p em C3 , precisa ser avaliada como TRUE para cada tupla poss√≠vel atribu√≠da a ela, para tornar a f√≥rmula quantificada TRUE .

As primeiras tuplas a excluir (fazendo que sejam avaliadas automaticamente como TRUE ) s√£o aquelas que n√£o est√£o na rela√ß√£o R de interesse. Em C3 , o uso da express√£o NOT ( PROJETO ( p )) na f√≥rmula quantificada universalmente avalia como TRUE todas as tuplas x que n√£o est√£o na rela√ß√£o PROJETO .  Depois, exclu√≠mos as tuplas em que n√£o estamos interessados da  pr√≥pria R .  Em C3 ,  o  uso  da  express√£o NOT ( p . Dnum = 5)  avalia  como TRUE todas as tuplas p que est√£o  na  rela√ß√£o PROJETO, mas  n√£o  s√£o  controladas pelo departamento 5. Por fim, especificamos uma condi√ß√£o F 2 que precisa ser mantida sobre todas as tuplas restantes em R . Logo, podemos explicar C3 da seguinte forma:

- 1. Para a f√≥rmula F' = ‚àÄ ( p )( F ) ser TRUE , precisamos fazer que a f√≥rmula F seja TRUE para todas as tuplas no universo que possam ser atribu√≠das a p. Por√©m, em C3 s√≥ estamos interessados em F ser TRUE para  todas as tuplas da rela√ß√£o PROJE√á√ÉO que  s√£o  controladas pelo departamento 5. Logo, a f√≥rmula F tem a forma ( NOT ( PROJETO ( p )) OR F 1 ). A condi√ß√£o ' NOT ( PROJETO ( p )) OR ...' √© TRUE para todas as tuplas que n√£o est√£o na rela√ß√£o PROJETO e tem o efeito de eliminar essas tuplas da considera√ß√£o no valor verdade de F 1 . Para cada tupla na rela√ß√£o PROJETO , F 1 precisa ser TRUE se F ' tiver de ser TRUE .

- 2. Usando a mesma linha de racioc√≠nio, n√£o queremos considerar tuplas na rela√ß√£o PROJETO que n√£o sejam controladas pelo departamento n√∫mero 5, pois s√≥ estamos interessados em tuplas de PROJETO cujo Dnum = 5. Portanto, podemos escrever:
- 3. Logo,  a f√≥rmula F 1 tem  a forma NOT ( p . Dnum = 5) OR F 2 . No contexto de C3 , isso significa  que,  para  uma  tupla p na  rela√ß√£o PROJETO , seu Dnum ‚â† 5 ou ela precisa satisfazer F 2 .
- 4. Finalmente, F 2 d√° a condi√ß√£o que queremos manter para uma tupla selecionada FUNCIONARIO :  que  o  funcion√°rio trabalhe em cada tupla de PROJETO que ainda n√£o tenha sido exclu√≠da . Essas tuplas de funcion√°rios s√£o selecionadas pela consulta.

IF ( p .Dnum = 5) THEN F 2

que √© equivalente a

( NOT ( p .Dnum = 5) OR F 2 )

Em portugu√™s, C3 gera a seguinte condi√ß√£o para selecionar uma tupla de FUNCIONARIO f : para cada tupla p na rela√ß√£o PROJETO com p . Dnum = 5, √© preciso que haja uma tupla   em t TRABALHA\_EM tal que t . Fcpf = f . Cpf e  . t Pnr = p . Projnumero . Isso equivale a dizer que FUNCIONARIO f trabalha em cada PROJETO p no DEPARTAMENTO n√∫mero 5.

Usando a transforma√ß√£o geral dos quantificadores universal para existencial, dada na Se√ß√£o 6.6.6, podemos reformular a consulta em C3 como mostramos em C3A ,  que  usa  um  quantificador  existencial negado em vez do quantificador universal:

AND

C3A: { .Unome,  .Pnome   FUNCIONARIO( ) f f | f ( NOT ( ‚àÉ p ) (PROJETO( p ) AND ( p .Dnum = 5) AND NOT ( ( ‚àÉ t )(TRABALHA\_ EM( ) t AND t .Fcpf = f .Cpf AND p .Projnumero = t .Pnr))))}

Agora,  mostramos  alguns  exemplos  adicionais de consultas que usam quantificadores.

Consulta 6. Listar os nomes de funcion√°rios que n√£o possuem dependentes.

C6: { .Pnome,  .Unome | FUNCIONARIO( ) f f f AND ( NOT ( ‚àÉ d )(DEPENDENTE( d ) AND .Cpf f = d .Fcpf  ))}

Usando a regra  da  transforma√ß√£o  geral,  podemos reformular C6 da seguinte forma:

C6A: { .Pnome,  .Unome | FUNCIONARIO( ) f f f (( ‚àÄ d )( NOT (DEPENDENTE( d )) OR NOT ( f .Cpf = d .Fcpf  )))}

AND

Consulta  7. Listar  os  nomes  dos  gerentes  que possuem pelo menos um dependente.

C7: { .Pnome,  .Unome | FUNCIONARIO( ) f f f AND (( ‚àÉ d )( ‚àÉ ùõí )(DEPARTAMENTO( d ) AND DEPENDENTE ( ùõí ) AND f .Cpf = d .Cpf\_gerente AND ùõí .Fcpf = f .Cpf ))}

Essa consulta √© tratada interpretando os gerentes que possuem pelo menos um dependente como gerentes para os quais existe algum dependente .

## 6.6.8 Express√µes seguras

Sempre que usamos quantificadores universais, quantificadores existenciais ou nega√ß√£o de predicados em uma express√£o de c√°lculo, temos de garantir que a express√£o resultante fa√ßa sentido. Uma express√£o segura em c√°lculo relacional √© aquela que garante a  gera√ß√£o de um n√∫mero finito de tuplas como resultado;  caso  contr√°rio,  a  express√£o  √©  chamada  de insegura . Por exemplo, a express√£o

## { t | NOT (FUNCIONARIO( ))} t

√© insegura , pois gera todas as tuplas no universo que n√£o s√£o tuplas de FUNCIONARIO , e que s√£o infinitamente numerosas. Se seguirmos as regras para C3 , discutidas anteriormente, obteremos uma express√£o segura ao usar quantificadores universais. Podemos definir express√µes seguras com mais precis√£o introduzindo o conceito do dom√≠nio de uma express√£o de c√°lculo relacional de tupla : este √© o conjunto de todos os valores que aparecem como valores constantes na express√£o ou existem em qualquer tupla nas rela√ß√µes referenciadas na express√£o. Por exemplo, o dom√≠nio de {  | t NOT (FUNCIONARIO ( ))} √© o conjunto de todos t os valores de atributo que aparecem em alguma tupla da rela√ß√£o FUNCIONARIO (para  qualquer atributo). O dom√≠nio da express√£o C3A incluiria todos os valores  que  aparecem em FUNCIONARIO , PROJETO e TRABALHA\_EM (unidos com o valor 5 aparecendo na pr√≥pria consulta).

Uma  express√£o  √©  considerada segura se todos  os  valores  em  seu  resultado  forem  do  dom√≠nio  da  express√£o.  Observe  que  o  resultado  de  { t | NOT ( FUNCIONARIO ( ))}  √©  inseguro,  pois,  em  geral, t incluir√°  tuplas  (e,  portanto,  valores)  de  fora  da  rela√ß√£o FUNCIONARIO . Esses valores n√£o est√£o no dom√≠nio da express√£o. Todos os outros exemplos s√£o express√µes seguras.

## 6.7 O c√°lculo relacional de dom√≠nio

Existe outro tipo de c√°lculo relacional chamado c√°lculo relacional de dom√≠nio, ou apenas c√°lculo de dom√≠nio . Historicamente, enquanto a SQL (ver cap√≠tulos 4 e 5), que foi baseada no c√°lculo relacional de tupla, estava sendo desenvolvida pela IBM Research em San Jose,  Calif√≥rnia,  outra  linguagem,  chamada QBE  (Query-By-Example),  que  est√°  relacionada  ao c√°lculo de dom√≠nio, estava sendo desenvolvida quase simultaneamente no IBM T. J. Watson Research Center em Yorktown Heights, Nova York. A especifica√ß√£o formal do c√°lculo de dom√≠nio foi proposta ap√≥s o desenvolvimento da linguagem e sistema em QBE.

- O c√°lculo de dom√≠nio difere do c√°lculo de tupla no tipo  das  vari√°veis usadas  nas  f√≥rmulas:  em  vez de ter vari√°veis percorrendo as tuplas, elas o fazem por valores isolados dos dom√≠nios de atributos. Para formar uma rela√ß√£o de grau n para um resultado de consulta, precisamos ter n dessas vari√°veis de dom√≠nio - uma para cada atributo. Uma express√£o do c√°lculo de dom√≠nio tem a forma

<!-- formula-not-decoded -->

onde x 1 , x 2 , ..., x n , x n +1 , x n +2 , ..., x n m + s√£o vari√°veis de dom√≠nio que percorrem os dom√≠nios (dos atributos) e COND √© uma condi√ß√£o ou f√≥rmula do c√°lculo relacional do dom√≠nio.

Uma f√≥rmula √© composta de √°tomos . Os √°tomos de uma f√≥rmula s√£o ligeiramente diferentes daqueles para o c√°lculo de tupla e podem ser um dos seguintes:

- 1. Um √°tomo da forma R( x 1 , x 2 , ..., x j ), onde R √© o nome de uma rela√ß√£o de grau   e cada j x i , 1 ‚â§ i ‚â§ j ,  √©  uma  vari√°vel  de  dom√≠nio. Esse √°tomo  declara  que  uma  lista  de  valores  de &lt; x 1 , x 2 , ..., x j &gt; deve ser uma tupla na rela√ß√£o cujo nome √© R , onde x i √© o valor do  -√©simo i valor de atributo da tupla. Para tornar uma express√£o de c√°lculo de dom√≠nio mais concisa, podemos remover as v√≠rgulas em uma lista de vari√°veis, escrevendo assim:

<!-- formula-not-decoded -->

no lugar de

<!-- formula-not-decoded -->

- 2. Um √°tomo da forma x i op x j , onde op √© um dos operadores de compara√ß√£o no conjunto { =, &lt;, ‚â§, &gt;, ‚â•, ‚â† } e x i e x j s√£o vari√°veis de dom√≠nio.
- 3. Um √°tomo da forma x i op c ou c op x j , onde op √©  um  dos  operadores de compara√ß√£o no conjunto { =, &lt;, ‚â§, &gt;, ‚â•, ‚â† }, x i e x j s√£o vari√°veis de dom√≠nio, e c √© um valor constante.

Assim como no c√°lculo de tupla, os √°tomos s√£o avaliados  como TRUE ou FALSE para  um  conjunto de valores espec√≠fico, chamados valores verdade dos √°tomos. No caso 1, se as vari√°veis de dom√≠nio receberem valores correspondentes a uma tupla da rela√ß√£o especificada R , ent√£o o √°tomo √© TRUE . Nos casos 2 e 3, se as vari√°veis de dom√≠nio receberem valores que satisfazem a condi√ß√£o, ent√£o o √°tomo √© TRUE .

De um modo semelhante ao c√°lculo relacional de tupla, as f√≥rmulas s√£o compostas de √°tomos, vari√°veis e quantificadores, de modo que n√£o repetiremos as especifica√ß√µes de f√≥rmulas aqui. A seguir, apresentamos alguns exemplos de consultas especificadas no c√°lculo de dom√≠nio. Usaremos as letras min√∫sculas  , l m n , , ..., x y , , z para as vari√°veis de dom√≠nio.

Consulta 0. Listar a data de nascimento e o endere√ßo do funcion√°rio cujo nome √© 'Jo√£o B. Silva'.

<!-- formula-not-decoded -->

Precisamos de dez vari√°veis para a rela√ß√£o FUNCIONARIO ,  uma para percorrer cada um dos dom√≠nios dos atributos de FUNCIONARIO em ordem. Das dez vari√°veis q , r , s , ..., z , somente u e v s√£o livres, pois aparecem √† esquerda da barra e, portanto, n√£o devem estar ligadas a um quantificador. Primeiro, especificamos os atributos solicitados , Datanasc e Endereco , pelas vari√°veis de dom√≠nio livres u para DATANASC e v para ENDERECO . Depois, especificamos a condi√ß√£o para selecionar uma tupla ap√≥s a barra ( ) | - a saber, que a sequ√™ncia de valores atribu√≠dos √†s vari√°veis qrstuvwxyz seja uma tupla da rela√ß√£o FUNCIONARIO e que os valores para q ( Pnome ), r ( Minicial ) e s ( Unome ) sejam iguais a 'Jo√£o', 'B' e 'Silva', respectivamente.  Por  conveni√™ncia,  quantificaremos apenas as vari√°veis que realmente aparecem em uma condi√ß√£o (estas seriam q , r e s em C0 ) no restante de nossos exemplos. 14

Uma  nota√ß√£o  abreviada  alternativa,  usada  em QBE, para escrever essa consulta, √© atribuir as constantes  'Jo√£o',  'B'  e  'Silva'  diretamente  como  mostramos  em C0A .  Aqui,  todas  as  vari√°veis  que  n√£o aparecem  √†  esquerda  da  barra  s√£o  implicitamente quantificadas de maneira existencial: 15

14 Observe que a nota√ß√£o de quantificar apenas as vari√°veis de dom√≠nio realmente usadas nas condi√ß√µes e de mostrar um predicado como FUNCIONARIO ( qrstuvwxyz ) sem separar as vari√°veis de dom√≠nio com v√≠rgulas √© uma nota√ß√£o abreviada, utilizada por conveni√™ncia; essa n√£o √© a nota√ß√£o formal correta.

15 Mais uma vez, esta n√£o √© uma nota√ß√£o formalmente precisa.

C0A: u, v | FUNCIONARIO('Jo√£o','B','Silva', , { t u , v w x y z , , , , ) }

Consulta 1 . Recuperar o nome e o endere√ßo de todos os funcion√°rios que trabalham para o departamento 'Pesquisa'.

C1: { q s , , v | ( ‚àÉ z ) ( ‚àÉ l ) ( ‚àÉ m ) (FUNCIONARIO ( qrstuvwxyz ) AND DEPARTAMENTO ( lmno ) AND l = 'Pesquisa' AND m z = )}

Uma  condi√ß√£o  relacionando  duas  vari√°veis  de dom√≠nio que percorra os atributos de duas rela√ß√µes, como m = z em C1 , √© uma condi√ß√£o de jun√ß√£o , enquanto uma condi√ß√£o que relaciona uma vari√°vel de dom√≠nio a uma constante, como l = 'Pesquisa', √© uma condi√ß√£o de sele√ß√£o .

Consulta  2. Para  cada  projeto  localizado  em 'Mau√°', listar o n√∫mero do projeto, o n√∫mero do departamento de controle e √∫ltimo nome, data de nascimento e endere√ßo do gerente do departamento.

C2: , { i k , s , u , v | ( ‚àÉ j )( ‚àÉ m )( ‚àÉ n )( ‚àÉ t )(PROJETO( hijk ) AND FUNCIONARIO ( qrstuvwxyz ) AND DEPARTAMENTO ( lmno ) AND k = m AND n = t AND j = 'Mau√°')}

Consulta  6. Listar  os  nomes  dos  funcion√°rios que n√£o t√™m dependentes.

C6: { q s , | ( ‚àÉ t )(FUNCIONARIO( qrstuvwxyz ) AND ( NOT ( ‚àÉ l )(DEPENDENTE( lmnop ) AND t = l )))}

C6 pode ser reformulada usando quantificadores universais no lugar dos quantificadores existenciais, como mostramos em C6A :

C6A: { q s , | ( ‚àÉ t )(FUNCIONARIO( qrstuvwxyz ) AND (( ‚àÄ l )( NOT (DEPENDENTE( lmnop )) OR NOT ( t = l ))))}

Consulta  7. Listar  os  nomes  dos  gerentes  que t√™m pelo menos um dependente.

C7: { s , q | ( ‚àÉ t )( ‚àÉ j )( ‚àÉ l )(FUNCIONARIO( qrstuvwxyz ) AND DEPARTAMENTO( hijk )

AND DEPENDENTE( lmnop ) AND t = j AND l = t )}

Como dissemos anteriormente, pode-se mostrar que qualquer consulta que pode ser expressa na √°lgebra relacional b√°sica tamb√©m pode ser expressa no c√°lculo relacional de dom√≠nio ou de tupla. Al√©m disso, qualquer express√£o segura no c√°lculo relacional de dom√≠nio ou de tupla pode ser expressa na √°lgebra relacional b√°sica.

A linguagem QBE foi baseada no c√°lculo relacional de dom√≠nio, embora isso fosse observado mais tarde, depois que o c√°lculo de dom√≠nio foi formalizado.  A  QBE  foi  uma  das  primeiras  linguagens  de consulta gr√°ficas com sintaxe m√≠nima desenvolvidas para sistemas de banco de dados. Ela foi desenvolvida  na  IBM  Research  e  est√°  dispon√≠vel  como  um produto comercial da empresa como parte da op√ß√£o de interface Query Management Facility (QMF) para DB2. As ideias b√°sicas usadas na QBE t√™m sido aplicadas  em  v√°rios  outros  produtos  comerciais.  Devido a seu lugar importante na hist√≥ria das linguagens relacionais,  inclu√≠mos  uma  vis√£o  geral  da  QBE  no Ap√™ndice C.

## Resumo

Neste cap√≠tulo, apresentamos duas linguagens formais para o modelo de dados relacional. Elas s√£o usadas para manipular rela√ß√µes e produzir novas rela√ß√µes como respostas √†s consultas. Discutimos a √°lgebra relacional e  suas  opera√ß√µes,  que  s√£o  usadas  para  especificar  uma sequ√™ncia de opera√ß√µes para determinar uma consulta. Depois, apresentamos dois tipos de c√°lculos relacionais, chamados c√°lculo de tupla e c√°lculo de dom√≠nio.

Nas  se√ß√µes  de  6.1  a  6.3,  apresentamos  as  opera√ß√µes b√°sicas da √°lgebra relacional e ilustramos os tipos de consultas para as quais cada uma √© usada. Primeiro, discutimos os operadores relacionais un√°rios SELE√á√ÉO e PROJE√á√ÉO , bem como a opera√ß√£o RENOMEAR . Depois, discutimos as opera√ß√µes te√≥ricas do conjunto bin√°rio  exigindo que as rela√ß√µes sobre as quais s√£o aplicadas sejam compat√≠veis na uni√£o (ou tipo); estas incluem UNI√ÉO INTERSEC√á√ÉO , e DIFEREN√áA DE CONJUNTO . A opera√ß√£o PRODUTO CARTESIANO √© uma opera√ß√£o de  conjunto  que  pode  ser  usada  para  combinar  tuplas de duas rela√ß√µes, produzindo todas as combina√ß√µes poss√≠veis.  Ela  √©  raramente  usada  na  pr√°tica.  Por√©m,  mostramos como o PRODUTO CARTESIANO seguido  por SELE√á√ÉO pode ser usado para definir tuplas combinadas de duas rela√ß√µes e levar √† opera√ß√£o JUN√á√ÉO. Diferentes opera√ß√µes JUN√á√ÉO, chamadas JUN√á√ÉO THETA , EQUIJUN√á√ÉO e JUN√á√ÉO NATURAL , foram apresentadas. √Årvores de consulta foram apresentadas como uma representa√ß√£o  gr√°fica  das  consultas  da  √°lgebra  relacional, as quais tamb√©m podem ser usadas como base para estruturas de dados internas, que o SGBD pode utilizar para representar uma consulta.

Discutimos  alguns  tipos  importantes  de  consultas que n√£o podem ser declaradas com as opera√ß√µes b√°sicas da √°lgebra relacional, mas s√£o importantes para situa√ß√µes pr√°ticas. Apresentamos a PROJE√á√ÉO GENERALIZADA para usar fun√ß√µes de atributos na lista de proje√ß√£o e a opera√ß√£o FUN√á√ÉO DE AGREGA√á√ÉO para lidar com tipos de agrega√ß√£o das solicita√ß√µes estat√≠sticas, que resumem as informa√ß√µes nas tabelas. Discutimos sobre

as consultas recursivas, para as quais n√£o existe suporte direto na √°lgebra, mas que podem ser tratadas de uma maneira  passo  a  passo,  conforme  demonstramos.  Depois, apresentamos as opera√ß√µes JUN√á√ÉO EXTERNA e UNI√ÉO EXTERNA ,  que  estendem JUN√á√ÉO e UNI√ÉO e permitem que todas as informa√ß√µes nas rela√ß√µes de origem sejam preservadas no resultado.

As  duas  √∫ltimas  se√ß√µes  descreveram  os  conceitos b√°sicos  por  tr√°s  do  c√°lculo  relacional,  que  √©  baseado no ramo da l√≥gica matem√°tica chamado c√°lculo de predicado.  Existem  dois  tipos  de  c√°lculo  relacional:  (1)  o c√°lculo  relacional  de  tupla,  que  usa  vari√°veis  de  tupla que percorrem as tuplas (linhas) das rela√ß√µes e (2) c√°lculo relacional de dom√≠nio, que usa vari√°veis de dom√≠nio que percorrem os dom√≠nios (colunas das rela√ß√µes). No c√°lculo  relacional,  uma  consulta  √©  especificada  em  um √∫nico comando declarativo, sem determinar qualquer ordem ou m√©todo para recuperar o resultado da consulta. Logo, o c√°lculo  relacional  normalmente  √©  considerado como uma linguagem declarativa de n√≠vel mais alto do que a √°lgebra relacional, pois uma express√£o do c√°lculo relacional  declara o  que queremos  recuperar,  independentemente de como a consulta pode ser executada.

Discutimos a sintaxe das consultas do c√°lculo relacional usando vari√°veis de tupla e de dom√≠nio. Apresentamos  os  grafos  de  consulta  como  uma  representa√ß√£o interna para as consultas no c√°lculo relacional. Tamb√©m  discutimos  o  quantificador  existencial  ( ‚àÉ )  e o  quantificador  universal  ( ‚àÄ ).  Vimos  que  as  vari√°veis do c√°lculo relacional s√£o ligadas por esses quantificadores. Descrevemos, com detalhes, como as consultas com quantifica√ß√£o universal s√£o escritas, e discutimos o problema de especificar consultas seguras, cujos resultados  s√£o  finitos.  Tamb√©m  discutimos  regras  para transformar quantificadores universais em existenciais, e vice-versa. S√£o os quantificadores que d√£o poder expressivo ao c√°lculo relacional, tornando-o equivalente √† √°lgebra relacional b√°sica. N√£o existe algo semelhante para fun√ß√µes de agrupamento e agrega√ß√£o no c√°lculo relacional  b√°sico,  embora  algumas  extens√µes  tenham sido sugeridas.

## Perguntas de revis√£o

- 6.1. Liste as opera√ß√µes da √°lgebra relacional e a finalidade de cada uma.
- 6.2. O que √© compatibilidade na uni√£o? Por que as opera√ß√µes UNI√ÉO , INTERSEC√á√ÉO e DIFEREN√áA exigem  que  as  rela√ß√µes  sobre  as  quais  s√£o aplicadas sejam compat√≠veis na uni√£o?
- 6.3. Discuta alguns tipos de consultas para as quais a renomea√ß√£o de atributos √© necess√°ria para especificar a consulta de forma n√£o amb√≠gua.
- 6.4. Discuta os v√°rios tipos de opera√ß√µes de jun√ß√£o interna (JUN√á√ÉO  INTERNA ).  Por  que  a JUN√á√ÉO THETA √© exigida?
- 6.5. Que papel √© desempenhado pela chave estrangeira ao especificar os tipos mais comuns de opera√ß√µes de jun√ß√£o significativas?
- 6.6. O que √© a opera√ß√£o de FUN√á√ÉO ? Para que √© usada?
- 6.7. Como as opera√ß√µes JUN√á√ÉO EXTERNA diferem das opera√ß√µes JUN√á√ÉO INTERNA ? Como a opera√ß√£o UNI√ÉO EXTERNA √© diferente de UNI√ÉO ?
- 6.8. Em que sentido o c√°lculo relacional difere da √°lgebra relacional, e em que sentido eles s√£o semelhantes?
- 6.9. Como o c√°lculo relacional de tupla difere do c√°lculo relacional de dom√≠nio?
- 6.10. Discuta os significados do quantificador existencial ( ‚àÉ ) e do quantificador universal ( ‚àÄ ).
- 6.11. Defina os seguintes termos com rela√ß√£o ao c√°lculo de tupla: tupla vari√°vel , rela√ß√£o de intervalo , √°tomo , f√≥rmula e express√£o .
- 6.12. Defina os seguintes termos com rela√ß√£o ao c√°lculo de dom√≠nio: vari√°vel de dom√≠nio , rela√ß√£o de intervalo , √°tomo , f√≥rmula e express√£o .
- 6.13. O que significa uma express√£o segura no c√°lculo relacional?
- 6.14. Quando uma linguagem de consulta √© chamada de relacionalmente completa?

## Exerc√≠cios

- 6.15. Mostre o resultado de cada um dos exemplos da consulta na Se√ß√£o 6.5 se fosse aplicado ao estado de banco de dados da Figura 3.6.
- 6.16. Especifique as seguintes consultas no esquema de banco de dados relacional EMPRESA mostrado na Figura 5.5, usando os operadores relacionais discutidos neste cap√≠tulo. Mostre tamb√©m o resultado de cada consulta como ele se aplica ao estado de banco de dados da Figura 3.6.
- a. Recupere  o  nome  de  todos  os  funcion√°rios no  departamento  5  que  trabalham  mais  de 10 horas por semana no projeto ProdutoX.
- b. Liste  o  nome  de  todos  os  funcion√°rios  que  t√™m  um dependente com o primeiro nome igual ao seu.
- c. Liste  o  nome  de  todos  os  funcion√°rios  que s√£o  supervisionados  diretamente  por  'Fernando Wong'.
- d. Para cada projeto, liste o nome do projeto e o  total  de  horas  por  semana  (por  todos  os funcion√°rios) gastas nesse projeto.
- e. Recupere  o  nome  de  todos  os  funcion√°rios que trabalham em cada projeto.
- f. Recupere  o  nome  de  todos  os  funcion√°rios que n√£o trabalham em projeto algum.
- g. Para cada departamento, recupere o nome do departamento e o sal√°rio m√©dio de todos os seus funcion√°rios.

- h. Recupere o sal√°rio m√©dio de todos os funcion√°rios do sexo feminino.
- i. Encontre o nome e endere√ßo de todos os funcion√°rios que trabalham em pelo menos um projeto  localizado  em  S√£o  Paulo,  mas  cujo departamento n√£o est√° localizado l√°.
- j. Liste o √∫ltimo nome de todos os gerentes de departamento que n√£o possuem dependentes.
- 6.17. Considere  o  esquema  de  banco  de  dados  relacional COMPANHIA AEREA mostrado na Figura 3.8, que foi descrito no Exerc√≠cio 3.12. Especifique as seguintes consultas em √°lgebra relacional:
- a. Para cada voo, liste o n√∫mero do voo, o aeroporto de partida para o primeiro trecho e o aeroporto de chegada para o √∫ltimo trecho.
- b. Liste os n√∫meros de voo e dias da semana de todos os voos ou de seus trechos que saem do Aeroporto Internacional de Guarulhos em S√£o Paulo (c√≥digo de aeroporto 'GRU') e chegam ao Aeroporto Internacional Salgado Filho de Porto Alegre (c√≥digo de aeroporto 'POA').
- c. Liste o n√∫mero do voo, o c√≥digo do aeroporto de partida, a hora de partida programada, o c√≥digo do aeroporto de chegada, a hora de chegada programada e os dias da semana de todos os voos ou trechos que saem de algum aeroporto na cidade de S√£o Paulo e chegam a algum aeroporto na cidade de Porto Alegre.
- d. Liste  todas  as  informa√ß√µes  de  tarifa  para  o voo n√∫mero 'CO197'.
- e. Recupere  o  n√∫mero  de  assentos  dispon√≠veis para o voo n√∫mero 'CO197' em '09-10-2010'.
- 6.18. Considere o esquema de banco de dados relacional BIBLIOTECA mostrado na Figura 6.14, que √© usado para registrar livros, leitores e empr√©stimos de livro.  As  restri√ß√µes  de  integridade  referencial aparecem  como  arcos  diretos  na  Figura  6.14, como na nota√ß√£o da Figura 3.7. Escreva as express√µes relacionais para as seguintes consultas:
- a. Quantas c√≥pias do livro intitulado A Tribo Perdida existem  na  unidade  da  biblioteca cujo nome √© 'Central'?
- b. Quantas c√≥pias do livro intitulado A Tribo Perdida existem em cada unidade da biblioteca?
- c. Recupere o nome de todos os usu√°rios que n√£o possuem livros registrados em seu nome.
- d. Para cada livro que √© emprestado da unidade de Central e cuja Data\_devolucao √© hoje, recupere o t√≠tulo do livro, o nome e o endere√ßo do usu√°rio.
- e. Para cada unidade da biblioteca, recupere o nome da unidade e o n√∫mero total de livros retirados de l√°.

## LIVRO



## Figura 6.14

Um esquema de banco de dados relacional para um banco de dados BIBLIOTECA.

- f. Recupere o nome, endere√ßo e n√∫mero de livros emprestados para todos os usu√°rios que possuem mais de cinco livros emprestados.
- g. Para  cada  livro  cujo  autor  (ou  coautor)  √© Stephen King, recupere o t√≠tulo e o n√∫mero de c√≥pias pertencentes √† unidade da biblioteca cujo nome √© Central.
- 6.19. Especifique  as  seguintes  consultas  na  √°lgebra relacional sobre o esquema de banco de dados mostrado no Exerc√≠cio 3.14:
- a. Liste o Num\_Pedido e Data\_envio para todos os pedidos enviados do Num\_deposito com n√∫mero 2.
- b. Liste a informa√ß√£o do DEPOSITO do qual o CLIENTE chamado Jose Lopez recebeu seus pedidos. Produza uma listagem: Num\_pedi-do Num\_deposito , .
- c. Produza  uma  listagem  com Nome\_cliente , Nr\_pedidos , Media\_valor\_pedido ,  em que a coluna do meio seja o n√∫mero total de pedidos feitos pelo cliente e a √∫ltima coluna seja o valor m√©dio do pedido para esse cliente.
- d. Liste os pedidos que foram entregues em at√© 30 dias ap√≥s sua solicita√ß√£o.

6.20.

- e. Liste o Num\_pedido para os pedidos que foram  entregues  de todos os  dep√≥sitos  que  a empresa tem em Curitiba.
- Especifique  as  seguintes  consultas  em  √°lgebra relacional sobre o esquema de banco de dados mostrado no Exerc√≠cio 3.15:
- a. D√™ os detalhes (todos os atributos da rela√ß√£o de  viagem)  para  as  viagens  que  excederam R$ 2.000 nas despesas.
- b. Imprima o Cpf dos  vendedores que realizaram viagens para Pernambuco.
- c. Imprima  o  total de despesas de viagem contra√≠das pelo vendedor com CPF = '23456789011'.
- 6.21. Especifique  as  seguintes  consultas  na  √°lgebra relacional sobre o esquema de banco de dados dado no Exerc√≠cio 3.16:
- a. Liste o n√∫mero de cursos realizados por todos os alunos chamados 'Jo√£o Silva' no segundo semestre de 2009 (ou seja, Semestre = S09).
- b. Produza  uma  lista  dos  livros-texto  (inclua Num\_disciplina , Isbn\_livro , Titulo\_livro )  para os cursos oferecidos pelo departamento 'CC' que usaram mais de dois livros.
- c. Liste qualquer departamento que tenha todos os  livros  adotados  publicados  pela  'Editora Pearson'.
- 6.22. Considere as duas tabelas T 1 e T 2 mostradas na Figura 6.15. Mostre os resultados das seguintes opera√ß√µes:

a. T 1 /triangleleft /triangleright T 2

```
T 1. P = T 2. A b. T 1 /triangleleft /triangleright T 1. Q = T 2. B T 2 c. T 1 /triangleleft /triangleright T 1. P = T 2. A T 2 d. T 1 /triangleleft /triangleright T 1. Q = T 2. B T 2 e. T 1 ‚à™ T 2
```

- f. T 1 /triangleleft /triangleright ( T 1. P = T 2. A AND T 1. R = T 2. C ) T 2

## TABELA T1

## TABELA T2

Figura 6.15

|   P | Q   |   R |
|-----|-----|-----|
|  10 | a   |   5 |
|  15 | b   |   8 |
|  25 | a   |   6 |

|   A | B   |   C |
|-----|-----|-----|
|  10 | b   |   6 |
|  25 | c   |   3 |
|  10 | b   |   5 |

Um estado do banco de dados para as rela√ß√µes T 1 e T 2.

- 6.23. Especifique as seguintes consultas na √°lgebra relacional sobre o esquema de banco de dados do Exerc√≠cio 3.17:
- a. Para a vendedora chamada 'Jane Dolores', liste as seguintes informa√ß√µes para todos os carros que ela vendeu: Num\_chassi , Fabricante , Preco\_venda .
- b. Liste o Num\_chassi e Modelo dos carros que n√£o possuem opcionais.
- c. Considere  a  opera√ß√£o JUN√á√ÉO  NATURAL entre VENDEDOR e VENDA . Qual √© o significado de uma jun√ß√£o externa esquerda para essas  tabelas  (n√£o  mude  a  ordem  das  rela√ß√µes)? Explique com um exemplo.
- d. Escreva  uma  consulta  na  √°lgebra  relacional envolvendo sele√ß√£o e uma opera√ß√£o de conjunto e diga, em palavras, o que a consulta faz.
- 6.24. Especifique as consultas a, b, c, e, f, i e j do Exerc√≠cio 6.16 no c√°lculo relacional de tupla e de dom√≠nio.
- 6.25. Especifique as consultas a, b, c e d do Exerc√≠cio 6.17 no c√°lculo relacional de tupla e de dom√≠nio.
- 6.26. Especifique  as  consultas  c,  d  e  f  do  Exerc√≠cio 6.18 no c√°lculo relacional de tupla e de dom√≠nio.
- 6.27. Em uma consulta de c√°lculo relacional de tupla com n vari√°veis  de  tupla,  qual  seria  o  n√∫mero m√≠nimo t√≠pico de condi√ß√µes de jun√ß√£o? Por qu√™? Qual √© o efeito de ter um n√∫mero menor de condi√ß√µes de jun√ß√£o?
- 6.28. Reescreva as consultas do c√°lculo relacional de dom√≠nio que seguiram C0 na Se√ß√£o 6.7 no estilo da nota√ß√£o abreviada de C0A , em que o objetivo √© minimizar o n√∫mero de vari√°veis de dom√≠nio escrevendo constantes no lugar de vari√°veis sempre que poss√≠vel.
- 6.29. Considere esta consulta: recupere o Cpf dos funcion√°rios que trabalham pelo menos nos projetos em  que  o  funcion√°rio  com Cpf =12345678966 trabalha.  Isso  pode  ser  declarado  como  ( FORALL p ) ( IF P THEN Q ), onde
- ¬Ñ p √© uma vari√°vel de tupla que percorre a rela√ß√£o PROJETO .
- ¬Ñ P ‚â° FUNCIONARIO com Cpf = 12345678966 trabalha no PROJETO x.
- ¬Ñ Q ‚â° FUNCIONARIO f trabalha no PROJETO p.

Expresse a consulta no c√°lculo relacional de tupla, usando as regras

- ¬Ñ ( ‚àÄ p )( P p ( )) ‚â° NOT ( ‚àÉ p )( NOT ( P p ( ))).
- ¬Ñ ( IF P THEN Q ) ‚â° ( NOT ( P ) OR Q ).
- 6.30. Mostre como voc√™ pode especificar as seguintes opera√ß√µes da √°lgebra relacional no c√°lculo relacional de tupla e de dom√≠nio.

a. ùõî A = C ( R A  B  C ( , , ))

b. ùõë &lt;A, B&gt; ( R A  B  C ( , , ))

c. R A  B  C ( , , ) ÔÇ´ S C  D  E ( , , )

- d. R A  B  C ( , , ) ‚à™ S A  B  C ( , , )
- e. R A  B  C ( , , ) ‚à© S A  B  C ( , , )
- f. R A  B  C ( , , ) = S A  B  C ( , , )

g. R A  B  C ( , , ) √ó S D  E  F ( , , )

h. R A  B ( , ) √∑ S A ( )

- 6.31. Sugira extens√µes ao c√°lculo relacional, de modo que  ele  possa  expressar  os  seguintes  tipos  de opera√ß√µes que foram discutidas na Se√ß√£o 6.4: (a) fun√ß√µes de agrega√ß√£o e agrupamento; (b) opera√ß√µes JUN√á√ÉO EXTERNA ; (c) consultas de fechamento recursivo.
- 6.32. Uma consulta aninhada √© uma consulta dentro de outra. Mais especificamente, trata-se de uma consulta entre par√™nteses cujo resultado pode ser usado como um valor em diversos lugares, como no lugar de uma rela√ß√£o. Especifique as seguintes consultas sobre o banco de dados mostrado na  Figura  3.5  usando  o  conceito  de  consultas aninhadas  e  os  operadores  relacionais  discutidos neste cap√≠tulo. Mostre tamb√©m o resultado de cada consulta se fosse aplicado ao estado do banco de dados na Figura 3.6.
- a. Liste  o  nome  de  todos  os  funcion√°rios  que trabalham no departamento que tem o funcion√°rio com o maior sal√°rio entre todos os funcion√°rios.
- b. Liste o nome de todos os funcion√°rios cujo supervisor do supervisor tem como Cpf o numero '88866555576'.
- c. Liste  o  nome  dos  funcion√°rios  que  ganham pelo menos R$10.000 a mais do que o funcion√°rio que menos recebe na empresa.
- 6.33. Indique se as seguintes conclus√µes s√£o verdadeiras ou falsas:
- a. NOT ( P x ( ) OR Q x ( )) ‚Üí ( NOT ( P x ( )) AND ( NOT ( Q x ( )))
- b. NOT ( ‚àÉ x ) ( P x ( )) ‚Üí‚àÄ x ( NOT ( P x ( ))
- c. ( ‚àÉ x ) ( P x ( )) ‚Üí‚àÄ x (( P x ( ))

## Exerc√≠cios de laborat√≥rio

6.34. Especifique e execute as seguintes consultas em √°lgebra  relacional  (RA  relational  algebra ) usando o interpretador RA sobre o esquema de banco de dados EMPRESA da Figura 3.5.

- a. Liste o nome de todos os funcion√°rios no departamento 5 que trabalham mais de 10 horas por semana no projeto ProdutoX.
- b. Liste  o  nome  de  todos  os  funcion√°rios  que t√™m  um  dependente  com  o  primeiro  nome igual.
- c. Liste o nome dos funcion√°rios que s√£o supervisionados diretamente por Fernando Wong.
- d. Liste o nome dos funcion√°rios que trabalham em cada projeto.
- e. Liste o nome dos funcion√°rios que n√£o trabalham em projeto algum.
- f. Liste o nome e endere√ßo dos funcion√°rios que
- trabalham em pelo menos um projeto localizado em S√£o Paulo, mas cujo departamento n√£o est√° localizado l√°.
- g. Liste  o  nome  de  gerentes  de  departamento que n√£o t√™m dependentes.
- 6.35. Considere o seguinte esquema relacional PEDI-DO\_CORREIO descrevendo os dados para uma empresa de vendas por cat√°logo.

PECAS Pnr  Pnome  Qtddisp  Preco  Pnivel ( , , , , ) CLIENTES Cnr  Cnome  Rua  Cep  Telefone ( , , , , ) FUNCIONARIO S( Fnr  Fname  Cep  Datacontrat , , , ) CEPS Cep  Cidade ( , ) PEDIDOS PEDnr   Cnr   Fnr   Recebimento ( , , , , Envio ) DETALHES PEDnr  Pnr  Qtd ( , , )

Qtddisp significa quantidade dispon√≠vel: os outros nomes de atributo s√£o relativamente autoexplicativos. Especifique e execute as seguintes consultas usando o interpretador RA sobre o esquema de banco de dados PEDIDO\_CORREIO .

- a. Recupere o nome das pe√ßas que custam menos de R$20,00.
- b. Recupere o nome e cidade dos funcion√°rios que  receberam  pedidos  por  pe√ßas  custando mais de R$50,00.
- c. Recupere os pares de valores de n√∫mero de cliente dos que moram no mesmo CEP.
- d. Recupere o nome dos clientes que pediram pe√ßas de funcion√°rios que moram em Bras√≠lia.
- e. Recupere  o  nome  dos  clientes  que  pediram pe√ßas que custam menos de R$20,00.
- f. Recupere o nome de clientes que n√£o fizeram um pedido.
- g. Recupere o nome de clientes que fizeram exatamente dois pedidos.
- 6.36. Considere  o  seguinte  esquema  relacional DIARIONOTAS descrevendo os dados para um di√°rio  de  um  professor  em  particular.  ( Nota: Os atributos A B C , , e D de DISCIPLINAS armazenam os limites das notas.)

CATALOGO Cnr  Ctitulo ( , ) ALUNOS Cod\_aluno  Pnome  Unome  Mini-( , , , cial ) DISCIPLINAS Sigla  Num\_semestre  Cnr  A ( , , , , B  C  D , , ) MATRICULA Cod\_aluno ( , Sigla , Num\_se-mestre )

Especifique e  execute  as  seguintes  consultas  usando o interpretador RA sobre o esquema de banco de dados DIARIONOTAS.

- a. Recupere o nome dos alunos matriculados na turma de Aut√¥mato durante o primeiro semestre de 2009.

6.38.

- b. Recupere os valores de Cod\_aluno daqueles que se matricularam em CCc226 e CCc227.
- c. Recupere os valores de Cod\_aluno daqueles que se matricularam em CCc226 ou CCc227.
- d. Recupere o nome dos alunos que n√£o se matricularam em nenhuma turma.
- e. Recupere o nome dos alunos que se matricularam em todos os cursos da tabela CATALOGO .

Considere um banco de dados que consiste nas

6.37. rela√ß√µes a seguir.

FORNECEDOR Fnr  Fnome ( , ) PECA Pnr  Pnome ( , ) PROJETO PRnr  PRnome ( , ) FORNECIMENTO Fnr  Pnr  PRnr ( , , )

- O  banco  de  dados  registra  informa√ß√µes  sobre fornecedores, pe√ßas e projetos, e inclui um relacionamento tern√°rio entre fornecedores, pe√ßas e projetos. Este √© um relacionamento muitos-para-muitos. Especifique e execute as seguintes consultas usando o interpretador RA.
- a. Recupere os n√∫meros de pe√ßa que s√£o fornecidos para exatamente dois projetos.
- b. Recupere o nome dos fornecedores que fornecem mais de duas pe√ßas ao projeto 'P1'.
- c. Recupere os n√∫meros de pe√ßa que s√£o fornecidos por cada fornecedor.
- d. Recupere os nomes de projeto que s√£o fornecidos pelo fornecedor 'F1' apenas.
- e. Recupere o nome dos fornecedores que fornecem pelo menos duas pe√ßas diferentes cada a pelo menos dois projetos diferentes.

Especifique e execute as seguintes consultas para o  banco  de  dados  do  Exerc√≠cio  3.16  usando  o interpretador RA.

- a. Recupere o nome dos alunos que se matricularam em uma disciplina que usa um livro-texto publicado pela Editora Pearson.
- b. Recupere  o  nome  das  disciplinas  em  que  o livro-texto foi mudado pelo menos uma vez.
- c. Recupere o nome dos departamentos que adotam somente livros-texto publicados pela Editora Pearson.
- d. Recupere  o  nome  dos  departamentos  que adotam  livros-texto  escritos  por  Navathe  e publicados pela Editora Pearson.
- e. Recupere o nome dos alunos que nunca usaram um livro (em um curso) escrito por Navathe e publicado pela Editora Pearson.

6.39. Repita os Exerc√≠cios de Laborat√≥rio 6.34 a 6.38 no c√°lculo relacional de dom√≠nio (DRC Domain Relational Calculus ) usando o interpretador DRC.

## Bibliografia selecionada

Codd (1970) definiu a √°lgebra relacional b√°sica. Date (1983a) discute as jun√ß√µes externas. O trabalho sobre a extens√£o das opera√ß√µes relacionais √© discutido por Carlis (1986) e Ozsoyoglu et al. (1985). Cammarata et al. (1989) estendem as restri√ß√µes de integridade e jun√ß√µes do modelo relacional.

Codd (1971) introduziu a linguagem Alpha, que √© baseada nos conceitos do c√°lculo relacional de tupla. Alpha tamb√©m inclui a no√ß√£o de fun√ß√µes de agrega√ß√£o, que vai al√©m do c√°lculo relacional. A defini√ß√£o formal original do c√°lculo relacional foi dada por Codd (1972), que tamb√©m forneceu um algoritmo que transforma qualquer express√£o do c√°lculo relacional de tupla em √°lgebra relacional. A QUEL (Stonebraker et al., 1976) √© baseada no c√°lculo relacional de tupla, com quantificadores existenciais impl√≠citos, mas sem quantificadores universais, e foi implementada no sistema INGRES como uma linguagem dispon√≠vel comercialmente. Codd definiu a totalidade relacional de uma linguagem de consulta como sendo pelo menos t√£o poderosa quanto o c√°lculo relacional. Ullman (1988)  descreve  uma  prova  formal  da  equival√™ncia  da √°lgebra relacional com express√µes seguras de c√°lculo relacional  de  tupla  e  dom√≠nio.  Abiteboul  et  al.  (1995)  e Atzeni e deAntonellis (1993) fazem um tratamento detalhado das linguagens relacionais formais.

Embora as ideias do c√°lculo relacional de dom√≠nio tenham sido propostas inicialmente na linguagem QBE (Zloof, 1975), o conceito foi definido de maneira formal por Lacroix e Pirotte (1977a). A vers√£o experimental do sistema Query-By-Example √© descrita em Zloof (1975). A ILL (Lacroix e Pirotte, 1977b) √© baseada no c√°lculo relacional de dom√≠nio. Whang et al. (1990) estendem a QBE com quantificadores universais. As linguagens de consulta visuais, dentre as quais a QBE √© um exemplo, est√£o sendo propostas como um meio de consultar bancos de dados. Confer√™ncias como a Visual Database Systems Working Conference [por exemplo, Arisawa e Catarci (2000) ou Zhou e Pu (2002)] apresentam uma s√©rie de propostas para tais linguagens.



Modelagem conceitual e projeto de banco de dados

## Modelagem de dados usando o modelo Entidade-Relacionamento (ER)



A modelagem conceitual √© uma fase muito importante no projeto de uma aplica√ß√£o de banco de dados bem-sucedida. Geralmente, o termo aplica√ß√£o de banco de dados refere-se a um banco de dados em particular e aos programas associados que implementam as consultas e atualiza√ß√µes dele. Por exemplo, uma aplica√ß√£o de banco de dados para um BANCO que controla contas de clientes incluiria programas que implementam atualiza√ß√µes ao banco de dados correspondentes a dep√≥sitos e saques de clientes. Esses programas oferecem interfaces gr√°ficas com o usu√°rio (GUIs) de f√°cil utiliza√ß√£o, com formul√°rios  e  menus  para  os  usu√°rios  finais  da  aplica√ß√£o - os caixas de banco, neste exemplo. Logo, uma  parte  importante  da  aplica√ß√£o  de  banco  de dados exigir√° o projeto, a implementa√ß√£o e o teste desses programas de aplica√ß√£o. Tradicionalmente, o projeto  e  o  teste  dos programas de aplica√ß√£o t√™m sido considerados parte da engenharia de software , em vez do projeto  de  banco  de  dados .  Em muitas ferramentas de projeto de software, as metodologias de projeto de banco de dados e de engenharia de software s√£o interligadas, pois essas atividades est√£o fortemente relacionadas.

dos, e muitas ferramentas de projeto de banco de dados empregam seus conceitos. Descrevemos os conceitos e restri√ß√µes b√°sicas de estrutura√ß√£o de dados do modelo ER e discutimos seu uso no projeto de esquemas conceituais para aplica√ß√µes de banco de dados. Tamb√©m apresentamos a nota√ß√£o diagram√°tica associada ao modelo ER, conhecido como diagramas ER .

Neste cap√≠tulo, abordamos a t√©cnica tradicional  de  concentrar  nas  estruturas  e  restri√ß√µes  de banco de dados durante seu projeto conceitual. O projeto  de  programas  de  aplica√ß√£o  normalmente √©  abordado  em  cursos  de  engenharia  de  software.  Apresentamos  os  conceitos  de  modelagem  do modelo Entidade-Relacionamento (ER) ,  que  √©  um modelo  de  dados  conceitual  popular  de  alto  n√≠vel. Esse modelo e suas varia√ß√µes costumam ser utilizados para o projeto conceitual de aplica√ß√µes de banco de da-

As metodologias de modelagem de objeto, como a Unified Modeling Language ( UML ),  est√£o se tornando cada vez mais populares no projeto e software de banco de dados. Essas metodologias v√£o al√©m do projeto de banco de dados para especificar o projeto detalhado dos m√≥dulos de software e suas intera√ß√µes usando v√°rios tipos de diagramas. Uma parte importante dessas metodologias - a saber, os diagramas de classe 1 - √© semelhante, de muitas maneiras, aos diagramas ER. Nos diagramas de classe s√£o especificadas opera√ß√µes sobre objetos, al√©m da especifica√ß√£o da estrutura do esquema do banco de dados. As opera√ß√µes podem ser usadas para especificar os requisitos funcionais durante o projeto de banco de dados, conforme discutiremos na Se√ß√£o 7.1. Apresentamos parte da nota√ß√£o e conceitos em UML para diagramas de classe que s√£o particularmente relevantes ao projeto de banco de dados da Se√ß√£o 7.8, e comparamos rapidamente estes com a nota√ß√£o e conceitos de ER. Nota√ß√£o e conceitos de UML adicionais ser√£o apresentados na Se√ß√£o 8.6 e no Cap√≠tulo 10.

Este cap√≠tulo est√° organizado da seguinte forma: a  Se√ß√£o  7.1  discute  o  papel  dos  modelos  de  dados conceituais de alto n√≠vel no projeto de banco de dados. Apresentamos os requisitos para uma aplica√ß√£o de banco de dados de exemplo na Se√ß√£o 7.2, para

ilustrar o uso dos conceitos do modelo ER. Esse banco de dados de exemplo tamb√©m √© usado no decorrer do livro. Na Se√ß√£o 7.3, apresentamos os conceitos de entidades e atributos, e gradualmente introduzimos a t√©cnica diagram√°tica para exibir um esquema ER. Na Se√ß√£o 7.4, apresentamos os conceitos de relacionamentos bin√°rios e suas fun√ß√µes e restri√ß√µes estruturais. A Se√ß√£o 7.5 apresenta os tipos de entidade fraca. A Se√ß√£o 7.6 mostra como um projeto de esquema √© refinado para incluir relacionamentos. A Se√ß√£o 7.7 analisa a nota√ß√£o para diagramas ER, resume os problemas e armadilhas comuns que ocorrem no projeto de esquema e discute como escolher os nomes para constru√ß√µes de esquema de banco de dados. A Se√ß√£o 7.8 apresenta alguns conceitos de diagrama de classe UML, compara-os com os conceitos do modelo ER e os aplica ao mesmo banco de dados de exemplo. A Se√ß√£o 7.9 discute tipos de relacionamentos mais complexos. No final h√° um resumo do cap√≠tulo.

O material nas se√ß√µes 7.8 e 7.9 pode ser exclu√≠do de um curso introdut√≥rio. Se uma cobertura mais completa dos conceitos de modelagem de dados e projeto de banco de dados conceitual for desejada, o leitor dever√° continuar at√© o Cap√≠tulo 8, onde descrevemos as extens√µes ao modelo ER que levam ao modelo EER (ER Estendido), o qual inclui conceitos como especializa√ß√£o, generaliza√ß√£o, heran√ßa e tipos (categorias) de uni√£o. Tamb√©m apresentaremos alguns conceitos adicionais e a nota√ß√£o de UML no Cap√≠tulo 8.

## 7.1 Usando modelos de dados conceituais de alto n√≠vel para o projeto do banco de dados

A  Figura  7.1  mostra  uma  vis√£o  geral  simplificada do processo de projeto de banco de dados. A primeira etapa mostrada √© o levantamento e an√°lise de  requisitos .  Durante  essa  etapa,  os  projetistas  de banco  de  dados  entrevistam  os  usu√°rios  esperados para entenderem e documentarem seus requisitos de dados . O resultado dessa etapa √© um conjunto de requisitos dos usu√°rios escrito de forma concisa. Esses requisitos devem ser especificados da forma mais detalhada e completa poss√≠vel. Em paralelo com a especifica√ß√£o dos requisitos de dados, √© √∫til determinar os conhecidos requisitos funcionais da aplica√ß√£o. Estes consistem em opera√ß√µes (ou transa√ß√µes ) definidas pelo  usu√°rio,  que  ser√£o  aplicadas  ao  banco  de  dados, incluindo recupera√ß√µes e atualiza√ß√µes. No projeto de software, √© comum usar diagramas de fluxo de dados , diagramas de sequ√™ncia , cen√°rios e outras t√©cnicas  para  especificar  requisitos  funcionais.  N√£o discutiremos  essas  t√©cnicas  aqui;  elas  normalmente s√£o descritas em detalhes nos textos de engenharia de software. Daremos uma vis√£o geral dessas t√©cnicas no Cap√≠tulo 10.

Assim que os requisitos tiverem sido levantados e  analisados, a pr√≥xima etapa √© criar um esquema conceitual para o banco de dados, usando um modelo de dados conceitual de alto n√≠vel. Essa etapa √© chamada de projeto conceitual . O esquema conceitual √© uma descri√ß√£o concisa dos requisitos de dados dos usu√°rios e inclui detalhes dos tipos de entidade, relacionamentos e restri√ß√µes; estes s√£o expressos usando os conceitos fornecidos pelo modelo de dados de alto n√≠vel. Como n√£o incluem descri√ß√µes detalhadas de implementa√ß√£o, esses conceitos normalmente s√£o mais f√°ceis de entender e podem ser usados para a comunica√ß√£o com usu√°rios n√£o t√©cnicos. O esquema conceitual de alto n√≠vel tamb√©m pode ser utilizado como uma refer√™ncia para garantir que todos os requisitos de dados dos usu√°rios sejam atendidos e que n√£o estejam em conflito. Essa t√©cnica permite que os projetistas de banco de dados se concentrem em especificar as propriedades dos dados, sem se preocuparem com detalhes de armazenamento e implementa√ß√£o. Isso torna mais f√°cil criar um bom projeto de banco de dados conceitual.

Durante ou ap√≥s o projeto do esquema conceitual, as opera√ß√µes b√°sicas do modelo de dados podem ser usadas para especificar as consultas e opera√ß√µes do usu√°rio de alto n√≠vel, identificadas durante a an√°lise funcional. Isso tamb√©m serve para confirmar se o esquema conceitual atende a todos os requisitos funcionais identificados. Modifica√ß√µes no esquema conceitual podem ser introduzidas, se alguns requisitos funcionais n√£o puderem ser especificados usando o esquema inicial.

A pr√≥xima etapa no projeto de banco de dados √© a implementa√ß√£o real do pr√≥prio banco de dados, usando um SGBD comercial. A maioria dos SGBDs comerciais utiliza um modelo de dados de implementa√ß√£o - como o modelo de banco de dados relacional ou objeto-relacional -, de modo que o esquema conceitual √© transformado do modelo de dados de alto n√≠vel para o modelo de dados da implementa√ß√£o. Essa etapa √© chamada de projeto l√≥gico ou mapeamento do modelo de dados . Seu resultado √© um esquema de banco de dados no modelo de dados da implementa√ß√£o do SGBD. O mapeamento do modelo de dados normalmente  √©  automatizado  ou  semiautomatizado nas ferramentas de projeto do banco de dados.

A √∫ltima etapa √© a fase do projeto f√≠sico , durante a qual as estruturas de armazenamento internas, organiza√ß√µes de arquivo, √≠ndices, caminhos de acesso e par√¢metros f√≠sicos do projeto para os arquivos do banco de dados s√£o especificados. Em paralelo com essas atividades, os programas de aplica√ß√£o s√£o projetados e implementados como transa√ß√µes de banco de dados correspondentes √†s especifica√ß√µes da transa√ß√£o de alto n√≠vel. Discutiremos o processo de projeto do banco de dados com mais detalhes no Cap√≠tulo 10.

Figura 7.1 Um diagrama simplificado para ilustrar as principais fases do projeto de banco de



dados.

Neste cap√≠tulo, apresentamos apenas os conceitos b√°sicos do modelo ER para o projeto do esquema conceitual. Outros conceitos de modelagem ser√£o discutidos no Cap√≠tulo 8, quando apresentaremos o modelo EER.

registra os funcion√°rios, departamentos e projetos de uma empresa. Suponha que, depois da fase de levantamento e an√°lise de requisitos, os projetistas de banco de dados ofere√ßam a seguinte descri√ß√£o do minimundo - a parte da empresa que ser√° representada no banco de dados:

## 7.2 Exemplo de aplica√ß√£o de banco de dados

Nesta se√ß√£o, descrevemos um exemplo de aplica√ß√£o de banco de dados, chamado EMPRESA ,  que serve  para  ilustrar  os  conceitos  b√°sicos  do  modelo ER e seu uso no projeto do esquema. Listamos os requisitos de dados para o banco de dados aqui, e depois  criaremos  seu  esquema  conceitual  passo  a passo, quando introduzirmos os conceitos de modelagem do modelo ER. O banco de dados EMPRESA

- ¬Ñ A  empresa  √©  organizada  em  departamentos. Cada departamento tem um nome exclusivo, um n√∫mero exclusivo e um funcion√°rio em particular que o gerencia. Registramos a data inicial em que esse funcion√°rio come√ßou a gerenciar o departamento. Um departamento pode ter v√°rios locais.
- ¬Ñ Um departamento controla uma s√©rie de projetos, cada um deles com um nome exclusivo, um n√∫mero exclusivo e um local exclusivo.

- ¬Ñ Armazenamos  o  nome,  n√∫mero  do  Cadastro de Pessoa F√≠sica, 2 endere√ßo, sal√°rio, sexo (g√™nero) e data de nascimento de cada funcion√°rio. Um funcion√°rio √© designado para um  departamento,  mas  pode  trabalhar  em v√°rios  projetos,  que  n√£o  necessariamente s√£o controlados pelo mesmo departamento. Registramos o n√∫mero atual de horas por semana que um funcion√°rio trabalha em cada projeto.  Tamb√©m  registramos  o  supervisor direto de cada funcion√°rio (que √© outro funcion√°rio).
- ¬Ñ Queremos  registrar  os  dependentes  de  cada funcion√°rio para fins de seguro. Para cada dependente, mantemos o nome, sexo, data de nascimento e parentesco com o funcion√°rio.

A Figura 7.2 mostra como o esquema para essa aplica√ß√£o  de  banco  de  dados  pode  ser  exibido  por meio da nota√ß√£o gr√°fica conhecida como diagramas ER .  Essa figura ser√° explicada gradualmente √† medida que os conceitos do modelo ER forem apresentados. Descrevemos o processo passo a passo da deriva√ß√£o desse esquema com base nos requisitos declarados e explicamos a nota√ß√£o diagram√°tica ER - √† medida que introduzirmos os conceitos do modelo ER.

## 7.3 Tipos de entidade, conjuntos de entidades, atributos e chaves

O modelo ER descreve os dados como entidades , relacionamentos e atributos .  Na  Se√ß√£o  7.3.1, apresentamos os conceitos de entidades e seus atributos. Discutimos os tipos de entidade e os principais atributos na Se√ß√£o 7.3.2. Depois, na Se√ß√£o 7.3.3, especificamos  o  projeto  conceitual  inicial  dos  tipos de  entidade  para  o  banco  de  dados EMPRESA .  Os relacionamentos s√£o descritos na Se√ß√£o 7.4.

Figura 7.2



Um diagrama de esquema ER para o banco de dados EMPRESA. A nota√ß√£o diagram√°tica √© apresentada gradualmente no decorrer do cap√≠tulo e resumida na Figura 7.14.

2 O n√∫mero do Cadastro de Pessoa F√≠sica (CPF) √© um identificador exclusivo de onze d√≠gitos, atribu√≠do a cada indiv√≠duo no Brasil, para registrar seu emprego, benef√≠cios e impostos. Outros pa√≠ses possuem esquemas de identifica√ß√£o semelhantes, como n√∫meros do Seguro Social (SSN) e identifica√ß√£o civil.

## 7.3.1 Entidades e atributos

Entidades e seus atributos . O objeto b√°sico que o modelo ER representa √© uma entidade , que √© algo no mundo  real  com  uma  exist√™ncia  independente.  Uma entidade pode ser um objeto com uma exist√™ncia f√≠sica (por exemplo, uma pessoa em particular, um carro, uma casa ou um funcion√°rio), ou pode ser um objeto com uma exist√™ncia conceitual (por exemplo, uma empresa, um cargo ou um curso universit√°rio). Cada entidade possui atributos - as propriedades espec√≠ficas que a descrevem. Por exemplo, uma entidade FUNCIONARIO pode ser descrita pelo nome, idade, endere√ßo, sal√°rio e cargo do funcion√°rio. Uma entidade em particular ter√° um valor para cada um de seus atributos. Os  valores  de  atributo  que  descrevem  cada  entidade tornam-se uma parte importante dos dados armazenados no banco de dados.

A Figura 7.3 mostra duas entidades e os valores de seus atributos. A entidade FUNCIONARIO f 1 tem quatro atributos: Nome Endereco Idade , , e Telefone\_residencial ; seus valores s√£o 'Jo√£o Silva,' 'Rua das Flores, 751, S√£o Paulo, SP, 07700110', '55' e '13-4749-2630', respectivamente. A entidade EMPRESA e 1 tem tr√™s atributos: Nome , Matriz e Presidente ; seus valores s√£o 'Companhia Modelo', 'S√£o Paulo' e 'Jo√£o Silva', respectivamente.

V√°rios tipos de atributos ocorrem no modelo ER: simples versus composto , valor √∫nico versus multivalorado ,  e armazenado versus derivado .  Primeiro, vamos definir esses tipos de atributo e ilustrar seu uso por meio de exemplos. Depois, discutiremos o conceito de um valor NULL para um atributo.

Atributos compostos versus simples (at√¥micos) . Atributos compostos podem ser divididos em subpartes menores, que representam atributos mais b√°sicos, com significados independentes. Por exemplo, o atributo Logradouro da entidade FUNCIONARIO mostrada na Figura 7.3 pode ser subdividido em Logradouro ,

Cidade , Estado e Cep , 3 com os valores 'Rua das Flores, 751', 'S√£o Paulo', 'SP' e '07700110.' Os atributos n√£o divis√≠veis s√£o chamados atributos simples ou at√¥micos . Os  atributos  compostos  podem  formar uma hierarquia; por exemplo, Logradouro pode  ser subdividido em tr√™s atributos simples: Numero , Rua e Numero\_apartamento , como mostra a Figura 7.4. O valor de um atributo composto √© a concatena√ß√£o dos valores de seus componentes atributos simples.

Atributos compostos s√£o √∫teis para modelar situa√ß√µes em que um usu√°rio √†s vezes se refere ao atributo composto como uma unidade, mas outras vezes se refere especificamente a seus componentes. Se o atributo composto for referenciado apenas como um todo, n√£o √©  necess√°rio  subdividi-lo  em  atributos  componentes. Por  exemplo,  se  n√£o  for  preciso  referenciar  os  componentes individuais de um endere√ßo (CEP, rua etc.), ent√£o o endere√ßo inteiro pode ser designado como um atributo simples.

Atributos de valor √∫nico versus multivalorados . A maioria dos atributos possui  um valor  √∫nico  para uma entidade em particular; tais atributos s√£o chamados de valor √∫nico . Por exemplo, Idade √© um atributo de valor √∫nico de uma pessoa. Em alguns casos, um atributo pode ter um conjunto de valores para a mesma entidade - por exemplo, um atributo Cores para um carro, ou um atributo Formacao\_academica para uma pessoa. Os carros com uma cor t√™m um √∫nico valor, enquanto os carros com duas cores possuem dois valores de cor. De modo semelhante, uma pessoa pode n√£o ter forma√ß√£o acad√™mica, outra pessoa pode ter, e uma terceira pode ter duas ou mais forma√ß√µes; portanto, diferentes pessoas podem ter distintos n√∫meros de valores para o atributo Formacao\_academica .  Esses  atributos s√£o chamados de multivalorados . Um atributo multivalorado pode ter um limite m√≠nimo e um m√°ximo para restringir o n√∫mero de valores permitidos para cada entidade individual. Por exemplo, o atributo Cores de

Figura 7.3 Duas entidades, FUNCIONARIO   e EMPRESA f e , e seus atributos.



1 1

3 CEP (C√≥digo de Endere√ßamento Postal) √© o nome usado no Brasil para um c√≥digo postal com oito d√≠gitos, como 07601-090.

Figura 7.4 Uma hierarquia de atributos compostos.



um carro pode ser restrito a ter entre um e tr√™s valores, se considerarmos que um carro pode ter no m√°ximo tr√™s cores.

Atributos armazenados versus derivados . Em alguns casos, dois (ou mais) valores de atributo est√£o relacionados - por exemplo, os atributos Idade e Data\_nascimento de  uma  pessoa.  Para  uma entidade  de  pessoa  em  particular,  o  valor  de Idade pode ser determinado pela data atual (hoje) e o valor da Data\_nascimento dessa  pessoa.  O  atributo Idade , portanto, √© chamado de atributo derivado e considerado deriv√°vel do atributo Datanasc , que √© chamado, por sua vez, de atributo armazenado . Alguns valores de atributo podem ser derivados de entidades relacionadas ; por exemplo, um atributo Numero\_funcionarios de uma entidade DEPARTAMENTO pode ser derivado contando-se o n√∫mero de funcion√°rios relacionados a (trabalhando para) esse departamento .

{Endere√ßo\_telefone( {Telefone(Codigo\_area, Numero\_telefone)},Endereco(Logradouro (Numero,Rua,Numero\_apartamento),Cidade,Estado,Cep) )}

Figura 7.5

Um atributo complexo: Endere√ßo\_telefone .

ainda em mais dois casos. O primeiro caso acontece quando se sabe que o valor do atributo existe, mas est√° faltando - por exemplo, se o atributo Altura de uma pessoa for listado como NULL . O segundo caso surge quando n√£o se sabe se o valor do atributo existe - por exemplo, se o atributo Telefone\_residencial de uma pessoa for NULL .

Atributos complexos . Observe que, em geral, os atributos compostos e multivalorados podem ser aninhados arbitrariamente. Podemos representar o aninhamento arbitr√°rio ao agrupar componentes de um atributo composto entre par√™nteses ( ) e separ√°-los com v√≠rgulas, e ao exibir os atributos multivalorados entre chaves { }. Esses atributos s√£o chamados de atributos complexos . Por exemplo, se uma pessoa pode ter mais de uma resid√™ncia e cada resid√™ncia pode ter um √∫nico endere√ßo e  v√°rios  telefones,  um  atributo Endere√ßo\_telefone para uma pessoa pode ser especificado como na Figura 7.5. 4  Tanto Telefone quanto Endereco s√£o atributos compostos.

## 7.3.2 Tipos de entidade, conjuntos de entidade, chaves e conjuntos de valores

Valores NULL . Em alguns casos, uma entidade em particular pode n√£o ter um valor aplic√°vel para um atributo. Por exemplo, o atributo Numero\_apar -tamento de um endere√ßo s√≥ se aplica a endere√ßos que est√£o em pr√©dios de apartamento, e n√£o a outros tipos de resid√™ncias, como casas. De modo semelhante, um atributo Formacao\_academica s√≥ se aplica a pessoas com esse tipo de forma√ß√£o. Para tais situa√ß√µes, foi  criado  um  valor  especial,  chamado NULL .  Um endere√ßo de uma casa teria NULL para seu atributo Numero\_apartamento ,  e  uma  pessoa  sem  forma√ß√£o acad√™mica  teria NULL para Formacao\_academica . NULL tamb√©m pode ser usado quando n√£o conhecemos o valor de um atributo para determinada entidade - por exemplo, se n√£o soubermos o n√∫mero do telefone residencial de 'Jo√£o Silva' na Figura 7.3. O significado do primeiro tipo de NULL √© n√£o aplic√°vel , enquanto o significado do segundo √© desconhecido . A categoria desconhecido de NULL pode ser classificada

Tipos de entidade e conjuntos de entidade . Um banco de dados em geral cont√©m grupos de entidades que s√£o semelhantes. Por exemplo, uma empresa que  emprega  centenas  de  funcion√°rios  pode  querer armazenar  informa√ß√µes  semelhantes  com  rela√ß√£o  a cada um dos funcion√°rios. Essas entidades de funcion√°rio compartilham os mesmos atributos, mas cada uma tem o(s) pr√≥prio(s) valor(es) para cada atributo. Um tipo de entidade define uma cole√ß√£o (ou conjunto ) de entidades que t√™m os mesmos atributos. Cada tipo de entidade no banco de dados √© descrito por seu nome e atributos. A Figura 7.6 mostra dois tipos de entidade: FUNCIONARIO e EMPRESA ,  e  uma lista de alguns dos atributos para cada um. Algumas entidades individuais de cada tipo tamb√©m s√£o ilustradas, junto com os valores de seus atributos. A cole√ß√£o de todas as entidades de determinado tipo de entidade no banco de dados, em qualquer ponto no tempo, √© chamada de conjunto de entidades . Normalmente, refere-se ao conjunto de entidades para usar o mesmo nome do

4 Para aqueles acostumados com XML, devemos observar que os atributos complexos s√£o semelhantes aos elementos complexos em XML (ver Cap√≠tulo 12).



Dois tipos de entidade, , e algumas entidades membro de cada uma.

Figura 7.6 FUNCIONARIO e EMPRESA

tipo de entidade. Por exemplo, FUNCIONARIO refere-se ao tipo de entidade e tamb√©m ao conjunto atual de todas as entidades de funcion√°rio no banco de dados.

Um tipo de entidade √© representado nos diagramas ER 5  (ver Figura 7.2) como uma caixa retangular delimitando seu nome. Os nomes de atributo s√£o delimitados em ovais, sendo ligados a seu tipo de entidade por linhas retas. Os atributos compostos s√£o ligados aos seus atributos componentes por linhas retas. Os atributos multivalorados aparecem em ovais duplas. A Figura 7.7(a) mostra um tipo de entidade CARRO nessa nota√ß√£o.

Um tipo de entidade descreve o esquema ou conota√ß√£o para um conjunto de entidades que compartilham a mesma estrutura. A cole√ß√£o de entidades de determinado tipo √© agrupada em um conjunto de entidades, que tamb√©m √© chamado de extens√£o do tipo de entidade.

sica). √Äs vezes, v√°rios atributos juntos formam uma chave,  significando  que  a combina√ß√£o dos  valores de atributo deve ser distinta para cada entidade. Se um conjunto de atributos  possui  essa  propriedade, o  modo correto de representar isso  no  modelo  ER que descrevemos aqui √© definir um atributo composto e  design√°-lo como um atributo-chave do tipo de entidade. Observe que essa chave composta precisa ser m√≠nima , ou seja, todos os atributos componentes precisam estar inclu√≠dos no atributo composto para ter a propriedade de exclusividade. Atributos sup√©rfluos n√£o devem ser inclu√≠dos em uma chave. Na nota√ß√£o diagram√°tica ER, cada atributo-chave tem seu nome sublinhado dentro da oval, conforme ilustrado na Figura 7.7(a).

Atributos-chave de um tipo de entidade . Uma restri√ß√£o importante das entidades de um tipo de entidade √© a chave ou restri√ß√£o de exclusividade sobre os atributos. Um tipo de entidade normalmente tem um ou mais atributos cujos valores s√£o distintos para cada entidade individual no conjunto de entidades. Esse  atributo  √©  denominado atributo-chave ,  e  seus valores podem ser usados para identificar cada entidade de maneira exclusiva. Por exemplo, o atributo Nome √©  uma  chave  do  tipo  de  entidade EMPRESA na Figura 7.6, pois duas empresas n√£o podem ter o mesmo nome. Para o tipo de entidade PESSOA , um atributo-chave t√≠pico √© o Cpf (Cadastro de Pessoa F√≠-

Especificar que um atributo √© uma chave de um tipo de entidade significa que a propriedade anterior da exclusividade precisa ser mantida para cada conjunto de entidades do tipo de entidade. Logo, essa √© uma restri√ß√£o que pro√≠be que duas entidades tenham o mesmo valor para o atributo-chave ao mesmo tempo. Essa n√£o √© a propriedade de um conjunto de entidades em particular; em vez disso, √© uma restri√ß√£o sobre qualquer conjunto de entidades do tipo de entidade em qualquer ponto no tempo. Essa restri√ß√£o-chave  (e  outras  restri√ß√µes  que  discutiremos  mais adiante) √© derivada das restri√ß√µes do minimundo que o banco de dados representa.

Alguns tipos de entidade possuem mais de um atributo-chave. Por exemplo, cada um dos atributos Cod\_veiculo e Registro do tipo de entidade CAR-

5 Usamos a nota√ß√£o para diagramas ER, a qual √© pr√≥xima da nota√ß√£o da proposta original (Chen, 1976). Muitas outras nota√ß√µes est√£o em uso; ilustraremos algumas delas mais adiante neste cap√≠tulo, quando apresentarmos os diagramas de classe UML, e no Ap√™ndice A.

(a)

(b)

CARRO Registro (Numero, Estado), Cod\_veiculo, Marca, Modelo, Ano, {Cor}



CARRO1

((ITU, ABC 1234), TKO6290, Volkswagen Gol, 2004 {vermelho, preto})

CARRO2

((ITATIAIA, ABC 1234), WPL9872, Chevrolet Corsa, 4 portas, 2005, {azul})

CARRO3

((SANTOS, VSY 7200), TDD7299, Ford Ka, 4 portas, 2002, {branco, azul})

## Figura 7.7

O tipo de entidade CARRO com dois atributos-chave, Registro e Co d\_veiculo. (a) Nota√ß√£o do diagrama ER. (b) Conjunto de entidade com tr√™s entidades.

RO (Figura 7.7) √© uma chave por si s√≥. O atributo Registro √©  um  exemplo  de  uma  chave  composta formada por dois atributos componentes simples, Estado e Numero ,  nenhum deles sendo uma chave por si s√≥. Um tipo de entidade tamb√©m pode n√£o ter chave ; nesse caso, ele √© chamado de tipo de entidade fraca (ver Se√ß√£o 7.5).

Em nossa nota√ß√£o diagram√°tica, se dois atributos forem sublinhados separadamente, ent√£o cada um √© uma chave por si s√≥ . Diferentemente do modelo relacional (ver Se√ß√£o 3.2.2), n√£o existe o conceito de chave prim√°ria no modelo ER que apresentamos aqui; a chave prim√°ria ser√° escolhida durante o mapeamento para um esquema relacional (ver Cap√≠tulo 9).

Conjuntos (dom√≠nios) de valores dos atributos . Cada atributo simples de um tipo de entidade √© associado a um conjunto de valores (ou dom√≠nio de valores), o qual especifica o conjunto de valores que podem ser designados a esse atributo para cada entidade individual. Na Figura 7.6, se o intervalo de idades permitidas para os funcion√°rios estiver entre 16 e  70,  podemos  especificar  o  conjunto  de  valores do atributo Idade de FUNCIONARIO como sendo o conjunto de n√∫meros inteiros entre 16 e 70. De modo semelhante, podemos especificar o conjunto de valores para o atributo Nome como sendo o conjunto de cadeias de caracteres alfab√©ticos separados por  caracteres  de  espa√ßo,  e  assim  por  diante.  Os conjuntos de valores n√£o s√£o exibidos nos diagramas ER, e s√£o com frequ√™ncia especificados usando os tipos de dados b√°sicos dispon√≠veis na maioria das linguagens de programa√ß√£o, como inteiro, cadeia de caracteres,  booleano,  real,  tipo  enumerado,  intervalo de valores, e assim por diante. Outros tipos de dados que representam tipos comuns no banco de dados, como  data,  hora  e  outros  conceitos,  tamb√©m  s√£o empregados. Matematicamente, um atributo A do conjunto de entidades E, cujo conjunto de valores √© V, pode ser definido como uma fun√ß√£o de E ao conjunto de pot√™ncia 6 P V ( ) de V :

<!-- formula-not-decoded -->

Referimo-nos  ao  valor  do  atributo A para  a entidade e como A e ( ).  A  defini√ß√£o  anterior cobre tanto  atributos  de  √∫nico  valor  quanto  atributos multivalorados, bem como NULL s. Um valor NULL √© representado pelo conjunto vazio . Para atributos de  √∫nico  valor, A e ( )  √©  restrito  a  ser  um conjunto

6 O conjunto de pot√™ncia P V ( ) de um conjunto V √© o conjunto de todos os subconjuntos de V .

singular 7 para cada entidade e em E ,  ao passo que n√£o existe restri√ß√£o sobre atributos multivalorados. Para um atributo composto A , o conjunto de valores V √© o conjunto de pot√™ncia do produto Cartesiano de P V ( 1 ), P V ( 2 ), ..., P V ( n ), onde V 1 , V 2 , ..., V n s√£o os conjuntos de valores dos atributos componentes simples que formam A :

<!-- formula-not-decoded -->

O conjunto de valores oferece todos os valores poss√≠veis. Em geral, apenas um pequeno n√∫mero desses valores existe no banco de dados em determinado momento. Esses valores representam os dados do estado atual do minimundo. Eles correspondem aos dados conforme realmente existem no minimundo.

## 7.3.3 Projeto conceitual inicial do banco de dados EMPRESA

Agora, podemos definir os tipos de entidade para o banco de dados EMPRESA , com base nos requisitos descritos na Se√ß√£o 7.2. Ap√≥s definir aqui v√°rios tipos de entidade e seus atributos, refinamos nosso projeto na Se√ß√£o 7.4, depois de introduzir o conceito de um relacionamento. De acordo com os requisitos listados na Se√ß√£o 7.2, podemos identificar quatro tipos de entidade - uma correspondente a cada um dos quatro itens na especifica√ß√£o (ver Figura 7.8):

- 1. Um  tipo  de  entidade DEPARTAMENTO com atributos Nome , Numero , Localizacoes , Gerente e Data\_inicio\_gerente  Localizacoes . √© o √∫nico atributo  multivalorado.  Podemos  especificar que tanto Nome quanto Numero s√£o atributos-chave (separados), pois cada um foi especificado como sendo exclusivo.
- 2. Um tipo de entidade PROJETO com atributos Nome Numero , , Localizacao e Departamento\_ge -renciador . Tanto Nome quanto Numero s√£o atributos-chave (separados).
- 3. Um tipo de entidade FUNCIONARIO com atributos Nome , Cpf Sexo , , Endereco Salario , , Data\_ nascimento  Departamento , e Supervisor .  Tanto Nome quanto Endereco podem  ser  atributos compostos; no entanto, isso n√£o foi especificado nos requisitos. Temos de voltar aos usu√°rios para ver se algum deles ir√° se referir aos componentes individuais de Nome -Primeiro\_nome , Inicial\_meio , Ultimo\_nome - ou de Endereco .

At√©  aqui,  n√£o  representamos  o  fato  de  que  um funcion√°rio  pode  trabalhar  em  v√°rios  projetos  nem o  n√∫mero  de  horas  por  semana  que  um  funcion√°rio trabalha em cada projeto. Essa caracter√≠stica √© listada como parte do terceiro requisito na Se√ß√£o 7.2, e pode ser  representada  por  um  atributo  composto  multivalorado de FUNCIONARIO , chamado Trabalha\_em , com os componentes simples ( Projeto , Horas ).  Como alternativa,  ela  pode  ser  representada  como  um  atributo composto multivalorado de PROJETO , chamado Traba -lhadores , com os componentes simples ( Funcionario , Horas ). Escolhemos a primeira alternativa na Figura 7.8, que mostra cada um dos tipos de entidade descritos. O atributo Nome de FUNCIONARIO aparece como um atributo composto, aparentemente ap√≥s a consulta com os usu√°rios.









## Figura 7.8

- 4. Um tipo de entidade DEPENDENTE com atributos Funcionario , Nome\_dependente Sexo Data\_ , , nascimento e Parentesco (para o funcion√°rio).

Projeto preliminar de tipos de entidade para o banco de dados EMPRESA . Alguns dos atributos mostrados ser√£o refinados nos relacionamentos.

7 Um conjunto singular (ou singleton ) √© um conjunto com apenas um elemento (valor).

## 7.4 Tipos e conjuntos de relacionamentos, pap√©is e restri√ß√µes estruturais

Na Figura 7.8 existem v√°rios relacionamentos impl√≠citos entre os diversos tipos de entidade. De fato, sempre  que  um  atributo  de  um  tipo  de  entidade  se refere a outro tipo de entidade, existe algum relacionamento. Por exemplo, o atributo Gerente de DEPARTAMENTO refere-se a um funcion√°rio que gerencia o departamento;  o  atributo Departamento\_gerenciador de PROJETO refere-se ao departamento que controla o projeto; o atributo Supervisor de FUNCIONARIO refere-se a outro funcion√°rio (aquele que supervisiona esse funcion√°rio); o atributo Departamento de FUNCIONARIO refere-se ao departamento para o qual o funcion√°rio trabalha, e assim por diante. No modelo ER, essas refer√™ncias n√£o devem ser representadas como atributos,  mas  como relacionamentos ,  que  s√£o  discutidos nesta se√ß√£o. O esquema do banco de dados EMPRESA ser√° refinado na Se√ß√£o 7.6 para representar relacionamentos de maneira expl√≠cita. No projeto inicial dos tipos  de  entidade,  os  relacionamentos  normalmente s√£o capturados na forma de atributos. √Ä medida que o projeto √© refinado, esses atributos s√£o convertidos em relacionamentos entre os tipos de entidade.

Este  t√≥pico  √©  organizado  da  seguinte  forma:  a Se√ß√£o 7.4.1 apresenta os conceitos dos tipos, conjuntos e inst√¢ncias de relacionamento. Definimos os conceitos de grau de relacionamento, nomes de fun√ß√£o e relacionamentos recursivos na Se√ß√£o 7.4.2, e depois discutimos as restri√ß√µes estruturais sobre os relacionamentos - como as  raz√µes  de  cardinalidade  e  depend√™ncias  de  exist√™ncia  na Se√ß√£o 7.4.3. A Se√ß√£o 7.4.4 mostra como os tipos de relacionamento tamb√©m podem ter atributos.

## 7.4.1 Tipos, conjuntos e inst√¢ncias de relacionamento

Um tipo  de  relacionamento R entre n tipos  de entidade E 1 , E 2 , ..., E n define um conjunto de associa√ß√µes - ou um conjunto de relacionamento - entre as entidades desses tipos de entidade. Assim como no caso dos tipos de entidade e conjuntos de entidade, um tipo de relacionamento e seu conjunto de relacionamento correspondente em geral s√£o referenciados pelo mesmo nome R , . Matematicamente, o conjunto de relacionamento R √© um conjunto de inst√¢ncias de relacionamento r , i onde  cada r i associa-se a n entidades  individuais  ( e 1 , e 2 ,  ..., e n ),  e  cada  entidade e j em r i √© um membro do conjunto de entidades E j , 1 ‚â§ j ‚â§ n . Logo, um conjunto de relacionamento √© uma rela√ß√£o matem√°tica sobre E 1 , E 2 , ..., E n . Como alternativa, ele pode ser definido como um subconjunto do produto cartesiano dos conjuntos de entidades E 1 √ó E 2 √ó ... √ó E n . Cada um dos tipos de entidade E  E 1 , 2 , ..., E n √© dito participar no tipo de relacionamento R ; de modo semelhante, cada uma das entidades individuais e 1 , e 2 , ..., e n √© dito participar na inst√¢ncia de relacionamento r i = ( e 1 , e 2 , ..., e n ).

Informalmente, cada inst√¢ncia de relacionamento r i em R √©  uma  associa√ß√£o  de  entidades,  onde  a associa√ß√£o inclui exatamente uma entidade de cada tipo de entidade participante. Cada inst√¢ncia de relacionamento r i desse tipo representa o fato de que as entidades  participantes  em r i est√£o  relacionadas  de alguma maneira na situa√ß√£o do minimundo correspondente. Por exemplo, considere um tipo de relacionamento TRABALHA\_PARA entre os dois tipos de entidade FUNCIONARIO e DEPARTAMENTO , que associa cada funcion√°rio ao departamento para o qual o funcion√°rio  trabalha  no  conjunto  de  entidades  correspondente. Cada inst√¢ncia de relacionamento no conjunto de relacionamentos TRABALHA\_PARA associa uma entidade FUNCIONARIO a uma entidade DEPARTAMENTO. A Figura 7.9 ilustra esse exemplo, onde cada  inst√¢ncia  de  relacionamento r i aparece  conectada √†s entidades FUNCIONARIO e DEPARTAMENTO que participam em r i .  No minimundo representado pela Figura 7.9, os funcion√°rios f 1 , f 3 e f 6 trabalham para o departamento d 1 ; os funcion√°rios f 2 e f 4 trabalham para o departamento d 2 ; e os funcion√°rios f 5 e f 7 trabalham para o departamento d 3 .

Figura 7.9



Algumas inst√¢ncias no conjunto de relacionamentos TRABALHA\_PARA, que representa um tipo de relacionamento TRABALHA\_PARA entre FUNCIONARIO e DEPARTAMENTO.

Nos diagramas ER, os tipos de relacionamento s√£o exibidos como caixas em forma de losango, que s√£o conectadas por linhas retas √†s caixas retangulares que representam os tipos de entidade participantes. O nome do relacionamento √© exibido na caixa em forma de losango (ver Figura 7.2).

## 7.4.2 Grau de relacionamento, nomes de fun√ß√£o e relacionamentos recursivos

Grau de um tipo de relacionamento. O grau de um tipo de relacionamento √© o n√∫mero dos tipos de entidade participantes. Logo, o relacionamento TRA-BALHA\_PARA tem  grau  dois.  Um  tipo  de  relacionamento de grau dois √© chamado de bin√°rio , e um tipo de grau tr√™s √© chamado de tern√°rio . Um exemplo de relacionamento tern√°rio √© FORNECE , mostrado na Figura 7.10, em que  cada inst√¢ncia de relacionamento r i associa tr√™s entidades - um fornecedor  , uma pe√ßa f p e um projeto   - sempre que   fornece a pe√ßa j f p ao projeto j .  Os relacionamentos geralmente podem ser de qualquer grau, mas os mais comuns s√£o os relacionamentos bin√°rios. Relacionamentos de grau mais alto geralmente s√£o mais complexos do que os bin√°rios. N√≥s os caracterizaremos mais adiante, na Se√ß√£o 7.9.

Figura 7.10



Algumas inst√¢ncias de relacionamento no conjunto de relacionamento tern√°rio FORNECE.

Relacionamentos como atributos. √Äs vezes, √© conveniente  pensar  em  um  tipo  de  relacionamento bin√°rio em termos de atributos, conforme discutimos na Se√ß√£o 7.3.3. Considere o tipo de relacionamento TRABALHA\_PARA da Figura 7.9. Pode-se pensar em um atributo chamado Departamento do tipo de entidade FUNCIONARIO , em que o valor do Departamento para cada entidade FUNCIONARIO √© a (uma refer√™ncia √†) entidade DEPARTAMENTO para a qual esse funcion√°rio  trabalha.  Logo,  o  conjunto  de  valores para esse atributo Departamento √© o conjunto de todas as entidades DEPARTAMENTO , que √© o conjunto de entidades DEPARTAMENTO .  Foi isso que fizemos na Figura 7.8, quando especificamos o projeto inicial do tipo de entidade FUNCIONARIO para o banco de  dados EMPRESA .  Por√©m,  quando  pensamos  em um relacionamento bin√°rio como um atributo, sempre temos duas op√ß√µes. Neste exemplo, a alternativa √© pensar em um atributo multivalorado Funcionario do tipo de entidade DEPARTAMENTO, cujos valores para cada entidade DEPARTAMENTO √© o conjunto de entidades de FUNCIONARIO que trabalham para esse departamento. O conjunto de valores desse atributo Funcionario √© o conjunto de pot√™ncia do conjunto de entidades FUNCIONARIO .  Qualquer  um  desses  dois atributos Departamento de FUNCIONARIO ou Funcionario de DEPARTAMENTO - pode representar  o tipo de relacionamento TRABALHA\_PARA . Se os dois forem representados, eles s√£o restringidos a serem o inverso um do outro. 8

Nomes  de  fun√ß√£o  e  relacionamentos  recursivos. Cada tipo de entidade que participa de um tipo de relacionamento desempenha nele uma fun√ß√£o em particular. O nome da fun√ß√£o significa a fun√ß√£o que uma entidade participante do tipo de entidade desempenha em cada inst√¢ncia de relacionamento, e ajuda a explicar o que o relacionamento significa. Por exemplo, no tipo de  relacionamento TRABALHA\_PARA , FUNCIONARIO desempenha a fun√ß√£o de funcion√°rio ou trabalhador , e DEPARTAMENTO desempenha a fun√ß√£o de departamento ou empregador .

Os nomes de fun√ß√£o n√£o s√£o tecnicamente necess√°rios nos tipos de relacionamento em que todos os tipos de entidade participantes s√£o distintos, pois o nome de cada tipo de entidade participante pode ser usado como nome de fun√ß√£o. Contudo, em algumas ocasi√µes, o mesmo tipo de entidade participa mais de uma vez em um tipo de relacionamento em fun√ß√µes diferentes . Nesses casos, o nome da fun√ß√£o torna-se essencial para distinguir o significado da fun√ß√£o que cada entidade

8 Esse conceito de representar os tipos de relacionamento como atributos √© usado em uma classe de modelos de dados chamada modelos de dados funcionais . Nos bancos de dados de objeto (ver Cap√≠tulo 11), os relacionamentos podem ser representados por atributos de refer√™ncia, seja em uma dire√ß√£o ou nas duas dire√ß√µes como inversos. Em bancos de dados relacionais (ver Cap√≠tulo 3), as chaves estrangeiras s√£o um tipo de atributo de refer√™ncia usado para representar relacionamentos.

FUNCIONARIO

Um relacionamento recursivo SUPERVISAO entre FUNCIONARIO no papel de supervisor (1) e FUNCIONARIO no papel



Figura 7.11 de subordinado (2).

9 N significa qualquer n√∫mero de entidades relacionadas (zero ou mais).

participante  desempenha.  Esses  tipos  de  relacionamento s√£o chamados de relacionamentos recursivos . A Figura 7.11 mostra um exemplo. O tipo de relacionamento SUPERVISAO relaciona um funcion√°rio a um supervisor, no qual as entidades funcion√°rio e supervisor  s√£o  membros  do  mesmo  conjunto  entidade FUNCIONARIO . Logo, o tipo de entidade FUNCIONARIO participa  duas  vezes na SUPERVISAO : uma vez no papel de supervisor (ou chefe )  e  outra no papel de supervisionado (ou subordinado ). Cada inst√¢ncia  de  relacionamento r i na SUPERVISAO associa duas entidades de funcion√°rio f j e f k , uma das quais desempenha a fun√ß√£o de supervisor e a outra, a fun√ß√£o de supervisionado. Na Figura 7.11, as linhas marcadas com '1' representam a fun√ß√£o de supervisor, e aquelas marcadas com '2' representam a fun√ß√£o de supervisionado; assim, f 1 supervisiona f 2 e f 3 , f 4 supervisiona f 6 e f 7 , e f 5 supervisiona f 1 e f 4 . Neste exemplo,  cada  inst√¢ncia  de  relacionamento  precisa ser conectada com duas linhas, uma marcada com '1' (supervisor) e a outra com '2' (supervisionado).

## 7.4.3 Restri√ß√µes sobre tipos de relacionamento bin√°rios

Os tipos de relacionamento costumam ter certas restri√ß√µes que limitam as combina√ß√µes de entidades que podem participar no conjunto de relacionamen- tos  correspondente. Essas restri√ß√µes s√£o determinadas com base na situa√ß√£o do minimundo que os relacionamentos representam. Por exemplo, na Figura 7.9, se a empresa tem uma regra de que cada funcion√°rio precisa trabalhar para exatamente um departamento, ent√£o gostar√≠amos de descrever essa restri√ß√£o no esquema. Podemos distinguir dois tipos principais de  restri√ß√µes  de  relacionamento  bin√°rio: raz√£o  de cardinalidade e participa√ß√£o .

Raz√µes de cardinalidade para relacionamentos bin√°rios. A raz√£o de cardinalidade para um relacionamento bin√°rio especifica o n√∫mero m√°ximo de inst√¢ncias  de  relacionamento  em  que  uma  entidade  pode  participar. Por exemplo, no tipo de relacionamento bin√°rio TRABALHA\_PARA , DEPARTAMENTO:FUNCIONARIO tem  raz√£o  de  cardinalidade  1:N,  significando  que cada departamento pode estar relacionado a (ou seja, emprega)  qualquer  n√∫mero  de  funcion√°rios, 9   mas um funcion√°rio s√≥ pode estar relacionado a (trabalha para) um departamento. Isso significa que, para esse relacionamento TRABALHA\_PARA em particular, uma entidade de departamento em particular pode estar  relacionada  a  qualquer  n√∫mero  de  funcion√°rios (N indica que n√£o existe um n√∫mero m√°ximo). Por sua vez, um funcion√°rio pode estar relacionado no m√°ximo a um √∫nico departamento. As raz√µes de cardinalidade poss√≠veis para tipos de relacionamento bin√°rios s√£o 1:1, 1:N, N:1 e M:N.

Um exemplo de relacionamento bin√°rio 1:1 √© GERENCIA (Figura 7.12), o qual relaciona uma entidade de departamento ao funcion√°rio que gerencia esse departamento. Isso representa as restri√ß√µes do minimundo que - em qualquer ponto no tempo - um funcion√°rio pode gerenciar apenas um departamento e um departamento pode ter apenas um gerente. O tipo de relacionamento TRABALHA\_EM (Figura 7.13) √© de raz√£o de cardinalidade M:N, porque a regra do minimundo √© a de que um funcion√°rio pode trabalhar em v√°rios projetos e um projeto pode ter v√°rios funcion√°rios.

As raz√µes de cardinalidade para relacionamentos bin√°rios s√£o representadas nos diagramas ER exibindo 1,  M  e  N  nos  losangos,  como  mostra  a  Figura 7.2. Observe que, nessa nota√ß√£o, podemos especificar nenhum m√°ximo (N) ou um m√°ximo de um (1) na participa√ß√£o. Uma nota√ß√£o alternativa (ver Se√ß√£o 7.7.4) permite que o projetista especifique um n√∫mero m√°ximo na participa√ß√£o, como 4 ou 5.

Restri√ß√µes de participa√ß√£o e depend√™ncias de exist√™ncia. A restri√ß√£o de participa√ß√£o especifica se a exist√™ncia  de  uma  entidade  depende  dela  estar  relacionada a outra entidade por meio do tipo de relacionamento. Essa restri√ß√£o especifica o n√∫mero m√≠nimo de inst√¢ncias de relacionamento em que cada entidade pode participar, e √†s vezes √© chamada de restri√ß√£o de cardinalidade m√≠nima . Existem dois tipos de restri√ß√µes de participa√ß√£o - total e parcial - que vamos ilustrar.  Se  a  pol√≠tica  de  uma  empresa  afirma  que todo funcion√°rio precisa trabalhar para um departamento, ent√£o  uma  entidade  de  funcion√°rio  s√≥  pode  existir se participar em, pelo menos, uma inst√¢ncia de relacionamento TRABALHA\_PARA (Figura 7.9). Assim, a

Figura 7.12 Um relacionamento 1:1, GERENCIA.



participa√ß√£o de FUNCIONARIO em TRABALHA\_PARA √© chamada de participa√ß√£o total , significando que cada entidade no conjunto total de entidades de funcion√°rio deve estar relacionada a uma entidade de departamento por meio de TRABALHA\_PARA . A participa√ß√£o total tamb√©m √© conhecida como depend√™ncia de exist√™ncia .  Na Figura 7.12, n√£o esperamos que cada funcion√°rio gerencie um departamento, de modo que a  participa√ß√£o  de FUNCIONARIO no  tipo  de  relacionamento GERENCIA √© parcial ,  significando que uma parte  do  conjunto  de entidades  de  funcion√°rio  est√° relacionada a alguma entidade de departamento por meio de GERENCIA , mas n√£o necessariamente todas. Vamos nos referir √† raz√£o de cardinalidade e restri√ß√µes de participa√ß√£o, juntas, como as restri√ß√µes estruturais de um tipo de relacionamento.

Em diagramas ER, a participa√ß√£o total (ou depend√™ncia de exist√™ncia) √© exibida como uma linha dupla que conecta o tipo de entidade participante ao relacionamento,  enquanto  a  participa√ß√£o  parcial  √© representada por uma linha simples (ver Figura 7.2). Observe que, nessa nota√ß√£o, podemos especificar nenhum m√≠nimo (participa√ß√£o parcial) ou um m√≠nimo de um (participa√ß√£o total). A nota√ß√£o alternativa (ver Se√ß√£o 7.7.4) permite que o projetista indique um n√∫mero m√≠nimo espec√≠fico da participa√ß√£o no relacionamento, como 4 ou 5.

Discutiremos  as  restri√ß√µes  sobre  os  relacionamentos de grau mais alto na Se√ß√£o 7.9.

## 7.4.4 Atributos de tipos de relacionamento

Os tipos de relacionamento tamb√©m podem ter atributos, semelhantes √†queles dos tipos de entidade. Por exemplo, para registrar o n√∫mero de horas por semana que um funcion√°rio trabalha em determinado projeto, podemos incluir um atributo Horas para o tipo de relacionamento TRABALHA\_EM na Figura 7.13. Outro exemplo √© incluir a data em que um gerente come√ßou a chefiar um departamento por meio de um atributo Data\_inicio para o tipo de relacionamento GERENCIA na Figura 7.12.

Observe que os atributos dos tipos  de  relacionamento 1:1 ou 1:N podem ser migrados para um dos tipos de entidade participantes. Por exemplo, o atributo Data\_inicio para  o  relacionamento GERENCIA pode ser um atributo de FUNCIONARIO ou de DEPARTAMENTO , embora conceitualmente ele perten√ßa a GERENCIA . Isso porque GERENCIA √© um relacionamento 1:1, de modo que cada entidade de departamento ou funcion√°rio participa de no m√°ximo uma inst√¢ncia de relacionamento. Logo, o valor do atributo Data\_inicio pode ser determinado separadamente,

pela entidade do departamento participante ou pela entidade do funcion√°rio participante (gerente).

Para um tipo de relacionamento 1:N, um atributo de relacionamento pode ser migrado somente para o tipo  de  entidade  no  lado  N  do  relacionamento.  Por exemplo, na Figura 7.9, se o relacionamento TRABA-LHA\_PARA tamb√©m tiver um atributo Data\_inicio que indica  quando um funcion√°rio come√ßou a trabalhar para um departamento, esse atributo pode ser inclu√≠do como um atributo de FUNCIONARIO . Isso porque cada funcion√°rio trabalha para somente um departamento, e por isso participa de, no m√°ximo, uma inst√¢ncia de relacionamento  em TRABALHA\_PARA .  Nos  tipos  de relacionamento 1:1 e 1:N, a decis√£o de onde colocar um atributo de relacionamento - como um atributo de tipo de relacionamento ou como um atributo de um tipo de entidade participante - √© determinada de maneira subjetiva pelo projetista do esquema.

Para tipos de relacionamento M:N, alguns atributos podem ser determinados pela combina√ß√£o de entidades participantes em uma inst√¢ncia de relacionamento, e n√£o por qualquer entidade isolada. Esses atributos precisam ser especificados como atributos de relacionamento. Um exemplo √© o atributo Horas do relacionamento M:N de TRABALHA\_EM (Figura



7.13). O n√∫mero de horas por semana que um funcion√°rio trabalha atualmente em um projeto √© determinado por uma combina√ß√£o funcion√°rio-projeto, e n√£o de maneira separada por qualquer entidade.

## 7.5 Tipos de entidade fraca

Tipos de entidade que n√£o possuem atributos-chave pr√≥prios s√£o chamados tipos de entidade fraca. Ao contr√°rio, os tipos de entidade regulares que n√£o t√™m um atributo-chave - o que inclui todos os exemplos discutidos at√© aqui - s√£o chamados tipos de entidade fortes .  As  entidades  pertencentes  a  um tipo de entidade fraca s√£o identificadas por estarem relacionadas  a  entidades  espec√≠ficas  de  outro  tipo em combina√ß√£o com um de seus valores de atributo. Chamamos esse outro tipo de entidade de tipo de entidade de identifica√ß√£o ou propriet√°rio , 10 e chamamos o tipo de relacionamento que relaciona um tipo de entidade fraca a seu propriet√°rio de relacionamento de identifica√ß√£o do tipo de entidade fraca. 11  Um tipo de entidade fraca sempre tem uma restri√ß√£o de participa√ß√£o  total (depend√™ncia  de  exist√™ncia)  com rela√ß√£o a seu relacionamento de identifica√ß√£o, porque a entidade fraca n√£o pode ser identificada sem uma entidade propriet√°ria. Por√©m, nem toda depend√™ncia de exist√™ncia resulta em um tipo de entidade fraca. Por exemplo, uma entidade CARTEIRA\_MOTO -RISTA n√£o pode existir a menos que esteja relacionada a uma entidade PESSOA , embora tenha a pr√≥pria chave ( Numero\_habilitacao ) e, portanto, n√£o seja uma entidade fraca.

Considere o tipo de entidade DEPENDENTE , relacionado a FUNCIONARIO , que √© usado para registrar os dependentes de cada funcion√°rio por meio de um relacionamento 1:N (Figura 7.2). Em nosso exemplo, os atributos de DEPENDENTE s√£o Nome (o primeiro nome do dependente), Data\_nascimento  Sexo , e Parentesco (com o funcion√°rio). Dois dependentes de dois funcion√°rios distintos podem, por coincid√™ncia, ter os mesmos valores para Nome , Data\_nascimento , Sexo e Parentesco , mas, ainda assim, eles s√£o entidades distintas. Eles s√£o identificados como entidades distintas apenas depois de determinar a entidade de funcion√°rio  em  particular √†  qual  cada  dependente est√° relacionado. Considera-se que cada entidade de funcion√°rio possui as entidades dependentes que est√£o relacionadas a ele.

Figura 7.13 Um relacionamento M:N, TRABALHA\_EM .

Um  tipo  de  entidade  fraca  normalmente  tem uma chave parcial , que √© o atributo que pode iden-

10 O tipo de entidade de identifica√ß√£o √© tamb√©m chamado de tipo de entidade pai , ou tipo de entidade dominante .

11 O tipo de entidade fraca tamb√©m √© chamado de tipo de entidade filho , ou tipo de entidade subordinado .

tificar exclusivamente as entidades fracas que est√£o relacionadas  √†  mesma  entidade  propriet√°ria . 12 Em nosso exemplo, se considerarmos que dois dependentes  do  mesmo  funcion√°rio  n√£o  poder√£o  ter  o mesmo nome, o atributo Nome de DEPENDENTE √© a chave parcial. No pior dos casos, um atributo composto de todos os atributos da entidade fraca ser√° a chave parcial.

Em diagramas ER, tanto um tipo de entidade fraca  quanto  seu  relacionamento  de  identifica√ß√£o s√£o distinguidos ao delimitar suas caixas e losangos com linhas duplas (ver Figura 7.2). O atributo de chave parcial √© sublinhado com uma linha tracejada ou pontilhada.

Os tipos de entidade fraca √†s vezes podem ser representados  como  atributos  complexos  (compostos, multivalorados). No exemplo anterior, poder√≠amos especificar um atributo multivalorado Dependentes para FUNCIONARIO ,  que √© um atributo composto com os atributos componentes Nome , Data\_nascimento , Sexo e Parentesco . A escolha de qual representa√ß√£o usar √© feita  pelo  projetista  de  banco  de  dados.  Um crit√©rio que pode ser usado √© escolher a representa√ß√£o do tipo de entidade fraca se houver muitos atributos. Se a entidade fraca participar independentemente nos tipos de relacionamento al√©m de seu tipo de relacionamento de identifica√ß√£o, ent√£o ela n√£o dever√° ser modelada como um atributo complexo.

Em geral, podemos definir qualquer quantidade de n√≠veis de tipos de entidade fraca; um tipo de entidade propriet√°rio pode ele mesmo ser um tipo de entidade fraca. Al√©m disso, um tipo de entidade fraca pode ter mais de um tipo de entidade de identifica√ß√£o e um tipo de relacionamento de identifica√ß√£o de grau maior que dois, conforme ilustraremos na Se√ß√£o 7.9.

## 7.6 Refinando o projeto ER para o banco de dados EMPRESA

Agora, podemos refinar o projeto de banco de dados da Figura 7.8 alterando os atributos que representam relacionamentos para tipos de relacionamento. A raz√£o de cardinalidade e a restri√ß√£o de participa√ß√£o  de  cada  tipo  de  relacionamento  s√£o determinadas com base nos requisitos listados na Se√ß√£o 7.2. Se alguma delas n√£o puder ser especificada dessa maneira, os usu√°rios ter√£o de ser questionados ainda mais para determinar essas restri√ß√µes estruturais.

Em nosso  exemplo,  especificamos  os  seguintes tipos de relacionamento:

- ¬Ñ GERENCIA , um tipo de relacionamento 1:1 entre FUNCIONARIO e DEPARTAMENTO .  A  participa√ß√£o de FUNCIONARIO √© parcial. A participa√ß√£o de DEPARTAMENTO n√£o √© clara pelos requisitos.  Questionamos  os  usu√°rios,  que dizem que um departamento precisa ter um gerente o tempo todo, o que implica participa√ß√£o total. 13 O atributo Data\_inicio √© atribu√≠do a esse tipo de relacionamento.
- ¬Ñ TRABALHA\_PARA , um tipo de relacionamento 1:N entre DEPARTAMENTO e FUNCIONARIO . As duas participa√ß√µes s√£o totais.
- ¬Ñ CONTROLA , um tipo de relacionamento 1:N entre DEPARTAMENTO e PROJETO . A participa√ß√£o de PROJETO √© total, enquanto a de DEPARTAMENTO √© determinada para ser parcial, depois que os usu√°rios indicaram que alguns departamentos podem n√£o controlar projeto algum.
- ¬Ñ SUPERVISAO , um tipo de relacionamento 1:N entre FUNCIONARIO (no papel de supervisor) e FUNCIONARIO (no papel de supervisionado). As duas participa√ß√µes s√£o determinadas como sendo parciais, depois que os usu√°rios indicaram que nem todo funcion√°rio √© um supervisor e nem todo funcion√°rio tem um supervisor.
- ¬Ñ TRABALHA\_EM , determinado como sendo um tipo  de  relacionamento  M:N  com  atributo Horas ,  depois que os usu√°rios indicaram que um projeto pode ter v√°rios funcion√°rios trabalhando nele. As duas participa√ß√µes s√£o determinadas como totais.
- ¬Ñ DEPENDENTES\_DE , um tipo de relacionamento 1:N entre FUNCIONARIO e DEPENDENTE , que tamb√©m √© o relacionamento de identifica√ß√£o para o tipo de entidade fraca DEPENDENTE . A participa√ß√£o de FUNCIONARIO √© parcial, enquanto a de DEPENDENTE √© total.

Depois de especificar os seis tipos de relacionamento citados, removemos dos tipos de entidade da Figura  7.8  todos  os  atributos  que  foram  refinados para relacionamentos. Estes incluem Gerente e Data\_ inicio\_gerente de DEPARTAMENTO ; Departamento\_ge -renciador de PROJETO ; Departamento , Supervisor e Trabalha\_em de FUNCIONARIO ; e Funcionario de DEPENDENTE .  √â  importante ter o m√≠nimo poss√≠vel de redund√¢ncia quando projetamos o esquema concei-

12 A chave parcial √†s vezes √© chamada de discriminadora .

13 As regras no minimundo que determinam as restri√ß√µes tamb√©m s√£o chamadas de regras de neg√≥cio , pois elas s√£o determinadas pelo neg√≥cio ou pela organiza√ß√£o que utilizar√° o banco de dados.

tual de um banco de dados. Se alguma redund√¢ncia for desejada no n√≠vel de armazenamento ou no n√≠vel de vis√£o do usu√°rio, ela pode ser introduzida mais tarde, conforme discutimos na Se√ß√£o 1.6.1.

## 7.7 Diagramas ER, conven√ß√µes de nomes e quest√µes de projeto

## 7.7 .1 Resumo da nota√ß√£o para diagramas ER

As figuras 7.9 a 7.13 ilustram exemplos da participa√ß√£o dos tipos de entidade nos tipos de relacionamento ao exibir seus conjuntos ou extens√µes - as inst√¢ncias de entidade individuais em um conjunto de entidades e as inst√¢ncias de relacionamento individuais em um conjunto de relacionamentos. Nos diagramas ER, a √™nfase est√° em representar os esquemas em vez das inst√¢ncias. Isso √© mais √∫til no projeto de banco de dados porque um esquema de banco de dados muda raramente, enquanto o conte√∫do dos conjuntos de entidades muda com frequ√™ncia. Al√©m disso, o esquema √© obviamente mais f√°cil de exibir, pois √© muito menor.

A Figura 7.2 exibe o esquema de banco de dados EMPRESA como um diagrama ER . Agora, revisamos a nota√ß√£o completa do diagrama ER. Tipos de entidade como FUNCIONARIO , DEPARTAMENTO e PROJETO s√£o mostrados nas caixas retangulares. Tipos de relacionamento como TRABALHA\_PARA , GERENCIA , CONTROLA e TRABALHA\_EM s√£o mostrados em caixas em forma de losango, conectadas aos tipos de entidade participantes com linhas retas. Os atributos s√£o mostrados em ovais, e cada atributo √© conectado por  uma  linha  reta  a  seu  tipo  de  entidade  ou  tipo de relacionamento. Os atributos componentes de um atributo composto s√£o conectados √† oval que representa o atributo composto, conforme ilustrado pelo atributo Nome de FUNCIONARIO . Os atributos multivalorados aparecem em ovais duplas, conforme ilustrado pelo atributo Localizacoes de DEPARTAMENTO . Os atributos-chave t√™m seus nomes sublinhados. Os atributos derivados aparecem em ovais pontilhadas, conforme  ilustrado  pelo  atributo Numero\_funciona -rios de DEPARTAMENTO .

Os tipos de entidade fraca s√£o distinguidos ao serem colocados em ret√¢ngulos duplos e terem seu relacionamento de identifica√ß√£o colocado em losangos duplos, conforme ilustrado pelo tipo de entidade DEPENDENTE e DEPENDENTES\_DE identificando  o tipo de relacionamento. A chave parcial do tipo de entidade fraca √© sublinhada com uma linha tracejada.

Na Figura 7.2, a raz√£o de cardinalidade de cada tipo  de  relacionamento bin√°rio √©  especificada  pela  conec√ß√£o  de  um  1,  M  ou  N  em  cada  aresta  participante.  A  raz√£o de  cardinalidade  de DEPARTAMENTO:FUNCIONARIO em GERENCIA √© 1:1, enquanto √© 1:N para DEPARTAMENTO: FUNCIONARIO em TRABALHA\_PARA , e M:N para TRABALHA\_EM .  A  restri√ß√£o  de  participa√ß√£o  √© especificada por uma linha simples para participa√ß√£o parcial e por linhas duplas para a participa√ß√£o total (depend√™ncia de exist√™ncia).

Na Figura  7.2,  mostramos  os  nomes  de  papel para o tipo de relacionamento SUPERVISAO , pois o mesmo tipo de entidade FUNCIONARIO desempenha dois  pap√©is  distintos  nesse  relacionamento.  Observe que a raz√£o de cardinalidade √© 1:N de supervisor para supervisionado porque cada funcion√°rio no papel de supervisionado tem, no m√°ximo, um supervisor direto, ao passo que um funcion√°rio no papel de supervisor pode controlar zero ou mais funcion√°rios.

A Figura 7.14 resume as conven√ß√µes para diagramas ER. √â importante observar que existem muitas  outras  nota√ß√µes  diagram√°ticas  alternativas  (ver Se√ß√£o 7.7.4 e Ap√™ndice A).

## 7.7.2 Nomea√ß√£o apropriada de constru√ß√µes de esquema

Ao projetar um esquema de banco de dados, a escolha de nomes para tipos de entidade, atributos, tipos de relacionamento e (particularmente) fun√ß√µes nem sempre √© simples. √â preciso escolher nomes que transmitam, tanto quanto poss√≠vel, os significados conectados  √†s  diferentes  constru√ß√µes  no  esquema. Escolhemos usar nomes no singular para  os  tipos de entidade, em vez de nomes no plural, porque o nome se aplica a cada entidade individual pertencente a esse tipo de entidade. Em nossos diagramas ER, usaremos a conven√ß√£o de que os nomes do tipo de  entidade  e  tipo  de  relacionamento  s√£o  escritos em letras mai√∫sculas, os nomes de atributo t√™m apenas a letra inicial em mai√∫scula e os nomes de papel s√£o escritos em letras min√∫sculas. Usamos essa conven√ß√£o na Figura 7.2.

Como uma pr√°tica geral, dada uma descri√ß√£o narrativa dos requisitos do banco de dados, os nomes que aparecem na narrativa tendem a gerar nomes de tipo de entidade, e os verbos tendem a indicar nomes de tipos de  relacionamento.  Os  nomes  de  atributo  costumam surgir  de  nomes  adicionais  que  descrevem  os  nomes correspondentes para tipos de entidade.

Outra considera√ß√£o de nomea√ß√£o envolve a escolha de nomes de relacionamento bin√°rio para tornar o diagrama ER do esquema leg√≠vel da esquerda para a direita e de cima para baixo. Seguimos essa orienta√ß√£o de modo geral na Figura 7.2. Para explicar essa conven√ß√£o de nomea√ß√£o ainda mais, temos uma exce√ß√£o para a Figura 7.2 - o tipo de relaciona-

Figura 7.14



| Significado                                               |
|-----------------------------------------------------------|
| Entidade                                                  |
| Entidade fraca                                            |
| Relacionamento                                            |
| Relacionamento de identifica√ß¬™o                           |
| Atributo                                                  |
| Atributo-chave                                            |
| Atributo multivalorado                                    |
| Atributo composto                                         |
| Atributo derivado                                         |
| Participa√ß¬™o total de E 2 em R                            |
| Raz¬™o de cardinalidade 1: N para E 1 : E 2 em R           |
| Restri√ß¬™o estrutural (min, max) na participa√ß¬™o de E em R |

Resumo da nota√ß√£o para diagramas ER.

mento DEPENDENTES\_DE , lido de baixo para cima. Quando descrevemos esse relacionamento, podemos dizer que as entidades DEPENDENTE (tipo de entidade  inferior)  s√£o DEPENDENTES\_DE (nome  de  relacionamento)  um FUNCIONARIO (tipo  de  entidade superior). Para mudar isso e ler de cima para baixo, poder√≠amos renomear o tipo de relacionamento para

POSSUI\_DEPENDENTES , que ent√£o seria lido da seguinte forma: uma entidade FUNCIONARIO (tipo de entidade  superior) POSSUI\_DEPENDENTES (nome de  relacionamento)  do  tipo DEPENDENTE (tipo  de entidade inferior). Observe que esse problema surge porque  cada  relacionamento  bin√°rio  pode  ser  descrito come√ßando de qualquer um dos dois tipos de entidades participantes, conforme discutido no in√≠cio da Se√ß√£o 7.4.

## 7.7.3 Escolhas de projeto para o projeto conceitual ER

√Äs vezes, √© dif√≠cil decidir se um conceito em particular no minimundo deve ser modelado como um tipo de entidade, um atributo ou um tipo de relacionamento. Nesta se√ß√£o, oferecemos algumas orienta√ß√µes r√°pidas sobre qual constru√ß√£o deve ser escolhida em situa√ß√µes espec√≠ficas.

Em geral, o processo de projeto de esquema deve ser considerado um processo de refinamento iterativo, no qual um projeto inicial √© criado e depois refinado iterativamente at√© que seja alcan√ßado o mais adequado. Alguns dos refinamentos frequentemente utilizados incluem o seguinte:

- ¬Ñ Um conceito pode ser modelado como um atributo e depois refinado para um relacionamento, pois √© determinado que o atributo √© uma refer√™ncia para outro tipo de entidade. Com frequ√™ncia acontece de um par desses atributos, que s√£o inversos um do outro, ser refinado em um relacionamento bin√°rio. Discutimos esse tipo de refinamento com detalhes na Se√ß√£o 7.6. √â importante observar que, em nossa nota√ß√£o, quando um atributo  √©  substitu√≠do  por  um  relacionamento,  o pr√≥prio atributo deve ser removido do tipo de entidade para evitar duplica√ß√£o e redund√¢ncia.
- ¬Ñ De modo semelhante, um atributo que existe em v√°rios tipos de entidade pode ser elevado ou promovido para um tipo de entidade independente. Por exemplo, suponha que cada tipo de entidade em um banco de dados UNIVERSIDADE , como ALUNO , PROFESSOR e DISCIPLINA , tenha um atributo Departamento no projeto inicial. O projetista pode ent√£o escolher  criar  um  tipo  de  entidade DEPARTAMENTO com um √∫nico atributo Dept\_nome e relacion√°-lo aos tr√™s tipos de entidade ( ALUNO PROFESSOR , e DISCIPLINA ) por meio de relacionamentos apropriados. Outros atributos/relacionamentos de DEPARTAMENTO podem ser descobertos mais tarde.

- ¬Ñ Um refinamento inverso para o caso anterior pode ser aplicado - por exemplo, se um tipo de entidade DEPARTAMENTO existir no projeto inicial com um atributo isolado Dept\_nome e estiver relacionado a somente outro tipo de entidade, ALUNO . Nesse caso, DEPARTAMENTO pode ser reduzido ou rebaixado para um atributo de ALUNO .
- ¬Ñ A Se√ß√£o 7.9 vai discutir as escolhas referentes ao grau de um relacionamento. No Cap√≠tulo 8, discutiremos outros refinamentos referentes √† especializa√ß√£o/generaliza√ß√£o. O Cap√≠tulo 10 abordar√° refinamentos top-down e bottom-up adicionais que s√£o comuns no projeto de esquema conceitual em grande escala.

## 7.7.4 Nota√ß√µes alternativas para diagramas ER

Existem muitas nota√ß√µes diagram√°ticas alternativas para exibir diagramas ER. O Ap√™ndice A mostra algumas das mais populares. Na Se√ß√£o 7.8, vamos introduzir a nota√ß√£o Unified Modeling Language (UML) para diagramas de classe, que foi proposta como um padr√£o para a modelagem conceitual de objeto.

Nesta se√ß√£o, descrevemos uma nota√ß√£o ER alternativa para especificar restri√ß√µes estruturais sobre os relacionamentos, que substitui a raz√£o de cardinalidade (1:1, 1:N, M:N) e a nota√ß√£o de linha simples/dupla  para  as  restri√ß√µes  de  participa√ß√£o.  Essa nota√ß√£o envolve associar um par de n√∫meros inteiros  (min,  max)  a  cada participa√ß√£o de  um  tipo  de entidade E em um tipo de relacionamento R ,  onde 0 ‚â§ min ‚â§ max e max ‚â• 1.  Os  n√∫meros significam que, para cada entidade e em E e , precisa participar de pelo menos min e no m√°ximo max inst√¢ncias de relacionamento em R em qualquer ponto no tempo . Nesse m√©todo, min = 0 implica participa√ß√£o parcial, enquanto min &gt; 0 implica participa√ß√£o total.

A Figura 7.15 mostra o esquema de banco de dados EMPRESA usando a nota√ß√£o (min, max). 14  Em geral, usa-se ou a nota√ß√£o de raz√£o de cardinalidade/ linha, simples/linha dupla ou a nota√ß√£o (min, max). A  nota√ß√£o  (min,  max)  √©  mais  precisa,  e  podemos us√°-la  para  especificar  algumas  restri√ß√µes  estruturais para os tipos de relacionamento de maior grau . Por√©m, isso n√£o √© suficiente para especificar algumas restri√ß√µes  de  chave  nos  relacionamentos  de  maior grau, conforme discutiremos na Se√ß√£o 7.9.

## 7.8 Exemplo de outra nota√ß√£o: diagramas de classes UML

A metodologia UML est√° sendo bastante utilizada no projeto de software e tem muitos tipos de diagramas para diversas finalidades do projeto de software. Aqui, apresentamos rapidamente os fundamentos dos diagramas de classes UML e os comparamos com os diagramas ER. De algumas maneiras, os diagramas de classes podem ser considerados uma nota√ß√£o alternativa aos diagramas ER. A nota√ß√£o e os conceitos adicionais da UML ser√£o apresentados na Se√ß√£o 8.6 e no Cap√≠tulo 10. A Figura 7.16 mostra como o esquema de banco de dados ER EMPRESA da Figura 7.15 pode ser exibido usando a nota√ß√£o de diagrama de classes UML. Os tipos de entidade na Figura 7.15 s√£o modelados como classes na Figura 7.16. Uma entidade em ER corresponde a um objeto em UML.

Nos diagramas de classes UML, uma classe (semelhante  a  um  tipo  de  entidade  em  ER)  √©  exibida como uma caixa (ver Figura 7.16) que inclui tr√™s se√ß√µes: a se√ß√£o superior mostra o nome da classe (semelhante ao nome do tipo de entidade); a se√ß√£o do meio inclui os atributos ;  e  a  √∫ltima  se√ß√£o  inclui  as opera√ß√µes que podem ser aplicadas aos objetos individuais  (semelhante  √†s  entidades  individuais  em um conjunto de entidades) da classe. As opera√ß√µes n√£o s√£o especificadas em diagramas ER. Considere a classe FUNCIONARIO na Figura 7.16. Seus atributos s√£o Nome , Cpf , Datanasc , Sexo , Endereco e Salario . O projetista pode, opcionalmente, especificar o dom√≠nio de um atributo, se desejar, colocando um sinal de dois-pontos (:) seguido pelo nome ou descri√ß√£o do dom√≠nio, conforme ilustrado pelos atributos Nome , Sexo e Datanasc de FUNCIONARIO na  Figura  7.16. Um atributo composto √© modelado como um dom√≠nio  estruturado ,  conforme  ilustrado  pelo  atributo Nome de FUNCIONARIO . Um atributo multivalorado geralmente ser√° modelado como uma classe separada, conforme ilustrado pela classe LOCALIZACAO na Figura 7.16.

A Figura 7.15 tamb√©m apresenta todos os nomes de papel para o esquema de banco de dados EMPRESA .

Os tipos de relacionamento s√£o chamados de associa√ß√µes em terminologia UML, e as inst√¢ncias de relacionamento s√£o chamadas de liga√ß√µes .  Uma associa√ß√£o bin√°ria (tipo de relacionamento bin√°rio) √© representada como uma linha que conecta as classes participantes (tipos de entidade) e pode, de maneira  opcional,  ter  um  nome.  Um atributo de relacionamento, chamado atributo  de  liga√ß√£o ,  √©  colocado em uma caixa que est√° conectada √† linha da associa-

14 Em algumas nota√ß√µes, particularmente aquelas usadas nas metodologias de modelagem de objeto, como UML, o (min, max) √© colocado nos lados opostos aos que mostramos. Por exemplo, para o relacionamento TRABALHA\_PARA da Figura 7.15, o (1,1) estaria no lado DEPARTAMENTO, e o (4,N) estaria no lado FUNCIONARIO. Aqui, usamos a nota√ß√£o original de Abrial (1974).

Figura 7.15



Diagramas ER para o esquema EMPRESA , com restri√ß√µes estruturais especificadas usando a nota√ß√£o (min, max) e nomes de fun√ß√£o.

√ß√£o por uma linha tracejada. A nota√ß√£o (min, max) descrita na Se√ß√£o 7.7.4 √© usada para especificar restri√ß√µes de relacionamento, que s√£o chamadas multiplicidades em terminologia UML. As multiplicidades s√£o especificadas na forma min..max, e um asterisco ( √© )  indica  nenhum  limite  m√°ximo  na  participa√ß√£o. Contudo, as multiplicidades s√£o colocadas nos lados opostos do relacionamento quando comparadas com a nota√ß√£o discutida na Se√ß√£o 7.7.4 (compare as figuras 7.15 e 7.16). Em UML, um √∫nico asterisco indica uma multiplicidade de 0.. √© , e um √∫nico 1 indica uma multiplicidade de 1..1. Um relacionamento recursivo

(ver Se√ß√£o 7.4.2) √© chamado de associa√ß√£o reflexiva em UML, e os nomes de fun√ß√£o - como as multiplicidades  -  s√£o  colocados  nos  cantos  opostos  de uma associa√ß√£o quando comparados com o posicionamento dos nomes de fun√ß√£o na Figura 7.15.

Em UML, existem dois tipos de relacionamentos: associa√ß√£o e agrega√ß√£o. A agrega√ß√£o serve para representar um relacionamento entre um objeto inteiro e suas partes componentes, e possui uma nota√ß√£o diagram√°tica distinta. Na Figura 7.16, modelamos os locais de um departamento e o local isolado de um projeto como agrega√ß√µes. Por√©m, agrega√ß√£o

Figura 7.16



O esquema conceitual EMPRESA na nota√ß√£o do diagrama de classes UML.

e  associa√ß√£o  n√£o  possuem  propriedades  estruturais diferentes, e a escolha quanto a qual tipo de relacionamento usar √© um tanto subjetiva. No modelo ER, ambas s√£o representadas como relacionamentos.

A UML tamb√©m distingue entre associa√ß√µes (ou agrega√ß√µes) unidirecionais e bidirecionais .  No  caso unidirecional, a linha que conecta as classes √© exibida com uma seta para indicar que apenas uma dire√ß√£o para acessar objetos relacionados √© necess√°ria. Se nenhuma seta for exibida, o caso bidirecional √© assumido, que √© o padr√£o. Por exemplo, se sempre esperamos acessar  o  gerente  de  um  departamento  come√ßando por  um objeto DEPARTAMENTO ,  podemos  desenhar a  linha  de  associa√ß√£o  representando  a  associa√ß√£o GERENCIA com  uma  seta  de DEPARTAMENTO para FUNCIONARIO . Al√©m disso, as inst√¢ncias de relacionamento podem ser especificadas para serem ordenadas . Por  exemplo,  poder√≠amos  especificar  que  os  objetos do  funcion√°rio  relacionados  a  cada  departamento por meio da associa√ß√£o (relacionamento) TRABALHA\_ PARA devem ser ordenados por seu valor de atributo Salario. Os nomes de associa√ß√£o (relacionamento) s√£o opcionais em UML, e os atributos do relacionamento s√£o exibidos em uma caixa conectada com uma linha tracejada √† linha que representa a associa√ß√£o/agrega√ß√£o (ver Data\_inicio e Horas na Figura 7.16).

As opera√ß√µes dadas em cada classe s√£o derivadas dos requisitos funcionais da aplica√ß√£o, conforme discutimos na Se√ß√£o 7.1. Em geral, basta especificar os nomes de opera√ß√£o inicialmente para as opera√ß√µes l√≥gicas que dever√£o ser aplicadas a objetos individuais de uma classe, conforme mostra a Figura 7.16. √Ä medida que o projeto √© refinado, mais detalhes s√£o acrescentados, como  os  tipos  de  argumento  (par√¢metros)  exatos para  cada  opera√ß√£o,  mais  uma  descri√ß√£o  funcional de cada opera√ß√£o. A UML tem descri√ß√µes de fun√ß√£o e diagramas de sequ√™ncia para especificar alguns dos detalhes da opera√ß√£o, mas estes est√£o fora do escopo de  nossa  discuss√£o.  O  Cap√≠tulo  10  apresentar√°  alguns desses diagramas.

Entidades fracas  podem ser modeladas usando a constru√ß√£o chamada de associa√ß√£o qualificada (ou agrega√ß√£o qualificada ) em UML. Esta pode representar  tanto  o  relacionamento de identifica√ß√£o quanto a chave parcial, que √© colocada em uma caixa ligada √† classe propriet√°ria. Isso √© ilustrado pela classe DEPENDENTE e  sua  agrega√ß√£o  qualificada  a FUNCIONARIO na Figura 7.16. A chave parcial Nome\_depen -dente √©  chamada de discriminador em terminologia UML, pois seu valor distingue os objetos associados (relacionados) ao mesmo FUNCIONARIO . As associa√ß√µes qualificadas n√£o s√£o restritas √† modelagem de

entidades  fracas  e  podem  ser  usadas  para  modelar outras situa√ß√µes em UML.

Esta se√ß√£o n√£o pretende oferecer uma descri√ß√£o completa  dos  diagramas  de  classe  UML,  mas  sim ilustrar um tipo popular de nota√ß√£o diagram√°tica alternativa que pode ser utilizada para representar os conceitos de modelagem ER.

## 7.9 Tipos de relacionamento de grau maior que dois

Na Se√ß√£o 7.4.2, definimos o grau de um tipo de relacionamento como o n√∫mero de tipos de entidade participantes e chamamos um tipo de relacionamento de grau dois de bin√°rio , e de grau tr√™s de tern√°rio .

Nesta se√ß√£o, explicamos melhor as diferen√ßas entre os relacionamentos bin√°rio e de grau maior, quando escolher relacionamentos de grau maior versus bin√°rio, al√©m de como especificar as restri√ß√µes sobre relacionamentos de grau maior.

## 7.9.1 Escolhendo entre relacionamentos bin√°rio e tern√°rio (ou de grau maior)

A nota√ß√£o de diagrama ER para um tipo de relacionamento tern√°rio aparece na Figura 7.17(a), a qual mostra o esquema para o tipo de relacionamento FORNECE que foi mostrado no n√≠vel de conjunto de entidades/conjunto de relacionamentos ou de inst√¢ncia na Figura 7.10. Lembre-se de que o conjunto de relacionamentos de FORNECE √©  um conjunto de inst√¢ncias

Figura 7.17



Tipos de relacionamento tern√°rio. (a) O relacionamento FORNECE . (b) Tr√™s relacionamentos bin√°rios n√£o equivalentes a FORNECE. (c) FORNECE representado como um tipo de entidade fraca.

de relacionamento ( ,  , f j p ), onde   √© um f FORNECEDOR que atualmente est√° abastecendo um PROJETO j com uma PECA p .  Em  geral,  um  tipo  de  relacionamento R de grau n ter√° n arestas em um diagrama ER, uma conectando R a cada tipo de entidade participante.

A  Figura  7.17(b)  mostra  um  diagrama  ER  para os tr√™s tipos de relacionamento bin√°rio PODE\_FORNE -CER  USA , e FORNECE . Em geral, um tipo de relacionamento tern√°rio representa informa√ß√µes diferentes dos tr√™s tipos de relacionamento bin√°rio. Considere os tr√™s tipos  de  relacionamento  bin√°rio PODE\_FORNECER , USA e FORNECE . Suponha que PODE\_FORNECER , entre FORNECEDOR   PECA e , inclua uma inst√¢ncia ( , f p ) sempre que o fornecedor f puder fornecer a pe√ßa p (a qualquer projeto); USA , entre PROJETO e PECA , inclui uma inst√¢ncia ( , j p ) sempre que o projeto   usa a pe√ßa j p ; e FORNECE , entre FORNECEDOR   PROJETO e , inclui uma inst√¢ncia ( ,  ) sempre que o fornecedor f j f fornece alguma pe√ßa ao projeto  . A exist√™ncia de tr√™s inst√¢ncias j de relacionamento ( , f  p ), ( , j  p ) e ( , f j ) em PODE\_FOR -NECER USA , e FORNECE , respectivamente, n√£o implica que existe uma inst√¢ncia ( ,  , f j p ) no relacionamento tern√°rio FORNECE , pois o significado √© diferente . Com frequ√™ncia, √© complicado decidir se um relacionamento em particular deve ser representado como um tipo de relacionamento de grau n ou se deve ser desmembrado em v√°rios tipos de relacionamento de graus menores. O projetista dever√° basear essa decis√£o na sem√¢ntica ou significado da situa√ß√£o em particular que est√° sendo representada. A solu√ß√£o t√≠pica √© incluir ao relacionamento tern√°rio com um ou mais dos relacionamentos bin√°rios, se eles representarem significados diferentes e se todos forem necess√°rios √† aplica√ß√£o.

Algumas ferramentas de projeto de banco de dados  s√£o  baseadas  em  varia√ß√µes  do  modelo  ER  que permitem  apenas  relacionamentos  bin√°rios.  Nesse caso,  um  relacionamento  tern√°rio  como FORNECE deve ser representado como um tipo de entidade fraca, sem chave parcial e com tr√™s relacionamentos de identifica√ß√£o.  Os  tr√™s  tipos  de  entidade  participantes FORNECEDOR PECA , e PROJETO s√£o, juntos, os tipos  de  entidade  propriet√°ria  (ver  Figura  7.17(c)). Logo, uma entidade no tipo de entidade fraca FORNECE na Figura 7.17(c) √© identificada pela combina√ß√£o de suas tr√™s entidades propriet√°rias de FORNECEDOR PECA , e PROJETO .

Tamb√©m √© poss√≠vel representar o relacionamento tern√°rio como um tipo de entidade regular introduzindo  uma  chave  artificial  ou  substituta.  Neste exemplo,  um  atributo-chave Cod\_fornecimento poderia ser usado para o tipo de entidade FORNECE , convertendo-o em um tipo de entidade regular. Tr√™s relacionamentos bin√°rios N:1 relacionam FORNECE aos tr√™s tipos de entidade participantes.

Outro exemplo √© mostrado na Figura 7.18. O tipo  de  relacionamento  tern√°rio OFERECE representa  informa√ß√µes  sobre  professores  que  oferecem cursos  durante  determinados  semestres.  Logo,  ele inclui  uma  inst√¢ncia  de  relacionamento  ( p , s , d ) sempre que o PROFESSOR p oferece  a DISCIPLINA d durante o SEMESTRE s .  Os  tr√™s  tipos  de  relacionamento bin√°rio mostrados na Figura 7.18 t√™m os seguintes  significados: PODE\_LECIONAR relaciona uma disciplina aos professores que podem lecionar esta disciplina, LECIONOU\_DURANTE relaciona um semestre aos professores que lecionaram alguma disciplina durante esse semestre, e OFERECIDA\_DURAN -TE relaciona  um  semestre  √†s  disciplinas  oferecidas durante esse semestre por qualquer professor . Esses relacionamentos tern√°rios e bin√°rios representam informa√ß√µes diferentes,  mas  certas  restri√ß√µes  dever√£o ser mantidas entre os relacionamentos. Por exemplo, uma inst√¢ncia  de  relacionamento  ( p , s , d )  n√£o  deve existir em OFERECE a menos que exista uma inst√¢ncia ( p s , ) em LECIONOU\_DURANTE , uma inst√¢ncia ( , s d ) existe em OFERECIDA\_DURANTE e uma inst√¢ncia ( p, d ) existe em PODE\_LECIONAR . Contudo, a rec√≠proca nem sempre √© verdadeira: podemos ter inst√¢ncias ( p s , ), ( s , d ) e ( p d , ) nos tr√™s tipos de relacionamento bin√°rio sem a inst√¢ncia correspondente ( p s , , d ) em OFERECE . Observe que, neste exemplo, com base no significado dos relacionamentos, podemos deduzir as inst√¢ncias de LECIONOU\_DURANTE e OFERECIDA\_DURANTE com base nas inst√¢ncias em OFERECE , mas n√£o podemos  deduzir  as  inst√¢ncias  de PODE\_LECIONAR . Portanto, LECIONOU\_DURANTE e OFERECIDA\_DU -RANTE s√£o redundantes e podem ser omitidas.

Embora em geral  tr√™s  relacionamentos  bin√°rios n√£o  possam substituir  um  relacionamento  tern√°rio, eles podem fazer isso sob certas restri√ß√µes adicionais . Em nosso  exemplo,  se  o  relacionamento PODE\_LE -

Figura 7.18



Outro exemplo de tipos de relacionamento tern√°rio versus bin√°rio.

Figura 7.19 Um tipo de entidade fraca ENTREVISTA com um tipo de relacionamento de identifica√ß√£o tern√°rio.



- 15 Esta nota√ß√£o nos permite determinar a chave da rela√ß√£o do relacionamento , conforme discutiremos no Cap√≠tulo 9.
- 16 Isso tamb√©m √© verdadeiro para raz√µes de cardinalidade dos relacionamentos bin√°rios.

CIONAR for 1:1 (um professor pode lecionar uma disciplina, e uma disciplina pode ser lecionada por apenas  um  professor),  ent√£o  o  relacionamento  tern√°rio OFERECE pode ser omitido porque pode ser deduzido pelos tr√™s relacionamentos bin√°rios PODE\_LECIONAR , LECIONOU\_DURANTE e OFERECIDA\_DURANTE . O projetista do esquema precisa analisar o significado de cada situa√ß√£o espec√≠fica para decidir quais dos tipos de relacionamento bin√°rio e tern√°rio s√£o necess√°rios.

ser usadas se for importante determinar totalmente as restri√ß√µes estruturais sobre um relacionamento tern√°rio ou de grau maior. A primeira nota√ß√£o √© baseada na nota√ß√£o de raz√£o de cardinalidade dos relacionamentos bin√°rios exibidos na Figura 7.2. Aqui, um 1, M ou N √© especificado em cada arco de participa√ß√£o (os s√≠mbolos M e N significam muitos ou qualquer n√∫mero ). 15 Vamos ilustrar essa restri√ß√£o usando o relacionamento FORNECE da Figura 7.17.

Observe que √© poss√≠vel ter um tipo de entidade fraca com um tern√°rio ( n -√°rio) identificando o tipo de  relacionamento.  Nesse  caso,  o  tipo  de  entidade fraca pode ter v√°rios tipos de entidade propriet√°rios. Um exemplo √© mostrado na Figura 7.19. Ele mostra parte de um banco de dados que registra candidatos para entrevistas de emprego em diversas empresas, e pode fazer parte de um banco de dados de ag√™ncia de emprego, por exemplo. Nos requisitos, um candidato pode ter v√°rias entrevistas com a mesma empresa (por exemplo, com diferentes departamentos dela ou em datas separadas), mas uma oferta de emprego √© feita com base em uma das entrevistas. Aqui, ENTREVISTA √© representada como uma entidade fraca com dois propriet√°rios CANDIDATO e EMPRESA , e com a chave parcial Dept\_data . Uma entidade ENTREVISTA √©  identificada  exclusivamente  por  um  candidato, uma empresa e a combina√ß√£o da data e departamento da entrevista.

## 7.9.2 Restri√ß√µes sobre relacionamentos tern√°rios (ou de grau mais alto)

Existem duas nota√ß√µes para especificar restri√ß√µes estruturais sobre relacionamentos n -√°rios, e elas especificam restri√ß√µes diferentes. Assim, ambas devem

Lembre-se de que o conjunto de relacionamento de FORNECE √© um conjunto de inst√¢ncias de relacionamento ( ,  , f j p ), em que f √© um FORNECEDOR , j √© um PROJETO e p √© uma PECA. Suponha que exista a restri√ß√£o de que, para determinada combina√ß√£o de projeto-pe√ßa, somente um fornecedor ser√° usado (somente um fornecedor abastece determinado projeto com determinada pe√ßa). Nesse caso, colocamos 1 na participa√ß√£o de FORNECEDOR , e M, N nas participa√ß√µes de PROJETO PECA , na Figura 7.17. Isso especifica a restri√ß√£o de que uma combina√ß√£o em particular ( , j p ) pode aparecer no m√°ximo uma vez no conjunto de relacionamento, pois cada combina√ß√£o ( PROJETO PECA , ) desse tipo determina de maneira exclusiva um √∫nico fornecedor. Logo, qualquer inst√¢ncia de relacionamento ( ,  , f j p )  √©  identificada  exclusivamente no conjunto de relacionamentos por sua combina√ß√£o ( , j p ),  que  torna  ( , j p )  uma  chave  para  o  conjunto de relacionamentos. Nessa nota√ß√£o, as participa√ß√µes que t√™m 1 especificado nelas n√£o precisam fazer parte da chave de identifica√ß√£o para o conjunto de relacionamentos. 16  Se todas as tr√™s cardinalidades forem M ou N, ent√£o a chave ser√° a combina√ß√£o de todos os tr√™s participantes.

A segunda nota√ß√£o √© baseada na nota√ß√£o (min, max) exibida na Figura 7.15 para relacionamentos

bin√°rios. Um (min, max) em uma participa√ß√£o aqui especifica que cada entidade est√° relacionada a pelo menos min e no m√°ximo max inst√¢ncias de relacionamento no conjunto de relacionamentos. Essas restri√ß√µes n√£o t√™m influ√™ncia na determina√ß√£o da chave de um relacionamento n -√°rio, no qual n &gt; 2, 17 mas especificam  um  tipo  diferente  de  restri√ß√£o,  que  faz restri√ß√µes sobre o n√∫mero de inst√¢ncias de relacionamento de que cada entidade participa.

## Resumo

Neste cap√≠tulo, apresentamos os conceitos de modelagem  de  um  modelo  de  dados  conceitual  de  alto n√≠vel,  o  modelo  Entidade-Relacionamento  (ER).  Come√ßamos discutindo o papel que um modelo de dados de  alto  n√≠vel  desempenha  no  processo  de  projeto  de banco de dados, e depois apresentamos um exemplo de conjunto de requisitos para o banco de dados EMPRESA ,  que  √©  um  dos  exemplos  usados  no  decorrer deste livro. Definimos os conceitos b√°sicos do modelo ER de entidades e seus atributos. Depois, discutimos os valores NULL e  apresentamos os diversos tipos de atributos,  que  podem  ser  aninhados  arbitrariamente para produzir atributos complexos:

- ¬Ñ Simples ou at√¥micos.
- ¬Ñ Compostos.
- ¬Ñ Multivalorados.

Tamb√©m discutimos rapidamente atributos armazenados versus derivados. Depois, abordamos os conceitos do modelo ER no n√≠vel de esquema ou 'conota√ß√£o':

- ¬Ñ Tipos de entidade e seus conjuntos de entidades correspondentes.
- ¬Ñ Atributos-chave dos tipos de entidade.
- ¬Ñ Conjuntos de valores (dom√≠nios) dos atributos.
- ¬Ñ Tipos de relacionamento e seus conjuntos de relacionamentos correspondentes.
- ¬Ñ un√ß√µes  de  participa√ß√£o  dos  tipos  de  entidade F nos tipos de relacionamento.

Apresentamos  dois  m√©todos  para  especificar  as restri√ß√µes  estruturais  sobre  tipos  de  relacionamento.  O primeiro m√©todo distinguiu dois tipos de restri√ß√µes estruturais:

- ¬Ñ Raz√µes  de  cardinalidade  (1:1,  1:N,  M:N  para relacionamentos bin√°rios).
- ¬Ñ Restri√ß√µes de participa√ß√£o (total, parcial).

Observamos que, como alternativa, outro m√©todo de  especifica√ß√£o  de  restri√ß√µes  estruturais  √©  faz√™-lo  com n√∫meros m√≠nimo e m√°ximo (min, max) sobre a participa√ß√£o de cada tipo de entidade em um tipo de relacio- namento. Discutimos sobre tipos de entidade fraca e os conceitos relacionados de tipos de entidade propriet√°ria, tipos de relacionamento de identifica√ß√£o e atributos-chave parciais.

Os esquemas Entidade-Relacionamento podem ser representados de maneira diagram√°tica como diagramas  ER.  Mostramos  como  projetar  um  esquema  ER para o banco de dados EMPRESA ao definir, primeiro, os tipos de entidade e seus atributos e depois refinando o projeto para incluir tipos de relacionamento. Apresentamos o diagrama ER para o esquema de banco de dados EMPRESA . Discutimos  alguns  dos  conceitos b√°sicos dos diagramas de classe UML e como eles se relacionam aos conceitos de modelagem ER. Tamb√©m descrevemos os tipos de relacionamento tern√°rio e de grau maior com mais detalhes, e discutimos as circunst√¢ncias sob as quais eles s√£o distinguidos dos relacionamentos bin√°rios.

Os conceitos de modelagem ER que apresentamos at√© aqui - tipos de entidade, tipos de relacionamento, atributos, chaves e restri√ß√µes estruturais - podem modelar muitas aplica√ß√µes de banco de dados. Contudo, aplica√ß√µes mais complexas - como projeto de engenharia, sistemas de informa√ß√µes m√©dicas e telecomunica√ß√µes - exigem conceitos adicionais se quisermos model√°-las com maior precis√£o. Discutiremos alguns conceitos  de  modelagem  avan√ßados  no  Cap√≠tulo  8  e analisaremos t√©cnicas de modelagem de dados ainda mais avan√ßadas no Cap√≠tulo 26.

## Perguntas de revis√£o

- 7.1. Discuta o papel de um modelo de dados de alto n√≠vel no processo de projeto de banco de dados.
- 7.2. Liste os diversos casos em que o uso de um valor NULL seria apropriado.
- 7.3. Defina  os  seguintes  termos: entidade   atributo , , valor  de  atributo   inst√¢ncia  de  relacionamen-, to   atributo  composto   atributo  multivalorado , , , atributo derivado  atributo complexo  atributo-, , -chave e conjunto de valores  dom√≠nio ( ).
- 7.4. O que √© um tipo de entidade? O que √© um conjunto de entidades? Explique as diferen√ßas entre uma entidade, um tipo de entidade e um conjunto de entidades.
- 7.5. Explique  a  diferen√ßa  entre  um  atributo  e  um conjunto de valores.
- 7.6. O que √© um tipo de relacionamento? Explique as diferen√ßas entre uma inst√¢ncia de relacionamento, um tipo de relacionamento e um conjunto de relacionamentos.
- 7.7. O que √© uma fun√ß√£o de participa√ß√£o? Quando √© necess√°rio usar nomes de fun√ß√£o na descri√ß√£o dos tipos de relacionamento?

17 No entanto, as restri√ß√µes (min, max) podem determinar as chaves para relacionamentos bin√°rios.

- 7.8. Descreva  as  duas  alternativas  para  especificar restri√ß√µes  estruturais  sobre  tipos  de  relacionamento. Quais s√£o as vantagens e desvantagens de cada um?
- 7.9. Sob que condi√ß√µes um atributo de um tipo de relacionamento bin√°rio pode ser migrado para se tornar um atributo de um dos tipos de entidade participantes?
- 7.10. Quando  pensamos  nos  relacionamentos  como atributos, quais s√£o os conjuntos de valores desses atributos? Que classe de modelos de dados √© baseada nesse conceito?
- 7.11. O que queremos dizer com um tipo de relacionamento recursivo? D√™ alguns exemplos.
- 7.12. Quando o conceito de uma entidade fraca √© usado na modelagem de dados? Defina os termos tipo  de  entidade  propriet√°ria , tipo  de  entidade fraca , tipo de relacionamento de identifica√ß√£o e chave parcial .
- 7.13. Um relacionamento de identifica√ß√£o de um tipo de entidade fraca pode ser de um grau maior que dois? D√™ exemplos para ilustrar sua resposta.
- 7.14. Discuta as conven√ß√µes para exibir um esquema ER como um diagrama ER.
- 7.15. Discuta as conven√ß√µes de nomea√ß√£o usadas para os diagramas de esquema ER.

## Exerc√≠cios

- 7.16. Considere o seguinte conjunto de requisitos para um banco de dados UNIVERSIDADE, que √© usado para registrar os hist√≥ricos dos alunos. Este √© semelhante, mas n√£o id√™ntico, ao banco de dados mostrado na Figura 1.2:
- a. A  universidade  registrar  o  nome,  n√∫mero  de aluno, n√∫mero do CPF, endere√ßo atual e com seu n√∫mero de telefone fixo, endere√ßo permanente com seu n√∫mero de telefone fixo, data de nascimento, sexo, turma (novato, segundo ano, ...,  formado),  departamento  principal,  departamento secund√°rio (se houver) e programa de forma√ß√£o  (gradua√ß√£o,  mestrado,  ...,  doutorado) de cada aluno. Algumas aplica√ß√µes do usu√°rio precisam se referir √† cidade, estado e CEP do endere√ßo permanente do aluno e ao sobrenome do aluno. O n√∫mero do CPF e o n√∫mero de aluno possuem valores exclusivos para cada um deles.
- b. Cada departamento √© descrito por um nome, c√≥digo  de  departamento,  n√∫mero  de  escrit√≥rio, n√∫mero de telefone comercial e faculdade. Nome  e  c√≥digo  possuem  valores  exclusivos para cada departamento.
- c. Cada  disciplina  tem  um  nome,  descri√ß√£o, n√∫mero de disciplina, n√∫mero de horas por semestre, n√≠vel e departamento que oferece. O valor do n√∫mero da disciplina √© exclusivo para cada uma delas.
- d. Cada turma tem um professor, semestre, ano, disciplina e n√∫mero de turma. O n√∫mero de turma  distingue  as  turmas  da  mesma  disciplina  que  s√£o  lecionadas  durante  o  mesmo semestre/ano; seus valores s√£o 1, 2, 3, ..., at√© o n√∫mero de turmas lecionadas durante cada semestre.
- e. Um relat√≥rio de notas tem um aluno, turma, nota com letra e nota num√©rica (0 A 10).
- Projete  um  esquema  ER  para  essa  aplica√ß√£o  e desenhe um diagrama ER para o esquema. Especifique os atributos de chave de cada tipo de entidade, e as restri√ß√µes estruturais sobre cada tipo de relacionamento. Observe quaisquer requisitos n√£o especificados e fa√ßa suposi√ß√µes apropriadas para tornar a especifica√ß√£o completa.
- 7.17. Atributos  compostos  e  multivalorados  podem ser aninhados para qualquer n√∫mero de n√≠veis. Suponha  que  queiramos  projetar  um  atributo  para  um  tipo  de  entidade ALUNO a  fim  de registrar  a  forma√ß√£o  acad√™mica  anterior.  Esse atributo ter√° uma entrada para cada faculdade frequentada anteriormente, e cada entrada desse tipo  ser√°  composta  de  um  nome  de  faculdade, datas de in√≠cio e t√©rmino, entradas de t√≠tulo (t√≠tulos  concedidos  nessa  faculdade,  se  houver)  e entradas  de  hist√≥rico  (disciplinas  completadas nessa faculdade, se houver). Cada entrada de t√≠tulo cont√©m o nome do t√≠tulo, o m√™s e o ano em que o t√≠tulo foi conferido, e cada entrada de hist√≥rico cont√©m um nome de disciplina, semestre, ano e turma. Crie um atributo para manter essa informa√ß√£o. Use as conven√ß√µes da Figura 7.5.
- 7.18. Mostre um projeto alternativo para o atributo descrito no Exerc√≠cio 7.17 que use apenas tipos de entidade (incluindo tipos de entidade fraca, se for preciso) e tipos de relacionamento.
- 7.19. Considere o diagrama ER da Figura 7.20, que mostra um esquema simplificado para um sistema de reserva a√©rea. Extraia do diagrama ER os requisitos  e  restri√ß√µes  que  produziram  esse  esquema. Tente ser o mais preciso poss√≠vel em sua especifica√ß√£o de requisitos e restri√ß√µes.
- 7.20. Nos cap√≠tulos 1 e 2, discutimos o ambiente e os usu√°rios de banco de dados. Podemos considerar muitos  tipos  de  entidade  para  descrever  tal  ambiente, como SGBD, banco de dados armazenado, DBA e cat√°logo/dicion√°rio de dados. Tente especificar todos os tipos de entidade que podem descre-



um TRECHO em uma data em particular.

Figura 7.20 Um diagrama ER para um esquema de banco de dados COMPANHIA AEREA.

ver totalmente um sistema de banco de dados e seu ambiente; depois, especifique os tipos de relacionamento entre eles e desenhe um diagrama ER para descrever tal ambiente de banco de dados geral.

- 7.21. Projete um esquema ER para registrar informa√ß√µes sobre votos realizados no Congresso Nacional durante a sess√£o atual de dois anos no congresso. O banco de dados precisa registrar cada nome de ESTADO do Brasil (por exemplo, 'S√£o  Paulo',  'Rio  de  Janeiro',  'Porto  Alegre') e  incluir  a Regiao do  estado  (cujo  dom√≠nio  √© {'Nordeste', 'Centro-Oeste', 'Sudeste', 'Sul', 'Norte'}). Cada CONGRESSISTA no  Congresso  Nacional √© descrito  por  seu Nome ,  mais  o Estado representado,  a Data\_inicio em  que  o

congressista foi eleito pela primeira vez e o Partido pol√≠tico  ao  qual  ele  ou  ela  pertence  (cujo dom√≠nio √© {'Oposi√ß√£o', 'Aliados', 'Independente',  'Outro'}). O banco de dados registra cada PROJETO\_LEI (ou seja, lei proposta), incluindo a Nome\_proj , a Data\_votacao sobre a lei, se a lei passou\_ou\_falhou (cujo  dom√≠nio  √©  {'Sim', 'N√£o'}) e o Proponente (o congressista que patrocinou - ou seja, prop√¥s - a lei). O banco de dados tamb√©m registra como cada congressista votou  em  cada  lei  (dom√≠nio  do  atributo Voto √© {'Sim', 'N√£o', 'Absten√ß√£o', 'Nulo'}). Desenhe um diagrama de esquema ER para essa aplica√ß√£o.  Indique  claramente  quaisquer  suposi√ß√µes que voc√™ fizer.

- 7.22. Um banco de dados est√° sendo constru√≠do para registrar os times e jogos de uma liga esportiva. Um time tem uma s√©rie de jogadores, nem todos participando em todos os jogos. Deseja-se registrar  os  jogadores  que  participam  em  cada  jogo para cada time, as posi√ß√µes em que eles jogaram e o resultado do jogo. Crie um diagrama de esquema ER para essa aplica√ß√£o, indicando quaisquer suposi√ß√µes que voc√™ fizer. Escolha seu esporte favorito (por exemplo, futebol, basquete, voleibol).
- 7.23. Considere  o  diagrama  ER  mostrado  na  Figura 7.21 para parte de um banco de dados BANCO . Cada banco pode ter v√°rias filiais, e cada filial pode ter v√°rias contas e empr√©stimos.
- a. Liste os tipos de entidade forte (n√£o fraca) no diagrama ER.
- b. Existe um tipo de entidade fraca? Se houver, diga seu nome, chave parcial e relacionamento de identifica√ß√£o.
- c. Quais restri√ß√µes a chave parcial e o relacionamento de identifica√ß√£o do tipo de entidade fraca especificam nesse diagrama?
- d. Liste os nomes de todos os tipos de relacionamento e especifique a restri√ß√£o (min, max) sobre cada participa√ß√£o de um tipo de entidade em um tipo de relacionamento. Justifique suas escolhas.
- e. Liste resumidamente os requisitos do usu√°rio que levaram a esse projeto de esquema ER.
- f. Suponha que cada cliente deva ter pelo menos uma conta, mas esteja restrito a no m√°ximo dois empr√©stimos de cada vez, e que uma filial  de  banco  n√£o  pode  ter  mais  de  1.000 empr√©stimos. Como isso √© exposto nas restri√ß√µes (min, max)?
- 7.24. Considere o diagrama ER da Figura 7.22. Suponha que um funcion√°rio possa trabalhar em at√© dois departamentos ou n√£o possa ser atribu√≠do a qualquer departamento. Suponha que cada departamento deva ter um e possa ter at√© tr√™s n√∫meros de telefone. Forne√ßa restri√ß√µes (min, max) sobre esse diagrama. Indique claramente quaisquer suposi√ß√µes adicionais que estiver fazendo . Sob que condi√ß√µes o relacionamento POSSUI\_ TELEFONE seria redundante neste exemplo?

Figura 7.21



Figura 7.22 Parte de um diagrama ER para um banco de dados



EMPRESA.

- 7.25. Considere  o  diagrama  ER  da  Figura  7.23.  Suponha  que  uma  disciplina  possa  ou  n√£o  usar um livro-texto, mas que um texto por defini√ß√£o √©  um  livro  que  √©  usado  em  alguma  disciplina. Uma disciplina n√£o pode usar mais de cinco livros. Os professores lecionam de duas a quatro disciplinas. Forne√ßa restri√ß√µes (min, max) sobre esse  diagrama. Indique  claramente  quaisquer suposi√ß√µes  adicionais  que  estiver  fazendo . Se acrescentarmos  o  relacionamento ADOTADO , para indicar o(s) livros(s)-texto que um professor utiliza para uma disciplina, ele dever√° ser um relacionamento  bin√°rio  entre PROFESSOR e LIVRO\_TEXTO ,  ou um relacionamento tern√°rio entre todos os tr√™s tipos de entidade? Que restri√ß√µes (min, max) voc√™ incluiria? Por qu√™?
- 7.26. Considere um tipo de entidade TURMA em um banco  de  dados UNIVERSIDADE ,  que  descreve as ofertas de turmas das disciplinas. Os atributos da TURMA s√£o Numero\_turma , Semestre  Ano , , Numero\_disciplina  Professor  Num\_sala , , (em que a turma √© realizada), Predio (onde a turma √© realizada), Dias\_da\_semana (dom√≠nio s√£o as combina√ß√µes poss√≠veis de dias da semana em que a tur-

Figura 7.23 Parte de um diagrama ER para um banco de dados DISCIPLINAS.



ma pode ser oferecida {'SQS', 'SQ', 'TQ' e assim por diante}) e Horas (dom√≠nio s√£o todos os per√≠odos poss√≠veis durante os quais as turmas s√£o oferecidas  {'9-9:50',  '10-10:50',  ...,  '15:30-16:50', '17:30-18:20', e assim por diante}). Suponha que Numero\_turma seja exclusivo para cada disciplina em determinada combina√ß√£o de semestre/ano (ou  seja,  se  uma  disciplina  for  oferecida  v√°rias vezes  durante  um  semestre  em  particular,  suas ofertas s√£o numeradas com 1, 2, 3, e assim por diante). Existem v√°rias chaves compostas por turma, e alguns atributos s√£o componentes de mais de uma chave. Identifique tr√™s chaves compostas e mostre como elas podem ser representadas em um diagrama de esquema ER.

- 7.27. Raz√µes de cardinalidade  normalmente  ditam  o projeto detalhado de um banco de dados. A raz√£o de cardinalidade depende do significado no mundo real dos tipos de entidade envolvidos e √© definida pela aplica√ß√£o espec√≠fica. Para os seguintes relacionamentos bin√°rios, sugira raz√µes de  cardinalidade  com  base  no  significado  comum dos tipos de entidade. Indique claramente quaisquer suposi√ß√µes que voc√™ fizer.
- 7.28. Considere o esquema ER para o banco de dados FILMES mostrado na Figura 7.24.

| Entidade 1                                     | Raz√£o de cardinalidade   | Entidade 2              |
|------------------------------------------------|--------------------------|-------------------------|
| 1. ALUNO                                       | ____________             | CADASTRO_ PESSOA_FISICA |
| 2. ALUNO                                       | ____________             | PROFESSOR               |
| 3. SALA_AULA                                   | ____________             | PAREDE                  |
| 4. PAIS                                        | ____________             | PRESIDENTE_ATUAL        |
| 5. DISCIPLINA                                  | ____________             | LIVRO_TEXTO             |
| 6. ITEM (que pode ser encontrado em um pedido) | ____________             | PEDIDO                  |
| 7. ALUNO                                       | ____________             | AULA                    |
| 8. AULA                                        | ____________             | PROFESSOR               |
| 9. PROFESSOR                                   | ____________             | ESCRITORIO              |
| 10. ITEM_LEILOADO                              | ____________             | COD_LEILAO              |

Suponha que FILMES seja  um  banco  de  dados preenchido. ATOR √© usado como um termo gen√©rico e inclui atrizes. Dadas as restri√ß√µes mostradas  no  esquema  ER,  responda  √†s  seguintes afirma√ß√µes  com Verdadeira , Falsa ou Talvez . Atribua uma resposta Talvez a declara√ß√µes que, embora  n√£o  mostradas  explicitamente  como sendo Verdadeiras ,  n√£o se pode provar que sejam Falsas com base no esquema mostrado. Justifique cada resposta.

Figura 7.24 Um diagrama ER para um esquema de banco de dados FILMES.



- a. N√£o existem atores neste banco de dados que n√£o estiveram em nenhum filme.
- b. Existem alguns atores que atuaram em mais de dez filmes.
- c. Alguns atores foram protagonistas em v√°rios filmes.
- d. Um filme s√≥ pode ter um m√°ximo de dois atores protagonistas.
- e. Cada diretor foi ator em algum filme.
- f. Nenhum produtor j√° foi um ator.
- g. Um produtor n√£o pode ser ator em outro filme.
- h. Existem filmes com mais de doze atores.
- i. Alguns produtores tamb√©m j√° foram diretores.
- j. A  maioria  dos  filmes  tem  um  diretor  e  um produtor.
- k. Alguns filmes t√™m um diretor, mas v√°rios produtores.
- l. Existem alguns atores que foram protagonistas, dirigiram um filme e produziram algum filme.
- m. Nenhum filme tem um diretor que tamb√©m atuou nesse filme.
- 7.29. Dado o esquema ER para o banco de dados FILMES da  Figura  7.24,  desenhe um diagrama de inst√¢ncia usando tr√™s filmes que foram lan√ßados recentemente.  Desenhe  inst√¢ncias  de  cada  tipo de entidade: FILMES ATORES PRODUTORES , , , DIRETORES envolvidos; crie inst√¢ncias dos re-

lacionamentos  conforme  existem  na  realidade para esses filmes.

- Ilustre o Diagrama UML para o Exerc√≠cio 7.16. Seu projeto UML dever√° observar os seguintes
- 7.30. requisitos:
- a. Um aluno dever√° ter a capacidade de calcular sua m√©dia e acrescentar ou retirar disciplinas obrigat√≥rias e optativas.
- b. Cada  departamento  dever√°  ser  capaz  de acrescentar ou retirar disciplinas e contratar ou demitir o corpo docente.
- c. Cada professor dever√° ser capaz de atribuir ou alterar a nota de um aluno para uma disciplina.

Nota : algumas dessas fun√ß√µes podem se espalhar por v√°rias turmas.

## Exerc√≠cios de laborat√≥rio

- 7.31. Considere  o  banco  de  dados UNIVERSIDADE descrito no Exerc√≠cio 7.16. Crie o esquema ER para esse banco de dados usando uma ferramenta de modelagem de dados como ERwin ou Rational Rose.
- 7.32. Considere  um  banco  de  dados PEDIDO\_COR -REIO em que os funcion√°rios fazem pedidos de pe√ßas dos clientes. Os requisitos de dados s√£o resumidos da seguinte forma:
- ¬Ñ A empresa que vende por cat√°logo tem funcion√°rios,  cada  um  identificado  por  um  n√∫mero de funcion√°rio exclusivo, nome e sobrenome, e CEP.
- ¬Ñ Cada cliente da empresa √© identificado por um n√∫mero de cliente exclusivo, nome e sobrenome, e CEP.
- ¬Ñ Cada pe√ßa vendida pela empresa √© identificada por um n√∫mero de pe√ßa exclusivo, um nome de pe√ßa, pre√ßo e quantidade em estoque.
- ¬Ñ Cada pedido feito por um cliente √© recuperado por um funcion√°rio e recebe um n√∫mero de pedido exclusivo. Cada pedido cont√©m quantidades especificadas de uma ou mais pe√ßas. Cada pedido tem uma data de recebimento bem como uma data de entrega esperada. A data de entrega real tamb√©m √© registrada.
- Crie um  diagrama Entidade-Relacionamento para o banco de dados de compras por cat√°logo e construa o projeto usando uma ferramenta de modelagem como ERwin ou Rational Rose.
- 7.33. Considere um banco de dados FILME em que os dados s√£o registrados sobre a ind√∫stria do cinema. Os requisitos de dados s√£o resumidos a seguir:
- ¬Ñ Cada filme √© identificado por um t√≠tulo e ano de lan√ßamento. Cada filme tem uma dura√ß√£o em minutos. Cada um tem uma companhia produtora, e

- √© classificado sob um ou mais g√™neros (como terror, a√ß√£o, drama etc.). Cada filme tem um ou mais diretores e um ou mais atores participando dele. Tamb√©m tem um resumo da trama. Finalmente, cada filme tem zero ou mais falas, cada uma delas dita por um ator em particular que aparece no filme.
- ¬Ñ Os atores s√£o identificados por nome e data de nascimento e aparecem em um ou mais filmes. Cada ator tem um papel no filme.
- ¬Ñ Os  diretores tamb√©m  s√£o  identificados  por nome  e  data  de  nascimento  e  dirigem  um  ou mais filmes. √â poss√≠vel que um diretor atue em um filme (incluindo aquele que ele ou ela tamb√©m pode dirigir).
- ¬Ñ As  empresas  produtoras  s√£o  identificadas  por nome e cada uma tem um endere√ßo. Uma produtora produz um ou mais filmes.
- Crie um  diagrama Entidade-Relacionamento para  o  banco  de  dados  de  filmes  e  construa  o projeto usando uma ferramenta de modelagem de dados, como ERwin ou Rational Rose.
- 7.34. Considere um banco de dados REVISAO\_CONFE -RENCIA em que os pesquisadores submetem seus artigos de pesquisa para avalia√ß√£o. As an√°lises dos revisores s√£o registradas para uso no processo de sele√ß√£o  de  artigo.  O  sistema  de  banco  de  dados atende  principalmente  a  revisores  que  registram respostas a perguntas de avalia√ß√£o para cada artigo que eles revisam e fazem recomenda√ß√µes com rela√ß√£o a se aceitar ou rejeitar o artigo. Os requisitos de dados s√£o resumidos da seguinte forma:
- ¬Ñ Autores  de  artigos  s√£o  identificados  exclusivamente pelo correio eletr√¥nico. Os nomes e sobrenomes tamb√©m s√£o registrados.
- ¬Ñ Cada  artigo  recebe  um  identificador  exclusivo pelo sistema e √© descrito por um t√≠tulo, resumo e o nome do arquivo eletr√¥nico que cont√©m o artigo.
- ¬Ñ Um artigo pode ter v√°rios autores, mas um deles √© designado como o autor de contato.
- ¬Ñ Os  revisores  dos  artigos  s√£o  identificados  exclusivamente  pelo  endere√ßo  de  correio  eletr√¥nico. Nome, sobrenome, n√∫mero de telefone, afilia√ß√£o e t√≥picos de interesse de cada revisor tamb√©m s√£o registrados.
- ¬Ñ Cada artigo √© atribu√≠do a dois a quatro revisores. Um revisor avalia cada artigo atribu√≠do a ele ou ela em uma escala de 1 a 10, em quatro categorias: m√©rito t√©cnico, legibilidade, originalidade e relev√¢ncia √†  confer√™ncia. Por fim, cada revisor oferece uma recomenda√ß√£o geral com rela√ß√£o a cada artigo.
- ¬Ñ Cada revis√£o cont√©m dois tipos de coment√°rios escritos: um a ser visto pelo comit√™ de revis√£o apenas e o outro como retorno ao(s) autor(es).

Crie um diagrama Entidade-Relacionamento para o  banco  de  dados REVISAO\_CONFERENCIA e construa o projeto usando uma ferramenta de modelagem como ERwin ou Rational Rose.

7.35. Considere o diagrama ER para o banco de dados COMPANHIA AEREA mostrado  na  Figura  7.20. Construa esse projeto usando uma ferramenta de modelagem como ERwin ou Rational Rose.

## Bibliografia selecionada

O  modelo  Entidade-Relacionamento  foi  introduzido  por  Chen  (1976)  e  um  trabalho  relacionado aparece em Schmidt e Swenson (1975), Wiederhold e Elmasri (1979) e Senko (1975). Desde ent√£o, diversas modifica√ß√µes foram sugeridas no modelo ER. Incorporamos algumas delas em nossa apresenta√ß√£o. Restri√ß√µes estruturais sobre os relacionamentos s√£o discutidas em Abrial (1974), Elmasri e Wiederhold (1980), e Lenzerini e Santucci (1983). Atributos multivalorados e compostos s√£o incorporados ao modelo ER em Elmasri et al. (1985). Embora n√£o tenhamos discutido as linguagens para o modelo ER e suas extens√µes, h√° v√°rias propostas para tais linguagens. Elmasri e Wiederhold (1981) propuseram a linguagem de consulta GORDAS para o modelo ER. Outra linguagem de consulta  ER  foi  proposta  por  Markowitz  e  Raz  (1983). Senko (1980) apresentou uma linguagem de consulta para o modelo DIAM de Senko. Um conjunto formal de  opera√ß√µes,  chamado  √°lgebra  ER,  foi  apresentado por Parent e Spaccapietra (1985). Gogolla e Hohenstein (1991) apresentaram outra linguagem formal para o modelo ER. Campbell et al. (1985) apresentaram um conjunto de opera√ß√µes ER e mostraram que elas s√£o completas no sentido relacional. Uma reuni√£o para a dissemina√ß√£o dos resultados de pesquisa relacionada ao modelo ER tem sido mantida regularmente desde 1979. A confer√™ncia, agora conhecida como International Conference on Conceptual Modeling, foi realizada em Los Angeles (ER 1979, ER 1983, ER 1997), Washington,  D.C.  (ER  1981),  Chicago  (ER  1985), Dijon, na Fran√ßa (ER 1986), Nova York (ER 1987), Roma (ER 1988), Toronto (ER 1989), Lausanne, na Su√≠√ßa (ER 1990), San Mateo, na Calif√≥rnia (ER 1991), Karlsruhe, na Alemanha (ER 1992), Arlington, no Texas (ER 1993), Manchester, na Inglaterra (ER 1994), Brisbane,  na  Austr√°lia  (ER  1995),  Cottbus,  na  Alemanha  (ER  1996),  Cingapura  (ER  1998),  Paris,  na Fran√ßa (ER 1999), Salt Lake City, em Utah (ER 2000), Yokohama, no Jap√£o (ER 2001), Tampere, na Finl√¢ndia (ER 2002), Chicago, em Illinois (ER 2003), Shanghai, na China (ER 2004), Klagenfurt, na √Åustria (ER 2005), Tucson, no Arizona (ER 2006), Auckland, na Nova Zel√¢ndia (ER 2007), Barcelona, Catalunha, na Espanha (ER 2008) e Gramado, no Rio Grande do Sul, Brasil (ER 2009). A confer√™ncia de 2010 ser√° realizada em Vancouver, BC, no Canad√°.



## O modelo Entidade-Relacionamento Estendido (EER)

O s conceitos de modelagem ER discutidos no Cap√≠tulo 7 s√£o suficientes para representar muitos esquemas de banco de dados para aplica√ß√µes tradicionais ,  que  incluem  diversas  aplica√ß√µes  de  processamento de dados no com√©rcio e na ind√∫stria. Desde o final da d√©cada de 1970, por√©m, os projetistas de aplica√ß√µes de banco de dados t√™m tentado projetar esquemas de banco de dados mais precisos, que refletem as propriedades de dados e restri√ß√µes com mais precis√£o.  Isso  foi  particularmente  importante  para aplica√ß√µes mais novas da tecnologia de banco de dados, como aqueles para projeto de engenharia e manufatura  (CAD/CAM), 1   telecomunica√ß√µes,  sistemas de  software  complexos  e  sistemas  de  informa√ß√µes geo  gr√°ficas  ( GIS -Geographic  Information  Systems ),  entre  muitas  outras  aplica√ß√µes.  Esses  tipos  de bancos de dados possuem requisitos mais complexos do que as aplica√ß√µes mais tradicionais. Isso levou ao desenvolvimento de conceitos adicionais de modelagem sem√¢ntica de dados , que foram incorporados em modelos de dados conceituais, como o modelo ER. V√°rios modelos de dados sem√¢nticos t√™m sido propostos na literatura. Muitos desses conceitos tamb√©m foram  desenvolvidos  independentemente  nas  √°reas relacionadas de ci√™ncia da computa√ß√£o, como a √°rea de representa√ß√£o do conhecimento da intelig√™ncia artificial e a √°rea de modelagem de objeto na engenharia de software.

incluir esses conceitos, levando ao modelo ER Estendido (EER ). 2 Come√ßamos na Se√ß√£o 8.1 incorporando os conceitos de relacionamentos de classe/subclasse e heran√ßa de tipo ao modelo ER. Depois, na Se√ß√£o 8.2, acrescentamos os conceitos de especializa√ß√£o e generaliza√ß√£o . A Se√ß√£o 8.3 discute os diversos tipos de restri√ß√µes sobre especializa√ß√£o/generaliza√ß√£o, e a Se√ß√£o 8.4 mostra como a constru√ß√£o UNION pode ser modelada ao incluir o conceito de categoria no modelo EER. A Se√ß√£o 8.5 oferece um esquema de banco de dados de exemplo UNIVERSIDADE no modelo EER e resume os conceitos do modelo EER oferecendo defini√ß√µes formais. Usaremos os termos objeto e entidade com o mesmo significado neste cap√≠tulo, pois muitos desses conceitos s√£o comumente usados nos modelos orientados a objeto.

Apresentamos a nota√ß√£o do diagrama de classes UML para representar a especializa√ß√£o e a generaliza√ß√£o na Se√ß√£o 8.6, e as comparamos resumidamente com a nota√ß√£o e os conceitos de EER. Isso serve como um exemplo de nota√ß√£o alternativa, e √© uma continua√ß√£o da Se√ß√£o 7.8, a qual apresentou a nota√ß√£o b√°sica do diagrama de classes UML que corresponde ao modelo ER b√°sico. Na Se√ß√£o 8.7, discutimos as abstra√ß√µes fundamentais que s√£o usadas como base de muitos modelos de dados sem√¢nticos. No final do cap√≠tulo h√° um resumo.

Neste cap√≠tulo, descrevemos recursos que foram propostos para modelos de dados sem√¢nticos, e mostramos como o modelo ER pode ser melhorado para

Para uma introdu√ß√£o detalhada √† modelagem conceitual, o Cap√≠tulo 8 deve ser considerado uma continua√ß√£o do Cap√≠tulo 7. Contudo, se apenas uma introdu√ß√£o b√°sica √† modelagem ER for desejada, este

1 CAD/CAM significa Computer-Aided Design/Computer-Aided Manufacturing (projeto auxiliado por computador/fabrica√ß√£o auxiliada por computador).

2 EER tamb√©m tem sido usado para indicar o modelo ER Aprimorado.

cap√≠tulo  poder√°  ser  omitido.  Como  alternativa,  o leitor pode decidir pular algumas ou todas as se√ß√µes posteriores deste cap√≠tulo (se√ß√µes 8.4 a 8.8).

## 8.1 Subclasses, superclasses e heran√ßa

O modelo EER inclui todos os conceitos de modelagem do modelo ER que foram apresentados no Cap√≠tulo 7. Al√©m disso, inclui os conceitos de subclasse e superclasse e  os  conceitos  relacionados  de especializa√ß√£o e generaliza√ß√£o (ver se√ß√µes 8.2 e 8.3). Outro conceito inclu√≠do no modelo EER √© o de uma categoria ou tipo de uni√£o (ver Se√ß√£o 8.4) usado para representar uma cole√ß√£o de objetos (entidades), que √© a uni√£o de objetos de diferentes tipos de entidade. Associado a esses conceitos est√° o importante mecanismo de heran√ßa de atributo e relacionamento . Infelizmente, n√£o existe uma terminologia-padr√£o para esses conceitos, de modo que usamos a terminologia mais comum. A terminologia alternativa √© dada nas notas de rodap√©. Tamb√©m descrevemos uma t√©cnica diagram√°tica para exibir esses conceitos quando eles surgem em um esquema EER. Chamamos os diagramas de esquema resultantes de diagramas ER estendidos , ou diagramas EER .

O primeiro conceito do modelo ER Estendidos (EER) ao qual nos dedicamos √© o de um subtipo ou subclasse de  um tipo de entidade. Conforme discu- timos no Cap√≠tulo 7, um tipo de entidade √© usado para representar um tipo  de  entidade e  o conjunto de entidades ou cole√ß√£o de entidades desse tipo que existem no banco de dados. Por exemplo, o tipo de entidade FUNCIONARIO descreve  o  tipo  (ou  seja,  os atributos e relacionamentos) de cada entidade de funcion√°rio, e tamb√©m se refere ao conjunto atual de entidades FUNCIONARIO no banco de dados EMPRESA . Em muitos casos, um tipo de entidade tem diversos subagrupamentos ou subtipos de suas entidades que s√£o significativos e precisam ser representados explicitamente, por causa de seu significado para a aplica√ß√£o de banco de dados. Por exemplo, as entidades que s√£o membros do tipo de entidade FUNCIONARIO podem ser distinguidas ainda mais em SECRETARIA , ENGENHEIRO , GERENTE, TECNICO , FUNCIONA -RIO\_MENSAL, FUNCIONARIO\_HORISTA, e assim por diante. O conjunto de entidades em cada um desses agrupamentos √© um subconjunto das entidades que pertencem ao conjunto de entidades FUNCIONARIO , significando que cada entidade que √© membro de um desses subagrupamentos tamb√©m √© um funcion√°rio. Chamamos cada um desses subagrupamentos de subclasse ou subtipo do tipo de entidade FUNCIONARIO , e  o  tipo  de  entidade FUNCIONARIO √©  chamado  de superclasse ou supertipo para cada uma dessas subclasses. A Figura 8.1 mostra como representar esses conceitos nos diagramas EER. (A nota√ß√£o de c√≠rculo na Figura 8.1 ser√° explicada na Se√ß√£o 8.2.)



Chamamos  o  relacionamento  entre  uma  superclasse  e  qualquer  uma  de  suas  subclasses  de relacionamento  superclasse/subclasse ,  ou supertipo/subtipo , ou simplesmente classe/subclasse . 3 Em nosso exemplo anterior, FUNCIONARIO SECRETARIA / e FUNCIONARIO / TECNICO s√£o dois relacionamentos de classe/subclasse. Observe  que  uma  entidade-membro  da  subclasse  representa a mesma entidade do mundo real de  algum membro  da  superclasse.  Por  exemplo,  uma  entidade SECRETARIA 'Joana  Logano'  tamb√©m  √©  a  entidade FUNCIONARIO 'Joana  Logano'.  Logo,  o  membro  da subclasse √© o mesmo que a entidade na superclasse, mas em um papel espec√≠fico distinto. Por√©m, quando implementamos um relacionamento de superclasse/subclasse no  sistema  de  banco  de  dados,  podemos  representar um membro da subclasse como um objeto de banco de dados distinto - digamos, um registro distinto que √© relacionado por meio do atributo-chave a sua entidade de superclasse. Na Se√ß√£o 9.2, discutiremos diversas op√ß√µes para representar os relacionamentos de superclasse/subclasse nos bancos de dados relacionais.

Uma  entidade  n√£o  pode  existir  no  banco  de dados  simplesmente  por  ser  um  membro  de  uma subclasse;  ela  tamb√©m  precisa  ser  um  membro  da superclasse.  Essa  entidade  pode  ser  inclu√≠da  opcionalmente como um membro de qualquer n√∫mero de subclasses.  Por  exemplo,  um  funcion√°rio  assalariado  que  tamb√©m  √©  um  engenheiro  pertence  √†s  duas subclasses ENGENHEIRO e FUNCIONARIO\_MENSAL do tipo de entidade FUNCIONARIO . Contudo, n√£o √© necess√°rio que toda entidade em uma superclasse seja um membro de alguma subclasse.

Um conceito importante associado √†s subclasses (subtipos) √© o de heran√ßa de tipo . Lembre-se de que o tipo de uma entidade √© definido pelos atributos que ela possui e os tipos de relacionamento de que participa. Como uma entidade na subclasse representa a mesma entidade do mundo real da superclasse, ela deve possuir valores para seus atributos espec√≠ficos bem como valores de seus atributos como um membro da superclasse. Dizemos que uma entidade que √© um membro de uma subclasse herda todos os atributos da entidade como um membro da superclasse. A entidade tamb√©m herda todos os relacionamentos de que a superclasse participa. Observe que uma subclasse, com os pr√≥prios atributos espec√≠ficos (ou locais) e relacionamentos junto com todos os atributos e relacionamentos que herda da superclasse, pode ser considerada um tipo de entidade por si pr√≥pria. 4

## 8.2 Especializa√ß√£o e generaliza√ß√£o

## 8.2.1 Especializa√ß√£o

Especializa√ß√£o √© o processo de definir um conjunto de subclasses de um tipo de entidade. Esse tipo de entidade √© chamado de superclasse da especializa√ß√£o. O conjunto de subclasses que forma uma especializa√ß√£o √© definido com base em alguma caracter√≠stica distinta das entidades na superclasse. Por exemplo, o conjunto de subclasses { SECRETARIA , ENGENHEIRO , TECNICO } √© uma especializa√ß√£o da superclasse FUN -CIONARIO , que distingue as entidades do funcion√°rio com base no tipo de cargo de  cada  uma.  Podemos ter v√°rias especializa√ß√µes do mesmo tipo de entidade com base em caracter√≠sticas distintas. Por exemplo, outra especializa√ß√£o do tipo de entidade FUNCIONA -RIO pode gerar o conjunto de subclasses { FUNCIONA -RIO\_MENSAL, FUNCIONARIO\_HORISTA }. Tal  especializa√ß√£o distingue os funcion√°rios baseando-se no m√©todo de pagamento .

A Figura 8.1 mostra como representamos uma especializa√ß√£o  na  forma  de  um  diagrama  EER.  As subclasses  que  definem  uma  especializa√ß√£o  s√£o  conectadas  por  linhas  a  um  c√≠rculo  que  representa  a especializa√ß√£o,  o  qual  est√°  conectado,  por  sua  vez, √† superclasse. O s√≠mbolo de subconjunto em cada linha que conecta uma subclasse ao c√≠rculo indica a dire√ß√£o do relacionamento superclasse/subclasse. 5  Os atributos que se aplicam apenas a entidades de uma subclasse  em  particular  -  como Velocidade\_digita-cao de SECRETARIA - s√£o conectados ao ret√¢ngulo que representa essa subclasse. Estes s√£o chamados de atributos espec√≠ficos (ou atributos locais ) da subclasse. De modo semelhante, uma subclasse pode participar de tipos de relacionamento espec√≠ficos , como a subclasse FUNCIONARIO\_HORISTA que  participa  do relacionamento PERTENCE\_A da  Figura  8.1.  Explicaremos o s√≠mbolo d nos c√≠rculos da Figura 8.1 e a nota√ß√£o adicional do diagrama EER em breve.

A Figura 8.2 mostra algumas inst√¢ncias de entidade que pertencem √†s subclasses da especializa√ß√£o { SECRETARIA , ENGENHEIRO , TECNICO }. Novamente, observe que uma entidade que pertence a uma subclasse representa a mesma entidade do mundo real que a entidade conectada a ela na superclasse FUN -CIONARIO , embora a mesma entidade apare√ßa duas vezes; por exemplo, f 1 aparece em FUNCIONARIO e SECRETARIA na  Figura  8.2.  Como  a  figura  sugere,

3 Um relacionamento de classe/subclasse com frequ√™ncia √© chamado de relacionamento √â\_UM IS-A ( - ou seja, √© um(a)), devido ao modo como nos referimos ao conceito. Dizemos que uma SECRETARIA √© uma FUNCIONARIA, um TECNICO √© um FUNCIONARIO, e assim por diante.

4 Em algumas linguagens de programa√ß√£o orientadas a objeto, uma restri√ß√£o comum √© que uma entidade (ou objeto) tem apenas um tipo . Isso geralmente √© muito restritivo para a modelagem conceitual do banco de dados.

5 Existem muitas nota√ß√µes alternativas para a especializa√ß√£o; apresentamos a nota√ß√£o UML na Se√ß√£o 8.6 e outras nota√ß√µes propostas no Ap√™ndice A.

Figura 8.2 Inst√¢ncias de uma especializa√ß√£o.



um  relacionamento  de  superclasse/subclasse,  como FUNCIONARIO SECRETARIA, / assemelha-se  a  um  relacionamento 1:1 no n√≠vel  de  inst√¢ncia (ver  Figura 7.12).  A  principal  diferen√ßa  √©  que,  em  um  relacionamento 1:1, duas entidades distintas est√£o relacionadas, enquanto em um relacionamento superclasse/ subclasse a entidade na subclasse √© a mesma entidade do mundo real que a entidade na superclasse, mas est√° desempenhando um papel especializado - por exemplo, um FUNCIONARIO especializado no papel de SECRETARIA , ou um FUNCIONARIO especializado no papel de TECNICO .

Existem dois motivos principais para incluir relacionamentos de classe/subclasse e especializa√ß√µes em um modelo de dados. O primeiro √© que certos atributos  podem  se  aplicar  a  algumas,  mas  n√£o  a todas as entidades da superclasse. Uma subclasse √© definida a fim de agrupar as entidades √†s quais esses atributos se aplicam. Os membros da subclasse ainda podem compartilhar a maioria de seus atributos com os outros membros da superclasse. Por exemplo, na Figura 8.1, a subclasse SECRETARIA tem o atributo  espec√≠fico Velocidade\_digita√ß√£o ,  enquanto a subclasse ENGENHEIRO tem o atributo espec√≠fico Tipo\_eng ,  mas SECRETARIA e ENGENHEIRO compartilham seus outros atributos herdados do tipo de entidade FUNCIONARIO .

O segundo motivo para usar subclasses √© que alguns tipos de relacionamento podem participar apenas de entidades que s√£o membros da subclasse. Por exemplo, se apenas FUNCIONARIOS\_HORISTAS puderem pertencer a um sindicato, podemos representar esse fato criando a subclasse FUNCIONARIO\_HO -RISTA de FUNCIONARIO e  relacionando a subclasse a um tipo de entidade SINDICATO por meio do tipo de relacionamento PERTENCE\_A , conforme ilustrado na Figura 8.1.

Resumindo,  o  processo  de  especializa√ß√£o  nos permite fazer o seguinte:

- ¬Ñ Definir um conjunto de subclasses de um tipo de entidade.
- ¬Ñ Estabelecer  atributos  espec√≠ficos  adicionais com cada subclasse.
- ¬Ñ Estabelecer  tipos  de  relacionamento  espec√≠fico adicionais entre cada subclasse e outros tipos de entidade ou outras subclasses.

## 8.2.2 Generaliza√ß√£o

Podemos  pensar  em  um processo  reverso da abstra√ß√£o  em  que  suprimimos  as  diferen√ßas  entre v√°rios tipos de entidade, identificamos suas caracter√≠sticas comuns e as generalizamos em uma √∫nica superclasse da  qual  os  tipos  de  entidade  originais s√£o subclasses especiais. Por exemplo, considere os tipos de entidade CARRO e CAMINHAO mostrados na  Figura  8.3(a).  Como  eles  t√™m  v√°rios  atributos comuns, podem ser generalizados no tipo de entidade VEICULO , como mostra a Figura 8.3(b). Tanto CARRO quanto CAMINHAO agora s√£o subclasses da superclasse generalizada VEICULO . Usamos o termo generaliza√ß√£o para nos referir ao processo de defini√ß√£o de um tipo de entidade generalizado com base nos tipos de entidade dados.

Observe que o processo de generaliza√ß√£o pode ser visto como sendo funcionalmente o inverso do processo  de  especializa√ß√£o.  Assim,  na  Figura  8.3, podemos  ver  { CARRO , CAMINHAO } como  uma especializa√ß√£o  de VEICULO , em  vez  de VEICULO como uma generaliza√ß√£o de CARRO e CAMINHAO . De modo semelhante, na Figura 8.1, podemos ver FUNCIONARIO como uma generaliza√ß√£o de SECRE -TARIA , TECNICO e ENGENHEIRO . Uma  nota√ß√£o diagram√°tica  para  distinguir  generaliza√ß√£o  de  especializa√ß√£o √© usada em algumas metodologias de projeto. Uma seta apontando para a superclasse ge-

Figura 8.3 Generaliza√ß√£o. (a) Dois tipos de entidade, CARRO e CAMINHAO. (b) Generalizando CARRO e CAMINHAO na superclasse VEICULO.



neralizada representa uma generaliza√ß√£o, ao passo que setas apontando para subclasses especializadas representam uma especializa√ß√£o. N√£o usaremos essa nota√ß√£o porque a decis√£o sobre qual processo √© seguido em determinada situa√ß√£o costuma ser subjetiva. O Ap√™ndice A oferece algumas nota√ß√µes diagram√°ticas alternativas sugeridas para diagramas de esquema e diagramas de classe.

At√© aqui, apresentamos os conceitos de subclasses e relacionamentos de superclasse/subclasse, bem como os processos de especializa√ß√£o e generaliza√ß√£o. Em geral,  uma  superclasse  ou  subclasse  representa uma cole√ß√£o de entidades do mesmo tipo e, portanto, tamb√©m descreve um tipo de entidade ; √© por isso que as superclasses e subclasses s√£o todas mostradas em ret√¢ngulos nos diagramas EER, como os tipos de entidade. Em seguida, discutimos as propriedades das especializa√ß√µes e generaliza√ß√µes com mais detalhes.

## 8.3 Restri√ß√µes e caracter√≠sticas das hierarquias de especializa√ß√£o e generaliza√ß√£o

Primeiro, vamos discutir as restri√ß√µes que se aplicam a uma √∫nica especializa√ß√£o ou a uma √∫nica generaliza√ß√£o. Para abreviar, nossa discuss√£o refere-se apenas √† especializa√ß√£o , embora se aplique tamb√©m √†  generaliza√ß√£o.  Depois,  vamos  discutir  as  diferen√ßas entre reticulado ( heran√ßa m√∫ltipla ) e hierarquias ( heran√ßa simples )  de  especializa√ß√£o/generaliza√ß√£o, e detalhar as diferen√ßas entre os processos de especiali- za√ß√£o e generaliza√ß√£o durante o projeto de esquema de banco de dados conceitual.

## 8.3.1 Restri√ß√µes sobre especializa√ß√£o e generaliza√ß√£o

Em geral, podemos ter v√°rias especializa√ß√µes definidas no mesmo tipo de entidade (ou superclasse), como mostra a Figura 8.1. Nesse caso, as entidades podem pertencer a subclasses em cada uma das especializa√ß√µes. Contudo, uma especializa√ß√£o tamb√©m pode consistir em uma √∫nica subclasse apenas, como a  especializa√ß√£o  { GERENTE }  na  Figura  8.1;  em  tal caso, n√£o usamos a nota√ß√£o de c√≠rculo.

Em algumas especializa√ß√µes, podemos determinar exatamente as entidades que se tornar√£o membros de cada subclasse ao colocar uma condi√ß√£o sobre o valor de algum atributo da superclasse. Essas subclasses s√£o chamadas subclasses definidas por predicado (ou definidas por condi√ß√£o ). Por exemplo, se o tipo de entidade FUNCIONARIO tiver um atributo Tipo\_emprego , como mostra a Figura 8.4, podemos especificar a condi√ß√£o  de  membro  na  subclasse SECRETARIA pela condi√ß√£o  ( Tipo\_emprego =  'Secretaria'),  que  chamamos de predicado de defini√ß√£o da subclasse. Essa condi√ß√£o √© uma restri√ß√£o que especifica exatamente que aquelas entidades do tipo de entidade FUNCIONARIO , cujo valor de atributo para Tipo\_emprego √© 'Secretaria',  pertencem √† subclasse. Apresentamos uma subclasse definida pelo predicado escrevendo a condi√ß√£o de predicado ao lado da linha que conecta a subclasse ao c√≠rculo de especializa√ß√£o.

Figura 8.4 Nota√ß√£o do diagrama EER para uma especializa√ß√£o definida por atributo sobre Tipo\_emprego.



Se todas as subclasses em uma especializa√ß√£o tiverem sua condi√ß√£o de membro no mesmo atributo da superclasse, a pr√≥pria especializa√ß√£o √© chamada de especializa√ß√£o definida por atributo , e o atributo √© chamado de atributo de defini√ß√£o da especializa√ß√£o. 6 Nesse caso, todas as entidades com o mesmo valor para o atributo pertencem √† mesma subclasse. Apresentamos uma especializa√ß√£o definida por atributo colocando o nome do atributo de defini√ß√£o ao lado do arco que vai do c√≠rculo √† superclasse, como mostra a Figura 8.4.

ser disjunta, conforme ilustrado pela especializa√ß√£o { FUNCIONARIO\_HORISTA, FUNCIONARIO\_MENSAL } na Figura 8.1. Se as subclasses n√£o forem restringidas a serem disjuntas, seus conjuntos de entidades podem ser sobrepostos ; ou seja, a mesma entidade (mundo real) pode ser um membro de mais de uma subclasse da especializa√ß√£o. Esse caso, que √© o padr√£o, √© exibido colocando-se um o (de overlapping ) no c√≠rculo, como mostra a Figura 8.5.

Quando n√£o temos uma condi√ß√£o para determinar os membros em uma subclasse, diz-se que esta √© definida pelo usu√°rio . A condi√ß√£o de membro nessa subclasse √© determinada pelos usu√°rios do banco de dados quando eles aplicam a opera√ß√£o para incluir uma entidade √† subclasse; logo, a condi√ß√£o de membro √© especificada individualmente para cada entidade  pelo  usu√°rio, e  n√£o  por  qualquer  condi√ß√£o  que possa ser avaliada automaticamente.

Duas outras restri√ß√µes podem se aplicar a uma especializa√ß√£o. A primeira √© a restri√ß√£o de disjun√ß√£o (ou desconex√£o ), que especifica que as subclasses da especializa√ß√£o devem ser disjuntas. Isso significa que uma entidade pode ser um membro de no m√°ximo uma das subclasses da especializa√ß√£o. Uma especializa√ß√£o que  √©  definida  por  atributo  implica  a  restri√ß√£o  de disjun√ß√£o (se o atributo usado para definir o predicado de membro for de valor √∫nico). A Figura 8.4 ilustra esse caso, onde o d no c√≠rculo significa disjun√ß√£o . A nota√ß√£o d tamb√©m se aplica a subclasses definidas pelo usu√°rio de uma especializa√ß√£o que precisa

A segunda restri√ß√£o sobre a especializa√ß√£o √© chamada de restri√ß√£o de completude (ou totalidade ), que pode ser total ou parcial. Uma restri√ß√£o de especializa√ß√£o total especifica que toda entidade na superclasse  precisa  ser  um  membro  de  pelo  menos  uma subclasse  na  especializa√ß√£o.  Por  exemplo,  se  todo FUNCIONARIO tiver  de  ser  um FUNCIONARIO\_HO -RISTA ou um FUNCIONARIO\_MENSAL, ent√£o a especializa√ß√£o { FUNCIONARIO\_HORISTA, FUNCIONARIO\_ MENSAL } da Figura 8.1 √© uma especializa√ß√£o total de FUNCIONARIO . Isso √© mostrado nos diagramas EER usando uma linha dupla para conectar a superclasse ao c√≠rculo. Uma linha simples √© utilizada para exibir uma especializa√ß√£o parcial , que permite que uma entidade n√£o perten√ßa a qualquer uma das subclasses. Por  exemplo,  se  algumas  entidades FUNCIONARIO n√£o pertencerem a nenhuma das subclasses { SECRE -TARIA , ENGENHEIRO , TECNICO }  nas  figuras  8.1  e 8.4, ent√£o essa especializa√ß√£o ser√° parcial. 7

Observe que as restri√ß√µes de disjun√ß√£o e completude s√£o independentes .  Logo,  temos quatro restri√ß√µes poss√≠veis na especializa√ß√£o:

6 Tal atributo √© chamado de discriminador em terminologia UML.

7 A nota√ß√£o de usar linhas simples ou duplas √© semelhante √† da participa√ß√£o parcial ou total de um tipo de entidade em um tipo de relacionamento, conforme descrito no Cap√≠tulo 7.

Figura 8.5 Nota√ß√£o de diagrama EER para uma especializa√ß√£o sobreposta (n√£o disjunta).



- ¬Ñ Disjun√ß√£o, total.
- ¬Ñ Disjun√ß√£o, parcial.
- ¬Ñ Sobreposi√ß√£o, total.
- ¬Ñ Sobreposi√ß√£o, parcial.

Naturalmente, a restri√ß√£o correta √© determinada com base no significado do mundo real que se aplica a cada especializa√ß√£o. Em geral, uma superclasse que foi identificada por meio do processo de generaliza√ß√£o costuma ser total , pois a superclasse √© derivada das subclasses e, portanto, cont√©m apenas as entidades que est√£o nas subclasses.

e tamb√©m uma superclasse de GERENTE\_ENGENHEI -RO . Isso representa a restri√ß√£o do mundo real de que cada  gerente  engenheiro  precisa  ser  um  engenheiro. Uma hierarquia  de  especializa√ß√£o tem  a  restri√ß√£o  de que cada subclasse participa como uma subclasse em apenas um relacionamento de classe/subclasse; ou seja, cada subclasse tem apenas um pai, que resulta em uma estrutura de √°rvore ou hierarquia estrita . Ao contr√°rio, para  um reticulado  de  especializa√ß√£o ,  uma  subclasse pode ser uma subclasse em mais de um relacionamento de classe/subclasse. Assim, a Figura 8.6 √© um reticulado.

Certas regras de inser√ß√£o e exclus√£o se aplicam √† especializa√ß√£o (e generaliza√ß√£o) como uma consequ√™ncia  das  restri√ß√µes  especificadas  anteriormente. Algumas dessas regras s√£o as seguintes:

- ¬Ñ Excluir uma entidade de uma superclasse implica que ela seja automaticamente exclu√≠da de todas as subclasses √†s quais pertence.
- ¬Ñ Inserir uma entidade em uma superclasse implica que a entidade seja obrigatoriamente inserida em todas as subclasses definidas por predicado (ou definidas por atributo ) para as quais a entidade satisfaz o predicado de defini√ß√£o.
- ¬Ñ Inserir uma entidade em uma superclasse de uma especializa√ß√£o total implica que a entidade  √©  obrigatoriamente  inserida  em,  pelo menos, uma das subclasses da especializa√ß√£o.

O leitor √© encorajado a fazer uma lista completa das regras para inser√ß√µes e exclus√µes para os v√°rios tipos de especializa√ß√µes.

## 8.3.2 Hierarquias e reticulado da especializa√ß√£o e generaliza√ß√£o

A pr√≥pria subclasse pode ter mais subclasses especificadas  nela,  formando  uma  hierarquia  ou  um reticulado de especializa√ß√µes. Por exemplo, na Figura 8.6, ENGENHEIRO √© uma subclasse de FUNCIONARIO

A Figura 8.7 mostra outro reticulado  de  especializa√ß√£o de mais de um n√≠vel. Isso pode ser parte de um esquema conceitual para um banco de dados UNIVERSIDADE . Observe que essa organiza√ß√£o teria sido  uma  hierarquia,  exceto  para  a  subclasse ALU -NO\_COLABORADOR ,  que  √©  uma  subclasse  em  dois relacionamentos de classe/subclasse distintos.

Os requisitos para a parte do banco de dados UNI -VERSIDADE mostrados na Figura 8.7 s√£o os seguintes:

- 1. O banco de dados registra tr√™s tipos de pessoas: funcion√°rios, ex-alunos e alunos. Uma pessoa pode pertencer a um, dois ou a todos esses tr√™s tipos. Cada pessoa tem um nome, CPF  sexo, endere√ßo e data de nascimento. ,
- 2. Cada funcion√°rio tem um sal√°rio, e existem tr√™s tipos de funcion√°rios: docente, administrativo e aluno colaborador. Cada funcion√°rio pertence a exatamente um desses tipos. Para cada ex-aluno, √© mantido um registro do t√≠tulo ou dos t√≠tulos que ele obteve na universidade, incluindo o nome do t√≠tulo, o ano em que o t√≠tulo foi concedido e o curso em que se formou. Cada aluno tem um departamento principal.
- 3. Cada membro do corpo docente tem um n√≠vel, enquanto  cada  membro  administrativo  tem um cargo administrativo. Os alunos colaboradores s√£o classificados  ainda  como  colabora-

Figura 8.6 Um reticulado de especializa√ß√£o com a subclasse compartilhada GERENTE\_ENGENHEIRO.



Figura 8.7 Um reticulado de especializa√ß√£o com heran√ßa m√∫ltipla para um banco de dados UNIVERSIDADE.



dores de pesquisa ou colaboradores de ensino, e a porcentagem de tempo em que eles trabalham √© registrada no banco de dados. Os colaboradores de pesquisa t√™m seu projeto de pesquisa armazenado, ao passo que os colaboradores de ensino t√™m a disciplina atual em que trabalham.

c√≠ficos  de  t√≠tulo  do  programa  (mestrado,  doutorado, M.B.A. etc.) para alunos de p√≥s-gradua√ß√£o formados e tipo de aluno (novato, segundo ano etc.) para os alunos de gradua√ß√£o.

- 4. Os alunos s√£o classificados ainda como p√≥s-gradua√ß√£o ou gradua√ß√£o, com os atributos espe-

Na Figura 8.7, todas as entidades de pessoa representadas no banco de dados s√£o membros do tipo de entidade PESSOA ,  que  √©  especializado  nas  subclasses

{ FUNCIONARIO , EX-ALUNO , ALUNO }. Essa especializa√ß√£o √© sobreposta; por exemplo, um ex-aluno tamb√©m pode ser um funcion√°rio e ainda pode ser um aluno buscando um t√≠tulo avan√ßado. A subclasse ALUNO √© a superclasse para a especializa√ß√£o { ALUNO\_POSGRADU -ACAO , ALUNO\_GRADUACAO },  enquanto FUNCIONA -RIO √© a superclasse para a especializa√ß√£o { ALUNO\_CO -LABORADOR , DOCENTE , ADMINISTRATIVO }.  Observe que ALUNO\_COLABORADOR tamb√©m √© uma subclasse de ALUNO .  Finalmente, ALUNO\_COLABORADOR √©  a superclasse para a especializa√ß√£o em { COLABORADOR\_ PESQUISA COLABORADOR\_ENSINO , }.

Em tal reticulado ou hierarquia de especializa√ß√£o, uma subclasse herda os atributos n√£o apenas de sua superclasse direta, mas tamb√©m de todas as suas superclasses predecessoras, at√© chegar √† raiz da hierarquia ou reticulado,  se  necess√°rio.  Por  exemplo,  uma  entidade em ALUNO\_POSGRADUACAO herda todos os atributos dessa entidade como um ALUNO e como uma PESSOA . Observe que uma entidade pode existir em v√°rios n√≥s folha da hierarquia, em que um n√≥ folha √© uma classe que n√£o tem subclasses pr√≥prias . Por exemplo, um membro  de ALUNO\_GRADUACAO tamb√©m  pode  ser um membro de COLABORADOR\_PESQUISA

Uma subclasse com mais de uma superclasse √© chamada de subclasse compartilhada , como GEREN -TE\_ENGENHEIRO na Figura 8.6. Isso leva ao conceito conhecido como heran√ßa m√∫ltipla , na qual a subclasse compartilhada GERENTE\_ENGENHEIRO herda diretamente atributos e relacionamentos de m√∫ltiplas classes. Observe que a exist√™ncia de pelo menos uma subclasse compartilhada leva a um reticulado (e, portanto, √† heran√ßa m√∫ltipla ). Se n√£o existisse qualquer subclasse  compartilhada,  ter√≠amos  uma  hierarquia em vez de um reticulado, e somente a heran√ßa simples existiria.  Uma  regra  importante  relacionada  √† heran√ßa m√∫ltipla pode ser ilustrada pelo exemplo da subclasse compartilhada ALUNO\_COLABORADOR na Figura 8.7, que herda atributos de FUNCIONARIO e ALUNO .  Aqui,  tanto FUNCIONARIO quanto ALUNO herdam os  mesmos  atributos de PESSOA .  A  regra declara que, se um atributo (ou relacionamento) originado na mesma superclasse ( PESSOA )  √©  herdado mais de uma vez por caminhos diferentes ( FUNCIO -NARIO e ALUNO ) no reticulado, ent√£o ele dever√° ser inclu√≠do apenas uma vez na subclasse compartilhada ( ALUNO\_COLABORADOR ).  Logo, os atributos de PESSOA s√£o herdados apenas uma vez na subclasse ALUNO\_COLABORADOR da Figura 8.7.

lhadas).  Tamb√©m  √©  importante  observar  que  alguns modelos n√£o permitem que uma entidade tenha tipos m√∫ltiplos, e, portanto, uma entidade pode ser membro de  apenas  uma  classe  folha . 8 Em  tal  modelo,  √© necess√°rio  criar  subclasses  adicionais  como  n√≥s  folha para cobrir todas as combina√ß√µes poss√≠veis de classes que podem ter alguma entidade que perten√ßa a todas essas classes simultaneamente. Por exemplo, em uma especializa√ß√£o de sobreposi√ß√£o de PESSOA para { FUNCIONARIO , EX-ALUNO , ALUNO } (ou { F, E, A } para abreviar), seria necess√°rio criar sete subclasses de PESSOA a  fim de cobrir todos os tipos de entidades poss√≠veis: F, E, A , F\_E, F\_A , E\_A e F\_E\_A . Obviamente, isso pode gerar uma complexidade extra.

Embora  tenhamos  usado  a  especializa√ß√£o  para ilustrar nossa discuss√£o, conceitos semelhantes se aplicam  igualmente √†  generaliza√ß√£o,  conforme  mencionamos no in√≠cio desta se√ß√£o. Logo, tamb√©m podemos falar de hierarquias de generaliza√ß√£o e reticulados de generaliza√ß√£o.

## 8.3.3 Utilizando especializa√ß√£o e generaliza√ß√£o no refinamento de esquemas conceituais

√â importante observar aqui que alguns modelos e  linguagens  s√£o  limitados  √† heran√ßa  simples e n√£o permitem a  heran√ßa  m√∫ltipla  (subclasses  comparti-

Agora, vamos detalhar as diferen√ßas entre os processos de especializa√ß√£o e generaliza√ß√£o, e como eles s√£o usados para refinar os esquemas conceituais durante o projeto conceitual do banco de dados. No processo de especializa√ß√£o, normalmente come√ßamos com um tipo de entidade e depois definimos subclasses do tipo de entidade pela especializa√ß√£o sucessiva; ou seja, definimos repetidamente agrupamentos mais espec√≠ficos do tipo de entidade. Por exemplo, ao projetar o reticulado de especializa√ß√£o da Figura 8.7, podemos primeiro especificar um tipo de entidade PESSOA para um banco de dados de universidade. Depois, descobriremos que tr√™s tipos de pessoas ser√£o representados no banco de dados: funcion√°rios da universidade, ex-alunos e alunos. Criamos a especializa√ß√£o { FUNCIONARIO , EX-ALUNO , ALUNO } para essa finalidade e escolhemos a restri√ß√£o de  sobreposi√ß√£o,  pois  uma  pessoa  pode  pertencer  a mais de uma das subclasses. Especializamos FUNCIO -NARIO ainda  mais  em  { DOCENTE , ADMINISTRATIVO , ALUNO\_COLABORADOR } e especializamos ALUNO em { ALUNO\_GRADUACAO , ALUNO\_POSGRADUACAO }. Por  fim,  especializamos ALUNO\_COLABORADOR em { COLABORADOR\_PESQUISA , COLABORADOR\_EN -SINO }. Essa  especializa√ß√£o  sucessiva  corresponde  a um processo de refinamento conceitual de cima para baixo(top-down) durante o projeto do esquema conceitual. At√© aqui, temos uma hierarquia; depois, obser-

8 Em alguns modelos, a classe √© restringida ainda mais para ser um n√≥ folha na hierarquia ou no reticulado.

vamos que ALUNO\_COLABORADOR √© uma subclasse compartilhada, pois ela tamb√©m √© uma subclasse de ALUNO , o que leva ao reticulado.

√â poss√≠vel chegar √† mesma hierarquia ou reticulado vindo de outra dire√ß√£o. Nesse caso, o processo envolve a generaliza√ß√£o, em vez da especializa√ß√£o, e corresponde a uma s√≠ntese conceitual de baixo para cima (bottom-up) . Por exemplo, os projetistas de banco de dados podem primeiro descobrir tipos de entidade como ADMINISTRATIVO, DOCENTE , EX-ALUNO , ALUNO\_GRADUACAO , ALUNO\_POSGRADUACAO , COLABORADOR\_PESQUISA , COLABORADOR\_ENSI -NO , e assim por diante; depois, eles podem generalizar { ALUNO\_GRADUACAO , ALUNO\_POSGRADUACAO } para ALUNO ;  da√≠  generalizar  { COLABORADOR\_PES -QUISA , COLABORADOR\_ENSINO }  para ALUNO\_CO -LABORADOR ; ent√£o  generalizar  { ADMINISTRATIVO, DOCENTE , ALUNO\_COLABORADOR }  para FUNCIO -NARIO ; e, finalmente, generalizar { FUNCIONARIO EX , --ALUNO , ALUNO } para PESSOA .

Em termos estruturais, hierarquias ou reticulados resultantes de qualquer processo podem ser id√™nticas. A √∫nica diferen√ßa relaciona-se √† maneira ou ordem em que as superclasses e subclasses do esquema foram criadas durante o processo de projeto. Na pr√°tica, √© prov√°vel que nem o processo de generaliza√ß√£o  nem  de  especializa√ß√£o  seja  seguido estritamente, mas que seja empregada uma combina√ß√£o dos dois processos. Novas classes s√£o incorporadas de maneira cont√≠nua em uma hierarquia ou reticulado √† medida que elas se tornam aparentes  aos  usu√°rios  e  projetistas.  Observe  que  a  no√ß√£o de representar dados e conhecimento usando hierarquias  e  reticulados  de  superclasse/subclasse √©  muito comum em sistemas baseados em conhecimento e sistemas especialistas, que combinam a tecnologia de banco de dados com t√©cnicas de intelig√™ncia artificial. Por exemplo, esquemas de representa√ß√£o do conhecimento baseada em quadro s√£o muito semelhantes √†s hierarquias de classes. A especializa√ß√£o tamb√©m √© comum nas metodologias de projeto de engenharia de software que s√£o baseadas no paradigma orientado a objeto.

## 8.4 Modelagem dos tipos UNIAO usando categorias

Todos  os  relacionamentos  de  superclasse/subclasse que vimos at√© aqui t√™m uma √∫nica superclasse . Uma subclasse compartilhada como GERENTE\_EN -GENHEIRO no reticulado da Figura 8.6 √© a subclasse em tr√™s relacionamentos de superclasse/subclasse dis- tintos , em que cada um dos tr√™s relacionamentos tem uma √∫nica superclasse. Por√©m, √†s vezes √© necess√°rio representar um √∫nico relacionamento de superclasse/ subclasse com mais de uma superclasse, no qual as superclasses representam diferentes tipos de entidade. Nesse caso, a subclasse representar√° uma cole√ß√£o  de  objetos  que  √©  um  subconjunto  da UNIAO de tipos de entidade distintos. Chamamos essa subclasse de tipo de uni√£o ou categoria . 9

Por exemplo, suponha que tenhamos tr√™s tipos de entidade: PESSOA BANCO , e EMPRESA . Em um banco de dados para registro de ve√≠culo a motor, o propriet√°rio  de  um  ve√≠culo  pode  ser  uma  pessoa, um banco (mantendo uma aliena√ß√£o sobre um ve√≠culo) ou uma empresa. Precisamos criar uma classe (cole√ß√£o de entidades) que inclui entidades de todos os tr√™s tipos para desempenhar o papel de propriet√°rio de ve√≠culo . Uma categoria (tipo de uni√£o) PROPRIETARIO , que √© uma subclasse da UNI√ÉO dos tr√™s conjuntos de entidades de EMPRESA BANCO , e PESSOA , pode ser criada para essa finalidade. Exibimos  categorias  no  diagrama  EER  como  mostra a Figura 8.8. As superclasses EMPRESA , BANCO e PESSOA s√£o conectadas ao c√≠rculo com o s√≠mbolo ‚à™ ,  que  significa opera√ß√£o  de  uni√£o  de  conjuntos . Um arco  com  o  s√≠mbolo  de  subconjunto  conecta o  c√≠rculo  √†  categoria  (subclasse) PROPRIETARIO . Se um predicado de defini√ß√£o for necess√°rio, ele √© exibido  ao  lado  da  linha  da  superclasse  √†  qual  o predicado se aplica. Na Figura 8.8, temos duas categorias: PROPRIETARIO ,  que  √©  uma  subclasse  da uni√£o de PESSOA , BANCO e EMPRESA ;  e VEICU -LO\_REGISTRADO , que √© uma subclasse da uni√£o de CARRO e CAMINHAO .

Uma categoria tem duas ou mais superclasses que podem representar tipos de entidade distintos , enquanto  outros  relacionamentos  de  superclasse/ subclasse sempre t√™m uma √∫nica superclasse. Para entender  melhor  a  diferen√ßa,  podemos  comparar uma categoria, como PROPRIETARIO da Figura 8.8, com  a  subclasse  compartilhada GERENTE\_ENGE -NHEIRO da Figura 8.6. Esta √∫ltima √© uma subclasse de cada  uma das  tr√™s  superclasses ENGENHEIRO , GERENTE e FUNCIONARIO\_MENSAL, de modo que uma entidade que √© um membro de GERENTE\_EN -GENHEIRO deva existir em todas as tr√™s . Isso representa a restri√ß√£o de que um gerente de engenharia precisa  ser  um ENGENHEIRO ,  um GERENTE e um FUNCIONARIO\_MENSAL ; ou seja, GERENTE\_ENGE -NHEIRO √©  um  subconjunto  da interse√ß√£o das  tr√™s classes (conjuntos de entidades). Por sua vez, uma categoria  √©  um  subconjunto  da uni√£o de  suas  su-

9 Nosso uso do termo categoria √© baseado no modelo ECR (Entity-Category-Relationship, ou entidade-categoria-relacionamento) (Elmasri et al., 1985).

Figura 8.8



Duas categorias (tipos de uni√£o): PROPRIETARIO e VEICULO\_REGISTRADO.

perclasses. Logo, uma entidade que √© um membro de PROPRIETARIO deve existir em apenas uma das superclasses. Isso representa a restri√ß√£o de que um PROPRIETARIO pode ser uma EMPRESA ,  um BAN -CO ou uma PESSOA na Figura 8.8.

A heran√ßa de atributo funciona de maneira mais seletiva no caso de categorias. Por exemplo, na Figura 8.8, cada entidade PROPRIETARIO herda os atributos de uma EMPRESA , uma PESSOA ou um BANCO , dependendo da superclasse √† qual a entidade pertence. Por sua vez, uma subclasse compartilhada como GERENTE\_ENGENHEIRO (Figura 8.6) herda todos os atributos  de  suas  superclasses FUNCIONARIO\_MEN -SAL, ENGENHEIRO e GERENTE .

se  generalizada VEICULO (Figura  8.3(b)).  Na  Figura 8.3(b), todo carro e todo caminh√£o √© um VEICULO ; mas, na Figura 8.8, a categoria VEICULO\_REGISTRA -DO inclui alguns carros e alguns caminh√µes, mas n√£o necessariamente todos eles (por exemplo, alguns carros ou caminh√µes podem n√£o ser registrados). Em geral,  uma especializa√ß√£o ou generaliza√ß√£o como a da Figura 8.3(b), se fosse parcial , n√£o impediria VEICULO de conter outros tipos de entidades, como motocicletas. Por√©m, uma categoria como VEICULO\_REGISTRA -DO na Figura 8.8 implica que somente carros e caminh√µes, mas n√£o outros tipos de entidades, possam ser membros de VEICULO\_REGISTRADO .

√â interessante observar a diferen√ßa entre a categoria VEICULO\_REGISTRADO (Figura 8.8) e a superclas-

Uma categoria pode ser total ou parcial . A total mant√©m a uni√£o de  todas as entidades em suas superclasses, enquanto a parcial pode manter um subconjunto da uni√£o .  Uma categoria total √© represen-

tada em diagrama por uma linha dupla que conecta a categoria e o c√≠rculo, ao passo que uma categoria parcial √© indicada por uma linha simples.

As superclasses de uma categoria podem ter diferentes atributos de chave, conforme demonstrado pela categoria PROPRIETARIO da Figura 8.8, ou podem ter o mesmo atributo de chave, conforme demonstrado pela categoria VEICULO\_REGISTRADO . Observe que, se  uma categoria √© total (n√£o parcial), ela pode ser representada alternativamente como uma especializa√ß√£o total (ou uma generaliza√ß√£o total). Nesse caso, a escolha de qual representa√ß√£o usar √© subjetiva. Se as duas classes representam o mesmo tipo de entidades e compartilham diversos atributos, incluindo os mesmos  atributos-chave,  a  especializa√ß√£o/generaliza√ß√£o √© preferida; caso contr√°rio, a categoriza√ß√£o (tipo de uni√£o) √© mais apropriada.

√â importante observar que algumas metodologias de modelagem n√£o possuem tipos de uni√£o. Nesses modelos, um tipo de uni√£o precisa ser representado de uma maneira indireta (ver Se√ß√£o 9.2).

## 8.5 Um exemplo de esquema UNIVERSIDADE de EER, op√ß√µes de projeto e defini√ß√µes formais

Nesta  se√ß√£o,  primeiro  vamos  dar  um  exemplo de esquema de banco de dados no modelo EER para ilustrar o uso dos diversos conceitos discutidos aqui e no Cap√≠tulo 7. Depois, vamos discutir as escolhas de projeto para esquemas conceituais e, por fim, resumir os conceitos do modelo EER e defini-los formalmente da mesma maneira que fizemos com os conceitos do modelo ER b√°sico, no Cap√≠tulo 7.

## 8.5.1 O exemplo do banco de dados UNIVERSIDADE

Para  nosso  exemplo  de  aplica√ß√£o  de  banco  de dados, considere um banco de dados UNIVERSIDADE que registra alunos e suas disciplinas, hist√≥ricos e registro, bem como as ofertas de curso da universidade. O banco de dados tamb√©m registra os projetos  de pesquisa patrocinados do corpo docente e dos alunos de p√≥s-gradua√ß√£o. Esse esquema aparece na Figura 8.9. Uma discuss√£o dos requisitos que levaram a esse esquema pode ser vista em seguida.

Para  cada  pessoa,  o  banco  de  dados  mant√©m informa√ß√µes sobre o nome dela [ Nome ], n√∫mero do Cadastro  de  Pessoa  F√≠sica  [ Cpf ],  endere√ßo  [ Endereco ],  sexo  [ Sexo ]  e  data  de  nascimento [ Data\_nasc ].

Duas  subclasses  do  tipo  de  entidade PESSOA s√£o identificadas: DOCENTE e ALUNO .  Atributos  espec√≠ficos  de DOCENTE s√£o  a  classifica√ß√£o  [ Classificacao ] (assistente, associado,  adjunto,  pesquisador, visitante etc.), escrit√≥rio [ Doc\_escritorio ], telefone do escrit√≥rio  [ Doc\_telefone ]  e  sal√°rio  [ Salario ].  Todos os  membros  do  corpo  docente  est√£o  relacionados a  departamento(s)  acad√™mico(s)  ao(s)  qual(is)  eles est√£o afiliados [ PERTENCE ]  (um membro do corpo docente pode ser associado a v√°rios departamentos, de modo que o relacionamento √© M:N). Um atributo espec√≠fico de ALUNO √© [ Tipo\_aluno ] (novato = 1, segundo ano = 2, ..., aluno formado = 5). Cada ALUNO tamb√©m est√° relacionado a seus departamentos principal e secund√°rio (se forem conhecidos) [ PRINCIPAL ] e  [ SECUNDARIO ],  √†s  turmas  da  disciplina  que  est√° frequentando atualmente e √†s disciplinas completadas [ HISTORICO\_ESCOLAR ]. Cada inst√¢ncia de HIS -TORICO\_ESCOLAR inclui a nota que o aluno recebeu [ Nota ] em uma turma de um curso.

ALUNO\_POSGRADUACAO √©  uma  subclasse  de ALUNO , com o predicado de defini√ß√£o Tipo\_aluno = 5. Para cada aluno de p√≥s-gradua√ß√£o, mantemos uma lista dos t√≠tulos anteriores em um atributo composto, multivalorado [ Titulos ]. Tamb√©m relacionamos o aluno formado a um orientador acad√™mico [ ORIEN -TADOR ] e a um comit√™ de tese [ BANCA ], se existir.

Um departamento acad√™mico  tem  os  atributos nome [ Dnome ], telefone [ Dtelefone ] e n√∫mero de escrit√≥rio  [ Escritorio ],  e  est√°  relacionado  ao  membro acad√™mico que √© seu DIRETOR e √† faculdade √† qual pertence  [ DF ].  Cada  faculdade  tem  como  atributos o nome da faculdade [ Fnome ], n√∫mero do escrit√≥rio [ Fescritorio ] e o nome de seu reitor [ Reitor ].

Uma disciplina tem os atributos n√∫mero da disciplina [ Num\_discip ],  nome da disciplina [ Dnome ] e  descri√ß√£o  da  disciplina  [ Ddesc ].  S√£o  oferecidas v√°rias  turmas  de  cada  disciplina,  com  cada  uma tendo  os  atributos  n√∫mero  da  turma  [ Num\_tur-ma ], o ano e trimestre em que foi oferecida ([ Ano ] e [ Trim ]). 10 Os n√∫meros de turma identificam cada uma  de  maneira  exclusiva.  As  turmas  oferecidas durante  o  trimestre  atual  est√£o  em  uma  subclasse TURMA\_ATUAL de TURMA , com o predicado de defini√ß√£o Trim = Atual\_trim e Ano = Atual\_ano . Cada turma est√° relacionada ao professor que lecionou ou  est√°  lecionando  ([ ENSINA ]),  se  ele  estiver  no banco de dados.

A categoria PROFESSOR\_PESQUISADOR √© um subconjunto da uni√£o de DOCENTE e ALUNO\_POS -GRADUACAO e inclui todos os docentes, bem como

10 Consideramos que o sistema de trimestre , em vez de semestre , seja utilizado na universidade do exemplo.

Figura 8.9



O esquema conceitual EER para um banco de dados UNIVERSIDADE.

alunos formados que recebem apoio por ensino ou pesquisa. Finalmente, o tipo de entidade CONCES -SAO registra  concess√µes  e  contratos  de  pesquisa outorgados √† universidade. Cada concess√£o tem os atributos de t√≠tulo da concess√£o [ Titulo ], n√∫mero da concess√£o [ Num ], ag√™ncia de fomento [ Agencia ] e a data inicial [ Data\_inicial ]. Uma concess√£o est√° rela- cionada a um docente respons√°vel [ DR ] e a todos os pesquisadores a que ele d√° apoio [ APOIO ]. Cada inst√¢ncia de apoio tem como atributos a data inicial do apoio [ Inicio ], a data final do apoio (se for conhecida) [ Final ] e a porcentagem do tempo gasto no projeto [ Tempo ] pelo pesquisador que recebe o apoio.

## 8.5.2 Escolhas de projeto para especializa√ß√£o/generaliza√ß√£o

Nem sempre √© f√°cil escolher o projeto conceitual  mais apropriado para uma aplica√ß√£o de banco de dados.  Na  Se√ß√£o  7.7.3,  apresentamos  algumas  das quest√µes t√≠picas enfrentadas por um projetista de banco de dados ao escolher entre os conceitos de tipos de entidade, tipos de relacionamento e atributos para representar uma situa√ß√£o em particular do minimundo como um esquema ER. Nesta se√ß√£o, vamos discutir as diretrizes e escolhas de projeto para os conceitos EER de especializa√ß√£o/generaliza√ß√£o e categorias (tipos de uni√£o).

Conforme mencionamos na Se√ß√£o 7.7.3, o projeto conceitual do banco de dados deve ser considerado um processo de refinamento iterativo, at√© que o projeto mais adequado seja alcan√ßado. As orienta√ß√µes a seguir ajudam a guiar o processo de projeto para conceitos de EER:

- ¬Ñ Em  geral,  muitas  especializa√ß√µes  e  subclasses  podem  ser  definidas  para  tornar  o modelo  conceitual  preciso.  No  entanto,  a desvantagem √© que o projeto se torna muito confuso.  √â  importante  representar  apenas as subclasses que se julgue necess√°rias para evitar uma aglomera√ß√£o extrema do esquema conceitual.
- ¬Ñ Se  uma  subclasse  possui  poucos  atributos espec√≠ficos (locais) e nenhum relacionamento espec√≠fico, ela pode ser mesclada √† superclasse.  Os  atributos  espec√≠ficos  manteriam valores NULL para  entidades  que  n√£o  s√£o membros da subclasse. Um atributo de tipo poderia  especificar  se  uma  entidade  √©  um membro da subclasse.
- ¬Ñ De modo semelhante, se todas as subclasses da especializa√ß√£o/generaliza√ß√£o tiverem alguns atributos espec√≠ficos e nenhum relacionamento espec√≠fico, elas podem ser mescladas √† superclasse e substitu√≠das por um ou mais atributos de tipo que especificam a subclasse ou subclasses a que cada entidade pertence (ver Se√ß√£o 9.2 para saber como esse crit√©rio se aplica aos bancos de dados relacionais).
- pr√°ticas. Se poss√≠vel, tentamos modelar usando  a  especializa√ß√£o/generaliza√ß√£o  conforme discutimos no final da Se√ß√£o 8.4.
- ¬Ñ A  escolha  de  restri√ß√µes  disjuntas/sobrepostas  e  totais/parciais  sobre  a  especializa√ß√£o/ generaliza√ß√£o  √©  controlada  pelas  regras  no minimundo que est√° sendo modelado. Se os requisitos n√£o indicarem quaisquer restri√ß√µes em particular, o padr√£o geralmente seria sobreposi√ß√£o  e  parcial,  pois  isso  n√£o  especifica  quaisquer restri√ß√µes  sobre  a  condi√ß√£o  de membro da subclasse.

Como um exemplo da aplica√ß√£o dessas orienta√ß√µes,  considere  a  Figura  8.6,  na  qual  nenhum atributo espec√≠fico (local) aparece. Poder√≠amos mesclar  todas  as  subclasses  no  tipo  de  entidade FUNCIONARIO e acrescentar os seguintes atributos a ele:

- ¬Ñ Um atributo Tipo\_emprego cujo conjunto de valores {'Secret√°ria', 'Engenheiro', 'T√©cnico'} indicaria  a  qual  subclasse  cada  funcion√°rio pertence na primeira especializa√ß√£o.
- ¬Ñ Um atributo Forma\_pagto cujo  conjunto  de valores {'Mensal', 'Horista'} indicaria a qual subclasse  cada  funcion√°rio  pertence  na  segunda especializa√ß√£o.
- ¬Ñ Um atributo √â\_gerente cujo conjunto de valores {'Sim', 'N√£o'} indicaria se uma entidade de funcion√°rio individual √© um gerente ou n√£o.

## 8.5.3 Defini√ß√µes formais para os conceitos do modelo EER

Agora, vamos resumir os conceitos do modelo EER e mostrar as  defini√ß√µes  formais.  Uma classe 11 √©  um  conjunto  ou  cole√ß√£o  de  entidades,  incluindo qualquer uma das constru√ß√µes de esquema EER das entidades de grupo, como tipos de entidade, subclasses, superclasses e categorias. Uma subclasse S √© uma classe cujas entidades sempre precisam ser um subconjunto das entidades em outra classe, chamada superclasse C do relacionamento superclasse/subclasse (ou √â\_UM ). Indicamos tal relacionamento com C S / . Para tal  relacionamento superclasse/subclasse,  sempre devemos ter

- ¬Ñ Os  tipos  de  uni√£o  e  categorias  geralmente devem ser evitados, a menos que a situa√ß√£o definitivamente  justifique  esse  tipo  de  constru√ß√£o,  o  que  ocorre  em  algumas  situa√ß√µes

S ‚äÜ C

Uma especializa√ß√£o Z = { S 1 , S 2 , ..., S n } √© um conjunto de subclasses que t√™m a mesma superclasse G ;

11 O uso da palavra classe aqui difere de sua utiliza√ß√£o mais comum nas linguagens de programa√ß√£o orientadas a objeto, como C++. Em C++, uma classe √© uma defini√ß√£o de tipo estruturada com suas fun√ß√µes (opera√ß√µes) aplic√°veis.

ou seja, G S / i √©  um  relacionamento  superclasse/subclasse para   = 1, 2, ..., i n G . √© chamado de tipo de entidade generalizada (ou a superclasse da especializa√ß√£o, ou uma generaliza√ß√£o das subclasses { S 1 , S 2 , ..., S n } ). Z √© considerada total se sempre (em qualquer ponto no tempo) tivermos

<!-- formula-not-decoded -->

Caso  contr√°rio, Z √©  considerada parcial . Z √© considerada disjunta se sempre tivermos

<!-- formula-not-decoded -->

Caso contr√°rio, Z √© considerada sobreposta .

Uma subclasse S de C √© considerada definida por predicado se um predicado p sobre os atributos de C for usado para especificar quais entidades em C s√£o membros de  ; ou seja, S S = C p [ ], que √© o conjunto de entidades em C que  satisfazem  a p .  Uma subclasse que n√£o √© definida por um predicado √© chamada de definida pelo usu√°rio .

Uma especializa√ß√£o Z (ou generaliza√ß√£o G ) √© considerada definida por atributo se um predicado ( A = c i ), onde A √© um atributo de G e c i √© um valor constante do dom√≠nio de A , for usado para especificar a condi√ß√£o de membro em cada subclasse S i em Z . Observe que, se c i ‚â† c j para i ‚â† j , e A for um atributo de √∫nico valor, ent√£o a especializa√ß√£o ser√° disjunta.

A categoria T √© uma classe que √© um subconjunto da uni√£o de n que define as superclasses D 1 , D 2 , ..., Dn , n &gt; 1, podendo ser especificada formalmente da seguinte maneira:

<!-- formula-not-decoded -->

Um predicado p i sobre os atributos de Di pode ser usado para especificar os membros de cada Di que s√£o membros de T . Se um predicado for especificado sobre cada Di , obtemos

<!-- formula-not-decoded -->

Agora, devemos estender a defini√ß√£o de tipo de relacionamento dada no Cap√≠tulo 7, permitindo que qualquer classe - n√£o apenas um tipo de entidade participe de um relacionamento. Logo, devemos substituir as palavras tipo de entidade por classe naquela defini√ß√£o. A nota√ß√£o gr√°fica de EER √© coerente com ER porque todas as classes s√£o representadas por ret√¢ngulos.

## 8.6 Exemplo de outra nota√ß√£o: representando especializa√ß√£o e generaliza√ß√£o em diagramas de classes em UML

Agora, vamos discutir as nota√ß√µes UML para especializa√ß√£o/generaliza√ß√£o  e  heran√ßa.  J√°  apresentamos  a  nota√ß√£o  e  terminologia  b√°sica  do diagrama de classes UML na Se√ß√£o 7.8. A Figura 8.10 ilustra um poss√≠vel diagrama de classes UML correspondente ao diagrama EER da Figura 8.7. A  nota√ß√£o  b√°sica  para  especializa√ß√£o/generaliza√ß√£o (ver Figura 8.10) √© conectar as subclasses por linhas  verticais  a  uma  linha  horizontal,  que  tem um  tri√¢ngulo  conectando  a  linha  horizontal  por meio de outra linha vertical at√© a superclasse. Um tri√¢ngulo preto indica uma especializa√ß√£o/generaliza√ß√£o  com  a  restri√ß√£o disjunta ,  e  um  tri√¢ngulo contornado indica uma restri√ß√£o de sobreposi√ß√£o . A superclasse raiz √© chamada de classe base , e as subclasses (n√≥s folhas) s√£o chamadas de classes de folha .

A discuss√£o citada e o exemplo da Figura 8.10, junto  com  a  apresenta√ß√£o  da  Se√ß√£o  7.8,  oferecem uma  r√°pida  introdu√ß√£o  aos  diagramas  de  classes UML e sua terminologia. Focalizamos os conceitos que s√£o relevantes √† modelagem de banco de dados ER e EER, em vez dos conceitos que s√£o mais relevantes √† engenharia de software. Em UML, existem muitos detalhes que n√£o discutimos, pois est√£o fora do escopo deste livro e s√£o relevantes principalmente para a engenharia de software. Por exemplo, as classes podem ser de v√°rios tipos:

- ¬Ñ Classes abstratas definem atributos e opera√ß√µes, mas n√£o t√™m objetos correspondentes a essas classes. Elas s√£o usadas principalmente para especificar um conjunto de atributos e opera√ß√µes que podem ser herdados.
- ¬Ñ Classes concretas podem ter objetos (entidades) instanciados para pertencer √† classe.
- ¬Ñ Classes  gen√©ricas  (ou template )  especificam um modelo que pode ser usado tamb√©m para definir outras classes.

No projeto de banco de dados, estamos preocupados principalmente com a especifica√ß√£o de classes concretas, cujas cole√ß√µes de objetos s√£o permanentemente (ou persistentemente) armazenadas no banco de dados. A bibliografia selecionada ao final deste cap√≠tulo oferece algumas refer√™ncias a livros que descrevem  os  detalhes  completos  de  UML.  H√°  um material  adicional  relacionado  √†  UML  inclu√≠do  no Cap√≠tulo 10.



## Figura 8.10

Um diagrama de classes UML correspondente ao diagrama EER da Figura 8.7, ilustrando a nota√ß√£o UML para especializa√ß√£o/generaliza√ß√£o.

## 8.7 Conceitos de abstra√ß√£o de dados, representa√ß√£o do conhecimento e ontologia

Nesta  se√ß√£o,  discutimos  em  termos  gerais  alguns dos conceitos de modelagem que descrevemos bem  especificamente  em  nossa  apresenta√ß√£o  dos modelos ER e EER no Cap√≠tulo 7 e anteriormente neste cap√≠tulo. Essa terminologia n√£o √© usada apenas na modelagem de dados conceituais, mas tamb√©m na literatura de intelig√™ncia artificial quando se discute  a representa√ß√£o do conhecimento (ou RC , knowledge  representation ).  Esta  se√ß√£o  discute  as semelhan√ßas  e  diferen√ßas  entre  a  modelagem  conceitual e a representa√ß√£o do conhecimento, al√©m de introduzir um pouco da terminologia alternativa e de alguns conceitos adicionais.

O objetivo das t√©cnicas de RC √© desenvolver conceitos para modelar com precis√£o algum dom√≠nio de conhecimento , criando uma ontologia 12 que descreve os conceitos do dom√≠nio e como esses conceitos est√£o inter-relacionados. Tal ontologia √© usada para arma-

12 Uma ontologia √© algo semelhante a um esquema conceitual, mas com mais conhecimento, regras e exce√ß√µes.

zenar e manipular o conhecimento para tirar conclus√µes,  tomar decis√µes ou responder a perguntas. Os objetivos da RC s√£o semelhantes aos dos modelos de dados sem√¢nticos, mas existem algumas semelhan√ßas e diferen√ßas importantes entre as duas disciplinas:

- ¬Ñ Ambas as disciplinas usam um processo de abstra√ß√£o para identificar propriedades comuns e aspectos importantes de objetos no minimundo (tamb√©m conhecido como dom√≠nio de discurso em RC), enquanto suprimem diferen√ßas insignificantes e detalhes sem import√¢ncia.
- ¬Ñ As duas disciplinas oferecem conceitos, relacionamentos,  restri√ß√µes,  opera√ß√µes  e  linguagens para definir dados e representar conhecimento.
- ¬Ñ A RC geralmente √© mais ampla em escopo do que  os  modelos  de  dados  sem√¢nticos.  Diferentes formas de conhecimento, como regras (usadas  na  infer√™ncia,  dedu√ß√£o  e  pesquisa), conhecimento incompleto e padr√£o, e conhecimento temporal e espacial, s√£o representados em esquemas RC. Os modelos de banco de dados est√£o sendo expandidos para incluir alguns desses conceitos (ver Cap√≠tulo 26).
- ¬Ñ Esquemas RC incluem mecanismos de racioc√≠nio que deduzem fatos adicionais dos fatos armazenados em um banco de dados. Logo, embora a maioria dos sistemas de banco de dados atuais seja limitada a responder a consultas diretas, os sistemas baseados em conhecimento que usam esquemas RC podem responder a consultas que envolvem infer√™ncias sobre os dados armazenados. A tecnologia de banco de dados est√° sendo estendida com mecanismos de infer√™ncia (ver Se√ß√£o 26.5).
- ¬Ñ Embora a maioria dos modelos de dados se concentre  na  representa√ß√£o  dos  esquemas de  banco  de  dados,  ou  metaconhecimento, os esquemas RC costumam misturar os esquemas  com  as  pr√≥prias  inst√¢ncias,  a  fim de oferecer flexibilidade na representa√ß√£o de exce√ß√µes. Isso normalmente resulta em inefici√™ncias  quando  esses  esquemas  RC  s√£o implementados, especialmente quando comparados com bancos de dados e quando uma grande quantidade de dados (fatos) precisa ser armazenada.

Agora,  vamos  discutir  sobre  quatro conceitos de abstra√ß√£o que s√£o usados em modelos de dados sem√¢nticos,  como  o  modelo  EER,  bem  como  em esquemas  RC:  (1)  classifica√ß√£o  e  instancia√ß√£o,  (2) identifica√ß√£o, (3) especializa√ß√£o e generaliza√ß√£o e (4) agrega√ß√£o e associa√ß√£o. Os conceitos emparelhados de  classifica√ß√£o  e  instancia√ß√£o  s√£o  inversos  um  do outro, assim como a generaliza√ß√£o e a especializa√ß√£o. Os conceitos de agrega√ß√£o e associa√ß√£o tamb√©m s√£o relacionados. Discutimos esses conceitos abstratos e sua rela√ß√£o com as representa√ß√µes concretas usadas no modelo EER para esclarecer o processo de abstra√ß√£o de dados e melhorar nosso conhecimento do processo relacionado de projeto de esquema conceitual. Fechamos a se√ß√£o com uma r√°pida discuss√£o sobre ontologia , que est√° sendo bastante usada na pesquisa recente sobre representa√ß√£o do conhecimento.

## 8.7.1 Classifica√ß√£o e instancia√ß√£o

O processo de classifica√ß√£o envolve atribuir sistematicamente objetos/entidades semelhantes aos tipos classe/entidade do objeto. Agora, podemos descrever (em BD) ou raciocinar sobre (em RC) as classes em vez dos objetos individuais. Cole√ß√µes de objetos que compartilham os mesmos tipos de atributos, relacionamentos e restri√ß√µes s√£o classificadas em classes, a fim de simplificar o processo de descoberta de suas propriedades. A instancia√ß√£o √©  o  inverso  da  classifica√ß√£o, e refere-se √† gera√ß√£o e exame espec√≠fico de objetos  distintos  de  uma  classe.  Uma  inst√¢ncia  de objeto  est√°  relacionada  √†  sua  classe  de  objeto  por um  relacionamento √â\_UMA\_INST√ÇNCIA\_DE ou √â\_UM\_MEMBRO\_DE .  Embora os diagramas EER n√£o apresentem inst√¢ncias, os diagramas UML permitem uma forma de instancia√ß√£o ao possibilitar a exibi√ß√£o de objetos individuais. N√£o vamos descrever esse recurso em nossa introdu√ß√£o aos diagramas de classes UML.

Em geral,  os  objetos  de  uma  classe  devem  ter uma estrutura de tipo semelhante. Contudo, alguns objetos podem exibir propriedades que diferem em alguns aspectos dos outros objetos da classe. Esses objetos de exce√ß√£o tamb√©m precisam ser modelados, e os esquemas RC permitem exce√ß√µes mais variadas do que os modelos de banco de dados. Al√©m disso, certas  propriedades  se  aplicam  √†  classe  como  um todo, e n√£o aos objetos individuais; os esquemas RC permitem tais propriedades de classe . Os diagramas UML tamb√©m permitem a especifica√ß√£o de propriedades de classe.

No modelo EER, as entidades s√£o classificadas em tipos de entidade de acordo com seus atributos e  relacionamentos  b√°sicos.  As  entidades  s√£o  classificadas  ainda  em  subclasses  e  categorias,  com  base nas  semelhan√ßas  e  diferen√ßas  adicionais  (exce√ß√µes) entre elas. As inst√¢ncias de relacionamento s√£o classificadas em tipos de relacionamento. Logo, os tipos de  entidade,  subclasses,  categorias  e  tipos  de  relacionamento s√£o os diferentes conceitos usados para

classifica√ß√£o  no  modelo  EER.  O  modelo  EER  n√£o prov√™  explicitamente  propriedades  de  classifica√ß√£o, mas pode ser  estendido  para  fazer  isso.  Em  UML, os objetos s√£o classificados, e √© poss√≠vel exibir tanto propriedades de classe quanto objetos individuais.

Os  modelos  de  representa√ß√£o  do  conhecimento  permitem  m√∫ltiplos  esquemas  de  classifica√ß√£o, em que uma classe √© uma inst√¢ncia de outra classe (chamada metaclasse ).  Observe  que  isso n√£o  pode ser  representado diretamente no modelo EER, pois temos apenas dois n√≠veis - classes e inst√¢ncias. O √∫nico relacionamento entre classes no modelo EER √© um relacionamento de superclasse/subclasse, ao passo que em alguns esquemas RC um relacionamento adicional  de  classe/inst√¢ncia  pode  ser  representado diretamente em uma hierarquia de classes. Uma inst√¢ncia pode, por si s√≥, ser outra classe, permitindo esquemas de classifica√ß√£o multin√≠veis.

## 8.7.2 Identifica√ß√£o

Identifica√ß√£o √©  o  processo  de  abstra√ß√£o  pelo qual  classes  e  objetos  se  tornam  exclusivamente identific√°veis por meio de algum identificador . Por exemplo, um nome de classe identifica de maneira exclusiva uma classe inteira dentro de um esquema. √â necess√°rio que haja um mecanismo adicional para distinguir  inst√¢ncias  de  objeto  distintas  por  meio de identificadores de objeto. Al√©m disso, √© necess√°rio identificar m√∫ltiplas manifesta√ß√µes no banco de dados do mesmo objeto no mundo real. Por exemplo,  podemos  ter  uma  tupla &lt; 'Mauro  Campos', '610618', '3376-9821' &gt; em  uma rela√ß√£o PESSOA e  outra  tupla &lt; '301-540-836-51',  'CC',  3,8 &gt; em uma rela√ß√£o ALUNO que representem a mesma entidade do mundo real. N√£o h√° como identificar o fato de que esses dois objetos de banco de dados (tuplas) representam  a  mesma  entidade  do  mundo  real,  a menos que tomemos uma provid√™ncia em tempo de projeto para  a  refer√™ncia  cruzada  apropriada,  que fornece  essa  identifica√ß√£o.  Logo,  a  identifica√ß√£o  √© necess√°ria em dois n√≠veis:

- ¬Ñ Para distinguir objetos de classes de banco de dados.
- ¬Ñ Para identificar objetos de banco de dados e relacion√°-los a seus equivalentes no mundo real.

No  modelo  EER,  a  identifica√ß√£o  das  constru√ß√µes de esquema √© baseada em um sistema de nomes exclusivos para tais constru√ß√µes. Por exemplo, cada classe em um esquema EER - seja um tipo de entidade, uma subclasse, uma categoria ou um tipo de relacionamento - precisa ter um nome distinto. Os nomes  de  atributos  de  determinada  classe  tamb√©m precisam ser distintos. As regras para identificar refe- r√™ncias de nome de atributo sem ambiguidade em um reticulado ou hierarquia de especializa√ß√£o ou generaliza√ß√£o tamb√©m s√£o necess√°rias.

No n√≠vel de objeto, os valores dos atributos-chave s√£o usados para distinguir entre entidades de um tipo em particular. Para tipos de entidade fraca, as entidades s√£o identificadas por uma combina√ß√£o de valores pr√≥prios de chave parcial e aquelas √†s quais est√£o relacionadas, dependendo da raz√£o de cardinalidade especificada.

## 8.7.3 Especializa√ß√£o e generaliza√ß√£o

Especializa√ß√£o √©  o  processo  de  classificar  uma classe de objetos em subclasses mais especializadas. Generaliza√ß√£o √© o processo inverso de generalizar v√°rias classes em uma classe abstrata de mais alto n√≠vel, que inclua os objetos em todas essas classes. A especializa√ß√£o √© o refinamento conceitual, enquanto a generaliza√ß√£o √© a s√≠ntese conceitual. Subclasses s√£o usadas no modelo EER para representar a especializa√ß√£o e a generaliza√ß√£o. Chamamos o relacionamento entre uma subclasse e suas superclasses de relacionamento √â\_UMA\_SUBCLASSE\_DE ,  ou  simplesmente um relacionamento √â\_UM .  Trata-se do mesmo relacionamento √â\_UM discutido  anteriormente,  na  Se√ß√£o 8.5.3.

## 8.7.4 Agrega√ß√£o e associa√ß√£o

Agrega√ß√£o √©  um  conceito  de  abstra√ß√£o  para  a cria√ß√£o de objetos compostos com base em seus objetos  componentes.  Existem  tr√™s  casos  em  que  esse conceito pode estar relacionado ao modelo EER. O primeiro caso √© a situa√ß√£o em que agregamos valores de atributo de um objeto para formar o objeto total. O segundo caso  √©  quando  representamos  um  relacionamento de agrega√ß√£o como um relacionamento comum. O terceiro caso, que o modelo EER n√£o determina  explicitamente,  envolve  a  possibilidade  de combinar objetos que s√£o relacionados por uma inst√¢ncia de relacionamento em particular a um objeto agregado de n√≠vel superior . Isso √†s vezes √© √∫til quando o pr√≥prio objeto de agrega√ß√£o de n√≠vel mais alto tem de estar relacionado a outro objeto. Chamamos o  relacionamento  entre  os  objetos  primitivos  e  seu objeto de agrega√ß√£o √â\_UMA\_PARTE\_DE ; o inverso √© chamado de √â\_UM\_COMPONENTE\_DE . A UML possibilita todos os tr√™s tipos de agrega√ß√£o.

A abstra√ß√£o da associa√ß√£o √© usada para associar objetos de v√°rias classes independentes . Assim, √†s vezes ela √© semelhante ao segundo uso da agrega√ß√£o, representada no modelo EER por tipos de relacionamento, e em UML, por associa√ß√µes. Esse relacionamento abstrato √© chamado de √â\_ASSOCIADO\_A .

Para entender melhor os diferentes usos da agrega√ß√£o, considere o esquema ER mostrado na Figura 8.11(a), que armazena informa√ß√µes sobre entrevistas por  candidatos  a  emprego  para  v√°rias  empresas.  A classe EMPRESA √© uma agrega√ß√£o dos atributos (ou objetos  componentes) Enome (nome  de  empresa)  e Eendereco (endere√ßo  da  empresa),  enquanto CAN -DIDATO √©  uma agrega√ß√£o de Cpf , Nome , Endereco e Telefone . Os atributos de relacionamento Nome\_resp e Telefone\_resp representam o nome e o n√∫mero de telefone da pessoa na empresa que √© respons√°vel pela entrevista. Suponha que algumas entrevistas resultem em ofertas de emprego, ao passo que outras n√£o. Gostar√≠amos de tratar ENTREVISTA como uma classe para associ√°-la a OFERTA\_EMPREGO . O esquema mostrado na Figura 8.11(b) est√° incorreto porque requer que cada inst√¢ncia de relacionamento de entrevista tenha uma oferta de emprego. O esquema mostrado na Figura  8.11(c) n√£o √© permitido porque  o  modelo  ER n√£o permite relacionamentos entre relacionamentos.

Uma forma de representar essa situa√ß√£o √© criar uma classe agregada de n√≠vel mais alto, composta de EMPRESA , CANDIDATO e ENTREVISTA ,  e  relacion√°-la  a OFERTA\_EMPREGO , como  mostra  a  Figura 8.11(d). Embora o modelo EER, conforme descrito neste livro, n√£o tenha essa facilidade, alguns modelos de dados sem√¢nticos o permitem, e chamam o objeto resultante de objeto composto ou molecular . Outros modelos tratam tipos de entidade e tipos de relacionamento de maneira uniforme e, portanto, permitem relacionamentos  entre  relacionamentos,  conforme ilustrado pela Figura 8.11(c).

Para representar essa situa√ß√£o corretamente no modelo ER descrito aqui, precisamos criar um novo tipo de entidade fraca ENTREVISTA , como mostra a Figura 8.11(e), e relacion√°-lo a OFERTA\_EMPREGO . Logo,  sempre  podemos  representar  essas  situa√ß√µes de modo correto no modelo ER criando tipos de entidade adicionais, embora possa ser conceitualmente mais desej√°vel permitir a representa√ß√£o direta da agrega√ß√£o, como na Figura 8.11(d), ou permitir relacionamentos entre relacionamentos, como na Figura 8.11(c).

A  distin√ß√£o  estrutural  principal  entre  agrega√ß√£o  e  associa√ß√£o  √©  que,  quando  uma  inst√¢ncia  de associa√ß√£o √© exclu√≠da, os objetos participantes podem continuar a existir. Por√©m, se dermos suporte √† no√ß√£o de um objeto de agrega√ß√£o - por exemplo, um CARRO que  √©  composto  dos  objetos MOTOR , CHASSI e PNEUS -, ent√£o a exclus√£o do objeto de agrega√ß√£o CARRO corresponde  a  excluir  todos  os seus objetos componentes.

13 Essa defini√ß√£o √© dada em Gruber (1995).

## 8.7.5 Ontologias e a Web sem√¢ntica

Nos √∫ltimos anos, a quantidade de dados e informa√ß√µes computadorizadas dispon√≠veis na Web se tornou algo fora de controle. Muitos modelos e formatos diferentes s√£o utilizados. Al√©m dos modelos de banco de dados que apresentamos neste livro, muita informa√ß√£o √© armazenada na forma de documentos , que possuem consideravelmente muito menos estrutura do que a informa√ß√£o do banco de dados. Um projeto em andamento, que est√° tentando permitir a troca de informa√ß√µes entre computadores na Web, √© chamado de Web sem√¢ntica , que tenta criar modelos de representa√ß√£o do conhecimento que sejam bastante gen√©ricos, a fim de permitir a troca e a pesquisa de informa√ß√µes significativas entre m√°quinas. O conceito de ontologia √© considerado a base mais promissora para alcan√ßar os objetivos da Web sem√¢ntica e est√° bastante  relacionado  √†  representa√ß√£o  do  conhecimento. Nesta se√ß√£o, oferecemos uma r√°pida introdu√ß√£o ao que √© a ontologia e como ela pode ser usada como uma base para automatizar o conhecimento, a busca e troca de informa√ß√µes.

O estudo das ontologias tenta descrever as estruturas e os relacionamentos poss√≠veis na realidade por meio de um vocabul√°rio comum. Portanto, ele pode ser considerado um meio para descrever o conhecimento de certa comunidade sobre a realidade. A ontologia originou-se nas √°reas de filosofia e metaf√≠sica.  Uma defini√ß√£o muito usada de ontologia √© uma especifica√ß√£o de uma conceitualiza√ß√£o . 13

Nessa defini√ß√£o, uma conceitualiza√ß√£o √© o conjunto de conceitos usados para representar a parte da realidade ou conhecimento que √© de interesse de uma comunidade de usu√°rios. Especifica√ß√£o refere-se √† linguagem e termos do vocabul√°rio usados para especificar a conceitualiza√ß√£o. A ontologia inclui tanto a especifica√ß√£o quanto a conceitualiza√ß√£o . Por exemplo, a mesma conceitualiza√ß√£o pode ser especificada em duas linguagens diferentes, gerando duas ontologias separadas. Com base nessa defini√ß√£o bastante geral, n√£o existe consenso sobre o que √© exatamente uma ontologia. Algumas maneiras poss√≠veis de descrever as ontologias s√£o as seguintes:

- ¬Ñ Um thesaurus (ou  ainda  um dicion√°rio ou um gloss√°rio de termos) descreve os relacionamentos  entre  palavras  (vocabul√°rio)  que representam diversos conceitos.
- ¬Ñ Uma taxonomia descreve como os conceitos de  determinada  √°rea  do  conhecimento  s√£o relacionados  usando  estruturas  semelhantes √†quelas utilizadas em uma especializa√ß√£o ou generaliza√ß√£o.



## Figura 8.11

Agrega√ß√£o. (a) O tipo de relacionamento ENTREVISTA. (b) Incluindo OFERTA\_EMPREGO em um tipo de relacionamento tern√°rio (incorreto). (c) Fazendo o relacionamento RESULTA\_EM participar de outros relacionamentos (n√£o permitido em ER). (d) Usando agrega√ß√£o e um objeto composto (molecular) (geralmente, n√£o permitido em ER, mas permitido por algumas ferramentas de modelagem). (e) Representa√ß√£o correta em ER.

- ¬Ñ Um esquema de banco de dados detalhado √© considerado por alguns uma ontologia que descreve os conceitos (entidades e atributos) e relacionamentos de um minimundo da realidade.
- ¬Ñ Uma teoria l√≥gica usa conceitos da l√≥gica matem√°tica para tentar definir conceitos e seus inter-relacionamentos.

Normalmente, os conceitos usados para descrever ontologias s√£o muito semelhantes aos conceitos que discutimos na modelagem conceitual, como entidades, atributos, relacionamentos, especializa√ß√µes, e assim por diante. A principal diferen√ßa entre uma ontologia e, digamos, um esquema de banco de dados √© que o esquema em geral est√° limitado a descrever um pequeno subconjunto de um minimundo da realidade a fim de armazenar e gerenciar dados. Uma ontologia costuma ser considerada mais geral no sentido de tentar descrever uma parte da realidade ou de um dom√≠nio de interesse (por exemplo, termos m√©dicos, aplica√ß√µes de com√©rcio eletr√¥nico, esportes etc.) o mais completamente poss√≠vel.

## Resumo

Neste cap√≠tulo, discutimos as extens√µes ao modelo ER  que  melhoram  suas  capacidades  de  representa√ß√£o. Chamamos o modelo resultante de modelo ER estendido ou EER. Apresentamos o conceito de uma subclasse e sua superclasse e o mecanismo relacionado de heran√ßa de atributo/relacionamento. Vimos como √†s vezes √© necess√°rio criar classes de entidades adicionais, seja por causa dos atributos espec√≠ficos adicionais ou tipos de  relacionamento espec√≠ficos. Discutimos dois processos principais para definir hierarquias e reticulados de superclasse/subclasse: especializa√ß√£o e generaliza√ß√£o.

Em seguida, mostramos como apresentar essas novas constru√ß√µes em um diagrama EER. Tamb√©m discutimos os diversos tipos de restri√ß√µes que podem se aplicar √†  especializa√ß√£o  ou  generaliza√ß√£o.  As  duas  principais restri√ß√µes  s√£o  total/parcial  e  disjunta/sobreposta.  Al√©m disso, um predicado de defini√ß√£o para uma subclasse ou um atributo de defini√ß√£o para uma especializa√ß√£o podem ser especificados. Abordamos as diferen√ßas entre subclasses definidas pelo usu√°rio, por predicado e entre especializa√ß√µes definidas pelo usu√°rio e por atributo. Por fim, discutimos o conceito de uma categoria ou tipo de uni√£o, que √© um subconjunto da uni√£o de duas ou mais classes, e mostramos as defini√ß√µes formais de todos os conceitos apresentados.

Apresentamos parte da nota√ß√£o e terminologia da UML para representar a especializa√ß√£o  e  a  generaliza√ß√£o. Na Se√ß√£o 8.7, discutimos rapidamente a disciplina de representa√ß√£o do conhecimento (RC) e como ela est√° relacionada √† modelagem de dados sem√¢ntica. Tamb√©m demos uma vis√£o geral e um resumo dos tipos de conceitos abstratos da representa√ß√£o de dados: classifica√ß√£o e instancia√ß√£o, identifica√ß√£o, especializa√ß√£o e generaliza√ß√£o, e agrega√ß√£o e associa√ß√£o. Vimos como os conceitos de EER e UML est√£o relacionados a cada um deles.

## Perguntas de revis√£o

- 8.1. O que √© uma subclasse? Quando uma subclasse √© necess√°ria na modelagem de dados?
- 8.2. Defina os seguintes termos: superclasse de uma subclasse , relacionamento  de  superclasse/subclasse , relacionamento  √â\_UM , especializa√ß√£o , generaliza√ß√£o , categoria , atributos espec√≠ficos (locais ) e relacionamentos espec√≠ficos .
- 8.3. Discuta o mecanismo de heran√ßa de atributo/relacionamento. De que forma ele √© √∫til?
- 8.4. Discuta as subclasses definidas pelo usu√°rio e definidas por predicado, e identifique as diferen√ßas entre as duas.
- 8.5. Discuta as especializa√ß√µes definidas pelo usu√°rio e definidas por atributo, e identifique as diferen√ßas entre as duas.
- 8.6. Discuta os dois tipos principais de restri√ß√µes sobre especializa√ß√µes e generaliza√ß√µes.
- 8.7. Qual √© a diferen√ßa entre uma hierarquia de especializa√ß√£o e um reticulado de especializa√ß√£o?
- 8.8. Qual √© a diferen√ßa entre especializa√ß√£o e generaliza√ß√£o? Por que n√£o exibimos essa diferen√ßa nos diagramas de esquema?
- 8.9. Como  uma  categoria  difere  de  uma  subclasse compartilhada regular? Para que uma categoria √© usada? Ilustre sua resposta com exemplos.
- 8.10. Para cada um dos seguintes termos da UML (ver se√ß√µes  7.8  e  8.6),  discuta  o  termo  correspondente no modelo EER, se houver: objeto , classe , associa√ß√£o , agrega√ß√£o , generaliza√ß√£o , multiplicidade , atributos , discriminador , liga√ß√£o , atributo de liga√ß√£o , associa√ß√£o reflexiva e associa√ß√£o qualificada .
- 8.11. Discuta as principais diferen√ßas entre a nota√ß√£o para diagramas de esquema EER e diagramas de classe UML comparando como os conceitos comuns s√£o representados em cada um.
- 8.12. Liste os diversos conceitos de abstra√ß√£o de dados e os conceitos de modelagem correspondentes no modelo EER.
- 8.13. Que recurso de agrega√ß√£o est√° faltando do modelo EER? Como o modelo EER pode ser melhorado para dar suporte a esse recurso?
- 8.14. Quais s√£o as principais semelhan√ßas e diferen√ßas entre  as  t√©cnicas  conceituais  de  modelagem  de banco de dados e as t√©cnicas de representa√ß√£o do conhecimento?
- 8.15. Discuta as semelhan√ßas e diferen√ßas entre uma ontologia e um esquema de banco de dados.

## Exerc√≠cios

8.16. Projete um esquema EER para uma aplica√ß√£o de banco  de  dados  em  que  voc√™  est√°  interessado. Especifique  todas  as  restri√ß√µes  que  devem  ser mantidas no banco de dados. Cuide para que o esquema tenha pelo menos cinco tipos de entidade, quatro tipos de relacionamento, um tipo de entidade fraca, um relacionamento de superclas-

8.17.

8.18.

8.19.

se/subclasse, uma categoria e um tipo de relacionamento n -√°rio ( n &gt; 2).

Considere  o  esquema  ER BANCO da  Figura 7.21  e  suponha  que  seja  necess√°rio  registrar diferentes  tipos  de CONTAS ( CONTA\_POU -PANCA CONTA\_CORRENTE , , ...) e EMPRES -TIMOS ( EMPRESTIMO\_CARRO , EMPRESTI -MO\_HABITACAO , ...). Suponha que tamb√©m se deseje  registrar  cada  uma  das TRANSACOES de CONTA (dep√≥sitos,  saques,  cheques,  ...)  e os PAGAMENTOS de EMPRESTIMO ; ambos incluem o valor, data e hora. Modifique o esquema BANCO ,  usando  os  conceitos  de  ER  e EER de especializa√ß√£o e generaliza√ß√£o. Indique quaisquer suposi√ß√µes que voc√™ fizer sobre os requisitos adicionais.

A narrativa a seguir descreve uma vers√£o simplificada da organiza√ß√£o das instala√ß√µes ol√≠mpicas planejadas para os Jogos Ol√≠mpicos de ver√£o. Desenhe um diagrama EER que mostre os tipos  de  entidade,  atributos,  relacionamentos e especializa√ß√µes para essa aplica√ß√£o. Indique quaisquer suposi√ß√µes que voc√™ fizer. As instala√ß√µes  ol√≠mpicas  s√£o  divididas  em  complexos esportivos. Os complexos esportivos s√£o divididos em tipos de um esporte e poliesportivo . Os  complexos  poliesportivos  possuem  √°reas designadas para cada esporte com um indicador de localiza√ß√£o (por exemplo, centro, canto NE  e assim por diante). Um complexo tem um , local,  organizador  chefe,  √°rea  total  ocupada, e  assim  por  diante.  Cada  complexo  mant√©m uma s√©rie de eventos (por exemplo, o est√°dio com  raias  pode  englobar  muitas  corridas  diferentes).  Para  cada  evento,  existe  uma  data planejada, dura√ß√£o, n√∫mero de participantes, n√∫mero  de  oficiais  e  assim  por  diante.  Uma rela√ß√£o de todos os oficiais ser√° mantida junto com a lista dos eventos em que cada oficial estar√° envolvido. Diferentes equipamentos s√£o necess√°rios para os eventos (por exemplo, balizas, postes, barras paralelas), bem como para a  manuten√ß√£o.  Os  dois  tipos  de  instala√ß√µes (um  esporte  e  poliesportivo)  ter√£o  diferentes tipos de informa√ß√£o. Para cada tipo, o n√∫mero de instala√ß√µes necess√°rias √© mantido, junto com um or√ßamento aproximado.

Identifique  todos  os  conceitos  importantes  representados  no  estudo  de  caso  do  banco  de dados de biblioteca descrito a seguir. Em particular, identifique as abstra√ß√µes de classifica√ß√£o (tipos  de  entidade  e  tipos  de  relacionamento), agrega√ß√£o,  identifica√ß√£o  e  especializa√ß√£o/generaliza√ß√£o. Especifique as restri√ß√µes de cardinalidade (min, max) sempre que poss√≠vel. Liste detalhes que afetar√£o o eventual projeto, mas que n√£o t√™m significado sobre o projeto conceitual. Liste  as  restri√ß√µes  sem√¢nticas  separadamente.

Desenhe um diagrama EER do banco de dados de biblioteca.

Estudo  de  caso: A  Georgia  Tech  Library (GTL) tem aproximadamente 16 mil usu√°rios, 100 mil t√≠tulos e 250 mil volumes (uma m√©dia de 2,5 c√≥pias por livro). Cerca de 10 por cento dos volumes est√£o emprestados a qualquer momento. Os bibliotec√°rios garantem que os livros estejam dispon√≠veis quando os usu√°rios querem apanh√°-los emprestado. Al√©m disso, os bibliotec√°rios precisam saber quantas c√≥pias de cada livro  existem  na  biblioteca  ou  emprestadas  a qualquer momento. Um cat√°logo de livros est√° dispon√≠vel on-line, listando livros por autor, t√≠tulo e assunto. Para cada t√≠tulo da biblioteca, uma descri√ß√£o do livro √© mantida no cat√°logo, que varia de par√°grafos a v√°rias p√°ginas. Os bibliotec√°rios de refer√™ncia desejam poder acessar essa  descri√ß√£o  quando  os  usu√°rios  solicitarem informa√ß√µes sobre um livro. O pessoal da biblioteca inclui o bibliotec√°rio chefe, bibliotec√°rios associados ao departamento, bibliotec√°rios de refer√™ncia, pessoal de despacho e assistentes de bibliotec√°rio.

Os livros podem ser emprestados por 21 dias. Os usu√°rios t√™m permiss√£o para pegar apenas cinco livros de uma s√≥ vez. Os usu√°rios normalmente retornam os livros dentro de tr√™s a quatro semanas. A maioria dos usu√°rios sabe que t√™m uma semana  de  toler√¢ncia  antes  que  uma  nota  seja enviada para eles, e por isso tentam retornar os livros antes que o per√≠odo de toler√¢ncia termine. Cerca de 5 por cento dos usu√°rios precisa receber lembretes para devolver os livros. A maioria dos  livros  atrasados  √©  retornada  dentro  de  um m√™s da data de vencimento. Aproximadamente 5 por cento dos livros atrasados s√£o mantidos ou nunca s√£o retornados. Os membros mais ativos da  biblioteca  s√£o  definidos  como  aqueles  que pegam livros emprestados pelo menos dez vezes durante o ano. Um por cento dos usu√°rios que mais utilizam empr√©stimos realizam 15 por cento dos empr√©stimos, e os maiores 10 por cento dos usu√°rios realizam 40 por cento dos empr√©stimos. Cerca de 20 por cento dos usu√°rios s√£o totalmente inativos por nunca terem emprestado livros.

Para tornar-se um usu√°rio da biblioteca, os candidatos preenchem um formul√°rio incluindo seu CPF  endere√ßo de correspond√™ncia do campus e , da resid√™ncia, e n√∫meros de telefone. Os bibliotec√°rios emitem um cart√£o numerado, leg√≠vel √† m√°quina, com a foto do usu√°rio. Esse cart√£o tem validade de quatro anos. Um m√™s antes de um cart√£o expirar, uma nota √© enviada ao usu√°rio para fazer a renova√ß√£o. Os professores do instituto  s√£o  considerados  usu√°rios  autom√°ticos. Quando um novo usu√°rio do corpo docente entra  para  o  instituto,  sua  informa√ß√£o  √©  puxada

dos registros de funcion√°rio e um cart√£o da biblioteca √© remetido ao seu endere√ßo no campus. Os professores t√™m permiss√£o para retirar livros por intervalos de tr√™s meses, e possuem um per√≠odo de toler√¢ncia de duas semanas. As notas de renova√ß√£o para os professores s√£o enviadas para seu endere√ßo no campus.

A biblioteca  n√£o  empresta  alguns  livros,  como livros de refer√™ncia, livros raros e mapas. Os bibliotec√°rios precisam diferenciar livros que podem ser emprestados daqueles que n√£o podem. Al√©m disso, eles possuem uma lista de alguns livros em que est√£o interessados em adquirir, mas n√£o conseguem obter, como livros raros ou que est√£o esgotados, e livros que foram perdidos ou destru√≠dos, mas n√£o substitu√≠  dos. Os bibliotec√°rios precisam ter um sistema que registre os livros que n√£o podem ser emprestados bem como os livros que eles est√£o interessados em adquirir. Alguns livros podem ter o mesmo t√≠tulo; portanto, o t√≠tulo n√£o pode ser usado como um meio de identifica√ß√£o. Cada livro √© identificado por seu International  Standard  Book  Number  (ISBN), um  c√≥digo  internacional  exclusivo  atribu√≠do  a todos os livros. Dois livros com o mesmo t√≠tulo podem ter diferentes ISBNs se estiverem em diferentes idiomas ou tiverem diferentes encaderna√ß√µes (capa dura ou brochura). As edi√ß√µes de um mesmo livro possuem ISBNs diferentes.

O sistema de banco de dados proposto precisa ser  projetado  para  registrar  os  usu√°rios,  os  livros, o cat√°logo e a atividade de empr√©stimo.

8.20. Projete um banco de dados para registrar informa√ß√µes para um museu de arte. Suponha que os seguintes requisitos foram coletados:

- ¬Ñ O  museu  tem  uma  cole√ß√£o  de OBJETOS\_ ARTE . Cada OBJETO\_ARTE tem um nume-ro\_id  exclusivo,  um Artista (se  conhecido), um Ano (quando  foi  criado,  se  conhecido), um Titulo e  uma Descricao .  Os  objetos  de arte  s√£o  categorizados  de  v√°rias  maneiras, conforme discutido a seguir.
- ¬Ñ OBJETOS\_ARTE s√£o categorizados com base em seu tipo. Existem tr√™s tipos principais: PINTURA , ESCULTURA e ESTATUA , mais um tipo chamado OUTRO para acomodar objetos que n√£o se encaixam em nenhum dos tr√™s tipos principais.
- ¬Ñ Uma PINTURA tem  um Tipo\_pintura (√≥leo, aquarela etc.), material em que √© desenhada Desenhado\_em (papel, tela, madeira etc.) e Estilo (moderno, abstrato etc.).
- ¬Ñ Uma ESCULTURA ou  uma  est√°tua  tem  um Material com a qual foi criada (madeira, pedra etc.), Altura , Peso e Estilo .
- ¬Ñ Um objeto de arte na categoria OUTRO tem um Tipo (impress√£o, foto etc.) e Estilo .
- ¬Ñ OBJETOS\_ARTE s√£o categorizados  como COLECAO\_PERMANENTE (objetos que pertencem ao museu) e EMPRESTADOS . As informa√ß√µes capturadas sobre os objetos na COLECAO\_PERMANENTE incluem Data\_ aquisicao , Status (em  exibi√ß√£o,  emprestado ou guardado) e Custo . A informa√ß√£o capturada sobre objetos EMPRESTADOS inclui a Colecao da  qual  foi  emprestado, Data\_em-prestimo e Data\_retorno .
- ¬Ñ A informa√ß√£o descrevendo o pa√≠s ou cultura da Origem (italiano, eg√≠pcio, norte-americano, indiano etc.) e Epoca (Renascen√ßa, Moderno, Antiguidade, e assim por diante) √© capturada para cada OBJETO\_ARTE .
- ¬Ñ O museu registra a informa√ß√£o de ARTISTA , se for conhecida: Nome Data\_nascimento , (se conhecida), Data\_morte (se n√£o estiver vivo), Pais\_de\_origem , Epoca , Estilo\_principal e Descricao . O Nome √© considerado exclusivo.
- ¬Ñ Ocorrem diferentes EXPOSICOES , cada uma com um Nome Data\_inicio , e Data\_final .  As EXPOSICOES s√£o  relacionadas  a  todos  os objetos de arte que estavam em amostra durante a exposi√ß√£o.
- ¬Ñ A  informa√ß√£o  √©  mantida  em  outras COLE -COES com  as  quais  o  museu  interage,  incluindo Nome (exclusivo), Tipo (museu, pessoal  etc.), Descricao , Endereco , Telefone e Pessoa\_contato atual.

Desenhe  um  diagrama  de  esquema  EER  para essa aplica√ß√£o. Discuta quaisquer suposi√ß√µes que voc√™ fizer e que justifiquem suas escolhas de projeto EER.

- 8.21. A Figura 8.12 mostra um exemplo de diagrama EER para o banco de dados de um pequeno aeroporto  particular,  que  √©  usado  para  registrar aeronaves,  seus  propriet√°rios,  funcion√°rios  do aeroporto  e  pilotos.  Com  base  nos  requisitos para esse banco de dados, a informa√ß√£o a seguir foi coletada: cada AERONAVE tem um n√∫mero de registro [ Num\_reg ], √© de um tipo de avi√£o em particular [ DO\_TIPO ] e √© mantido em um hangar em  particular  [ GUARDADO\_EM ].  Cada TIPO\_ AVIAO tem  um  n√∫mero  de  modelo  [ Modelo ], uma capacidade [ Capacidade ] e um peso [ Peso ]. Cada HANGAR tem um n√∫mero [ Numero ], uma capacidade  [ Capacidade ] e  um  local  [ Localizacao ].  O  banco  de  dados  tamb√©m  registra  os PROPRIETARIOS de cada avi√£o [ PERTENCE ] e os FUNCIONARIOS que fazem a manuten√ß√£o do avi√£o [ MANUTENCAO ]. Cada inst√¢ncia de relacionamento em PERTENCE relaciona uma AE -RONAVE a um PROPRIETARIO e inclui a data de compra [ Data\_comp ]. Cada inst√¢ncia de relacionamento em MANUTENCAO relaciona um FUN -CIONARIO a um registro de servi√ßo [ SERVICO ].

Figura 8.12



Esquema EER para um banco de dados PEQUENO\_AEROPORTO.

Cada avi√£o passa por manuten√ß√£o muitas vezes; logo, ela √© relacionada por [ PLANO\_SERVICO ] a uma s√©rie de registros de SERVICO . Um registro de SERVICO inclui como atributos a data da manuten√ß√£o [ Data ],  o  n√∫mero  de  horas  gastas no trabalho [ Horas ]  e  o  tipo  de  trabalho realizado [ Cod\_trab ].  Usamos  um  tipo  de  entidade fraca [ SERVICO ]  para representar o servi√ßo na aeronave, pois o n√∫mero de registro da aeronave √© usado para identificar um registro de manuten√ß√£o. Um PROPRIETARIO √© uma pessoa ou uma corpora√ß√£o.  Assim,  usamos  um  tipo  de  uni√£o (categoria) [ PROPRIETARIO ] que √© um subconjunto da uni√£o dos tipos de entidade corpora√ß√£o [ CORPORACAO ] e  pessoa  [ PESSOA ]. Tanto pilotos  [ PILOTO ] quanto  funcion√°rios  [ FUN -CIONARIO ]  s√£o  subclasses  de PESSOA .  Cada PILOTO tem atributos espec√≠ficos de n√∫mero de licen√ßa [ Num\_licenca ] e restri√ß√µes [ Restricoes ];

cada FUNCIONARIO tem  atributos  espec√≠ficos de sal√°rio [ Salario ]  e  turno trabalhado [ Turno ]. Todas as entidades PESSOA no banco de dados possuem dados mantidos sobre seu n√∫mero de Cadastro de Pessoa F√≠sica [ Cpf ], nome [ Nome ], endere√ßo [ Endereco ] e n√∫mero de telefone [ Telefone ].  Para entidades CORPORACAO ,  os  dados mantidos incluem nome [ Nome ],  endere√ßo [ Endereco ]  e  n√∫mero de telefone [ Telefone ].  O banco de dados tamb√©m registra os tipos de avi√µes que cada piloto √© autorizado a voar [ VOA ] e os tipos de avi√µes em que cada funcion√°rio pode realizar o trabalho de manuten√ß√£o [ TRABALHA\_ EM ]. Mostre como o esquema EER PEQUENO\_ AEROPORTO da Figura 8.12 pode ser representado em nota√ß√£o UML. ( Nota: n√£o  discutimos como representar categorias (tipos de uni√£o) em UML, de modo que voc√™ n√£o precisa mapear as categorias nesta e na pr√≥xima quest√£o.)

|    | Conjunto de entidades   | (a) Tem relacionamento com   | (b) Tem um atributo que √©   | (c) √â uma especializa√ß√£o de   | (d) √â uma generaliza√ß√£o de   | Conjunto de entidades ou atributo   |
|----|-------------------------|------------------------------|-----------------------------|-------------------------------|------------------------------|-------------------------------------|
|  1 | M√ÉE                     |                              |                             |                               |                              | PESSOA                              |
|  2 | FILHA                   |                              |                             |                               |                              | M√ÉE                                 |
|  3 | ALUNO                   |                              |                             |                               |                              | PESSOA                              |
|  4 | ALUNO                   |                              |                             |                               |                              | Cod_aluno                           |
|  5 | ESCOLA                  |                              |                             |                               |                              | ALUNO                               |
|  6 | ESCOLA                  |                              |                             |                               |                              | SALA_AULA                           |
|  7 | ANIMAL                  |                              |                             |                               |                              | CAVALO                              |
|  8 | CAVALO                  |                              |                             |                               |                              | Ra√ßa                                |
|  9 | CAVALO                  |                              |                             |                               |                              | Idade                               |
| 10 | FUNCION√ÅRIO             |                              |                             |                               |                              | CPF                                 |
| 11 | M√ìVEL                   |                              |                             |                               |                              | CADEIRA                             |
| 12 | CADEIRA                 |                              |                             |                               |                              | Peso                                |
| 13 | HUMANO                  |                              |                             |                               |                              | MULHER                              |
| 14 | SOLDADO                 |                              |                             |                               |                              | PESSOA                              |
| 15 | COMBATENTE_INIMIGO      |                              |                             |                               |                              | PESSOA                              |

- 8.22. Mostre como o esquema EER UNIVERSIDADE da Figura 8.9 pode ser representado em nota√ß√£o UML.
- 3. Os  jogadores  recebem  uma  cor  preta  ou branca no in√≠cio do jogo.
- 8.23. Considere os conjuntos de entidades e atributos mostrados na tabela desta p√°gina. Coloque uma marca√ß√£o em uma coluna de cada linha, para indicar o relacionamento entre as colunas mais √† esquerda e √† direita.
- a. O  lado  esquerdo  tem  um  relacionamento com o lado direito.
- b. O lado direito √© um atributo do lado esquerdo.
- c. O  lado  esquerdo  √©  uma  especializa√ß√£o  do lado direito.
- d. O lado esquerdo √© uma generaliza√ß√£o do lado direito.
- 8.24. Desenhe  um  diagrama  UML  para  armazenar um jogo de xadrez em um banco de dados. Voc√™ pode  examinar  em &lt; http://www.chessgames. com &gt; como fazer uma aplica√ß√£o semelhante √† que  voc√™  est√°  projetando.  Indique  claramente quaisquer suposi√ß√µes que voc√™ fizer em seu diagrama UML. Uma amostra das suposi√ß√µes que voc√™ pode fazer sobre o escopo √© a seguinte:
- 1. O jogo de xadrez √© realizado por dois jogadores.
- 2. O jogo √© realizado em um tabuleiro de 8 √ó 8, como o que aparece a seguir:
- 4. Cada jogador come√ßa com as seguintes pe√ßas:
- 5. Cada pe√ßa tem a pr√≥pria posi√ß√£o inicial.
- 6. Cada  pe√ßa  tem  o  pr√≥prio  conjunto  de  jogadas v√°lidas com base no estado do jogo. Voc√™  n√£o  precisa  se  preocupar  com  quais jogadas s√£o v√°lidas ou n√£o, exceto pelas seguintes quest√µes:
- a. Uma pe√ßa pode se mover para um quadrado vazio ou capturar uma pe√ßa do oponente.
- b. Se uma pe√ßa for capturada, ela √© removida do tabuleiro.
- c. Se um pe√£o se mover para a √∫ltima fileira, ele √© 'promovido', sendo convertido para outra pe√ßa (rainha, torre, bispo ou cavalo).



- a. rei

- d. 2 bispos

- b. rainha

- e. 2 cavalos

- c. 2 torres

- f. 8 pe√µes

Nota : algumas dessas fun√ß√µes podem se espalhar por v√°rias classes.

- 8.25. Desenhe um diagrama EER para um jogo de xadrez conforme descrito no Exerc√≠cio 8.24. Focalize nos aspectos de armazenamento persistente do sistema. Por exemplo, o sistema precisaria recuperar todas as jogadas de cada jogo realizado em ordem sequencial.
- 8.26. Quais dos seguintes diagramas EER s√£o incorretos  e  por  qu√™?  Indique  claramente  quaisquer suposi√ß√µes que voc√™ fizer.

- 8.27. Considere o seguinte diagrama EER que descreve os sistemas de computador em uma empresa. Forne√ßa os pr√≥prios atributos e chave para cada tipo de entidade. Forne√ßa restri√ß√µes de cardinalidade max justificando sua escolha. Escreva uma descri√ß√£o narrativa completa do que esse diagrama EER representa.

b.

E1

1

R

1

E2

R

N

M



## Exerc√≠cios de laborat√≥rio

8.28. Considere um banco de dados DIARIO\_NOTAS em que os professores de um departamento acad√™mico registram pontos ganhos por alunos individuais em suas aulas. Os requisitos de dados s√£o resumidos da seguinte forma:

- ¬Ñ Cada aluno √© identificado por um identificador exclusivo, nome e sobrenome, e por um endere√ßo de e-mail.
- ¬Ñ Cada professor leciona certas disciplinas a cada per√≠odo. Cada disciplina √© identificada por um n√∫mero, um n√∫mero de se√ß√£o e o per√≠odo em que ela √© realizada. Para cada disciplina, o professor especifica o n√∫mero m√≠nimo de pontos necess√°rios para ganhar notas A, B, C, D e F. Por exemplo, 90 pontos  para  um  A,  80  pontos  para  um  B,  70 pontos para um C, e assim por diante.

E

d

a.

c.

E

E1

o

E1

E2

o

R

1

N

E3

E3

- ¬Ñ Os alunos s√£o matriculados em cada disciplina lecionada pelo professor.
- ¬Ñ Cada disciplina tem uma s√©rie de componentes de avalia√ß√£o (como exame do meio do per√≠odo, exame final, projeto, e assim por diante). Cada componente de avalia√ß√£o tem um n√∫mero m√°ximo de pontos (como 100 ou 50) e um peso (como 20 por cento ou 10 por cento). Os pesos de todos os componentes de avalia√ß√£o de um curso em geral totalizam 100.
- ¬Ñ Finalmente, o professor registra os pontos ganhos por aluno em cada um dos componentes de avalia√ß√£o em cada uma das disciplinas. Por exemplo, o aluno 1234 ganha 84 pontos para o componente de avalia√ß√£o do meio do per√≠odo  da  disciplina  CCc2310  da  se√ß√£o  2 no per√≠odo do segundo semestre de 2009. O componente de avalia√ß√£o de exame do meio do per√≠odo pode ter sido definido para ter um m√°ximo de 100 pontos e um peso de 20 por cento da nota da disciplina.

Crie  um  diagrama  Entidade-Relacionamento  estendido para o banco de dados do di√°rio e monte o projeto usando uma ferramenta de modelagem como ERwin ou Rational Rose.

- 8.29. Considere um sistema de banco de dados LEI -LAO\_ON-LINE em que os membros (compradores e vendedores) participam na venda de itens. Os requisitos de dados para esse sistema s√£o resumidos a seguir:
- ¬Ñ O  site  on-line  tem  membros,  e  cada  um  √© identificado por um n√∫mero de membro exclusivo e descrito por um endere√ßo de e-mail, nome, senha, endere√ßo residencial e n√∫mero de telefone.
- ¬Ñ Um membro pode ser um comprador ou um vendedor. Um comprador tem um endere√ßo de entrega registrado no banco de dados. Um vendedor tem um n√∫mero de conta banc√°ria e  um  n√∫mero  de  encaminhamento  registrados no banco de dados.
- ¬Ñ Os itens s√£o colocados √† venda por um vendedor e identificados por um n√∫mero de item exclusivo, atribu√≠do pelo sistema. Os itens tamb√©m s√£o descritos por um t√≠tulo de item, uma descri√ß√£o, um pre√ßo de lance inicial, um incremento de lance, a data inicial do leil√£o e a data final do leil√£o.
- ¬Ñ Os itens  tamb√©m  s√£o  classificados  com  base  em uma hierarquia  de  classifica√ß√£o  fixa  (por  exemplo,  um modem pode ser classificado como COMPUTADOR ‚Üí HARDWARE ‚Üí MODEM ).
- ¬Ñ Os compradores fazem lances para os itens em que est√£o interessados. O pre√ßo do lance e a hora do lance s√£o registrados. O comprador ao final do leil√£o com o maior pre√ßo de
- lance √© declarado o vencedor e uma transa√ß√£o entre comprador e vendedor pode ent√£o prosseguir.
- ¬Ñ O comprador e o vendedor podem registrar uma nota em rela√ß√£o √†s transa√ß√µes completadas. A nota cont√©m uma pontua√ß√£o da outra parte na transa√ß√£o (1-10) e um coment√°rio.

Crie  um  diagrama  Entidade-Relacionamento estendido para o banco de dados LEILAO\_ON --LINE e monte o projeto usando uma ferramenta  de  modelagem  como  ERwin  ou  Rational Rose.

- 8.30. Considere um sistema de banco de dados para uma organiza√ß√£o de beisebol como as principais ligas nacionais. Os requisitos de dados s√£o resumidos a seguir:
- ¬Ñ O pessoal envolvido na liga inclui jogadores, t√©cnicos, dirigentes e √°rbitros. Cada um tem uma identifica√ß√£o pessoal exclusiva. Eles tamb√©m s√£o descritos por seu nome e sobrenome, junto com a data e local de nascimento.
- ¬Ñ Os jogadores s√£o descritos ainda por outros atributos, como sua orienta√ß√£o de batida (esquerda, direita ou ambas) e t√™m uma m√©dia de batidas (MB) por toda a vida.
- ¬Ñ Dentro do grupo de jogadores existe um subgrupo de jogadores chamados lan√ßadores. Os lan√ßadores t√™m uma m√©dia de corrida ganha (MCG) por toda a vida associada a eles.
- ¬Ñ As equipes s√£o identificadas exclusivamente por seus nomes. As equipes tamb√©m s√£o descritas pela cidade em que est√£o localizadas e pela divis√£o e liga em que jogam (como a divis√£o Central da Liga Norte-americana).
- ¬Ñ As equipes possuem um dirigente, uma s√©rie de t√©cnicos e uma s√©rie de jogadores.
- ¬Ñ Os jogos s√£o realizados entre dois times com um designado como o time da casa e o outro como o time visitante em determinada data. A pontua√ß√£o (corridas, batidas e erros) √© registrado para cada time. O time com a maioria das corridas √© declarado o vencedor do jogo.
- ¬Ñ A cada jogo terminado, um lan√ßador vencedor e um lan√ßador perdedor s√£o registrados. Caso seja concedido um salvamento, o lan√ßador salvo tamb√©m √© registrado.
- ¬Ñ A cada jogo terminado, o n√∫mero de acertos (simples, duplos, triplos e home runs ) obtidos por jogador tamb√©m √© registrado.

Crie um diagrama Entidade-Relacionamento estendido para o banco de dados BEISEBOL e monte o projeto usando uma ferramenta de modelagem como ERwin ou Rational Rose.

- 8.31. Considere o diagrama EER para o banco de dados UNIVERSIDADE mostrado  na  Figura  8.9.

Entre com seu projeto usando uma ferramenta de modelagem de dados como ERwin ou Rational Rose. Fa√ßa uma lista das diferen√ßas na nota√ß√£o entre o diagrama no texto e a nota√ß√£o diagram√°tica equivalente que voc√™ acabou usando com a ferramenta.

8.32. Considere o diagrama EER para o pequeno banco de dados AEROPORTO mostrado na Figura 8.12. Monte esse projeto usando uma ferramenta de modelagem de dados como ERwin ou Rational Rose. Tenha cuidado ao modelar a categoria PROPRIETARIO nesse diagrama. ( Dica: considere o uso de CORPORACAO\_√â\_PROPRIETARIA e PESSOA\_√â\_PROPRIETARIA como tipos de relacionamento distintos.)

8.33. Considere o banco de dados UNIVERSIDADE descrito no Exerc√≠cio 7.16. Voc√™ j√° desenvolveu um esquema ER para esse banco de dados usando uma ferramenta de modelagem de dados como ERwin ou  Rational  Rose  no  Exerc√≠cio  de  Laborat√≥rio 7.31. Modifique esse diagrama classificando DIS -CIPLINAS como DISCIPLINA\_GRADUACAO ou DISCIPLINA\_POSGRADUACAO e PROFESSO -RES como PROFESSORES\_JUNIOR ou PRO -FESSORES\_SENIOR .  Inclua  atributos  apropriados  para  esses  novos  tipos  de  entidade.  Depois, estabele√ßa relacionamentos indicando que os professores  j√∫nior  lecionam  disciplinas  para  alunos em gradua√ß√£o enquanto os professores s√™nior lecionam disciplinas para alunos de p√≥s-gradua√ß√£o.

## Bibliografia selecionada

Muitos artigos propuseram modelos de dados conceituais  ou  sem√¢nticos.  Aqui,  oferecemos  uma  lista  representativa.  Um  grupo  de  artigos,  incluindo  Abrial

(1974),  modelo  DIAM  de  Senko  (1975),  o  m√©todo NIAM (Verheijen e VanBekkum, 1982) e Bracchi et al. (1976), apresenta modelos sem√¢nticos que s√£o baseados no conceito de relacionamentos bin√°rios. Outro grupo de artigos antigos discute m√©todos para estender o modelo relacional para melhorar suas capacidades de modelagem. Isso inclui os artigos de Schmid e Swenson (1975), Navathe e Schkolnick (1978), modelo RM/T de Codd (1979), Furtado (1978) e o modelo estrutural de Wiederhold e Elmasri (1979).

O modelo ER foi proposto originalmente por Chen (1976) e √© formalizado em Ng (1981). Desde ent√£o, diversas  extens√µes  de  suas  capacidades  de  modelagem  foram propostas, como em Scheuermann et al. (1979), Dos Santos et al. (1979), Teorey et al. (1986), Gogolla e Hohenstein (1991)  e  o  modelo  Entidade-Categoria-Relacionamento (ECR) de Elmasri et al. (1985). Smith e Smith (1977) apresentam os conceitos de generaliza√ß√£o e agrega√ß√£o. O modelo de dados sem√¢ntico de Hammer e McLeod (1981) introduziu os conceitos de reticulados de classe/subclasse, bem como outros conceitos de modelagem avan√ßados.

Um estudo da modelagem sem√¢ntica de dados aparece em Hull e King (1987). Eick (1991) discute projeto e transforma√ß√µes dos esquemas conceituais. A an√°lise de restri√ß√µes para relacionamentos n -√°rios √© dada em Soutou (1998). A UML √© descrita detalhadamente em Booch, Rumbaugh e Jacobson (1999). Fowler e Scott (2000) e Stevens e Pooley (2000) oferecem introdu√ß√µes concisas aos conceitos de UML.

Fensel (2000, 2003) discute a Web sem√¢ntica e a aplica√ß√£o  de  ontologias.  Uschold  e  Gruninger  (1996) e  Gruber  (1995)  discutem  sobre  ontologias.  A  edi√ß√£o de junho de 2002 de Communications of the ACM √© dedicada a conceitos e aplica√ß√µes da ontologia. Fensel (2003) √© um livro que discute as ontologias e o com√©rcio eletr√¥nico.



## Projeto de banco de dados relacional por mapeamento ER e EER para relacional

E ste  cap√≠tulo  discute  como projetar  um  esquema de  banco  de  dados  relacional com  base  em  um projeto  de  esquema  conceitual.  A  Figura  7.1  apresentou uma vis√£o de alto n√≠vel do processo de projeto de banco de dados, e neste cap√≠tulo focamos a etapa de projeto l√≥gico de banco de dados l√≥gico ou mapeamento de modelo de dados do projeto de banco de dados. Apresentamos os procedimentos para criar um esquema relacional com base em um esquema Entidade-Relacionamento (ER) ou ER estendido (EER). Nossa discuss√£o relaciona as constru√ß√µes dos modelos ER e EER, apresentadas nos cap√≠tulos 7 e 8, √†s constru√ß√µes do modelo relacional, apresentadas nos cap√≠tulos 3 a 6. Muitas ferramentas de engenharia  de  software  auxiliada  por  computador  (CASE) s√£o baseadas nos modelos ER e EER, ou outros modelos semelhantes, conforme discutimos nos cap√≠tulos 7 e 8. Muitas ferramentas utilizam diagramas ER ou EER ou varia√ß√µes para desenvolver um esquema graficamente, e depois o convertem de maneira autom√°tica em um esquema de banco de dados relacional na DDL de um SGBD relacional espec√≠fico, empregando algoritmos semelhantes aos apresentados neste cap√≠tulo.

Esbo√ßamos um algoritmo de sete etapas na Se√ß√£o 9.1 para converter as constru√ß√µes b√°sicas do modelo ER - tipos de entidade (forte e fraca), relacionamentos bin√°rios (com v√°rias restri√ß√µes estruturais), relacionamentos n -√°rios  e  atributos  (simples,  compostos e multivalorados) - em rela√ß√µes. Depois, na Se√ß√£o 9.2, continuamos o algoritmo de mapeamento ao descrever como mapear as constru√ß√µes do modelo EER - especializa√ß√£o/generaliza√ß√£o e tipos de uni√£o (categorias) - em rela√ß√µes. No final do cap√≠tulo h√° um resumo.

## 9.1 Projeto de banco de dados relacional usando o mapeamento ER para relacional

## 9.1.1 Algoritmo de mapeamento ER para relacional

Nesta se√ß√£o, vamos descrever as etapas de um algoritmo para mapeamento ER para relacional. Usamos o exemplo de banco de dados EMPRESA para ilustrar o procedimento de mapeamento. O esquema ER EMPRESA aparece  novamente  na  Figura  9.1,  e o esquema de banco de dados relacional EMPRESA correspondente aparece na Figura 9.2 para ilustrar as etapas de mapeamento. Assumimos que o mapeamento criar√° tabelas com atributos simples de √∫nico valor.  As  restri√ß√µes  do  modelo  relacional  definidas no Cap√≠tulo 3, que incluem chaves prim√°rias, chaves √∫nicas (se houver) e restri√ß√µes de integridade referencial  sobre  as  rela√ß√µes,  tamb√©m  ser√£o  especificadas nos resultados do mapeamento.

## Etapa 1: Mapeamento de tipos de entidade regular.

Para cada tipo de entidade regular (forte) E no  esquema ER, crie uma rela√ß√£o R que inclua todos os atributos  simples  de E .  Inclua  apenas  os  atributos de  componente  simples  de  um  atributo  composto. Escolha  um  dos  atributos-chave  de E como  chave prim√°ria para R . Se a chave escolhida de E for composta, ent√£o o conjunto de atributos simples que a comp√µem juntos formar√£o a chave prim√°ria de R .

Se v√°rias chaves fossem identificadas para E durante o projeto conceitual, a informa√ß√£o que descreve os atributos que formam cada chave adicional √©

Figura 9.1



O diagrama do esquema conceitual ER para o banco de dados EMPRESA.

mantida a fim de especificar chaves secund√°rias (√∫nicas) da rela√ß√£o R .  O conhecimento sobre as chaves tamb√©m √© mantido para fins de indexa√ß√£o e outros tipos de an√°lises.

de PROJETO s√£o chaves secund√°rias √© mantido para poss√≠vel uso posterior no projeto.

Em  nosso  exemplo,  criamos  as  rela√ß√µes FUNCIONARIO , DEPARTAMENTO e PROJETO na  Figura 9.2 para corresponder aos tipos de entidade regular FUNCIONARIO , DEPARTAMENTO e PROJETO da  Figura 9.1. Os atributos de chave estrangeira e relacionamento,  se  houver,  ainda  n√£o  est√£o  inclu√≠dos;  eles ser√£o acrescentados durante as etapas seguintes. Estes incluem os atributos Cpf\_supervisor e Dnr de FUNCIONARIO , Cpf\_gerente e Data\_inicio\_gerente de DEPARTAMENTO, e Dnum de PROJETO . Em nosso exemplo, escolhemos Cpf , Dnumero e Projnumero como chaves prim√°rias para as rela√ß√µes FUNCIONARIO , DEPARTAMENTO e PROJETO , respectivamente. O conhecimento de que o Dnome de DEPARTAMENTO e o Projnome

As rela√ß√µes que s√£o criadas com base no mapeamento dos tipos de entidade √†s vezes s√£o chamadas rela√ß√µes de entidade , pois cada tupla representa uma inst√¢ncia de entidade. O resultado ap√≥s essa etapa de mapeamento aparece na Figura 9.3(a).

## Etapa  2:  Mapeamento  de  tipos  de  entidade  fraca.

Para cada tipo de entidade fraca F no esquema ER com tipo de entidade propriet√°ria E , crie uma rela√ß√£o R e inclua todos os atributos simples (ou componentes simples dos atributos compostos) de F como atributos de R . Al√©m disso, inclua como atributos de chave estrangeira de R os atributos de chave prim√°ria da(s) rela√ß√£o(√µes) que corresponde(m) aos tipos de entidade propriet√°ria. Isso consegue mapear o tipo de relacionamento de identifica√ß√£o  de F .  A  chave  pri-

## FUNCIONARIO

Figura 9.2



Resultado do mapeamento do esquema ER EMPRESA para um esquema de banco de dados relacional.

## FUNCIONARIO (a)



## (c) tRABALHA\_em

Fcpf

Pnr

Horas

## (d) LOCALIZACAO\_dep

Figura 9.3



Ilustra√ß√£o de algumas etapas de mapeamento. (a) Rela√ß√µes de entidade ap√≥s a etapa 1. (b) Rela√ß√£o de entidade fraca ap√≥s a etapa 2. (c) Rela√ß√£o de relacionamento ap√≥s a etapa 5. (d) Rela√ß√£o representando atributo multivalorado ap√≥s a etapa 6.

m√°ria de R √© a combina√ß√£o das chaves prim√°rias dos propriet√°rios e a chave parcial do tipo de entidade fraca F , se houver.

Se  houver  um  tipo  de  entidade  fraca E 2 ,  cujo propriet√°rio tamb√©m √© um tipo de entidade E 1 , ent√£o E 1 deve ser mapeado antes de E 2 para determinar primeiro sua chave prim√°ria.

Em nosso exemplo, criamos a rela√ß√£o DEPENDENTE nesta etapa para corresponder ao tipo de entidade fraca DEPENDENTE (ver  Figura  9.3(b)).  Inclu√≠  mos  a chave prim√°ria Cpf da  rela√ß√£o FUNCIONARIO - que corresponde ao tipo de entidade propriet√°ria - como um atributo de chave estrangeira de DEPENDENTE ; renomeamos para Fcpf , embora isso n√£o seja necess√°rio. A chave prim√°ria da rela√ß√£o DEPENDENTE √©  a  combina√ß√£o { Fcpf , Nome\_dependente },  pois Nome\_depen-dente (tamb√©m renomeado de Nome na Figura 9.1) √© a chave parcial de DEPENDENTE .

√â comum escolher a op√ß√£o de propaga√ß√£o ( CASCADE ) para a a√ß√£o de disparo referencial (ver Se√ß√£o 4.2) na chave estrangeira na rela√ß√£o correspondente ao tipo de entidade fraca, pois uma entidade fraca tem uma depend√™ncia de exist√™ncia em sua entidade propriet√°ria. Isso pode ser usado para ON UPDATE e ON DELETE .

Etapa 3: Mapeamento dos tipos de relacionamento  bin√°rios  1:1. Para  cada  tipo  de  relacionamento bin√°rio 1:1 R no esquema ER, identifique as rela√ß√µes S e T que correspondem aos tipos de entidade participantes em R . Existem tr√™s t√©cnicas poss√≠veis: (1) a t√©cnica de chave estrangeira, (2) a t√©cnica de relacionamento mesclado e (3) a t√©cnica de rela√ß√£o de refer√™ncia cruzada ou relacionamento. A primeira t√©cnica √© a mais √∫til e deve ser seguida a menos que haja condi√ß√µes especiais, conforme discutimos a seguir.

- 1. T√©cnica de chave estrangeira: escolha uma das rela√ß√µes - digamos, S - e inclua como chave estrangeira em S a chave prim√°ria de T . √â melhor escolher um tipo de entidade com participa√ß√£o total em R no papel de S . Inclua todos os atributos simples (ou componentes simples dos atributos compostos) do tipo de relacionamento 1:1 R como atributos de S . Em nosso exemplo, mapeamos o tipo de relacionamento 1:1 GERENCIA da Figura 9.1 ao escolher  o  tipo  de  entidade  de  participa√ß√£o DEPARTAMENTO para  servir  ao  papel  de S , pois  sua  participa√ß√£o  no  tipo  de  relacionamento GERENCIA √© total (cada departamento tem um gerente). Inclu√≠mos a chave prim√°ria da rela√ß√£o FUNCIONARIO como chave estrangeira na rela√ß√£o DEPARTAMENTO e a renomeamos como Cpf\_gerente .  Tamb√©m inclu√≠mos

o atributo simples Data\_inicio do tipo de relacionamento GERENCIA na rela√ß√£o DEPARTAMENTO e o renomeamos como Data\_inicio\_ gerente (ver Figura 9.2).

Observe  que  √©  poss√≠vel  incluir  a  chave  prim√°ria de S como uma chave estrangeira em T em vez disso. Em nosso exemplo, isso significa  ter  um  atributo  de  chave  estrangeira, digamos, Depart\_gerenciado na rela√ß√£o FUNCIONARIO, mas ter√° um valor NULL para as tuplas de funcion√°rios que n√£o gerenciam um departamento. Se apenas 2 por cento dos funcion√°rios gerenciam um departamento, ent√£o 98 por cento das chaves estrangeiras seriam NULL nesse  caso.  Outra  possibilidade  √©  ter chaves estrangeiras nas rela√ß√µes S e T de maneira redundante, mas isso cria redund√¢ncia e agrega uma penalidade para a manuten√ß√£o da consist√™ncia.

- 2. T√©cnica de rela√ß√£o mesclada: um mapeamento  alternativo  de  um  tipo  de  relacionamento 1:1 √© mesclar os dois tipos de entidade e  o  relacionamento  em  uma  √∫nica  rela√ß√£o. Isso √© poss√≠vel quando ambas as participa√ß√µes s√£o totais , pois indicaria que as duas tabelas ter√£o exatamente o mesmo n√∫mero de tuplas o tempo inteiro.
- 3. T√©cnica de rela√ß√£o de refer√™ncia cruzada ou relacionamento: a terceira op√ß√£o √© configurar uma terceira rela√ß√£o R para a finalidade de refer√™ncia cruzada das chaves prim√°rias das duas rela√ß√µes S e T representando os tipos  de  entidade.  Conforme  veremos,  essa t√©cnica √© exigida para relacionamentos M:N bin√°rios. A rela√ß√£o R √©  chamada de rela√ß√£o de relacionamento (ou, √†s vezes, de tabela de pesquisa ), porque cada tupla em R representa uma inst√¢ncia de relacionamento que relaciona uma tupla de S a uma tupla de T . A rela√ß√£o R incluir√° os atributos de chave prim√°ria de S e T como chaves estrangeiras para S e T . A chave prim√°ria de R ser√° uma das duas chaves  estrangeiras,  e  a  outra  chave  estrangeira ser√° uma chave unique de R . A desvantagem √© ter uma rela√ß√£o extra e exigir uma opera√ß√£o de jun√ß√£o extra ao combinar tuplas relacionadas das tabelas.

Etapa 4: Mapeamento de tipos de relacionamento bin√°rio 1:N. Para cada tipo de relacionamento R bin√°rio regular 1:N, identifique a rela√ß√£o S que representa o tipo de entidade participante no lado N do tipo de relacionamento. Inclua como chave estrangeira em S a chave prim√°ria da rela√ß√£o T que representa

o outro tipo de entidade participante em R ; fazemos isso porque cada inst√¢ncia de entidade no lado N est√° relacionada a, no m√°ximo, uma inst√¢ncia de entidade no lado 1 do tipo de relacionamento. Inclua quaisquer atributos simples (ou componentes simples dos atributos compostos) do tipo de relacionamento 1:N como atributos de S .

Em  nosso  exemplo,  agora  mapeamos  os  tipos de relacionamento 1:N TRABALHA\_PARA , CONTROLA e SUPERVISAO da Figura 9.1. Para TRABA-LHA\_PARA , inclu√≠mos a chave prim√°ria Dnumero da rela√ß√£o DEPARTAMENTO como  chave  estrangeira na rela√ß√£o FUNCIONARIO e a chamamos de Dnr . Para SUPERVISAO , inclu√≠mos a chave prim√°ria da rela√ß√£o FUNCIONARIO como  chave  estrangeira  na  pr√≥pria rela√ß√£o FUNCIONARIO -  pois  o  relacionamento  √© recursivo - e a chamamos de Cpf\_supervisor . O relacionamento CONTROLA √© mapeado para o atributo de chave estrangeira Dnum de PROJETO , que referencia  a  chave  prim√°ria Dnumero da  rela√ß√£o DEPARTAMENTO. Essas  chaves  estrangeiras  s√£o mostradas na Figura 9.2.

Uma t√©cnica alternativa √© usar a op√ß√£o de rela√ß√£o de relacionamento (refer√™ncia cruzada) como na terceira op√ß√£o para os relacionamentos bin√°rios 1:1. Criamos uma rela√ß√£o separada R cujos atributos s√£o chaves prim√°rias de S e T , que tamb√©m ser√£o chaves estrangeiras para S e T . A chave prim√°ria de R √© igual √† chave prim√°ria de S .  Essa op√ß√£o pode ser usada se algumas tuplas em S participarem do relacionamento para evitar valores NULL excessivos na chave estrangeira.

## Etapa 5: Mapeamento de tipos de relacionamento

bin√°rio M:N. Para cada tipo de relacionamento R bin√°rio M:N, crie uma nova rela√ß√£o S para representar R . Inclua como atributos de chave estrangeira em S as chaves prim√°rias das rela√ß√µes que representam os tipos de entidade participantes; sua combina√ß√£o formar√° a chave prim√°ria de  . Inclua tamb√©m quaisquer S atributos simples do tipo de relacionamento M:N (ou componentes simples dos atributos compostos) como atributos de S . Observe que n√£o podemos representar  um tipo de relacionamento M:N por um √∫nico atributo  de  chave  estrangeira  em  uma  das  rela√ß√µes participantes (como fizemos para os tipos de relacionamento 1:1 ou 1:N) devido √† raz√£o de cardinalidade M:N; temos de criar uma rela√ß√£o de relacionamento S separada.

Em nosso exemplo, mapeamos o tipo de relacionamento M:N TRABALHA\_EM da Figura 9.1 criando a rela√ß√£o TRABALHA\_EM na Figura 9.2. Inclu√≠mos as chaves prim√°rias das rela√ß√µes PROJETO e FUNCIONARIO como chaves estrangeiras em TRABALHA\_EM e as renomeamos como Pnr e Fcpf , respectivamente.

Tamb√©m inclu√≠mos  um  atributo Horas em TRABA-LHA\_EM para representar o atributo Horas do tipo de relacionamento. A chave prim√°ria da rela√ß√£o TRA-BALHA\_EM √©  a  combina√ß√£o dos atributos de chave estrangeira {Fcpf  Pnr , }. Essa rela√ß√£o de relacionamento aparece na Figura 9.3(c).

A op√ß√£o de propaga√ß√£o ( CASCADE ) para a a√ß√£o de disparo referencial (ver Se√ß√£o 4.2) deve ser especificada sobre as chaves estrangeiras na rela√ß√£o correspondente ao relacionamento R ,  pois cada inst√¢ncia de relacionamento tem uma depend√™ncia de exist√™ncia sobre cada uma das entidades a que ela se relaciona.  Isso  pode  ser  usado  tanto  para ON UPDATE quanto para ON DELETE .

Observe que sempre podemos mapear relacionamentos 1:1 ou 1:N de uma maneira semelhante aos relacionamentos M:N usando a t√©cnica de refer√™ncia cruzada (rela√ß√£o de relacionamento), conforme discutimos anteriormente. Essa alternativa √© particularmente √∫til quando existem poucas inst√¢ncias de relacionamentos, a fim de evitar valores NULL em chaves estrangeiras. Nesse caso, a chave prim√°ria da rela√ß√£o de  relacionamento  ser√° apenas  uma das  chaves  estrangeiras  que  referenciam  as  rela√ß√µes  da  entidade participante. Para um relacionamento 1:N, a chave prim√°ria da rela√ß√£o de relacionamento ser√° a chave estrangeira que referencia a rela√ß√£o de entidade no lado N. Para um relacionamento 1:1, qualquer chave estrangeira pode ser usada como chave prim√°ria da rela√ß√£o de relacionamento.

## Etapa 6: Mapeamento de atributos multivalorados.

Para cada atributo multivalorado A , crie uma rela√ß√£o R . Essa rela√ß√£o R incluir√° um atributo correspondente a A , mais o atributo da chave prim√°ria Ch - como uma chave estrangeira em R - da rela√ß√£o que representa o tipo de entidade ou tipo de relacionamento que tem A como atributo multivalorado. A chave prim√°ria de R √© a combina√ß√£o de A e Ch . Se o atributo multivalorado for composto, inclu√≠mos seus componentes simples.

Em nosso exemplo, criamos uma rela√ß√£o LOCALI-ZACAO\_DEP (ver Figura 9.3(d)). O atributo Dlocalizacao representa o atributo multivalorado LOCALIZACOES de DEPARTAMENTO ,  enquanto Dnumero - como chave  estrangeira  -  representa  a  chave  prim√°ria  da rela√ß√£o DEPARTAMENTO . A chave prim√°ria de LOCA-LIZACAO\_DEP √© a combina√ß√£o de { Dnumero Dlocaliza-, cao }. Uma tupla separada existir√° em LOCALIZACAO\_ DEP para cada local que tenha um departamento.

A op√ß√£o de propaga√ß√£o ( CASCADE ) para a a√ß√£o de disparo referencial (ver Se√ß√£o 4.2) deve ser especificada na chave estrangeira da rela√ß√£o R correspondente ao atributo multivalorado para ON UPDATE e

Figura 9.4



Mapeando o tipo de relacionamento n -√°rio FORNECIMENTO da Figura 7.17(a).

ON DELETE . Tamb√©m devemos observar que a chave de R, ao mapear um atributo composto, multivalorado, requer alguma an√°lise do significado dos atributos componentes. Em alguns casos, quando um atributo multivalorado √© composto, somente alguns dos atributos componentes s√£o exigidos para fazer parte da chave de R .  Esses atributos s√£o semelhantes √† chave parcial de um tipo de entidade fraca que corresponde ao atributo multivalorado (ver Se√ß√£o 7.5).

A Figura 9.2 mostra o esquema de banco de dados relacional EMPRESA obtido  com as etapas 1 a 6, e a Figura 3.6 mostra um exemplo de estado de banco de dados. Observe que ainda n√£o discutimos o mapeamento de tipos de relacionamento n -√°rio ( n &gt; 2), pois ele n√£o existe na Figura 9.1. Estes s√£o mapeados de um modo semelhante aos tipos de relacionamento M:N, incluindo a etapa adicional a seguir no algoritmo de mapeamento.

## Etapa 7: Mapeamento de tipos de relacionamen-

to n -√°rio. Para cada tipo de relacionamento n -√°rio R , onde n &gt; 2, crie uma rela√ß√£o S para representar R .  Inclua  como  atributos  de  chave  estrangeira  em S as chaves prim√°rias das rela√ß√µes que representam os  tipos  de  entidade  participantes.  Inclua  tamb√©m quaisquer atributos simples do tipo de relacionamento n -√°rio (ou componentes simples de atributos compostos) como atributos de S . A chave prim√°ria de S normalmente √© uma combina√ß√£o de todas as chaves estrangeiras que referenciam as rela√ß√µes representando os tipos de entidade participantes. Por√©m, se as restri√ß√µes  de  cardinalidade  sobre  qualquer  um  dos tipos de entidade E participantes em R for 1, ent√£o a chave prim√°ria de S n√£o deve incluir o atributo de chave estrangeira que referencia a rela√ß√£o E ' corres-

Tabela 9.1 Correspond√™ncia entre os modelos ER e relacional.

| MODELO ER                         | MODELO RELACIONAL                                    |
|-----------------------------------|------------------------------------------------------|
| Tipo de entidade                  | Rela√ß√£o de entidade                                  |
| Tipo de relacionamento 1:1 ou 1:N | Chave estrangeira (ou rela√ß√£o de relacionamento )    |
| Tipo de relacionamento M:N        | Rela√ß√£o de relacionamento e duas chaves estrangeiras |
| Tipo de relacionamento n -√°rio    | Rela√ß√£o de relacionamento e n chaves estrangeiras    |
| Atributo simples                  | Atributo                                             |
| Atributo composto                 | Conjunto de atributos componentes simples            |
| Atributo multivalorado            | Rela√ß√£o e chave estrangeira                          |
| Conjunto de valores               | Dom√≠nio                                              |
| Atributo-chave                    | Chave prim√°ria (ou secund√°ria)                       |

pondente a E (ver discuss√£o na Se√ß√£o 7.9.2, referente a restri√ß√µes sobre relacionamentos n -√°rios).

Por exemplo, considere o tipo de relacionamento FORNECIMENTO da Figura 7.17. Este pode ser mapeado para a rela√ß√£o FORNECIMENTO mostrada na Figura 9.4, cuja chave prim√°ria √© a combina√ß√£o das tr√™s chaves estrangeiras { Fnome Num\_peca Proj\_nome , , }.

## 9.1.2 Discuss√£o e resumo do mapeamento para constru√ß√µes no modelo ER

A Tabela 9.1 resume as correspond√™ncias entre as constru√ß√µes e restri√ß√µes do modelo ER e relacional.

Um dos principais pontos a observar em um esquema relacional, ao contr√°rio de um esquema ER, √© que os tipos de relacionamento n√£o s√£o representados explicitamente. Em vez disso, eles s√£o representados com dois atributos A e B , um √© uma chave prim√°ria e o outro √© uma chave estrangeira (no mesmo dom√≠nio) inclu√≠da em duas rela√ß√µes S e T . Duas tuplas em S e T s√£o relacionadas quando t√™m o mesmo valor para A e B . Usando a opera√ß√£o EQUIJUN√á√ÉO (ou JUN√á√ÉO NATURAL , se os dois atributos de jun√ß√£o tiverem o mesmo nome) em S.A e T.B , podemos combinar todos os pares de tuplas relacionadas de S e T e materializar o relacionamento. Quando um tipo de relacionamento bin√°rio 1:1 ou 1:N √© envolvido, uma √∫nica opera√ß√£o de jun√ß√£o costuma ser necess√°ria.  Para  um  tipo  de  relacionamento  bin√°rio  M:N, duas opera√ß√µes de jun√ß√£o s√£o necess√°rias, enquanto para tipos de relacionamento n -√°rios, n jun√ß√µes s√£o necess√°rias para materializar totalmente as inst√¢ncias de relacionamento.

Por exemplo, para formar uma rela√ß√£o que inclui o nome do funcion√°rio, nome do projeto e horas

que o funcion√°rio trabalha em cada projeto, precisamos conectar cada tupla FUNCIONARIO √†s tuplas PROJETO relacionadas por meio da rela√ß√£o TRABA-LHA\_EM na Figura 9.2. Logo, precisamos aplicar a opera√ß√£o EQUIJUN√á√ÉO √†s  rela√ß√µes FUNCIONARIO e TRABALHA\_EM com  a  condi√ß√£o  de  jun√ß√£o Cpf = Fcpf ,  e  depois  aplicar  outra  opera√ß√£o EQUIJUN√á√ÉO √† rela√ß√£o resultante e a rela√ß√£o PROJETO com a condi√ß√£o de jun√ß√£o Pnr = Projnumero .  Em geral, quando  v√°rios  relacionamentos  precisam  ser  examinados, diversas opera√ß√µes de jun√ß√£o precisam ser especificadas. Um usu√°rio de banco de dados relacional sempre precisa estar ciente dos atributos de chave estrangeira para poder us√°-los corretamente na combina√ß√£o de tuplas relacionadas de duas ou mais rela√ß√µes. Isso √†s vezes √© considerado uma desvantagem do modelo de dados relacional, porque as correspond√™ncias de chave estrangeira/chave prim√°ria nem sempre s√£o √≥bvias pela inspe√ß√£o dos esquemas relacionais. Se uma EQUIJUN√á√ÉO for realizada entre atributos de duas rela√ß√µes que n√£o representam um relacionamento de chave estrangeira/chave prim√°ria, o resultado pode com frequ√™ncia ser sem sentido e levar a dados falsos (esp√∫rios). Por exemplo, o leitor pode tentar juntar as rela√ß√µes PROJETO e LOCALIZACAO\_DEP na condi√ß√£o Dlocal = Projlocal e examinar o resultado (veja a discuss√£o sobre tuplas esp√∫rias na Se√ß√£o 15.1.4).

No esquema relacional, criamos uma rela√ß√£o separada para cada atributo multivalorado. Para uma entidade em particular com um conjunto de valores para o atributo multivalorado, o valor do atributo-chave da entidade √© repetido uma vez para cada valor do atributo multivalorado em uma tupla separada, pois  o  modelo  relacional  b√°sico n√£o permite  valores m√∫ltiplos (uma lista, ou um conjunto de valores) para um atributo em uma √∫nica tupla. Por exemplo, como o departamento 5 tem tr√™s locais, existem tr√™s tuplas na rela√ß√£o LOCALIZACAO\_DEP da Figura 3.6; cada tupla especifica um dos locais. Em nosso exemplo,  aplicamos EQUIJUN√á√ÉO a LOCALIZACAO\_DEP e DEPARTAMENTO no atributo Dnumero para obter os valores de todas as localiza√ß√µes junto com outros atributos de DEPARTAMENTO . Na rela√ß√£o resultante, os valores dos outros atributos de DEPARTAMENTO s√£o  repetidos  em  tuplas  separadas  para  cada  local que tenha um departamento.

A √°lgebra relacional b√°sica n√£o tem uma opera√ß√£o ANINHAR ou COMPRIMIR que produziria um conjunto  de  tuplas  na  forma  { &lt; '1',  'S√£o  Paulo' &gt; , &lt; '4',  'Mau√°' &gt; , &lt; '5',  {'Santo  Andr√©',  'Itu',  'S√£o Paulo'} &gt; } com base na rela√ß√£o LOCALIZACAO\_DEP da Figura 3.6. Essa √© uma desvantagem s√©ria da vers√£o  b√°sica  normalizada  ou  do  modelo  relacional.

O modelo de dados de objeto e os sistemas objeto-relacional  (ver  Cap√≠tulo  11)  permitem  atributos multivalorados.

## 9.2 Mapeando constru√ß√µes do modelo EER para rela√ß√µes

A seguir, vamos discutir o mapeamento das constru√ß√µes do modelo EER para rela√ß√µes, estendendo o algoritmo de mapeamento ER para relacional que foi apresentado na Se√ß√£o 9.1.1.

## 9.2.1 Mapeamento da especializa√ß√£o ou generaliza√ß√£o

Existem  v√°rias  op√ß√µes  para  mapear  uma  s√©rie de subclasses que juntas formam uma especializa√ß√£o (ou,  como  alternativa,  que  s√£o  generalizadas  para uma superclasse), como as subclasses { SECRETARIA , TECNICO , ENGENHEIRO } de FUNCIONARIO na Figura 8.4. Podemos acrescentar outro passo ao nosso algoritmo de mapeamento da Se√ß√£o 9.1.1, que tem sete etapas, para lidar com o mapeamento da especializa√ß√£o. A etapa 8, que vem a seguir, oferece as op√ß√µes mais comuns; outros mapeamentos tamb√©m s√£o poss√≠veis. Discutimos as condi√ß√µes sob as quais cada op√ß√£o deve ser usada. Usamos Atrs( R ) para indicar os atributos da rela√ß√£o R e ChP( R ) para indicar a chave prim√°ria de R . Primeiro, vamos descrever o mapeamento formalmente e depois ilustrar com exemplos.

Etapa 8: Op√ß√µes para mapeamento da especializa√ß√£o  ou  generaliza√ß√£o. Converta  cada  especializa√ß√£o com m subclasses { S 1 , S 2 , ..., S m } e superclasse (generalizada) C , em que os atributos de C s√£o { ch , a 1 , ... a n } e ch √© a chave (prim√°ria) para os esquemas da rela√ß√£o usando uma das seguintes op√ß√µes:

- ¬Ñ Op√ß√£o  8A:  M√∫ltiplas  rela√ß√µes  -  superclasse  e  subclasses. Crie  uma  rela√ß√£o L para C com atributos Atrs( L )  =  { ch , a 1 ,  ..., a n } e ChP( L i ) = ch . Crie uma rela√ß√£o L i para cada subclasse S i , 1 ‚â§ i ‚â§ m , com os atributos Atrs( L i ) = { ch } ‚à™ {atributos de S i } e ChP( L i ) = ch .  Essa  op√ß√£o  funciona  para  qualquer especializa√ß√£o (total ou parcial, disjunta ou sobreposta).
- ¬Ñ Op√ß√£o  8B:  M√∫ltiplas  rela√ß√µes  -  apenas rela√ß√µes de subclasse. Crie uma rela√ß√£o L i para cada subclasse S i , 1 ‚â§ i ‚â§ m , com os atributos Atrs( L i )  =  {atributos  de S i } ‚à™ { ch  a , 1 , ..., a n } e ChP( L i ) = ch . Essa op√ß√£o s√≥ funciona para uma especializa√ß√£o cujas subclasses s√£o totais (cada entidade na superclasse deve pertencer  a  (pelo  menos)  uma  das  subclas-

- ses). Al√©m disso, isso s√≥ √© recomendado se a especializa√ß√£o tiver a restri√ß√£o de disjun√ß√£o (ver Se√ß√£o 8.3.1). Se a especializa√ß√£o for sobreposta , a mesma entidade pode ser duplicada em v√°rias rela√ß√µes.
- ¬Ñ Op√ß√£o 8C: Rela√ß√£o √∫nica com um atributo de tipo. Crie uma √∫nica rela√ß√£o L com atributos  Atrs( L )  =  { ch   a , 1 ,  ..., a n } ‚à™ {atributos de S 1 } ‚à™ ... ‚à™ {atributos de S m } ‚à™ { t } e ChP( L ) = ch . O atributo   √© chamado de atributo de t tipo (ou discriminador ),  cujo  valor  indica  a subclasse √† qual cada tupla pertence, se houver  alguma.  Essa  op√ß√£o  funciona  somente para uma especializa√ß√£o cujas subclasses s√£o disjuntas , e tem o potencial para gerar muitos valores NULL se diversos atributos espec√≠ficos existirem nas subclasses.
- ¬Ñ Op√ß√£o  8D:  Rela√ß√£o  isolada  com  atributos de  m√∫ltiplos  tipos. Crie  um  √∫nico  esquema de rela√ß√£o L com atributos Atrs( L ) = { ch , a 1 , ..., a n } ‚à™ {atributos de S 1 } ‚à™ ... ‚à™ {atributos de S m } ‚à™ { t 1 , t 2 , ..., t m } e ChP( L ) = ch . Cada t i , 1 ‚â§ i ‚â§ m , √© um atributo de tipo booleano indicando se uma tupla pertence √† subclasse S i . Essa op√ß√£o √© usada para uma especializa√ß√£o cujas subclasses s√£o sobrepostas (mas tamb√©m funcionar√° para uma especializa√ß√£o disjunta).

As op√ß√µes 8A e 8B podem ser chamadas de op√ß√µes de rela√ß√£o m√∫ltipla , enquanto as op√ß√µes 8C e 8D podem ser chamadas de op√ß√µes de rela√ß√£o √∫nica . A op√ß√£o 8A cria uma rela√ß√£o L para a superclasse C e seus atributos, mais uma rela√ß√£o L i para cada subclasse S i ;  cada L i inclui  os  atributos  espec√≠ficos (ou locais) de S i , mais a chave prim√°ria da superclasse C , que √© propagada para L i e torna-se sua chave prim√°ria.  Ela  tamb√©m se torna uma chave estrangeira para a rela√ß√£o da superclasse. Uma opera√ß√£o EQUIJUN√á√ÉO na chave prim√°ria entre qualquer L i e L produz todos os atributos espec√≠ficos e herdados das entidades em S i . Essa op√ß√£o √© ilustrada na Figura 9.5(a) para o esquema EER da Figura 8.4. A op√ß√£o 8A funciona para quaisquer restri√ß√µes sobre a especializa√ß√£o: disjuntas ou sobrepostas, totais ou parciais. Observe que a restri√ß√£o

<!-- formula-not-decoded -->

precisa  ser  mantida  para  cada L i .  Esta  especifica  uma chave estrangeira de cada L i para L , bem como uma depend√™ncia de inclus√£o L ch i . &lt; L ch . (ver Se√ß√£o 16.5).

Na op√ß√£o 8B, a opera√ß√£o EQUIJUN√á√ÉO entre cada subclasse e a superclasse √© embutida no esquema e a rela√ß√£o L √© abolida, conforme ilustra a Figura 9.5(b) para a especializa√ß√£o EER na Figura 8.3(b). Essa op√ß√£o funciona bem somente quando ambas as restri√ß√µes de disjun√ß√£o e total s√£o mantidas. Se a especializa√ß√£o n√£o

## FUNCIONARIO (a)

Figura 9.5



Op√ß√µes para mapeamento de especializa√ß√£o ou generaliza√ß√£o. (a) Mapeando o esquema EER na Figura 8.4 ao usar a op√ß√£o 8A. (b) Mapeando o esquema EER na Figura 8.3(b) ao usar a op√ß√£o 8B. (c) Mapeando o esquema EER na Figura 8.4 ao usar a op√ß√£o 8C. (d) Mapeando a Figura 8.5 ao usar a op√ß√£o 8D com campos de tipo booleano Tipo\_fabr e Tipo\_compr.

for total, uma entidade que n√£o pertence a qualquer uma das subclasses S i √© perdida. Se a especializa√ß√£o n√£o for disjunta, uma entidade pertencente a mais de uma subclasse ter√° seus atributos herdados da superclasse C armazenada de maneira redundante em mais de um L i . Com a op√ß√£o 8B, nenhuma rela√ß√£o mant√©m todas as entidades na superclasse C ; consequentemente, temos de  aplicar  uma  opera√ß√£o UNI√ÉO EXTERNA (ou JUN√á√ÉO EXTERNA COMPLETA ) (ver Se√ß√£o 6.4) √†s rela√ß√µes L i para recuperar todas as entidades em C . O resultado da uni√£o externa ser√° semelhante √†s rela√ß√µes sob as op√ß√µes 8C e 8D, exceto que os campos de tipo estar√£o faltando. Sempre que procurarmos uma entidade arbitr√°ria em C , devemos procurar todas as m rela√ß√µes L i .

As op√ß√µes 8C e 8D criam uma √∫nica rela√ß√£o para representar a superclasse C e todas as suas subclasses. Uma entidade que n√£o pertence a nenhuma das subclasses ter√° valores NULL para os atributos espec√≠ficos dessas subclasses. Essas op√ß√µes n√£o s√£o recomendadas se  muitos  atributos  espec√≠ficos  forem  definidos  para as subclasses. Contudo, se houver poucos atributos de subclasse,  esses  mapeamentos  s√£o  prefer√≠veis  √†s  op√ß√µes 8A e 8B porque dispensam a necessidade de especificar opera√ß√µes EQUIJUN√á√ÉO e UNI√ÉO EXTERNA . Portanto,  eles  podem  produzir  uma  implementa√ß√£o mais eficiente.

A op√ß√£o 8C √© utilizada para lidar com subclasses disjuntas, incluindo um √∫nico atributo de tipo (ou de imagem ou discriminador ) t para indicar a qual das m subclasses cada tupla pertence; logo, o dom√≠nio de t poderia ser {1, 2, ..., m }. Se a especializa√ß√£o for parcial, t pode ter valores NULL em tuplas que n√£o pertencem a nenhuma subclasse. Se a especializa√ß√£o for definida por atributo, esse atributo que serve √† finalidade de t e t n√£o √© necess√°rio. Tal op√ß√£o √© ilustrada na Figura 9.5(c) para a especializa√ß√£o EER da Figura 8.4.

A op√ß√£o 8D √© projetada para lidar com subclasses sobrepostas incluindo m campos de tipo (ou flag ) booleano , um para cada subclasse. Ela tamb√©m pode ser usada para subclasses disjuntas. Cada campo de tipo t i pode ter um dom√≠nio {sim, n√£o}, em que um valor sim indica que a tupla √© um membro da subclasse S i .  Se  usarmos essa op√ß√£o para a especializa√ß√£o EER na Figura 8.4, incluir√≠amos tr√™s atributos de tipo -tipo\_secretaria , tipo\_engenheiro e tipo\_tec-nico - no lugar do atributo Tipo\_emprego da Figura 9.5(c). Observe que tamb√©m √© poss√≠vel criar um √∫nico atributo de tipo de m bits em vez dos m campos de  tipo.  A  Figura  9.5(d)  mostra  o  mapeamento  da especializa√ß√£o da Figura 8.5 usando a op√ß√£o 8D.

Quando temos uma hierarquia ou reticulado de especializa√ß√£o (ou generaliza√ß√£o) multin√≠vel, n√£o precisamos seguir a mesma op√ß√£o de mapeamento para todas as especializa√ß√µes. Em vez disso, podemos utilizar uma op√ß√£o de mapeamento para parte da hierarquia ou reticulado e outras op√ß√µes para outras partes. A Figura 9.6 mostra um mapeamento poss√≠vel para as rela√ß√µes do reticulado EER da Figura 8.7. Aqui, usamos a op√ß√£o 8A  para PESSOA FUNCIONARIO /{ , EX\_ALUNO , ALUNO }, a op√ß√£o 8C para FUNCIONARIO /{ ADMINISTRATIVO , DOCENTE , ALUNO\_COLABORADOR }, incluindo o atributo de tipo Tipo\_funcionario, e a op√ß√£o 8D para ALUNO\_COLABORADOR/{COLABORADOR\_PESQUI-SA, COLABORADOR\_ENSINO} ao  incluir  os  atributos de  tipo Tipo\_col\_ensino e Tipo\_col\_pesq em FUNCIONARIO , ALUNO/ALUNO\_COLABORADOR incluindo os atributos de tipo Tipo\_aluno\_col em ALUNO , e ALUNO / { ALUNO\_POSGRADUACAO , ALUNO\_GRADUACAO } incluindo os atributos de tipo tipo\_pos e tipo\_grad em

## peSSOA

Figura 9.6



ALUNO . Na Figura 9.6, todos os atributos cujos nomes iniciam com tipo s√£o campos de tipo.

## 9.2.2 Mapeamento de subclasses compartilhadas (heran√ßa m√∫ltipla)

Uma  subclasse  compartilhada,  como GEREN-TE\_ENGENHEIRO da Figura 8.6, √© uma subclasse de v√°rias  superclasses,  indicando  a  heran√ßa  m√∫ltipla. Todas essas classes precisam ter o mesmo atributo-chave;  caso  contr√°rio,  a  subclasse  compartilhada seria modelada como uma categoria (tipo de uni√£o), conforme  discutimos  na  Se√ß√£o  8.4.  Podemos  aplicar qualquer uma das op√ß√µes discutidas na etapa 8 a uma subclasse compartilhada, sujeita √†s restri√ß√µes discutidas na etapa 8 do algoritmo de mapeamento. Na Figura 9.6, as op√ß√µes 8C e 8D s√£o utilizadas para a subclasse compartilhada ALUNO\_COLABORADOR . A op√ß√£o 8C √© usada na rela√ß√£o FUNCIONARIO (atributo Tipo\_funcionario ) e a op√ß√£o 8D, na rela√ß√£o ALUNO (atributo Tipo\_aluno\_col ).

## 9.2.3 Mapeamento de categorias (tipos de uni√£o)

Acrescentamos outra etapa ao procedimento de mapeamento - etapa 9 - para lidar com categorias. Uma categoria (ou tipo de uni√£o) √© uma subclasse da uni√£o de duas ou mais superclasses que podem ter diferentes chaves porque podem ser de diferentes tipos de entidade (ver Se√ß√£o 8.4). Um exemplo √© a categoria PROPRIETARIO mostrada na Figura 8.8, que √© um subconjunto da uni√£o de tr√™s tipos de entidade PESSOA BANCO , e EMPRESA . A outra categoria nessa figura, VEICULO\_REGISTRADO , tem duas superclasses que possuem o mesmo atributo de chave.

Etapa 9: Mapeamento de tipos de uni√£o (categorias). Para  o  mapeamento  de  uma  categoria  cuja defini√ß√£o  de  superclasses  tem  chaves  diferentes,  √© comum  especificar  um  novo  atributo-chave,  chamado chave substituta ,  ao  criar  uma  rela√ß√£o  para corresponder √† categoria. As chaves das classes de defini√ß√£o s√£o diferentes e, portanto, n√£o podemos usar nenhuma delas exclusivamente para identificar todas as entidades na categoria. Em nosso exemplo da Figura 8.8, criamos uma rela√ß√£o PROPRIETARIO para corresponder √† categoria PROPRIETARIO , conforme ilustrado na Figura 9.7, e inclu√≠mos alguns atributos  da  categoria  nessa  rela√ß√£o.  A  chave  prim√°ria da rela√ß√£o PROPRIETARIO √©  a  chave  substituta,  que  chamamos  de Id\_proprietario . Tamb√©m inclu√≠mos o atributo de chave substituta Id\_proprie-tario como uma chave estrangeira em cada rela√ß√£o correspondente  a  uma  superclasse  da  categoria,

## peSSOA

Figura 9.7



Mapeamento das categorias EER (tipos de uni√£o) na Figura 8.8 para rela√ß√µes.

para especificar a correspond√™ncia nos valores entre a chave substituta e a chave de cada superclasse. Observe que, se determinada entidade PESSOA (ou BANCO ou EMPRESA ) n√£o for um membro de PROPRIETARIO ,  ela  teria  um  valor NULL para  seu atributo Id\_proprietario em sua tupla correspondente  na  rela√ß√£o PESSOA (ou BANCO ou EMPRESA ), e  n√£o  teria  uma  tupla  na  rela√ß√£o PROPRIETARIO. Tamb√©m √© recomendado acrescentar um atributo de tipo (n√£o mostrado na Figura 9.7) √† rela√ß√£o PROPRIETARIO para indicar o tipo de entidade em particular ao qual cada tupla pertence ( PESSOA BANCO , ou EMPRESA ).

Para uma categoria cujas superclasses t√™m a mesma chave, como VEICULO na Figura 8.8, n√£o h√° necessidade de uma chave substituta. O mapeamento da categoria VEICULO\_REGISTRADO , que ilustra esse caso, tamb√©m aparece na Figura 9.7.

## Resumo

Na Se√ß√£o 9.1, mostramos como um projeto de esquema conceitual no modelo ER pode ser mapeado para um esquema de banco de dados relacional. Um algorit-

mo para mapeamento ER para relacional foi dado e ilustrado por meio de exemplos do banco de dados EMPRESA . A Tabela 9.1 resumiu as correspond√™ncias entre as constru√ß√µes e restri√ß√µes do modelo ER e relacional. Em seguida, acrescentamos as etapas adicionais ao algoritmo da Se√ß√£o 9.2 para mapear as constru√ß√µes do modelo EER para  o  modelo  relacional.  Algoritmos  semelhantes  s√£o incorporados nas ferramentas gr√°ficas de banco de dados para criar um esquema relacional com base em um projeto de esquema conceitual automaticamente.

## Perguntas de revis√£o

- 9.1. Discuta as correspond√™ncias entre as constru√ß√µes  do  modelo  ER  e  as  constru√ß√µes  do  mo-
- delo relacional. Mostre como cada constru√ß√£o do modelo ER pode ser mapeada para o modelo relacional e discuta quaisquer mapeamentos alternativos.
- 9.2. Discuta  as  op√ß√µes  para  mapear  as  constru√ß√µes do modelo EER para rela√ß√µes.

## Exerc√≠cios

- 9.3. Tente  mapear  o  esquema  relacional  da  Figura 6.14 em um esquema ER. Isso faz parte de um processo  conhecido  como engenharia  reversa , em que um esquema conceitual √© criado para um banco de dados implementado existente. Indique quaisquer suposi√ß√µes que voc√™ fizer.

Figura 9.8



Um esquema ER para um banco de dados MOVIMENTO\_NAVIO.

- 9.4. A Figura 9.8 mostra um esquema ER para um banco de dados que pode ser usado para registrar navios de transporte e seus locais para autoridades mar√≠timas. Mapeie esse esquema para um  esquema  relacional  e  especifique  todas  as chaves prim√°rias e estrangeiras.
- 9.5. Mapeie o esquema ER BANCO do Exerc√≠cio 7.23 (mostrado na Figura 7.21) em um esquema relacional. Especifique todas as chaves prim√°rias e estrangeiras. Repita para o esquema COMPANHIA
- AEREA (Figura 7.20) do Exerc√≠cio 7.19 e para os outros esquemas dos exerc√≠cios 7.16 a 7.24.
- 9.6. Mapeie os diagramas EER das figuras 8.9 e 8.12 para esquemas relacionais. Justifique sua escolha de op√ß√µes de mapeamento.
- 9.7. √â poss√≠vel mapear com sucesso um tipo de relacionamento bin√°rio M:N sem exigir uma nova rela√ß√£o? Por qu√™?
- 9.8. Considere o diagrama EER da Figura 9.9 para um revendedor de autom√≥veis.

Figura 9.9



Diagrama EER para um revendedor de autom√≥veis.

- Mapeie o esquema EER para um conjunto de rela√ß√µes. Para a generaliza√ß√£o de VEICULO para CARRO / CAMINHAOUTILITARIO / , considere as quatro op√ß√µes apresentadas na Se√ß√£o 9.2.1 e mostre o projeto de esquema relacional sob cada uma dessas op√ß√µes.
- 9.9. Usando os atributos que voc√™ forneceu para o diagrama EER do Exerc√≠cio 8.27, mapeie o esquema completo para um conjunto de rela√ß√µes. Escolha uma op√ß√£o apropriada de 8A at√© 8D, da Se√ß√£o 9.2.1, fazendo o mapeamento de generaliza√ß√µes, e defenda sua escolha.

## Exerc√≠cios de laborat√≥rio

- 9.10. Considere o projeto ER para o banco de dados UNIVERSIDADE que foi modelado usando uma ferramenta  como  ERwin  ou  Rational  Rose  no Exerc√≠cio de Laborat√≥rio 7.31. Utilizando o recurso de gera√ß√£o de esquema SQL da ferramenta de modelagem, gere o esquema SQL para um banco de dados Oracle.
- 9.11. Considere o projeto ER para o banco de dados PEDIDO\_CORREIO que  foi  modelado  usando uma ferramenta como ERwin ou Rational Rose no Exerc√≠cio de Laborat√≥rio 7.32. Utilizando o recurso  de  gera√ß√£o  de  esquema  SQL  da  ferramenta de modelagem, gere o esquema SQL para um banco de dados Oracle.
- 9.12. Considere o projeto ER para o banco de dados REVISAO\_CONFERENCIA que  foi  modelado usando uma ferramenta como ERwin ou Rational Rose no Exerc√≠cio de Laborat√≥rio 7.34. Utilizando o  recurso  de  gera√ß√£o  de  esquema  SQL  da  ferramenta de modelagem, gere o esquema SQL para um banco de dados Oracle.
- 9.13. Considere o projeto EER para o banco de dados DIARIO\_NOTAS que foi modelado usando uma ferramenta  como  ERwin  ou  Rational  Rose  no Exerc√≠cio de Laborat√≥rio 8.28. Utilizando o recurso de gera√ß√£o de esquema SQL da ferramenta de modelagem, gere o esquema SQL para um banco de dados Oracle.
- 9.14. Considere o projeto EER para o banco de dados LEILAO\_ONLINE que foi modelado usando uma ferramenta  como  ERwin  ou  Rational  Rose  no Exerc√≠cio de Laborat√≥rio 8.29. Utilizando o recurso de gera√ß√£o de esquema SQL da ferramenta de modelagem, gere o esquema SQL para um banco de dados Oracle.

## Bibliografia selecionada

- O algoritmo de mapeamento ER para relacional original foi descrito no artigo cl√°ssico de Chen (1976), que apresentou o modelo ER original. Batini et al. (1992) discutem uma s√©rie de algoritmos de mapeamento de modelos ER e EER para modelos legados, e vice-versa.



## Metodologia pr√°tica de projeto de banco de dados e uso de diagramas UML

N este cap√≠tulo, sa√≠mos dos princ√≠pios de projeto de banco de dados apresentados nos cap√≠tulos 7 a 9 para examinar alguns de seus aspectos mais pr√°ticos. J√° descrevemos o material relevante ao projeto dos bancos de dados atuais para aplica√ß√µes pr√°ticas do mundo real. Esse material inclui os cap√≠tulos 7 e 8, sobre modelagem conceitual do banco de dados; os cap√≠tulos 3 a 6, sobre o modelo relacional, a linguagem SQL e √°lgebra e c√°lculo relacional; e o Cap√≠tulo 9,  sobre  mapeamento  de  um  esquema  ER  ou  EER conceitual  de  alto  n√≠vel  para  um  esquema  relacional. Apresentaremos outros materiais relevantes em cap√≠tulos posteriores, incluindo uma vis√£o geral das t√©cnicas de programa√ß√£o para os sistemas relacionais (SGBDRs) nos cap√≠tulos 13 e 14, e a teoria de depend√™ncia de dados e algoritmos de normaliza√ß√£o relacional nos cap√≠tulos 15 e 16.

entre  muitos  outros.  Nosso  objetivo  neste  cap√≠tulo n√£o √© discutir uma metodologia espec√≠fica, mas sim o projeto de banco de dados em um contexto mais amplo, conforme realizado em grandes organiza√ß√µes para  o  projeto  e  implementa√ß√£o  de  aplica√ß√µes  que atendem a centenas ou milhares de usu√°rios.

A atividade geral de projeto de banco de dados precisa passar por um processo sistem√°tico chamado metodologia de projeto , seja o banco de dados alvo gerenciado  por  um  SGBDR,  um  sistema  de  gerenciamento de banco de dados de objeto (SGBDO, ver Cap√≠tulo 11), um sistema de gerenciamento de banco de dados objeto-relacional (SGBDOR, ver Cap√≠tulo 11) ou  algum  outro  tipo  de  sistema  de  gerenciamento de banco de dados. Diversas metodologias de projeto s√£o fornecidas nas ferramentas de projeto de banco de  dados  atualmente  fornecidas  pelos  vendedores. Ferramentas populares incluem o Oracle Designer e produtos relacionados no Oracle Developer Suite, da Oracle;  ERwin  e  produtos  relacionados  de  CA, PowerBuilder e PowerDesigner, da Sybase; e ER/Studio e produtos relacionados da Embarcadero Technologies,

Geralmente,  o  projeto  de  pequenos  bancos  de dados com cerca de 20 usu√°rios n√£o precisa ser muito  complicado. Contudo, para bancos de dados de tamanho m√©dio ou grande, que servem a v√°rios grupos de aplica√ß√µes diversificadas, cada uma com dezenas ou centenas de usu√°rios, um enfoque sistem√°tico para a atividade geral de projeto de banco de dados torna-se necess√°rio. O simples tamanho de um banco de dados preenchido n√£o reflete a complexidade do projeto; √© o esquema dele que √© o foco mais importante do projeto. Qualquer banco de dados com um esquema que inclua mais de 20 tipos de entidade e um n√∫mero semelhante de tipos de relacionamento requer uma metodologia de projeto cuidadosa.

Ao usar  o  termo banco  de  dados  grande para bancos de dados com v√°rias dezenas de gigabytes de dados e um esquema com mais de 30 ou 40 tipos de entidade distintos, podemos cobrir uma grande gama de bancos de dados usados no governo, na ind√∫stria e em institui√ß√µes financeiras e comerciais. Ind√∫strias do setor de servi√ßos, incluindo bancos, hot√©is, linhas a√©reas,  seguro,  concession√°rias de servi√ßos p√∫blicos e comunica√ß√µes, utilizam bancos de dados para suas opera√ß√µes di√°rias, 24 horas por dia, 7 dias por semana - conhecido na ind√∫stria como opera√ß√µes 24 por 7 . Os sistemas de aplica√ß√£o para esses bancos de dados s√£o chamados de sistemas de processamento

de transa√ß√£o , por causa do grande volume e velocidade  de  transa√ß√£o  exigidos.  Neste  cap√≠tulo,  vamos nos concentrar no projeto para bancos de dados em escala m√©dia e grande, em que o processamento de transa√ß√£o domina.

Este cap√≠tulo tem uma s√©rie de objetivos. A Se√ß√£o 10.1 discute o ciclo de vida do sistema de informa√ß√£o dentro das organiza√ß√µes com uma √™nfase particular no sistema de banco de dados. A Se√ß√£o 10.2 destaca as fases de uma metodologia de projeto de banco de dados dentro do contexto organizacional. A Se√ß√£o 10.3 introduz alguns tipos de diagramas UML e oferece detalhes sobre as nota√ß√µes que s√£o particularmente √∫teis na coleta de requisitos e realiza√ß√£o do projeto conceitual e l√≥gico dos bancos de dados. Apresentamos um exemplo parcial ilustrando o projeto de um banco de dados de universidade. A Se√ß√£o 10.4 introduz a ferramenta de desenvolvimento de software popular, chamada Rational Rose, que usa diagramas UML como a  principal  t√©cnica  de  especifica√ß√£o.  Os  recursos  da Rational Rose espec√≠ficos √† modelagem de requisitos e projeto de esquema de banco de dados s√£o destacados. A Se√ß√£o 10.5 discute rapidamente as ferramentas de projeto de banco de dados automatizadas. No final do cap√≠tulo h√° um resumo.

## 10.1 O papel dos sistemas de informa√ß√£o nas organiza√ß√µes

## 10.1.1 O contexto organizacional para o uso de sistemas de banco de dados

Os sistemas de banco de dados t√™m se tornado uma parte dos sistemas de informa√ß√£o de muitas organiza√ß√µes. Historicamente, os sistemas de informa√ß√£o eram dominados por sistemas de arquivos na d√©cada de 1960, mas, desde o in√≠cio dos anos 1970 as organiza√ß√µes passaram para sistemas de gerenciamento de banco de dados (SGBDs) de maneira gradual. Para acomodar os SGBDs, muitas organiza√ß√µes criaram o cargo de administrador de banco de dados (DBA, do ingl√™s database administrator ) e departamentos de administra√ß√£o de banco de dados para supervisionar e controlar as atividades de seu ciclo de vida. De modo semelhante, os departamentos de tecnologia da informa√ß√£o (TI) e gest√£o de recursos de informa√ß√£o (GRI) t√™m sido reconhecidos por grandes organiza√ß√µes como sendo fundamentais para o gerenciamento comercial bem-sucedido pelos seguintes motivos:

- ¬Ñ Os dados s√£o considerados um recurso corporativo, e seu gerenciamento e controle, s√£o considerados centrais para o trabalho eficaz da organiza√ß√£o.
- ¬Ñ Mais  fun√ß√µes  nas  organiza√ß√µes  s√£o  computadorizadas,  aumentando  a  necessidade  de manter grande volume de dados dispon√≠veis em um estado atualizado a cada minuto.
- ¬Ñ √Ä medida que a complexidade dos dados e aplica√ß√µes  cresce,  relacionamentos  complexos  entre  os  dados  precisam  ser  modelados e mantidos.
- ¬Ñ Existe uma tend√™ncia para a consolida√ß√£o de recursos de informa√ß√£o em muitas organiza√ß√µes.
- ¬Ñ Muitas  organiza√ß√µes  est√£o  reduzindo  seus custos  de  pessoal,  permitindo  que  os  usu√°rios  finais  realizem  transa√ß√µes  de  neg√≥cios. Isso √© evidente em servi√ßos de viagem, servi√ßos financeiros, educa√ß√£o superior, governo e muitos outros tipos de servi√ßos. Essa tend√™ncia  foi  observada desde cedo por pontos de venda de varejo on-line e com√©rcio eletr√¥nico da empresa ao cliente, como eBay e Amazon. com. Nessas organiza√ß√µes, um banco de dados operacional publicamente acess√≠vel e atualiz√°vel precisa ser projetado e se tornar dispon√≠vel para as transa√ß√µes do cliente.

Muitas capacidades fornecidas pelos sistemas de banco de dados as tornaram componentes integrais nos sistemas de informa√ß√£o baseados em computador. A seguir est√£o alguns dos principais recursos que eles oferecem:

- ¬Ñ Integra√ß√£o  de  dados  em  v√°rias  aplica√ß√µes  a um √∫nico banco de dados.
- ¬Ñ Suporte  para  o  desenvolvimento  de  novas aplica√ß√µes em pouco tempo, usando linguagens de alto n√≠vel, como a SQL.
- ¬Ñ Fornecimento de suporte para acesso casual para  navega√ß√£o  e  consulta  por  gerentes  enquanto oferece suporte para o processamento principal de transa√ß√£o em n√≠vel de produ√ß√£o para os clientes.

Desde o in√≠cio da d√©cada de 1970 at√© meados dos anos 1980, houve uma mudan√ßa na cria√ß√£o de grandes reposit√≥rios centralizados de dados gerenciados por um √∫nico SGBD. Desde ent√£o, a tend√™ncia tem sido a utiliza√ß√£o de sistemas distribu√≠dos, devido aos seguintes desenvolvimentos:

- 1. Computadores  pessoais  e  produtos  de  software para  sistema de banco de dados, como Excel, Visual FoxPro, Access (da Microsoft) e  SQL  Anywhere  (da  Sybase),  e  produtos de  dom√≠nio  p√∫blico,  como  MySQL  e  PostgreSQL, est√£o sendo bastante utilizados por usu√°rios que  anteriormente pertenciam  √† categoria de usu√°rios de banco de dados ca-

suais  e  ocasionais.  Muitos  administradores, secret√°rias, engenheiros, cientistas, arquitetos e  alunos  pertencem  a  essa  categoria.  Como resultado, a pr√°tica de cria√ß√£o de bancos de dados pessoais est√° ganhando popularidade. √Äs vezes, √© poss√≠vel conter uma c√≥pia de parte de  um banco de dados grande de um computador mainframe ou um servidor de banco de dados, trabalhar nela de uma esta√ß√£o de  trabalho  pessoal  e  depois  restaur√°-la  no mainframe. De modo semelhante, os usu√°rios podem projetar e criar os pr√≥prios bancos de dados e depois mescl√°-los em um maior.

- 2. O advento dos SGBDs distribu√≠dos e cliente-servidor  (ver  Cap√≠tulo  25)  est√°  abrindo  a op√ß√£o de distribuir o banco de dados por v√°rios sistemas de computa√ß√£o, para melhorar o  controle  local  e  agilizar  o  processamento local.  Ao  mesmo  tempo,  os  usu√°rios  locais podem acessar dados remotos usando as facilidades fornecidas pelo SGBD como um cliente, ou pela Web. Ferramentas de desenvolvimento  de  aplica√ß√£o,  como  PowerBuilder  e PowerDesigner (da Sybase) e OracleDesigner e  Oracle  Developer Suite (da Oracle), est√£o sendo usadas com facilidades embutidas para ligar aplica√ß√µes a v√°rios servidores de banco de dados de back-end.
- 3. Muitas organiza√ß√µes agora utilizam sistemas de dicion√°rio de dados ou reposit√≥rios de informa√ß√µes , que s√£o miniSGBDs que gerenciam metadados - ou seja, dados que descrevem a estrutura, as restri√ß√µes, as aplica√ß√µes, as autoriza√ß√µes, os usu√°rios do banco de dados, e assim por diante. Estes normalmente s√£o usados como uma ferramenta essencial para gerenciamento de recursos de informa√ß√£o. Um sistema √∫til de dicion√°rio de dados deve armazenar e gerenciar os seguintes tipos de informa√ß√£o:
- a. Descri√ß√µes  dos  esquemas  do  sistema  de banco de dados.
- b. Informa√ß√µes  detalhadas  sobre  o  projeto f√≠sico do banco de dados, como estruturas de armazenamento, caminhos de acesso e tamanhos de arquivo e registro.
- c. Descri√ß√µes dos tipos de usu√°rios do banco  de  dados,  suas  responsabilidades  e seus direitos de acesso.
- d. Descri√ß√µes  de  alto  n√≠vel  das  transa√ß√µes  e aplica√ß√µes de banco de dados e dos relacionamentos dos usu√°rios com as transa√ß√µes.
- e. O relacionamento entre as transa√ß√µes de banco  de  dados  e  os  itens  de  dados  re-
- ferenciados por elas. Isso √© √∫til para determinar  quais  transa√ß√µes  s√£o  afetadas quando  certas  defini√ß√µes  de  dados  s√£o alteradas.
- f. Uso estat√≠stico como frequ√™ncias de consultas,  transa√ß√µes  e  contadores  de  acesso para diferentes partes do banco de dados.
- g. A hist√≥ria de quaisquer mudan√ßas feitas no banco de dados e nas aplica√ß√µes, e a documenta√ß√£o  que  descreve  os  motivos para essas mudan√ßas. Isso √†s vezes √© conhecido como proced√™ncia dos dados .

Esses  metadados  est√£o  dispon√≠veis  aos  DBAs, projetistas e usu√°rios autorizados como documenta√ß√£o on-line do sistema. Isso melhora o controle dos DBAs sobre o sistema de informa√ß√£o, bem como seu entendimento e uso pelos usu√°rios. O advento da tecnologia de data warehousing (ver Cap√≠tulo 29) destacou a import√¢ncia dos metadados.

Ao projetar sistemas de processamento de transa√ß√£o de alto desempenho, que exigem opera√ß√£o cont√≠nua 24 horas por dia, o desempenho torna-se cr√≠tico. Esses bancos de dados com frequ√™ncia s√£o acessados por centenas ou milhares de transa√ß√µes por minuto, de  computadores remotos e terminais locais. O desempenho da transa√ß√£o, em rela√ß√£o ao n√∫mero m√©dio de transa√ß√µes por minuto e o tempo de resposta m√©dio e m√°ximo da transa√ß√£o, √© essencial. Um projeto f√≠sico  de  banco  de  dados  cuidadoso,  que  atende  √†s necessidades de processamento de transa√ß√£o da organiza√ß√£o, √© uma obriga√ß√£o em tais sistemas.

Algumas  organiza√ß√µes  t√™m  comprometido  seu gerenciamento  de  recursos  de  informa√ß√£o  a  certos produtos de SGBD e dicion√°rio de dados. Seu investimento no projeto e implementa√ß√£o de sistemas grandes e complexos torna dif√≠cil para elas mudarem para produtos de SGBD mais novos, o que significa que as organiza√ß√µes tornaram-se presas a seu sistema atual. Com rela√ß√£o a tais bancos de dados grandes e complexos, n√£o podemos enfatizar de maneira excessiva a import√¢ncia de um projeto cuidadoso, que leve em conta a necessidade de poss√≠veis modifica√ß√µes do sistema chamadas de ajuste - para responder √† mudan√ßa de requisitos.  Discutiremos  o  ajuste,  juntamente  com  a otimiza√ß√£o da consulta, no Cap√≠tulo 21. O custo pode ser muito alto se um sistema grande e complexo n√£o puder evoluir, e torna-se necess√°rio migrar para outros produtos de SGBD e reprojetar o sistema inteiro.

## 10.1.2 O ciclo de vida do sistema de informa√ß√£o

Em uma grande organiza√ß√£o, o sistema de banco de dados costuma fazer parte de um sistema de informa√ß√£o  SI ( ), que inclui todos os recursos que est√£o

envolvidos na cole√ß√£o, gerenciamento, uso e dissemina√ß√£o dos recursos de informa√ß√£o da organiza√ß√£o. Em  um  ambiente  computadorizado,  esses  recursos incluem os pr√≥prios dados, o software de SGBD, o hardware do sistema de computa√ß√£o e o meio de armazenamento, o pessoal que usa e gerencia os dados (DBA, usu√°rios finais, e assim por diante), os programas de aplica√ß√£o (software) que acessam e atualizam os dados, e os programadores que desenvolvem essas aplica√ß√µes. Assim, o sistema de banco de dados √© parte de um sistema de informa√ß√£o organizacional muito maior.

Nesta se√ß√£o, examinamos o ciclo de vida t√≠pico de um sistema de informa√ß√£o e como o sistema de banco de dados se encaixa nele. O ciclo de vida do sistema de informa√ß√£o tem sido chamado de ciclo de vida macro , enquanto o ciclo de vida do sistema de banco de dados tem sido chamado de ciclo de vida micro . A distin√ß√£o entre eles est√° se tornando menos pronunciada para os sistemas de informa√ß√£o em que os bancos de dados s√£o um componente essencialmente importante. O ciclo de vida macro normalmente inclui as seguintes fases:

- 1. An√°lise  de  viabilidade. Essa  fase  refere-se  a analisar √°reas de aplica√ß√£o em potencial, identificar economias da coleta e dissemina√ß√£o de informa√ß√µes,  realizar  estudos  preliminares  de custo-benef√≠cio, determinar a complexidade de dados e processos, e estabelecer prioridades entre as aplica√ß√µes.
- 2. Levantamento e an√°lise de requisitos. Os requisitos detalhados s√£o levantados pela intera√ß√£o com os usu√°rios em potencial e grupos de usu√°rios, para identificar seus problemas e necessidades em particular. Procedimentos de depend√™ncias entre aplica√ß√µes, comunica√ß√£o e relat√≥rio s√£o identificados.
- 3. Projeto. Essa fase tem dois aspectos: o projeto do sistema de banco de dados e o projeto dos sistemas de aplica√ß√£o (programas) que usam e processam o banco de dados por meio de recupera√ß√µes e atualiza√ß√µes.
- 4. Implementa√ß√£o. O  sistema  de  informa√ß√£o  √© implementado, o banco de dados √© carregado e as transa√ß√µes deste s√£o implementadas e testadas.
- 5. Valida√ß√£o e teste de aceita√ß√£o. A aceitabilidade do sistema em atender aos requisitos dos usu√°rios e crit√©rios de desempenho √© validada. O sistema √© testado contra os crit√©rios de desempenho  e  especifica√ß√µes  de  comportamento.
- 6. Implanta√ß√£o,  opera√ß√£o  e  manuten√ß√£o. Isso pode ser precedido pela convers√£o de usu√°rios de um sistema mais antigo, bem como pelo treinamento  do  usu√°rio.  A  fase  operacional come√ßa quando todas as fun√ß√µes do sistema est√£o em funcionamento e foram validadas. √Ä  medida  que  surgem  novos  requisitos  ou aplica√ß√µes, eles passam pelas fases anteriores at√©  que  sejam  validados  e  incorporados  ao sistema.  O  monitoramento  do  desempenho do sistema e sua manuten√ß√£o s√£o atividades importantes durante a fase operacional.

## 10.1.3 O ciclo de vida do sistema de aplica√ß√£o de banco de dados

As atividades relacionadas ao ciclo de vida micro , que focalizam o sistema de aplica√ß√£o de banco de dados, incluem:

- 1. Defini√ß√£o do sistema. O escopo do sistema de banco de dados, seus usu√°rios e suas aplica√ß√µes s√£o definidos. As interfaces para diversas categorias de usu√°rios, as restri√ß√µes do tempo de  resposta  e  as  necessidades  de  armazenamento e processamento s√£o identificadas.
- 2. Projeto do banco de dados. Um projeto l√≥gico e f√≠sico completo do sistema de banco de dados no SGBD escolhido √© preparado.
- 3. Implementa√ß√£o do banco de dados. Isso compreende  o  processo  de  especificar  as  defini√ß√µes de banco de dados conceituais, externas e internas, criar os arquivos de banco de dados (vazios) e implementar as aplica√ß√µes de software.
- 4. Carga  ou  convers√£o  de  dados. O  banco  de dados √© preenchido ou pela carga dos dados diretamente  ou  pela  convers√£o  de  arquivos existentes para o formato do sistema de banco de dados.
- 5. Convers√£o  de  aplica√ß√£o. Quaisquer  aplica√ß√µes de software de um sistema anterior s√£o convertidas para o novo sistema.
- 6. Teste e valida√ß√£o. O novo sistema √© testado e validado. O teste e a valida√ß√£o dos programas de aplica√ß√£o podem ser um processo bastante  complicado,  e  as  t√©cnicas  empregadas normalmente  s√£o  abordadas  em  cursos  de engenharia de software. Existem ferramentas automatizadas que auxiliam nesse processo, mas uma discuss√£o acerca delas est√° fora do escopo deste livro-texto.

- 7. Opera√ß√£o. O sistema de banco de dados e suas aplica√ß√µes s√£o colocados em opera√ß√£o. Normalmente, os sistemas antigos e os novos s√£o operados em paralelo por um per√≠odo de tempo.
- 8. Monitoramento  e  manuten√ß√£o. Durante  a fase operacional, o sistema √© constantemente monitorado e mantido. O crescimento e a expans√£o podem ocorrer no conte√∫do de dados e nas aplica√ß√µes de software. Importantes modifica√ß√µes e reorganiza√ß√µes podem ser necess√°rias de tempos em tempos.

ser subestimado. Com frequ√™ncia, existe um retorno entre as v√°rias etapas, pois novos requisitos surgem constantemente a cada est√°gio. A Figura 10.1 mostra o ciclo de retorno que afeta as fases de projeto conceitual e l√≥gico como resultado da implementa√ß√£o e do ajuste do sistema.

## 10.2 O projeto de banco de dados e o processo de implementa√ß√£o

As atividades 2, 3 e 4 fazem parte das fases de projeto e implementa√ß√£o do ciclo de vida macro do sistema de informa√ß√£o maior. Nossa √™nfase na Se√ß√£o 10.2 est√° nas atividades 2 e 3, que cobrem as fases de projeto e implementa√ß√£o de banco de dados. A maioria dos bancos de dados nas organiza√ß√µes passa por todas as atividades anteriores do ciclo de vida. As atividades de convers√£o (4 e 5) n√£o se aplicam quando o banco de dados e as aplica√ß√µes s√£o novos. Quando uma organiza√ß√£o passa de um sistema estabelecido para um novo, as atividades 4 e 5 tendem a ser muito  demoradas  e  o  esfor√ßo  para  realiz√°-las  costuma

Agora, focalizamos as atividades 2 e 3 do ciclo de vida do sistema de aplica√ß√£o de banco de dados, que s√£o seu projeto e implementa√ß√£o. O problema do projeto de banco de dados pode ser declarado da seguinte forma:

Projetar a estrutura l√≥gica e f√≠sica de um ou mais bancos de dados para acomodar as informa√ß√µes necess√°rias dos usu√°rios em uma organiza√ß√£o para um conjunto definido de aplica√ß√µes.

Os objetivos do projeto de banco de dados s√£o m√∫ltiplos:

- ¬Ñ Satisfazer os requisitos de conte√∫do de informa√ß√£o dos usu√°rios e aplica√ß√µes especificadas.

Figura 10.1



Fases de projeto e implementa√ß√£o para grandes bancos de dados.

- ¬Ñ Oferecer  uma  estrutura√ß√£o  da  informa√ß√£o que seja natural e f√°cil de entender.
- ¬Ñ Dar suporte aos requisitos de processamento e quaisquer objetivos de desempenho, como tempo de resposta, tempo de processamento e espa√ßo de armazenamento.

Esses  objetivos  s√£o  muito  dif√≠ceis  de  realizar  e medir, e envolvem uma escolha inerente: se algu√©m tentar obter mais naturalidade e compreensibilidade do modelo, isso pode custar o desempenho. O problema √© agravado porque o processo de projeto de banco de dados normalmente come√ßa com requisitos informais e incompletos. Ao contr√°rio, o resultado da atividade de projeto √© um esquema rigidamente definido,  que  n√£o  pode  ser  facilmente  modificado quando o banco de dados √© implementado. Podemos identificar seis fases principais do processo geral de projeto e implementa√ß√£o do banco de dados:

- 1. Levantamento e an√°lise de requisitos.
- 2. Projeto conceitual do banco de dados.
- 3. Escolha de um SGBD.
- 4. Mapeamento  do  modelo  de  dados  (tamb√©m chamado de projeto l√≥gico do banco de dados ).
- 5. Projeto f√≠sico do banco de dados.
- 6. Implementa√ß√£o e ajuste do sistema de banco de dados.
- O  processo  de  projeto  consiste  em  duas  atividades  paralelas,  conforme  ilustra  a  Figura  10.1.  A primeira  atividade  envolve  o  projeto  do conte√∫do de dados, estrutura e restri√ß√µes do banco de dados; a segunda relaciona-se ao projeto das aplica√ß√µes de banco de dados .  Para  manter a figura simples, evitamos mostrar a maioria das intera√ß√µes entre esses lados, mas as duas atividades est√£o intimamente interligadas. Por exemplo, analisando as aplica√ß√µes de banco de dados, podemos identificar itens de dados que ser√£o armazenados nele. Al√©m disso, a fase de projeto f√≠sico do banco de dados, durante a qual escolhemos as estruturas de armazenamento e os caminhos de acesso dos arquivos de banco de dados, depende das aplica√ß√µes que usar√£o esses arquivos para consulta e atualiza√ß√£o. Por outro lado, costumamos especificar o projeto das aplica√ß√µes de banco de dados referindo-nos √†s constru√ß√µes do seu esquema, as quais s√£o especificadas durante a primeira atividade. Claramente,  essas  duas  atividades  influenciam  bastante  uma √† outra. De maneira tradicional, as metodologias de projeto de banco de dados t√™m focalizado  principalmente  a  primeira  dessas  atividades, enquanto o projeto de software tem focalizado a segunda; isso pode ser chamado de projeto controlado por dados versus controlado por processo . Agora, √©

reconhecido por projetistas de banco de dados e engenheiros de software que as duas atividades devem prosseguir lado a lado, e as ferramentas de projeto as combinam cada vez mais.

As seis fases j√° mencionadas em geral n√£o prosseguem estritamente em sequ√™ncia. Em muitos casos podemos ter de modificar o projeto de uma fase mais antiga durante outra mais recente. Esses ciclos de retorno entre as fases - e tamb√©m dentro delas - s√£o comuns. Mostramos apenas alguns dos ciclos de retorno na Figura 10.1, mas existem muitos outros entre v√°rias fases. Tamb√©m mostramos alguma intera√ß√£o entre os lados dos dados e do processo da figura; na realidade, h√° mais intera√ß√µes. A Fase 1 na Figura 10.1 envolve o levantamento de informa√ß√µes sobre o uso intencionado do banco de dados, e a Fase 6 trata da implementa√ß√£o e do reprojeto do banco de dados. A parte central do processo de projeto de banco de dados compreende as fases 2, 4 e 5. Vamos resumir essas fases:

- ¬Ñ Projeto conceitual do banco de dados (Fase 2). O  objetivo  dessa  fase  √©  produzir  um  esquema conceitual para o banco de dados que seja  independente  de  um  SGBD  espec√≠fico. Normalmente, usamos um modelo de dados de  alto  n√≠vel,  como  o  modelo  ER  ou  EER (ver cap√≠tulos 7 e 8), durante essa fase. Al√©m disso,  especificamos  o  m√°ximo  poss√≠vel  das aplica√ß√µes ou transa√ß√µes de banco de dados conhecidas,  usando  uma  nota√ß√£o  que  seja independente  de  qualquer  SGBD  espec√≠fico. Em geral, a escolha do SGBD j√° √© feita para a organiza√ß√£o; a inten√ß√£o do projeto conceitual inda √© mant√™-lo o mais livre poss√≠vel das cona sidera√ß√µes de implementa√ß√£o.
- ¬Ñ Mapeamento do modelo de dados (Fase 4). Durante  essa  fase,  que  tamb√©m  √©  chamada projeto l√≥gico do banco de dados, mapeamos (ou transformamos ) o esquema conceitual do modelo de dados de alto n√≠vel usado na Fase 2 para o modelo de dados do SGBD escolhido. Podemos come√ßar essa fase ap√≥s escolhermos um tipo espec√≠fico de SGBD - por exemplo, se  decidirmos  usar  algum  SGBD  relacional, mas ainda n√£o tivermos decidido sobre qual deles em particular. Chamamos este de projeto l√≥gico independente do sistema (mas dependente do modelo de dados ). Em rela√ß√£o √† arquitetura de SGBD em tr√™s n√≠veis, discutida no Cap√≠tulo 2, o resultado dessa fase √© um esquema conceitual no modelo de dados escolhido. Al√©m disso, o projeto dos esquemas externos (vis√µes)  para  aplica√ß√µes  espec√≠ficas normalmente √© elaborado durante essa fase.

- ¬Ñ Projeto  f√≠sico  do  banco  de  dados  (Fase  5). Durante essa fase, projetamos as especifica√ß√µes para o banco de dados armazenado em mat√©ria  das  estruturas  f√≠sicas  de  armazenamento de arquivo, posicionamento de registros e √≠ndices. Isso corresponde ao projeto do esquema interno na terminologia da arquitetura de SGBD em tr√™s n√≠veis.
- ¬Ñ Implementa√ß√£o  e  ajuste  do  sistema  de  banco  de  dados  (Fase  6). Durante  essa  fase,  o banco de dados e os programas de aplica√ß√£o s√£o implementados, testados e, por fim, implantados  para  servi√ßo.  Diversas  transa√ß√µes e  aplica√ß√µes  s√£o  testadas  individualmente e, depois,  em  conjunto  umas  com  as  outras. Isso normalmente revela oportunidades para as mudan√ßas f√≠sicas no projeto, indexa√ß√£o de dados,  reorganiza√ß√£o  e  diferente  posicionamento de dados - uma atividade conhecida como ajuste do banco de dados .  O  ajuste  √© uma atividade cont√≠nua - uma parte da manuten√ß√£o do sistema que continua pelo ciclo de vida de um banco de dados, enquanto o banco  de  dados  e  as  aplica√ß√µes  continuam evoluindo e os problemas de desempenho s√£o detectados.

Vamos discutir cada uma das seis fases do projeto de banco de dados com mais detalhes nas pr√≥ximas subse√ß√µes.

## 10.2.1 ase 1: levantamento e an√°lise de F requisitos 1

Antes de podermos efetivamente projetar um banco de dados, devemos conhecer e analisar as expectativas dos usu√°rios e os usos intencionados do banco de dados com o m√°ximo de detalhe poss√≠vel. Esse processo √© chamado de levantamento e an√°lise de requisitos . Para especificar os requisitos, primeiro identificamos as outras partes do sistema de informa√ß√£o que interagir√£o com o sistema de banco de dados. Estas incluem usu√°rios e aplica√ß√µes novas e existentes, cujos requisitos s√£o ent√£o coletados e analisados. Normalmente, as seguintes atividades fazem parte dessa fase:

- 1. As principais √°reas de aplica√ß√£o e grupos de usu√°rio que utilizar√£o o banco de dados ou cujo trabalho ser√° afetado por ele s√£o identificados. Os principais indiv√≠duos e comit√™s dentro  de  cada  grupo  s√£o  escolhidos  para executar etapas subsequentes do levantamento e especifica√ß√£o de requisitos.

1 Uma parte desta se√ß√£o teve a contribui√ß√£o de Colin Potts.

- 2. A documenta√ß√£o existente referente √†s aplica√ß√µes  √©  estudada  e  analisada.  Outra  documenta√ß√£o  -  manuais  de  pol√≠tica,  formul√°rios, relat√≥rios e gr√°ficos de organiza√ß√£o - √© revista  para  determinar  se  tem  qualquer  influ√™ncia sobre o processo de levantamento e especifica√ß√£o de requisitos.
- 3. O ambiente operacional atual e o uso planejado da informa√ß√£o s√£o estudados. Isso inclui a  an√°lise  dos  tipos  de  transa√ß√µes  e  sua  frequ√™ncia,  bem  como o fluxo de informa√ß√µes dentro do sistema. Caracter√≠sticas geogr√°ficas com rela√ß√£o a usu√°rios, origem de transa√ß√µes, destino de relat√≥rios, e assim por diante, s√£o estudados. Os dados de entrada e sa√≠da para as transa√ß√µes s√£o especificados.
- 4. Respostas  escritas  aos  conjuntos  de  perguntas √†s vezes s√£o coletadas de usu√°rios de banco de dados em potencial ou grupos de usu√°rios. Essas perguntas envolvem as prioridades dos usu√°rios e a import√¢ncia que eles d√£o a v√°rias aplica√ß√µes. Os principais indiv√≠duos podem ser entrevistados para ajudar na avalia√ß√£o do valor da informa√ß√£o e no estabelecimento de prioridades.

A an√°lise de requisitos √© executada para os usu√°rios finais, ou clientes , do sistema de banco de dados, por uma equipe de analistas de sistemas ou especialistas em requisitos. √â prov√°vel que os requisitos iniciais  sejam  informais,  incompletos,  inconsistentes  e parcialmente  incorretos.  Portanto,  muito  trabalho precisa ser feito para transformar esses requisitos iniciais em uma especifica√ß√£o da aplica√ß√£o, que pode ser usada por desenvolvedores e testadores como ponto de partida para escrever a implementa√ß√£o e os casos de teste.  Como  os  requisitos  refletem  o  conhecimento inicial de um sistema que ainda n√£o existe, eles inevitavelmente mudar√£o. Portanto, √© importante usar t√©cnicas que ajudem os clientes a convergir rapidamente nos requisitos da implementa√ß√£o.

Existe evid√™ncia de que a participa√ß√£o do cliente no processo de desenvolvimento aumenta sua satisfa√ß√£o com o sistema entregue. Por esse motivo, muitos profissionais usam reuni√µes e workshops envolvendo todos os participantes. Uma metodologia para detalhar  os  requisitos  iniciais  do  sistema  √©  chamada  de Joint  Application  Design  (JAD).  Mais  recentemente, foram desenvolvidas t√©cnicas, como o Projeto Contextual (Contextual Design), que envolvem projetistas inseridos no local de trabalho em que a aplica√ß√£o dever√°

ser usada. Para ajudar os representantes do cliente a entenderem melhor o sistema proposto, √© comum percorrer o fluxo de trabalho, os cen√°rios de transa√ß√£o ou criar um prot√≥tipo r√°pido da aplica√ß√£o.

Os modos anteriores ajudam a estruturar e detalhar requisitos, mas ainda os deixam em um estado informal. Para transformar os requisitos em uma representa√ß√£o mais bem estruturada, as t√©cnicas de especifica√ß√£o de requisitos s√£o usadas. Estes incluem an√°lise orientada a objeto (AOO), diagramas de fluxo de dados (DFD) e o detalhamento dos objetivos da aplica√ß√£o. Esses m√©todos usam t√©cnicas diagram√°ticas para organizar e apresentar requisitos de processamento de informa√ß√£o. A documenta√ß√£o adicional, na forma de texto, tabelas, gr√°ficos e requisitos de decis√£o, costuma acompanhar os diagramas. Existem t√©cnicas que produzem uma especifica√ß√£o formal que pode ser verificada matematicamente pela consist√™ncia e an√°lise simb√≥lica hipot√©tica . Esses m√©todos podem se tornar padr√£o no futuro para as partes dos sistemas de informa√ß√£o que atendem √†s fun√ß√µes de miss√£o cr√≠tica e que, assim, precisam atuar conforme o planejado. Os m√©todos de especifica√ß√£o formal baseados em modelo, dos quais a nota√ß√£o e metodologia Z √© um exemplo proeminente, podem ser considerados extens√µes do modelo ER e, portanto, s√£o os mais aplic√°veis ao projeto do sistema de informa√ß√£o.

Algumas  t√©cnicas  auxiliadas  por  computador  chamadas  de  ferramentas Upper  CASE -  foram propostas para ajudar a verificar a consist√™ncia e a integralidade  das  especifica√ß√µes,  que  normalmente s√£o armazenadas em um √∫nico reposit√≥rio e podem ser exibidas e atualizadas enquanto o projeto prossegue. Outras ferramentas s√£o usadas para rastrear as liga√ß√µes entre requisitos e outras entidades de projeto, como m√≥dulos de c√≥digo e casos de teste. Esses bancos de dados de rastreabilidade s√£o especialmente importantes em conjunto com os procedimentos impostos de gerenciamento de mudan√ßa para sistemas onde os requisitos mudam com frequ√™ncia. Eles tamb√©m s√£o usados em projetos contratuais onde a organiza√ß√£o de desenvolvimento precisa fornecer evid√™ncia documental ao cliente de que todos os requisitos foram implementados.

corrigir um erro significativo quer dizer que o sistema n√£o satisfar√° o cliente e pode nem sequer ser utilizado. O levantamento e a an√°lise de requisitos s√£o assunto de livros inteiros.

## 10.2.2 ase 2: projeto conceitual do F banco de dados

A segunda fase  do  projeto  de  banco  de  dados envolve duas atividades paralelas. 2  A primeira atividade, o projeto do esquema conceitual , examina os requisitos  de  dados  resultantes  da  Fase  1  e  produz um esquema conceitual do banco de dados. A segunda atividade, o projeto de transa√ß√£o e aplica√ß√£o , examina as aplica√ß√µes de banco de dados analisadas na Fase 1 e produz especifica√ß√µes de alto n√≠vel para essas aplica√ß√µes.

Fase 2a: Projeto do esquema conceitual. O esquema conceitual produzido por essa fase normalmente √© contido em um modelo de dados de alto n√≠vel independente do SGBD pelas seguintes raz√µes:

- 1. O objetivo do projeto do esquema conceitual √© um conhecimento completo da estrutura do banco de dados, do significado (sem√¢ntica), dos  inter-relacionamentos  e  das  restri√ß√µes. Isso  √©  mais  bem  alcan√ßado  independentemente de um SGBD espec√≠fico, porque cada SGBD com frequ√™ncia  possui  particularidades e restri√ß√µes que n√£o dever√£o influenciar o projeto do esquema conceitual.
- 2. O  esquema  conceitual  √©  valioso  como  uma descri√ß√£o  est√°vel do  conte√∫do  de  banco  de dados. A escolha do SGBD e, mais tarde, as decis√µes de projeto podem mudar sem alterar o esquema conceitual independente do SGBD.
- 3. Um bom conhecimento do esquema conceitual √© crucial para os usu√°rios de banco de dados e projetistas de aplica√ß√£o. O uso de um modelo de dados de alto n√≠vel que √© mais expressivo e geral do que os modelos de dados dos SGBDs individuais √©, portanto, muito importante.

A fase  de  levantamento  e  an√°lise  de  requisitos pode ser bastante demorada, mas √© crucial para o sucesso do sistema de informa√ß√£o. A corre√ß√£o de um erro de requisitos √© mais dispendiosa do que a corre√ß√£o de um erro cometido durante a implementa√ß√£o, porque  os  efeitos  de  um  erro  de  requisito  normalmente  s√£o  difundidos  e,  como  resultado,  √©  preciso reimplementar  muito  mais  trabalho  adiante.  N√£o

- 4. A descri√ß√£o diagram√°tica do esquema conceitual pode servir como um ve√≠culo de comunica√ß√£o entre os usu√°rios do banco de dados, projetistas e analistas. Como os modelos de dados de alto n√≠vel  normalmente  contam  com  os  conceitos que s√£o mais f√°ceis de entender do que os modelos de dados espec√≠ficos do SGBD em n√≠vel mais baixo, ou defini√ß√µes sint√°ticas dos dados, qualquer comunica√ß√£o referente ao projeto de esquema torna-se mais exata e mais direta.

2 Essa fase do projeto √© discutida com mais detalhes nos sete primeiros cap√≠tulos de Batini et al. (1992). Resumimos essa discuss√£o aqui.

Nessa fase do projeto de banco de dados, √© importante usar um modelo de dados conceitual de alto n√≠vel com as seguintes caracter√≠sticas:

- 1. Expressividade. O modelo de dados deve ser expressivo o suficiente para distinguir diferentes tipos de dados, relacionamentos e restri√ß√µes.
- 2. Simplicidade e compreens√£o. O modelo deve ser simples o suficiente para que usu√°rios t√≠picos n√£o especialistas compreendam e usem seus conceitos.
- 3. Minimalismo. O modelo deve ter um n√∫mero pequeno de conceitos b√°sicos, que s√£o distintos e n√£o sobrepostos no significado.
- 4. Representa√ß√£o diagram√°tica. O modelo dever√° ter uma nota√ß√£o diagram√°tica para exibir um esquema conceitual que seja f√°cil de interpretar.
- 5. Formalidade. Um esquema conceitual expresso no modelo de dados deve representar uma especifica√ß√£o n√£o amb√≠gua formal dos dados. Logo, os conceitos do modelo devem ser definidos com precis√£o e sem ambiguidade.

Alguns desses requisitos - o primeiro, em particular  -  √†s  vezes  entram  em  conflito  com  os  outros requisitos. Muitos modelos conceituais de alto n√≠vel  foram  propostos  para  o  projeto  de  banco  de dados (ver a bibliografia selecionada no Cap√≠tulo 8). Na discuss√£o a seguir, usaremos a terminologia do modelo  Entidade-Relacionamento  Estendido  (EER) apresentado  no  Cap√≠tulo  8  e  assumiremos  que  ele est√° sendo usado nesta fase. O projeto do esquema conceitual,  incluindo  a  modelagem  de  dados,  est√° se tornando uma parte integral das metodologias de an√°lise e projeto orientadas a objeto. A UML possui diagramas de classes que, em grande parte, s√£o baseados em extens√µes do modelo EER.

T√©cnicas para o projeto de esquema conceitual. Para o projeto de esquema conceitual, devemos identificar os componentes b√°sicos (ou constru√ß√µes) do esquema:  os  tipos  de  entidade,  tipos  de  relacionamento e atributos. Tamb√©m devemos especificar atributos-chave,  cardinalidade  e  restri√ß√µes  de  participa√ß√£o nos relacionamentos, tipos de entidade fraca e hierarquias/reticulados de especializa√ß√£o/generaliza√ß√£o. Existem duas t√©cnicas para designar o esquema conceitual, que √© derivado dos requisitos coletados durante a Fase 1.

A primeira t√©cnica √© a t√©cnica de projeto de esquema centralizado (ou √∫nica tentativa ), em que os requisitos das diferentes aplica√ß√µes e grupos de usu√°rios da Fase 1 s√£o mesclados em um √∫nico conjunto de requisitos antes que o projeto do esquema comece. Um √∫nico esquema correspondente ao conjunto mesclado  de  requisitos  √©  ent√£o  projetado.  Quando existem muitos usu√°rios e aplica√ß√µes, mesclar todos os requisitos pode ser uma tarefa √°rdua e demorada. Sup√µe-se que uma autoridade centralizada, o DBA, seja respons√°vel por decidir como mesclar os requisitos e projetar o esquema conceitual para o banco de dados inteiro. Uma vez que o esquema conceitual esteja  projetado e finalizado, os esquemas externos para diversos grupos de usu√°rios e aplica√ß√µes podem ser especificados pelo DBA.

A segunda t√©cnica √© a t√©cnica de integra√ß√£o de vis√£o , em que os requisitos n√£o s√£o mesclados. Em vez disso, um esquema (ou vis√£o) √© projetado para cada grupo de usu√°rios ou aplica√ß√£o com base apenas nos pr√≥prios requisitos. Assim, desenvolvemos um esquema de alto n√≠vel (vis√£o) para cada grupo de usu√°rios ou aplica√ß√£o desse tipo. Durante a fase de integra√ß√£o de vis√£o subsequente, esses esquemas s√£o mesclados ou integrados em um esquema conceitual global para o banco de dados inteiro. As vis√µes individuais podem ser reconstru√≠das como esquemas externos ap√≥s a integra√ß√£o da vis√£o.

A principal diferen√ßa entre as duas t√©cnicas est√° na  maneira  e  no  est√°gio  em  que  v√°rias  vis√µes  ou requisitos dos muitos usu√°rios e aplica√ß√µes s√£o reconciliados e mesclados. Na t√©cnica centralizada, a reconcilia√ß√£o √© feita manualmente pelo DBA antes do projeto de quaisquer esquemas, e aplicada diretamente aos requisitos coletados na Fase 1. Isso coloca o peso para reconciliar as diferen√ßas e conflitos entre os grupos de usu√°rios no DBA. O problema costuma ser tratado usando consultores/especialistas em projeto externos, que aplicam seus m√©todos espec√≠ficos para resolver esses conflitos. Devido √†s dificuldades  de  gerenciar  essa  tarefa,  a  t√©cnica  de integra√ß√£o  de  vis√£o  tem  sido  proposta  como  uma alternativa.

Na t√©cnica de integra√ß√£o de vis√£o, cada grupo de usu√°rios ou aplica√ß√£o realmente projeta o pr√≥prio esquema conceitual (EER) com base em seus requisitos, com assist√™ncia do DBA. Depois, um processo de integra√ß√£o √© aplicado a esses esquemas (vis√µes) pelo DBA para formar um esquema integrado global. Embora a integra√ß√£o de vis√£o possa ser feita  manualmente, sua aplica√ß√£o em um grande banco de dados, envolvendo  dezenas  de  grupos  de  usu√°rios,  requer uma metodologia e o uso de ferramentas automatizadas. As correspond√™ncias entre os atributos, tipos de entidade e tipos de relacionamento nas diversas vis√µes precisam ser especificadas antes que a integra√ß√£o possa ser aplicada. Adicionalmente, problemas como a integra√ß√£o de vis√µes em conflito e a verifica√ß√£o da consist√™ncia das correspond√™ncias especificadas entre esquemas precisam ser tratados.

Estrat√©gias para projeto de esquema. Dado um conjunto de requisitos, seja para um √∫nico usu√°rio ou para uma grande comunidade de usu√°rios, temos de criar um esquema conceitual que satisfa√ßa tais requisitos. Existem diversas estrat√©gias para projetar tal esquema. A maioria das estrat√©gias segue uma t√©cnica incremental - ou seja, elas come√ßam com algumas constru√ß√µes de esquema importantes derivadas dos requisitos e depois modificam, detalham e constroem incrementalmente sobre elas. Agora, vamos discutir algumas dessas estrat√©gias:

- 1. Estrat√©gia de cima para baixo (top-down). Come√ßamos  com  um  esquema  contendo  abstra√ß√µes de alto n√≠vel e depois aplicamos sucessivos detalhamentos de cima para baixo. Por exemplo, podemos especificar apenas alguns tipos de entidade de alto n√≠vel e depois, √† medida que especificarmos seus atributos, dividi-los em tipos de entidade de n√≠vel inferior e especificar os relacionamentos. O processo de especializa√ß√£o para detalhar um tipo de entidade nas subclasses que ilustramos nas se√ß√µes 8.2 e 8.3 (ver figuras 8.1, 8.4 e 8.5) √© outra atividade durante a estrat√©gia de projeto de cima pra baixo.
- 2. Estrat√©gia de  baixo  para  cima  (bottom-up). Comece  com  um  esquema  contendo  abstra√ß√µes  b√°sicas  e  depois  combine  ou  acrescente algo  a  essas  abstra√ß√µes.  Por  exemplo,  podemos come√ßar com os atributos  de  banco  de dados  e  agrup√°-los  em  tipos  de  entidade  e relacionamentos. Podemos acrescentar novos relacionamentos entre os tipos de entidade √† medida que o projeto prossegue. O processo de generalizar tipos de entidades em superclasses generalizadas de n√≠vel mais alto (ver se√ß√µes 8.2 e 8.3 e Figura 8.3) √© outra atividade durante a estrat√©gia de projeto de baixo para cima.
- 3. Estrat√©gia de dentro para fora (inside-out). Esse √© um caso especial de uma estrat√©gia de cima para baixo, em que a aten√ß√£o √© focada em um conjunto central de conceitos que s√£o mais evidentes.  A  modelagem  ent√£o  se  espalha  para fora,  considerando  novos  conceitos  nas  vizinhan√ßas dos existentes. Poder√≠amos especificar alguns tipos de entidade claramente evidentes no esquema e continuar acrescentando outros tipos de entidade e relacionamentos que est√£o ligados a cada um.
- 4. Estrat√©gia mista. Em vez de seguir qualquer estrat√©gia particular por todo o projeto, os requisitos s√£o particionados de acordo com uma estrat√©gia de cima para baixo, e parte do esquema √© projetado para cada parti√ß√£o de acordo com uma estrat√©gia de baixo para cima. As diversas partes do esquema s√£o ent√£o combinadas.

As  figuras  10.2  e  10.3  ilustram  alguns  exemplos  simples  de  detalhamento  de  cima  para  baixo  e de baixo para cima, respectivamente. Um exemplo de detalhamento  de  cima  para  baixo  primitivo  √©  a  decomposi√ß√£o de um tipo de entidade em v√°rios tipos de entidade. A Figura 10.2(a) mostra uma DISCIPLINA sendo detalhada para DISCIPLINA e SEMINARIO ,  e  o relacionamento ENSINA √© dividido, da mesma forma, em ENSINA e OFERECE . A Figura 10.2(b) mostra um tipo de entidade OFERTA\_DISCIPLINA sendo detalhado para dois tipos de entidade ( DISCIPLINA   PROFESe SOR ) e um relacionamento entre eles. O detalhamento normalmente for√ßa um projetista a fazer mais perguntas e extrair mais restri√ß√µes e detalhes: por exemplo, as raz√µes de cardinalidade (min, max) entre DISCIPLINA e PROFESSOR s√£o  obtidas durante o detalhamento. A Figura 10.3(a) mostra o primitivo de detalhamento de baixo pra cima da gera√ß√£o de relacionamentos entre os tipos de entidade DOCENTE e ALUNO .  Dois relacionamentos s√£o identificados: ACONSELHA e TU-TOR\_RESPONSAVEL . O detalhamento de baixo para cima que usa a categoriza√ß√£o (tipo de uni√£o) √© ilustrado na Figura 10.3(b), onde o novo conceito de PRO-PRIETARIO\_VEICULO √© descoberto com base nos tipos de entidade existentes DOCENTE ADMINISTRATIVO , e ALUNO . Esse processo de cria√ß√£o de uma categoria e a nota√ß√£o diagram√°tica relacionada seguem o que apresentamos na Se√ß√£o 8.4.

Integra√ß√£o de esquema (vis√£o). Para grandes bancos de dados, com muitos usu√°rios e aplica√ß√µes esperadas,  pode  ser  utilizada  a  t√©cnica  de  integra√ß√£o de vis√£o do projeto de esquemas individuais para depois mescl√°-los. Como as vis√µes individuais podem ser mantidas relativamente pequenas, o projeto dos esquemas  √©  simplificado.  Por√©m,  uma  metodologia para integrar as vis√µes em um esquema de banco de dados global √© necess√°rio. A integra√ß√£o de esquema pode ser dividida nas seguintes subtarefas:

- 1. Identificar correspond√™ncias e conflitos entre os esquemas. Como os esquemas s√£o projetados individualmente, √© necess√°rio especificar constru√ß√µes nos esquemas que representam o mesmo conceito do mundo real. Essas correspond√™ncias devem ser identificadas antes que a  integra√ß√£o  possa  prosseguir.  Durante  esse processo, v√°rios tipos de conflitos entre os esquemas podem ser descobertos:
- a. Conflitos de nomes. Estes s√£o de dois tipos:  sin√¥nimos  e  hom√¥nimos.  Um sin√¥nimo ocorre  quando  dois  esquemas  utilizam diferentes nomes para descrever o mesmo  conceito.  Por  exemplo,  um  tipo de entidade CONSUMIDOR em um esquema pode descrever o mesmo conceito de um tipo  de  entidade CLIENTE em  outro

Figura 10.2



Exemplos de detalhamento de cima para baixo. (a) Gerando um novo tipo de entidade. (b) Decompondo um tipo de entidade em dois tipos de entidade e um tipo de relacionamento.

esquema.  Um hom√¥nimo ocorre  quando dois esquemas usam o mesmo nome para  descrever  diferentes  conceitos.  Por exemplo, um tipo de entidade PECA pode representar pe√ßas de computador em um esquema e pe√ßas de mob√≠lia em outro esquema, por exemplo.

- esquema representasse Peso em libras e o outro usasse quilogramas.
- b. Conflitos de tipo. O  mesmo conceito pode ser  representado em dois esquemas por diferentes  constru√ß√µes  de  modelagem. Por exemplo, o conceito de um DEPARTAMENTO pode ser um tipo de entidade em um esquema e um atributo em outro esquema.
- c. Conflitos de dom√≠nio (conjunto de valores). Um atributo pode ter diferentes dom√≠nios em dois esquemas. Por exemplo, Cpf pode ser declarado como um inteiro em um esquema e como uma cadeia de caracteres em outro. Um conflito da unidade  de  medida  poderia  ocorrer  se  um
- d. Conflitos entre restri√ß√µes. Dois esquemas podem  impor  diferentes  restri√ß√µes;  por exemplo, uma chave de um tipo de entidade pode ser diferente em cada esquema. Outro exemplo envolve diferentes restri√ß√µes  estruturais  em  um  relacionamento como ENSINA .  Um esquema pode represent√°-lo  como  1:N  (uma  disciplina  tem um professor), enquanto outro esquema o representa como M:N (uma disciplina pode ter mais de um professor).
- 2. Modificar  vis√µes  para  que  se  tornem  semelhantes. Alguns esquemas s√£o modificados de modo que sejam ajustados a outros esquemas mais parecidos. Alguns dos conflitos identificados na primeira subtarefa s√£o resolvidos durante essa etapa.
- 3. Mesclar  vis√µes. O  esquema  global  √©  criado pela mescla dos esquemas individuais. Con-

Figura 10.3



Exemplos de detalhamento de baixo para cima. (a) Descobrindo e acrescentando novos relacionamentos. (b) Descobrindo uma nova categoria (tipo de unidade) e relacionando-a.

ceitos correspondentes s√£o representados apenas uma vez no esquema global, e os mapeamentos entre as vis√µes e o esquema global s√£o especificados. Essa √© a etapa mais dif√≠cil de alcan√ßar nos bancos de dados da vida real envolvendo dezenas ou centenas de entidades e  relacionamentos. Ela envolve uma quantidade consider√°vel de interven√ß√£o humana e negocia√ß√£o  para  resolver  conflitos  e  decidir sobre as solu√ß√µes mais razo√°veis e aceit√°veis para um esquema global.

- 4. Reestruturar. Como uma √∫ltima etapa opcional,  o  esquema  global  pode  ser  analisado  e reestruturado para remover quaisquer redund√¢ncias ou complexidade desnecess√°ria.

Algumas dessas ideias s√£o ilustradas pelo exemplo  relativamente  simples  apresentado  nas  figuras 10.4 e 10.5. Na Figura 10.4, duas vis√µes s√£o mescladas para criar um banco de dados bibliogr√°fico. Du- rante a identifica√ß√£o das correspond√™ncias entre as duas vis√µes, descobrimos que PESQUISADOR e AUTOR s√£o sin√¥nimos (em se tratando desse banco de dados),  assim  como CONTRIBUIDO\_POR e ESCRI-TO\_POR . Al√©m disso, decidimos modificar a VISAO 1 a fim de incluir um ASSUNTO para ARTIGO , como mostra a Figura 10.4, para adequar-se √† VISAO 2 . A Figura 10.5 mostra o resultado da mescla de VISAO MODIFICADA 1 com  a VISAO  2 .  Generalizamos  os tipos de entidade ARTIGO e LIVRO no tipo de entidade PUBLICACAO , com seu atributo comum Titulo . Os  relacionamentos CONTRIBUIDO\_POR e ESCRI-TO\_POR s√£o mesclados, assim como os tipos de entidade PESQUISADOR   AUTOR e . O atributo Editora s√≥ se aplica ao tipo de entidade LIVRO , enquanto o atributo Tamanho e o tipo de relacionamento PUBLI-CADO\_EM s√≥ se aplicam a ARTIGO .

Esse exemplo simples ilustra a complexidade do processo de mescla e como o significado dos diversos conceitos precisa ser considerado na simplifica√ß√£o do



Vis¬™o modificada 1

Figura 10.4 Modificando vis√µes para conformidade antes da integra√ß√£o.

projeto de esquema resultante. Para projetos da vida real,  o  processo  de  integra√ß√£o  de  esquema  requer uma t√©cnica mais disciplinada e sistem√°tica. V√°rias estrat√©gias foram propostas para o processo de integra√ß√£o de vis√£o (ver Figura 10.6):

- 1. Integra√ß√£o em escala bin√°ria. Dois esquemas muito  semelhantes  s√£o  integrados  primeiro. O esquema resultante √© ent√£o integrado a outro esquema, e o processo √© repetido at√© que todos os esquemas sejam integrados. A orde-

Figura 10.5



Esquema integrado ap√≥s mesclar vis√µes 1 e 2.

Figura 10.6



Diferentes estrat√©gias para o processo de integra√ß√£o de vis√£o.

na√ß√£o dos esquemas para integra√ß√£o pode ser baseada  em  alguma  medida  de  semelhan√ßa do esquema. Essa estrat√©gia √© adequada para a  integra√ß√£o  manual,  devido  a  sua  t√©cnica passo a passo.

- 2. Integra√ß√£o n -√°ria. Todas as vis√µes s√£o integradas em um procedimento ap√≥s uma an√°lise e especifica√ß√£o de suas correspond√™ncias. Essa estrat√©gia requer ferramentas computadorizadas para grandes problemas de projeto.  Tais  ferramentas  foram  montadas  como prot√≥tipos de pesquisa, mas ainda n√£o est√£o dispon√≠veis para comercializa√ß√£o.
- 3. Estrat√©gia  balanceada  bin√°ria. Pares  de  esquemas s√£o integrados primeiro, e depois os esquemas resultantes s√£o emparelhados para maior integra√ß√£o; esse procedimento √© repetido at√© que o resultado seja um esquema global final.
- 4. Estrat√©gia  mista. Inicialmente,  os  esquemas s√£o  particionados  em  grupos  com  base  em sua semelhan√ßa, e cada grupo √© integrado de maneira separada. Os esquemas intermedi√°rios  s√£o  agrupados  de  novo  e  integrados,  e assim por diante.

Fase 2b: projeto de transa√ß√£o. A finalidade da Fase 2b, que prossegue em paralelo com a Fase 2a, √© projetar as caracter√≠sticas das transa√ß√µes (aplica√ß√µes) de banco de dados conhecidas de uma maneira independente do SGBD. Quando um sistema de banco de dados est√° sendo projetado, os projetistas est√£o cientes de muitas aplica√ß√µes (ou transa√ß√µes ) conhecidas, as quais ser√£o executadas no banco de dados uma vez implementado. Uma parte importante do projeto do banco de dados √© especificar as caracter√≠sticas funcionais dessas transa√ß√µes desde cedo no processo de projeto. Isso garante que o esquema de banco de dados incluir√° todas as informa√ß√µes exigidas por essas transa√ß√µes. Al√©m disso, conhecer a import√¢ncia relativa das diversas transa√ß√µes e as frequ√™ncias esperadas de suas chamadas desempenha um papel fundamental durante o projeto f√≠sico  do  banco  de dados  (Fase  5).  Normalmente,  nem  todas  as  transa√ß√µes  do  banco  de  dados  s√£o  conhecidas  durante o projeto. Depois que o sistema de banco de dados estiver  implementado,  novas  transa√ß√µes  s√£o  continuamente identificadas e implementadas. Por√©m, as transa√ß√µes mais importantes costumam ser conhecidas antes da implementa√ß√£o do sistema, e devem ser especificadas em um est√°gio inicial. A regra informal dos 80-20 em geral se aplica nesse contexto: 80 por cento  da  carga  de  trabalho  √©  representada  por  20 por cento das transa√ß√µes usadas com mais frequ√™ncia, que controlam o projeto f√≠sico do banco de dados. Em aplica√ß√µes que s√£o de consultas ocasionais ou da variedade de processamento de lote, consultas e  aplica√ß√µes  que  processam  uma  quantidade  substancial de dados devem ser identificadas.

Uma t√©cnica comum para especificar transa√ß√µes em um n√≠vel conceitual √© identificar sua entrada/sa√≠da e o comportamento funcional . Ao determinar os par√¢metros de entrada e sa√≠da (argumentos) e o fluxo de controle funcional interno, os projetistas podem especificar  uma  transa√ß√£o  de  uma  maneira  conceitual e independente do sistema. As transa√ß√µes normalmente podem ser agrupadas em tr√™s categorias: (1) transa√ß√µes de recupera√ß√£o ,  que s√£o usadas para recuperar dados para exibi√ß√£o em uma tela ou imprimir um relat√≥rio; (2) transa√ß√µes de atualiza√ß√£o , que s√£o utilizadas para a inser√ß√£o de novos dados ou modifica√ß√£o de dados existentes no banco de dados; e (3) transa√ß√µes mistas , que s√£o usadas para aplica√ß√µes mais complexas, que realizam alguma recupera√ß√£o e alguma atualiza√ß√£o. Por exemplo, considere um banco  de  dados  de  reservas  a√©reas.  Uma  transa√ß√£o  de recupera√ß√£o poderia, primeiro, listar todos os voos matutinos em determinada data entre duas cidades. Uma transa√ß√£o de atualiza√ß√£o poderia ser uma reserva de um assento em determinado voo. Uma transa√ß√£o mista poderia, em primeiro lugar, exibir alguns dados, como mostrar uma reserva do cliente em algum voo, e depois atualizar o banco de dados, como ao cancelar a reserva excluindo-a, ou acrescentando um trecho de voo a uma reserva existente. As transa√ß√µes  (aplica√ß√µes)  podem  ser  originadas  em  uma ferramenta de front-end, como o PowerBuilder (da Sybase), que coleta par√¢metros on-line e depois envia uma transa√ß√£o ao SGBD, como back-end. 3

V√°rias  t√©cnicas  para  especifica√ß√£o  de  requisitos incluem uma nota√ß√£o para especificar processos ,  os quais  nesse  contexto  s√£o  opera√ß√µes  mais  complexas, que podem consistir em v√°rias transa√ß√µes. Ferramentas de modelagem de processo, como BPwin, bem  como  ferramentas  de  modelagem  de  fluxo  de trabalho est√£o se tornando populares para identificar fluxos de informa√ß√£o nas organiza√ß√µes. A linguagem UML, que prov√™ a modelagem de dados por meio de diagramas de classes e objetos, possui uma s√©rie de diagramas de modelagem de processo, incluindo diagramas de transi√ß√£o de estado, de atividades, de sequ√™ncia e de colabora√ß√£o. Todos estes se referem a atividades,

3 Essa filosofia √© seguida h√° mais de 20 anos em produtos populares como CICS, que serve como uma ferramenta para gerar transa√ß√µes para SGBDs legados, como IMS.

eventos e opera√ß√µes dentro do sistema de informa√ß√£o, as entradas e sa√≠das dos processos, os requisitos de sequ√™ncia ou sincronismo, e outras condi√ß√µes. √â  poss√≠vel  detalhar  essas  especifica√ß√µes  e  extrair transa√ß√µes individuais delas. Outras propostas para especificar  transa√ß√µes  incluem  TAXIS,  GALILEO e GORDAS (veja na bibliografia selecionada deste cap√≠tulo). Algumas destas foram implementadas em sistemas e ferramentas de prot√≥tipo. A modelagem de processos continua sendo uma √°rea de pesquisa ativa.

- O projeto da transa√ß√£o √© t√£o importante quanto o projeto do esquema, mas com frequ√™ncia √© considerado parte da engenharia de software, em vez do projeto de banco de dados. Muitas metodologias de projeto atuais enfatizam um sobre o outro. Deve-se passar pelas fases 2a e 2b em paralelo, usando ciclos de retorno para o detalhamento, at√© que seja alcan√ßado  um  projeto  est√°vel  do  esquema  e  das transa√ß√µes. 4

## 10.2.3 Fase 3: escolha de um SGBD

A escolha de um SGBD √© controlada por uma s√©rie de fatores - alguns t√©cnicos, outros econ√¥micos e ainda outros referentes √† pol√≠tica da organiza√ß√£o. Os fatores t√©cnicos focalizam a adequa√ß√£o do SGBD para a tarefa dispon√≠vel. As quest√µes a considerar s√£o o tipo de SGBD (relacional, objeto-relacional, objeto, outro), as estruturas de armazenamento e os caminhos de acesso que o SGBD admite, as interfaces de usu√°rio e programador dispon√≠veis, os tipos de linguagens de consulta de alto n√≠vel, a disponibilidade  de  ferramentas  de  desenvolvimento,  a  capacidade de   interagir  com outros SGBDs por meio de interfaces-padr√£o, as op√ß√µes arquiteturais relacionadas √† opera√ß√£o cliente-servidor, e assim por diante. Os fatores n√£o t√©cnicos incluem o status financeiro e a organiza√ß√£o de suporte do vendedor. Nesta se√ß√£o, concentramo-nos na discuss√£o dos fatores econ√¥micos e organizacionais que afetam a escolha do SGBD. Os seguintes custos devem ser considerados:

- de projeto e suporte adicional da linguagem n√£o est√£o inclu√≠dos no pre√ßo b√°sico.
- 2. Custo de manuten√ß√£o. Este √© o custo recorrente do recebimento de servi√ßo de manuten√ß√£o-padr√£o do vendedor e para manter a vers√£o do SGBD atualizada.
- 3. Custo de aquisi√ß√£o de hardware. Pode ser preciso adquirir novo hardware, como mem√≥ria adicional, terminais, unidades de disco e controladores,  ou  dispositivos  especializados  em armazenamento e arquivamento do SGBD.
- 4. Custo de cria√ß√£o ou convers√£o do banco de dados. Este √© o custo da cria√ß√£o do sistema de banco de dados do zero ou da convers√£o de um sistema existente para o novo software de SGBD. Neste √∫ltimo caso, √© comum operar o sistema existente em paralelo ao novo sistema  at√©  que  todas  as  novas  aplica√ß√µes sejam  totalmente  implementadas  e  testadas. Esse custo √© dif√≠cil de projetar e costuma ser subestimado.
- 5. Custo  de  pessoal. A  aquisi√ß√£o  de  software de  SGBD  pela  primeira  vez  por  uma  organiza√ß√£o com frequ√™ncia √© acompanhada por uma reorganiza√ß√£o do departamento de processamento de dados. Cargos de DBA e seu pessoal existem na maioria das empresas que adotaram SGBDs.
- 6. Custo de treinamento. Como os SGBDs em geral s√£o sistemas complexos, o pessoal deve ser treinado com frequ√™ncia para usar e programar o SGBD. O treinamento √© exigido em todos os n√≠veis, incluindo programa√ß√£o e desenvolvimento de aplica√ß√µes, projeto f√≠sico e administra√ß√£o de banco de dados.
- 1. Custo de aquisi√ß√£o do software. Esse √© o custo inicial  da  compra do software, incluindo op√ß√µes de linguagem de programa√ß√£o, diferentes op√ß√µes de interface (formul√°rios, menus e ferramentas de interface gr√°fica com o usu√°rio (GUI) baseadas na Web), op√ß√µes de recupera√ß√£o/backup,  m√©todos  de  acesso  especiais e documenta√ß√£o. √â preciso selecionar a  vers√£o  de  SGBD  correta  para  um  sistema operacional espec√≠fico. Normalmente, as ferramentas  de  desenvolvimento,  ferramentas
- 7. Custo operacional. O custo da opera√ß√£o continuada do sistema de banco de dados normalmente n√£o √© calculado com base em uma avalia√ß√£o das alternativas porque √© contra√≠do independentemente do SGBD selecionado.

Os benef√≠cios da aquisi√ß√£o de um SGBD n√£o s√£o t√£o f√°ceis de medir e quantificar. Um SGBD tem diversas  vantagens  intang√≠veis  em  rela√ß√£o  aos  sistemas  de arquivo tradicionais, como facilidade de uso, consolida√ß√£o de informa√ß√µes de toda a empresa, maior disponibilidade de dados e acesso mais r√°pido √† informa√ß√£o. Com o acesso baseado na Web, certas partes dos dados podem se tornar globalmente acess√≠veis a funcion√°rios e tamb√©m a usu√°rios externos. Benef√≠cios mais tang√≠-

4 A modelagem de transa√ß√µes de alto n√≠vel √© abordada em Batini et al. (1992, cap√≠tulos 8, 9 e 11). A filosofia de an√°lise funcional e de dados √© defendida no decorrer deste livro.

veis incluem redu√ß√£o nos custos de desenvolvimento de aplica√ß√£o, redu√ß√£o na redund√¢ncia de dados e melhor controle e seguran√ßa. Embora os bancos de dados estejam fortemente estabelecidos na maioria das organiza√ß√µes, a decis√£o de passar uma aplica√ß√£o de um enfoque baseado em arquivo para um centralizado no banco de dados ainda precisa ser tomada. Essa mudan√ßa geralmente √© baseada nos seguintes fatores:

- 1. Complexidade dos dados. √Ä medida que os relacionamentos  dos  dados  se  tornam  mais complexos,  a  necessidade  de  um  SGBD  √© maior.
- 2. Compartilhamento  entre  aplica√ß√µes. A  necessidade  de  um  SGBD  √©  maior  quando  as aplica√ß√µes  compartilham  dados  comuns  armazenados  de  forma  redundante  em  v√°rios arquivos.
- 3. Evolu√ß√£o  ou  crescimento  din√¢mico  dos  dados. Se  os  dados  mudam constantemente, √© mais f√°cil lidar com essas mudan√ßas usando um SGBD do que um sistema de arquivo.
- 4. Frequ√™ncia  das  solicita√ß√µes  casuais  dos  dados. Os sistemas de arquivo n√£o s√£o adequados de forma alguma para a recupera√ß√£o casual de dados.
- 5. Volume e necessidade de controle dos dados. O grande volume de dados e a necessidade de control√°-los √†s vezes exige um SGBD.
- √â  dif√≠cil  desenvolver  um  conjunto  gen√©rico  de orienta√ß√µes para adotar uma √∫nica t√©cnica para o gerenciamento de dados em uma organiza√ß√£o - seja ela  relacional,  orientada  a  objeto  ou  objeto-relacional. Se os dados a serem armazenados no banco de dados tiverem um alto n√≠vel de complexidade e lidarem com v√°rios tipos de dados, a t√©cnica t√≠pica pode ser considerar um SGBD orientado a objeto ou objeto-relacional. 5 Al√©m disso, os benef√≠cios da heran√ßa entre as classes e a consequente vantagem da reutiliza√ß√£o favorecem essas t√©cnicas. Por fim, diversos  fatores  econ√¥micos  e  organizacionais  afetam  a escolha de um SGBD em rela√ß√£o a outro:
- 1. Ado√ß√£o em toda a organiza√ß√£o de certa filosofia. Esse costuma ser um fator dominante que afeta a aceita√ß√£o de determinado modelo de dados (por exemplo, relacional versus objeto), de certo vendedor ou certa metodologia e ferramentas de desenvolvimento (por exemplo, o uso de ferramentas e metodologia de an√°lise e projeto orientados a objeto pode ser exigido para todas as novas aplica√ß√µes).

5 Ver, no Cap√≠tulo 11, uma discuss√£o a respeito dessa quest√£o.

- 2. Familiaridade do pessoal com o sistema. Se o pessoal  de  programa√ß√£o  da  organiza√ß√£o  estiver familiarizado com determinado SGBD, este pode ser favorecido, para reduzir o custo de treinamento e o tempo de aprendizagem.
- 3. Disponibilidade de servi√ßos pelo vendedor. A disponibilidade de assist√™ncia do vendedor na solu√ß√£o de problemas com o sistema √© importante,  uma  vez  que  passar  de  um  ambiente n√£o SGBD para SGBD em geral √© uma grande incumb√™ncia,  exigindo  muita  assist√™ncia  do vendedor no in√≠cio.

Outro  fator  a  considerar  √©  a  portabilidade  do SGBD  entre  diferentes  tipos  de  hardware.  Muitos SGBDs  comerciais  agora  possuem  vers√µes  que  rodam  em  muitas  configura√ß√µes  (ou plataformas )  de hardware/software. A necessidade de aplica√ß√µes para backup,  recupera√ß√£o,  desempenho,  integridade  e seguran√ßa tamb√©m precisa ser considerada. Muitos SGBDs atualmente est√£o sendo projetados como solu√ß√µes totais para as necessidades de processamento de informa√ß√£o e gerenciamento de recursos de informa√ß√£o nas organiza√ß√µes. A maioria dos vendedores de SGBD est√° combinando seus produtos com as seguintes op√ß√µes ou recursos embutidos:

- ¬Ñ Editores de texto e navegadores.
- ¬Ñ Geradores de relat√≥rios e utilit√°rios de listagem.
- ¬Ñ Softwares de comunica√ß√£o (em geral chamados de monitores de teleprocessamento ).
- ¬Ñ Recursos  de  entrada  e  exibi√ß√£o  de  dados, como formul√°rios, telas e menus com recursos de edi√ß√£o autom√°ticos.
- ¬Ñ Ferramentas de consulta e acesso que podem ser usadas na World Wide Web (ferramentas habilitadas para a Web).
- ¬Ñ Ferramentas gr√°ficas  para  projeto  de  banco de dados.

Uma grande quantidade de software de terceiros est√°  dispon√≠vel  e  oferece  funcionalidade  adicional  a um SGBD em cada uma dessas √°reas. Em casos raros, pode ser  prefer√≠vel  desenvolver  software  interno  em vez de usar um SGBD - por exemplo, se as aplica√ß√µes  forem  muito  bem  definidas  e todas conhecidas de antem√£o. Sob tais circunst√¢ncias, um sistema personalizado, criado internamente, pode ser apropriado para implementar as aplica√ß√µes conhecidas da forma mais  eficiente.  Por√©m,  na  maioria  dos  casos,  novas

aplica√ß√µes que n√£o foram previstas no momento do projeto aparecem ap√≥s a  implanta√ß√£o do sistema. √â exatamente por isso que os SGBDs se tornaram muito populares: eles facilitam a incorpora√ß√£o de novas aplica√ß√µes apenas com modifica√ß√µes incrementais ao projeto existente de um banco de dados. Essa evolu√ß√£o de projeto - ou evolu√ß√£o de esquema - √© um recurso presente em v√°rios graus nos SGBDs comerciais.

## 10.2.4 ase 4: mapeamento do modelo F de dados (projeto l√≥gico do banco de dados)

A pr√≥xima fase do projeto de banco de dados √© criar um esquema conceitual e esquemas externos no modelo de dados do SGBD selecionado, mapeando os esquemas produzidos na Fase 2a. O mapeamento pode prosseguir em dois est√°gios:

- 1. Mapeamento independente do sistema. Nesse est√°gio,  o  mapeamento n√£o considera quaisquer  caracter√≠sticas  espec√≠ficas  ou  casos  especiais  que  se  aplicam  √†  implementa√ß√£o  do SGBD espec√≠fico do modelo de dados. Discutimos o mapeamento independente do SGBD de um esquema ER para um esquema relacional na Se√ß√£o 9.1, e das constru√ß√µes do esquema EER para esquemas relacionais na Se√ß√£o 9.2.
- 2. Ajuste dos esquemas para um SGBD espec√≠fico. Diferentes SGBDs implementam um modelo de dados usando recursos de modelagem e restri√ß√µes espec√≠ficas. Pode ser preciso ajustar os esquemas obtidos na etapa 1 para que corresponda aos recursos de implementa√ß√£o espec√≠ficos de um modelo de dados conforme usado no SGBD selecionado.
- O resultado dessa fase dever√° ser comandos DDL (Data Definition Language) na linguagem do SGBD escolhido, que especificam os esquemas no n√≠vel conceitual e externo do sistema de banco de dados. Mas, se os comandos DDL inclu√≠rem alguns par√¢metros do projeto f√≠sico, uma especifica√ß√£o DDL completa deve esperar at√© depois de a fase de projeto de banco de dados estar completada. Muitas ferramentas de projeto CASE (Computer-Aided Software Engineering) (ver Se√ß√£o 10.5) podem gerar DDL para sistemas comerciais com base em um projeto do esquema conceitual.

## 10.2.5 ase 5: projeto f√≠sico do banco de F dados

O projeto f√≠sico do banco de dados √© o processo de  escolher  estruturas  espec√≠ficas  de  armazenamento  de  arquivo e caminhos de acesso para os arquivos para alcan√ßar um bom desempenho nas diversas aplica√ß√µes de banco de dados. Cada SGBD oferece uma s√©rie de op√ß√µes para as organiza√ß√µes de arquivo e caminhos de acesso. Estas normalmente incluem diversos tipos de indexa√ß√£o, agrupamento de registros relacionados em blocos de disco, liga√ß√£o de registros relacionados por meio de ponteiros e v√°rios tipos de t√©cnicas de hashing (ver cap√≠tulos 17 e 18). Quando um SGBD espec√≠fico √© escolhido, o processo de projeto f√≠sico do banco de dados fica restrito a escolher as estruturas mais apropriadas para os arquivos de banco de dados dentre as op√ß√µes oferecidas por esse SGBD.  Nesta  se√ß√£o,  damos  orienta√ß√µes  gen√©ricas, mantidas para qualquer tipo de SGBD para decis√µes do projeto f√≠sico. Os crit√©rios a seguir com frequ√™ncia s√£o usados para orientar a escolha das op√ß√µes de projeto f√≠sico do banco de dados:

- 1. Tempo de resposta. Este √© o tempo decorrido entre a submiss√£o de uma transa√ß√£o do banco de dados para execu√ß√£o e o recebimento de uma resposta. Uma influ√™ncia importante sobre o tempo de resposta que est√° sob o controle do SGBD √© o tempo de acesso ao banco de dados para os itens de dados referenciados pela transa√ß√£o. O tempo de resposta tamb√©m √© influenciado por fatores que n√£o est√£o sob o controle do SGBD, como carga do sistema, escalonamento  do  sistema  operacional  ou atrasos de comunica√ß√£o.
- 2. Utiliza√ß√£o de espa√ßo. Essa √© a quantidade de espa√ßo de armazenamento usada pelos arquivos de banco de dados e suas estruturas de caminho de acesso no disco, incluindo √≠ndices e outros caminhos de acesso.
- 3. Throughput da transa√ß√£o. Esse √© o n√∫mero m√©dio de transa√ß√µes que podem ser processadas por minuto. √â um par√¢metro cr√≠tico dos sistemas de transa√ß√£o, como aqueles usados para reservas a√©reas ou opera√ß√µes banc√°rias. O throughput da transa√ß√£o precisa ser medido sob condi√ß√µes de pico no sistema.

Em geral,  limites  m√©dios  e  comprometidos  sobre os par√¢metros anteriores s√£o especificados como parte dos requisitos de desempenho do sistema. T√©cnicas anal√≠ticas ou experimentais, que podem incluir prot√≥tipo  e  simula√ß√£o,  s√£o  usadas  para  estimar  os valores m√©dio e pior caso sob diferentes decis√µes de projeto f√≠sico, para determinar se elas atendem aos requisitos de desempenho especificados.

- O desempenho depende do tamanho e do n√∫mero de registros no arquivo. Logo, precisamos estimar esses par√¢metros para cada arquivo. Al√©m disso, devemos estimar os padr√µes de atualiza√ß√£o e recupera√ß√£o para o arquivo cumulativamente de todas as transa√ß√µes. Os atributos usados para procurar registros espec√≠ficos devem ter caminhos de acesso principais e √≠ndices secund√°rios constru√≠dos para eles. Esti-

mativas do crescimento de arquivo, seja no tamanho do registro, devido a novos atributos, ou no n√∫mero de registros, tamb√©m devem ser levadas em considera√ß√£o durante o projeto f√≠sico do banco de dados.

O resultado da fase de projeto f√≠sico do banco de dados √© uma determina√ß√£o inicial das estruturas de armazenamento e caminhos de acesso para os arquivos. Quase sempre √© necess√°rio modificar o projeto com base em seu desempenho observado ap√≥s o sistema de banco de dados ser implementado. Inclu√≠mos essa atividade de ajuste de banco de dados na pr√≥xima fase e a abordaremos no contexto da otimiza√ß√£o de consulta no Cap√≠tulo 20.

## 10.2.6 ase 6: implementa√ß√£o e ajuste do F sistema de banco de dados

Depois que os projetos l√≥gico e f√≠sico forem conclu√≠dos,  podemos  implementar  o  sistema  de  banco de  dados.  Isso  normalmente  √©  responsabilidade  do DBA e √© executado em conjunto com os projetistas de banco de dados. Os comandos da linguagem na DDL, incluindo a SDL ( storage definition language ) do SGBD selecionado, s√£o compilados e usados para criar os esquemas e arquivos de banco de dados (vazios).  O  banco  de  dados  pode  ent√£o  ser carregado (preenchido) com os dados. Caso estes tiverem de ser convertidos  de  um  sistema  computadorizado  mais antigo, rotinas de convers√£o podem ser necess√°rias para reformat√°-los para a carga no novo banco de dados.

Os programas do banco de dados s√£o implementados pelos programadores de aplica√ß√£o, consultando as especifica√ß√µes conceituais das transa√ß√µes e depois escrevendo e testando o c√≥digo do programa com comandos embutidos na DML ( Data Manipulation Language ). Quando as transa√ß√µes estiverem prontas e os dados forem carregados no banco de dados, a fase de projeto e implementa√ß√£o termina e come√ßa a fase operacional do sistema de banco de dados.

consultas  ou  transa√ß√µes  podem  ser  reescritas  para melhorar o desempenho. O ajuste continua enquanto o banco de dados existir, enquanto problemas de desempenho forem descobertos e conforme os requisitos continua  rem mudando (ver Cap√≠tulo 20).

## 10.3 Uso de diagramas UML como recurso para especifica√ß√£o de projeto de banco de dados 6

## 10.3.1 UML como um padr√£o de especifica√ß√£o de projeto

Existe uma necessidade de alguma t√©cnica-padr√£o para cobrir todo o espectro de an√°lise de requisitos, modelagem, projeto, implementa√ß√£o e implanta√ß√£o de bancos de dados e suas aplica√ß√µes. Uma delas, que est√° recebendo grande aten√ß√£o e que tamb√©m √© proposta como  um  padr√£o  pelo  Object  Management  Group (OMG), √© a t√©cnica da linguagem de modelagem unificada ( Unified Modeling Language -UML ). Ela oferece um mecanismo na forma de nota√ß√£o diagram√°tica e sintaxe de linguagem associada para cobrir todo o ciclo de vida. Atualmente, a UML pode ser usada por desenvolvedores de software, modeladores de dados, projetistas de banco de dados, dentre outros, para definir  a  especifica√ß√£o  detalhada  de  uma  aplica√ß√£o. Eles tamb√©m a utilizam para determinar o ambiente que consiste  em  usu√°rios,  software,  comunica√ß√µes  e hardware para implementar e instalar a aplica√ß√£o.

A  maioria  dos  sistemas  inclui  um  utilit√°rio  de monitoramento  para  reunir  estat√≠sticas  de  desempenho, que s√£o mantidas no cat√°logo do sistema ou no dicion√°rio de dados para an√°lise posterior. Estas incluem  estat√≠sticas  sobre  o  n√∫mero  de  chamadas de  transa√ß√µes  ou  consultas  predefinidas,  atividade de entrada/sa√≠da ao inv√©s de arquivos, contagens de p√°ginas de disco do arquivo ou registros de √≠ndice, e frequ√™ncia de uso do √≠ndice. √Ä medida que os requisitos do sistema de banco de dados mudam, com frequ√™ncia torna-se necess√°rio acrescentar ou remover tabelas existentes e reorganizar alguns arquivos, alterando os m√©todos de acesso principais ou removendo √≠ndices antigos e construindo novos. Algumas

A UML combina conceitos comumente aceitos de muitos m√©todos e metodologias orientados a objeto  (O-O)  (veja,  na  bibliografia  selecionada  deste cap√≠tulo,  as  metodologias  que  contribu√≠ram  para  a UML). Ela √© gen√©rica, independente de linguagem e independente de plataforma. Com a UML, os arquitetos de software podem modelar qualquer tipo de aplica√ß√£o, rodando em qualquer sistema operacional, linguagem de programa√ß√£o ou rede. Isso tem tornado a t√©cnica bastante aceit√°vel. Ferramentas como Rational Rose atualmente s√£o populares para desenhar diagramas UML - elas permitem que os desenvolvedores de software fa√ßam modelos claros e f√°ceis de entender para especificar, visualizar, construir e documentar componentes de sistemas de software. Como o escopo da UML se estende para o desenvolvimento de software e aplica√ß√£o em geral, n√£o abordaremos todos os aspectos dessa linguagem aqui. Nosso objetivo √© mostrar algumas nota√ß√µes UML relevantes, que normalmente s√£o usadas na fase de levantamento e an√°lise de requisitos do projeto de banco de dados, bem como na fase de projeto conceitual (ver as

6 Agradecemos a colabora√ß√£o de Abrar Ul-Haque √†s se√ß√µes de UML e Rational Rose.

fases 1 e 2 na Figura 10.1). A metodologia de desenvolvimento de aplica√ß√£o detalhada usando UML est√° fora do escopo deste livro, e pode ser encontrada em diversos livros-texto dedicados ao projeto orientado a objeto, √† engenharia de software e UML (veja na bibliografia selecionada ao final deste cap√≠tulo).

A UML tem muitos tipos de diagramas. Diagramas de classes , que podem representar o resultado final do projeto conceitual do banco de dados, foram discutidos nas se√ß√µes 7.8 e 8.6. Para chegar aos diagramas de classes, os requisitos da aplica√ß√£o podem ser coletados e especificados usando diagramas de casos de uso , diagramas de sequ√™ncia e diagramas de estados . No restante desta se√ß√£o, vamos apresentar rapidamente os diferentes tipos de diagramas UML, para que o leitor tenha uma ideia do escopo da UML. Depois, vamos descrever um exemplo de uma pequena aplica√ß√£o para ilustrar o uso de alguns desses diagramas e mostrar como eles levam ao eventual diagrama de classes para o projeto conceitual final do banco de dados. Os diagramas apresentados nesta se√ß√£o pertencem √† nota√ß√£o UML padr√£o e foram desenhados usando Rational Rose. A Se√ß√£o 10.4 √© dedicada a uma discuss√£o geral do uso da Rational Rose no projeto de aplica√ß√µes de banco de dados.

## 10.3.2 UML para o projeto de aplica√ß√£o de banco de dados

A UML foi desenvolvida como uma metodologia de  engenharia  de  software.  Conforme  mencionamos anteriormente na Se√ß√£o 7.8, a maioria dos sistemas de software possui componentes de banco de dados muito grandes. A comunidade de banco de dados come√ßou a aceitar a UML e, agora, alguns projetistas e desenvolvedores a est√£o usando para modelagem de dados e tamb√©m para as fases subsequentes do projeto de banco de dados. A vantagem da UML √© que, embora seus conceitos sejam baseados nas t√©cnicas orientadas a objeto, os modelos resultantes de estrutura e comportamento podem ser usados para projetar bancos de dados relacionais, orientados a objeto ou objeto-relacionais (veja no Cap√≠tulo 11 as defini√ß√µes de bancos de dados orientados a objeto e objeto-relacional).

Uma das principais contribui√ß√µes da abordagem da UML foi reunir os modeladores, analistas e projetistas de banco de dados tradicionais aos desenvolvedores de aplica√ß√£o de software. Na Figura 10.1, mostramos as fases do projeto e implementa√ß√£o de banco de dados e como elas se aplicam a esses dois grupos. A UML tamb√©m nos permite realizar a modelagem comportamental, funcional e din√¢mica com a introdu√ß√£o de v√°rios tipos de diagramas. Isso resulta em uma especifica√ß√£o/descri√ß√£o  mais  completa  da  aplica√ß√£o geral de banco de dados. Nas pr√≥ximas se√ß√µes, vamos resumir os diferentes tipos de diagramas UML e de- pois oferecer um exemplo dos diagramas de casos de uso, sequ√™ncia e estados em um exemplo de aplica√ß√£o.

## 10.3.3 Diferentes tipos de diagramas em UML

A UML define nove tipos de diagramas, divididos em duas categorias:

- ¬Ñ Diagramas  estruturais. Estes  descrevem  os relacionamentos estruturais  ou  est√°ticos  entre  objetos  de  esquema,  objetos  de  dados  e componentes de software. Incluem de classes, de objetos, de componentes e diagramas de implanta√ß√£o.
- ¬Ñ Diagramas comportamentais. Sua finalidade √© descrever o comportamento ou os relacionamentos  din√¢micos  entre  os  componentes. Incluem diagramas de casos de uso, de sequ√™ncia, de colabora√ß√£o, de estados e de atividades.

A seguir, apresentamos os nove tipos rapidamente. Os diagramas estruturais incluem:

- A. Diagramas de classes. Os diagramas de classes capturam  a  estrutura  est√°tica  do  sistema  e  atuam como alicerce para outros modelos. Mostram classes,  interfaces,  colabora√ß√µes,  depend√™ncias,  generaliza√ß√µes, associa√ß√µes e outros relacionamentos. Eles s√£o um modo muito √∫til de modelar o esquema conceitual do banco de dados. Mostramos exemplos de diagramas de classes para o banco de dados EMPRESA na Figura 7.16 e para uma hierarquia de generaliza√ß√£o na Figura 8.10.

Diagramas de pacotes. Os diagramas de pacotes s√£o um subconjunto dos diagramas de classes. Eles organizam elementos do sistema em grupos relacionados, chamados de pacotes . Um pacote pode ser uma cole√ß√£o de classes relacionadas e os relacionamentos entre elas. Os diagramas de pacotes ajudam a minimizar as depend√™ncias em um sistema.

- B.  Diagramas  de  objetos. Os  diagramas  de  objetos mostram um conjunto de objetos individuais e seus relacionamentos, e √†s vezes s√£o referenciados como diagramas de inst√¢ncias . Eles d√£o uma vis√£o est√°tica de um sistema em determinado momento e normalmente s√£o usados para testar a precis√£o dos diagramas de classes.
- C.  Diagramas  de  componentes. Os  diagramas  de componentes ilustram as organiza√ß√µes e as depend√™ncias entre os componentes de software. Um diagrama de componentes em geral √© composto de componentes,  interfaces  e  relacionamentos  de  depend√™ncia. Um componente pode ser um componente do c√≥digo  fonte,  um  componente em tempo de execu√ß√£o ou um execut√°vel. Ele √© um bloco de constru√ß√£o f√≠sico

no  sistema,  sendo  representado  como  um  ret√¢ngulo com  dois  pequenos  ret√¢ngulos  ou  abas  sobrepostas em seu lado esquerdo. Uma interface √© um grupo de opera√ß√µes usadas ou criadas por um componente, e normalmente √© representada por um pequeno c√≠rculo.  O  relacionamento  de  depend√™ncia  √©  usado  para modelar o relacionamento entre dois componentes e √© representado por uma seta pontilhada que aponta de um componente para outro do qual ele depende. Para bancos de dados, os diagramas de componentes correspondem a dados armazenados, como tablespaces ou parti√ß√µes. As interfaces referem-se a aplica√ß√µes que utilizam os dados armazenados.

D.  Diagramas  de  implanta√ß√£o. Diagramas  de  implanta√ß√£o representam a distribui√ß√£o de componentes  (execut√°veis, bibliotecas, tabelas, arquivos) pela topologia de hardware. Eles representam os recursos f√≠sicos  em um sistema, incluindo n√≥s, componentes e conex√µes, e basicamente s√£o usados para mostrar a configura√ß√£o dos elementos de processamento em tempo de execu√ß√£o (os n√≥s) e os processos de software que residem neles (os threads).

A seguir, descrevemos rapidamente os diversos tipos de diagramas comportamentais e  expandimos aqueles que s√£o de interesse particular.

E. Diagramas de casos de uso. Os diagramas de casos de uso s√£o utilizados para modelar as intera√ß√µes funcionais entre os usu√°rios e o sistema. Um cen√°rio √© uma sequ√™ncia de etapas que descrevem uma intera√ß√£o entre um usu√°rio e um sistema. Um caso de uso √© um conjunto de cen√°rios que possuem um objetivo comum. O diagrama de casos de uso foi introduzido por Jacobson 7  para visualizar tais casos. Um diagrama de casos de uso mostra atores interagindo com os casos de uso e pode ser entendido facilmente sem o conhecimento de qualquer nota√ß√£o. Um caso de uso individual  aparece  como  uma  oval  e  corresponde  a uma tarefa espec√≠fica realizada pelo sistema. Um ator , mostrado com um desenho simb√≥lico de uma pessoa, representa um usu√°rio externo, que pode ser um usu√°rio  humano,  um  grupo  representativo  de  usu√°rios, uma fun√ß√£o determinada de uma pessoa na organiza√ß√£o ou algo externo ao sistema (ver Figura 10.7). O diagrama de casos de uso mostra as poss√≠veis intera√ß√µes do sistema (em nosso caso, um sistema de banco de dados) e descreve as tarefas espec√≠ficas que o sistema realiza como casos de uso. Como n√£o especificam qualquer  detalhe  de  implementa√ß√£o  e  supostamente s√£o f√°ceis de entender, eles s√£o usados como um ve√≠culo  para  a  comunica√ß√£o  entre  os  usu√°rios  finais  e desenvolvedores para facilitar a valida√ß√£o do usu√°rio em um est√°gio inicial. Os planos de teste tamb√©m podem ser descritos com diagramas desse tipo. A Figura

7 Ver Jacobson et al. (1992).

Figura 10.7



A nota√ß√£o do diagrama de casos de uso.

10.7 mostra a nota√ß√£o do diagrama de caso de uso. O relacionamento include √©  utilizado  para  chegar  a algum comportamento comum de dois ou mais dos casos de uso originais - ele √© uma forma de reutiliza√ß√£o. Por exemplo, em um ambiente de universidade mostrado na Figura 10.8, os casos de uso Registrar para disciplina e Inserir notas , em que os atores aluno e professor est√£o envolvidos, incluem um caso de uso comum chamado Validar usu√°rio . Se um caso de uso incorporar  dois  ou  mais  cen√°rios  significativamente diferentes, com base em circunst√¢ncias ou condi√ß√µes vari√°veis, o relacionamento extend √© usado para mostrar os subcasos conectados ao caso b√°sico.

Diagramas  de  intera√ß√£o. Os  dois  tipos  seguintes  de diagramas comportamentais em UML, diagramas de intera√ß√£o , s√£o usados para modelar os aspectos din√¢-

Figura 10.8



Um exemplo de diagrama de casos de uso para um banco de dados UNIVERSIDADE.

micos de um sistema. Eles consistem em um conjunto de mensagens trocadas entre um conjunto de objetos. Existem dois tipos de diagramas de intera√ß√£o, sequ√™ncia e colabora√ß√£o.

F. Diagramas de sequ√™ncia. Os diagramas de sequ√™ncia descrevem as intera√ß√µes entre diversos objetos com o tempo. Eles basicamente oferecem uma vis√£o din√¢mica do sistema,  mostrando  o  fluxo  de  mensagens entre objetos. No diagrama de sequ√™ncia, um objeto ou um ator √© mostrado como uma caixa no topo de uma linha vertical tracejada, que √© chamada de linha  da  vida  do  objeto .  Para  um  banco  de  dados, esse objeto em geral √© algo f√≠sico - um livro em um dep√≥sito que seria representado no banco de dados, um documento ou formul√°rio externo, como um formul√°rio de pedido, ou uma tela visual externa - que pode fazer parte de uma interface com o usu√°rio. A linha da vida representa a exist√™ncia de um objeto no tempo. A ativa√ß√£o , que indica quando um objeto est√° realizando uma a√ß√£o, √© representada como uma caixa retangular em uma linha da vida. Cada mensagem √© representada como uma seta entre as linhas da vida de dois objetos. Uma mensagem tem um nome e pode ter argumentos e informa√ß√µes de controle para explicar a natureza da intera√ß√£o. A ordem das mensagens √© lida de cima para baixo. Um diagrama de sequ√™ncia tamb√©m d√° a op√ß√£o de autochamada , que √© basicamente uma mensagem de um objeto para si mesmo. Marcadores de condi√ß√£o e itera√ß√£o tamb√©m podem ser mostrados nos diagramas de sequ√™ncia para especificar quando a mensagem deve ser enviada e para determinar a condi√ß√£o para envio de m√∫ltiplos mar- cadores. Uma linha tracejada de retorno mostra um retorno da mensagem e √© opcional, a menos que carregue um significado especial. A exclus√£o do objeto √© mostrada com um X grande. A Figura 10.9 explica parte da nota√ß√£o usada nos diagramas de sequ√™ncia.

- G. Diagramas de colabora√ß√£o. Os diagramas de colabora√ß√£o representam intera√ß√µes entre objetos como uma s√©rie de mensagens em sequ√™ncia. Neles, a √™nfase √© na organiza√ß√£o estrutural dos objetos que enviam e  recebem mensagens, ao passo que nos diagramas de sequ√™ncia a √™nfase √© na ordena√ß√£o das mensagens com  o  tempo.  Os  diagramas  de  colabora√ß√£o  mostram objetos como √≠cones e numeram as mensagens; as mensagens numeradas representam uma ordena√ß√£o.  O layout espacial dos diagramas de colabora√ß√£o permite liga√ß√µes entre objetos que mostram seus relacionamentos estruturais. O uso de diagramas de colabora√ß√£o e sequ√™ncia para representar intera√ß√µes √© uma quest√£o de escolha, visto que eles podem ser utilizados  para  prop√≥sitos  semelhantes.  Daqui  por diante, usaremos apenas diagramas de sequ√™ncia.

H. Diagramas de estados. Os diagramas de estados descrevem como o estado de um objeto muda em resposta a eventos externos.

Para descrever o comportamento de um objeto, √© comum, na maioria das t√©cnicas orientadas a objeto, desenhar um diagrama de estados para mostrar todos os estados poss√≠veis em que um objeto pode entrar em seu tempo de vida. Os diagramas de estados em UML s√£o baseados nos de David Harel. 8  Eles mostram uma m√°quina de estado que consiste em estados, transi√ß√µes, eventos e a√ß√µes, e s√£o muito √∫teis

Figura 10.9



A nota√ß√£o do diagrama de sequ√™ncia.

8 Ver Harel (1987).

no projeto conceitual da aplica√ß√£o, que atua contra um banco de dados de objetos armazenados.

Os elementos importantes de um diagrama de estados que aparecem na Figura 10.10 s√£o os seguintes:

- ¬Ñ Estados. Mostrados como caixas com cantos arredondados, eles representam situa√ß√µes no tempo de vida de um objeto.
- ¬Ñ Transi√ß√µes. Mostradas como setas s√≥lidas entre os estados, elas representam os caminhos entre diferentes estados de um objeto. Elas s√£o rotuladas  pelo  nome  do  evento  [condi√ß√£o]  / a√ß√£o; o evento dispara a transi√ß√£o e a a√ß√£o resulta dele. A guarda √© uma condi√ß√£o adicional e opcional, que especifica uma condi√ß√£o sob a qual a mudan√ßa de estado pode n√£o ocorrer.
- ¬Ñ Estado inicial. Mostrado por um c√≠rculo s√≥lido com uma seta de sa√≠da para um estado.
- ¬Ñ Estado final. Mostrado com um duplo c√≠rculo recebendo uma seta vinda de um estado.

Diagramas de estados s√£o √∫teis na especifica√ß√£o de  como  a  rea√ß√£o  de  um  objeto  a  uma  mensagem depende de seu estado. Um evento √© algo feito a um objeto,  como  receber  uma  mensagem;  uma a√ß√£o √© algo que um objeto faz, como enviar uma mensagem.

- I.  Diagramas  de  atividades . Os  diagramas  de  atividades apresentam uma vis√£o din√¢mica do sistema, modelando o fluxo de controle de uma atividade para outra. Eles podem ser considerados fluxogramas com estados. Uma atividade √© um estado de fazer algo, que poderia ser um processo do mundo real ou uma opera√ß√£o sobre algum objeto ou classe no banco de dados. Normalmente, os diagramas de atividades s√£o usados para modelar o fluxo de trabalho e as opera√ß√µes de neg√≥cios internas para uma aplica√ß√£o.

Figura 10.10 A nota√ß√£o do diagrama de estado.



## 10.3.4 Um exemplo de modelagem e projeto: banco de dados UNIVERSIDADE

Nesta se√ß√£o, vamos ilustrar rapidamente o uso de alguns dos diagramas UML que j√° apresentamos para projetar um banco de dados simples em um ambiente de universidade. Muitos detalhes s√£o omitidos para economizar espa√ßo. Ilustramos apenas um uso gradativo desses diagramas, que leva a um projeto conceitual e ao projeto de componentes do programa. Conforme indicamos, o SGBD eventual em que esse banco de dados por fim ser√° implementado pode ser relacional, orientado a objeto ou objeto-relacional. Isso n√£o mudar√° a an√°lise e modelagem gradual da aplica√ß√£o usando os diagramas UML.

Imagine um cen√°rio com alunos se matriculando em disciplinas que s√£o oferecidas por professores. O departamento de registro acad√™mico √© encarregado de manter um programa de disciplinas em um cat√°logo. Eles t√™m autoridade para acrescentar e excluir disciplinas, al√©m de realizar mudan√ßas no programa. Tamb√©m definem limites de matr√≠cula nas disciplinas. O departamento financeiro √© encarregado de processar pedidos de aux√≠lio realizados pelos alunos. Suponha que tenhamos de projetar um banco de dados que mant√©m os dados sobre alunos, professores, disciplinas, aux√≠lio financeiro, e assim por diante. Tamb√©m queremos projetar algumas das aplica√ß√µes que nos permitem realizar  matr√≠cula  na  disciplina,  processamento  de  pedido de aux√≠lio financeiro e manuten√ß√£o do cat√°logo de disciplinas da universidade pelo departamento de registro  acad√™mico.  Os  requisitos  anteriores  podem ser representados por uma s√©rie de diagramas UML.

Conforme  mencionamos  anteriormente,  um  dos primeiros passos envolvidos no projeto de um banco de dados √© levantar requisitos do cliente utilizando diagramas de caso de uso . Suponha que um dos requisitos no banco de dados UNIVERSIDADE seja  permitir que os professores incluam notas para as disciplinas que est√£o lecionando e que os alunos possam se matricular nelas e solicitar aux√≠lio financeiro. O diagrama de caso de uso correspondente a esses casos de uso pode ser desenhado como mostra a Figura 10.8.

Outro elemento √∫til ao projetar um sistema √© representar graficamente alguns dos estados em que o sistema pode estar, para visualizar os diversos estados do sistema no decorrer de uma aplica√ß√£o. Por exemplo, em nosso banco de dados UNIVERSIDADE , os diversos estados pelos quais o sistema passa quando o registro para uma disciplina com 50 vagas √© aberto podem ser representados pelo diagrama de estados da Figura 10.11. Este mostra os estados de uma disciplina enquanto a matr√≠cula est√° em andamento.   O

Figura 10.11



Um exemplo de diagrama de estados para o banco de dados UNIVERSIDADE.

primeiro estado define a quantidade de alunos matriculados como zero. Durante o estado de matr√≠cula, a  transi√ß√£o Matricular  aluno continua  enquanto  a contagem dos alunos matriculados for menor que 50. Quando a contagem atingir 50, o estado para fechar a  se√ß√£o  √©  iniciado.  Em  um  sistema  real,  estados  e/ ou transi√ß√µes adicionais poderiam ser acrescentados para permitir que um aluno deixe uma turma e quaisquer outras a√ß√µes necess√°rias.

Em  seguida,  podemos  projetar  um  diagrama de sequ√™ncia para visualizar a execu√ß√£o dos casos de uso. Para o banco de dados da universidade, o dia- grama de sequ√™ncia corresponde ao caso de uso: aluno solicita  matr√≠cula  e  seleciona  uma  disciplina espec√≠fica para se matricular √© mostrado na Figura 10.12. O cat√°logo √© pesquisado inicialmente para obter a lista de disciplinas. Depois, quando o aluno seleciona uma disciplina para se matricular, os pr√©-requisitos e a capacidade da disciplina s√£o verificados, e esta √© ent√£o acrescentada aos hor√°rios do aluno se os pr√©-requisitos forem atendidos e houver vaga.

Esses diagramas UML n√£o s√£o a especifica√ß√£o completa do banco de dados UNIVERSIDADE .  Ha-



## Figura 10.12

Um diagrama de sequ√™ncia para o banco de dados UNIVERSIDADE.

ver√° outros casos de uso para as diversas aplica√ß√µes dos  atores,  incluindo  registro,  aluno,  professor,  e assim  por  diante.  Uma  metodologia  completa  de como chegar aos diagramas de classes para os diversos  diagramas  que  ilustramos  nesta  se√ß√£o  est√° fora de nosso escopo. As metodologias de projeto continuam sendo uma quest√£o de bom senso e prefer√™ncia pessoal. Por√©m, o projetista deve garantir que o diagrama de classes considerar√° todas as especifica√ß√µes que foram dadas na forma dos diagramas de casos de uso, estados e sequ√™ncia. A Figura 10.13 mostra um diagrama de classes poss√≠vel para essa aplica√ß√£o, com os relacionamentos estruturais e as opera√ß√µes dentro das classes. Essas classes precisar√£o  ser  implementadas  para  que  se  desenvolva o  banco  de  dados UNIVERSIDADE e,  junto  com  as opera√ß√µes, elas implementar√£o a aplica√ß√£o completa de hor√°rio/matr√≠cula/aux√≠lio. Somente alguns dos atributos e m√©todos (opera√ß√µes) s√£o mostrados na Figura  10.13.  √â  prov√°vel  que  esses  diagramas  de classes sejam modificados √† medida que mais deta- lhes sejam especificados e mais fun√ß√µes evoluam na aplica√ß√£o UNIVERSIDADE .

## 10.4 Rational Rose: uma ferramenta de projeto baseada em UML

## 10.4.1 Rational Rose para projeto de banco de dados

Rational Rose √© uma das ferramentas de modelagem usadas na ind√∫stria para desenvolver sistemas de informa√ß√£o. Ela foi adquirida pela IBM em 2003. Conforme indicamos nas duas primeiras se√ß√µes deste cap√≠tulo, um banco de dados √© um componente central da maioria dos sistemas de informa√ß√£o. O Rational Rose oferece a especifica√ß√£o inicial em UML que eventualmente  leva  ao  desenvolvimento  do  banco de dados. Muitas extens√µes foram feitas nas vers√µes mais recentes do Rose para modelagem de dados, e



O projeto do banco de dados UNIVERSIDADE como um diagrama de classes.

agora ele oferece suporte para modelagem e projeto conceitual, l√≥gico e f√≠sico do banco de dados.

## 10.4.2 Rational Rose Data Modeler

Rational Rose Data Modeler √© uma ferramenta de modelagem visual para projetar bancos de dados. Por ser baseado na UML, oferece uma ferramenta e linguagem comuns para unir a lacuna entre projetistas de banco de dados e desenvolvedores de aplica√ß√£o. Isso permite que projetistas de banco de dados, desenvolvedores  e  analistas  trabalhem  juntos,  capturem  e  compartilhem  requisitos  de  neg√≥cios,  e  os acompanhem enquanto mudam no decorrer do processo. Al√©m disso, ao permitir que os projetistas modelem e projetem todas as especifica√ß√µes na mesma plataforma, usando a mesma nota√ß√£o, ele melhora o processo de projeto e reduz o risco de erros.

As  capacidades  do  processo  de  modelagem  no Rational Rose permitem a modelagem do comportamento de aplica√ß√µes de banco de dados, como vimos no pequeno exemplo anterior, na forma de casos de uso  (Figura  10.8),  diagramas  de  sequ√™ncia  (Figura 10.12) e diagramas de estados (Figura 10.11). Existe um mecanismo adicional dos diagramas de colabora√ß√£o,  para  mostrar  as  intera√ß√µes  entre  objetos, e diagramas de atividades, para modelar o fluxo de controle, que n√£o mostramos em nosso exemplo. O objetivo final √© gerar a especifica√ß√£o do banco de dados e o c√≥digo da aplica√ß√£o ao m√°ximo poss√≠vel. O Rose Data Modeler tamb√©m pode capturar triggers, stored  procedures  (procedimentos  armazenados)  e outros  conceitos  de  modelagem  explicitamente  no diagrama, em vez de represent√°-los com valores marcados ocultos, nos bastidores (ver Cap√≠tulo 26, que discute  bancos  de  dados  ativos  e  triggers).  O  Rose Data Modeler tamb√©m oferece a capacidade de realizar engenharia  direta de  um  banco  de  dados,  em rela√ß√£o √† altera√ß√£o constante dos requisitos, e engenharia reversa , passando de um banco de dados implementado, j√° existente, para seu projeto conceitual.

## 10.4.3 Modelagem de dados usando o Rational Rose Data Modeler

Existem muitas ferramentas e op√ß√µes dispon√≠veis no Rose Data Modeler para modelagem de dados.

Engenharia  reversa. A  engenharia  reversa  de  um banco de dados permite que o usu√°rio crie um modelo de dados conceitual baseado em um esquema de dados existente, especificado em um arquivo DDL. Podemos usar o assistente de engenharia reversa no

Rational  Rose  Data  Modeler  para  essa  finalidade. Tal assistente basicamente l√™ o esquema no banco de dados ou arquivo DDL e o recria como um modelo de dados. Enquanto isso √© feito, ele tamb√©m inclui o nome de todas as entidades identificadoras citadas.

Engenharia direta e gera√ß√£o de DDL. Tamb√©m podemos criar um modelo de dados diretamente, a partir do zero, no Rose. Ap√≥s criar o modelo de dados, 9 tamb√©m podemos us√°-lo para gerar a DDL para um SGBD espec√≠fico. Existe um assistente de engenharia direta  no  Rose  Data  Modeler  que  l√™  o  esquema  no modelo de dados ou l√™ tanto o esquema no modelo de dados como os locais de armazenamento (tablespaces) no modelo de armazenamento de dados, gerando o c√≥digo DDL apropriado em um arquivo DDL. O assistente tamb√©m oferece a op√ß√£o de gerar um banco de dados ao executar o arquivo DDL gerado.

Projeto conceitual  em  nota√ß√£o  UML. O  Rational Rose permite a modelagem do banco de dados usando  a  nota√ß√£o  UML.  Diagramas  ER  em  geral  s√£o usados no projeto conceitual de bancos de dados e pode facilmente ser embutido utilizando a nota√ß√£o UML como diagramas de classes no Rational Rose. Por exemplo, o esquema ER de nosso banco de dados EMPRESA do  Cap√≠tulo  7  pode  ser  redesenhado  no Rose usando a nota√ß√£o UML, como mostra a Figura 10.14. A especifica√ß√£o textual na Figura 10.14 pode ser convertida para a representa√ß√£o gr√°fica mostrada na Figura 10.15, com a op√ß√£o do diagrama de modelo de dados no Rose.

A Figura 10.15 √© semelhante √† Figura 7.16, com a exce√ß√£o de estar usando a nota√ß√£o fornecida pelo Rational Rose. Logo, pode ser considerada um diagrama ER usando a nota√ß√£o UML, com a inclus√£o de  m√©todos  e  outros  detalhes. Relacionamentos  de identifica√ß√£o especificam que um objeto em uma classe  filha  ( DEPENDENTE na  Figura  10.15)  n√£o  pode existir sem um objeto pai correspondente na classe pai  ( FUNCIONARIO na  Figura  10.15),  enquanto relacionamentos  sem  identifica√ß√£o especificam  uma associa√ß√£o regular (relacionamento) entre duas classes independentes. √â poss√≠vel atualizar os esquemas diretamente  em  sua  forma  textual  ou  gr√°fica.  Por exemplo, se o relacionamento entre FUNCIONARIO e PROJETO , chamado TRABALHA\_EM , fosse exclu√≠do, o Rose automaticamente atualizaria ou excluiria todas as chaves estrangeiras nas tabelas relevantes.

Uma diferen√ßa importante entre a Figura 10.15 e nossa nota√ß√£o ER anterior, mostrada nos cap√≠tulos 7 e 8, √© que os atributos de chave estrangeira realmen-

9 O termo modelo de dados utilizado pelo Rational Rose Data Modeler corresponde a nossa no√ß√£o de um modelo de aplica√ß√£o ou esquema conceitual.

Figura 10.14 Uma defini√ß√£o do diagrama de modelo de dados l√≥gico em Rational Rose.



te  aparecem  nos  diagramas  de  classes  em  Rational Rose. Isso √© comum em diversas nota√ß√µes diagram√°ticas, para tornar o projeto conceitual mais pr√≥ximo da forma como ele √© realizado na implementa√ß√£o do modelo relacional. Nos cap√≠tulos 7 e 8, os diagramas ER e EER conceituais e os diagramas de classes UML n√£o inclu√≠ram os atributos de chave estrangeira, que foram acrescentamos ao esquema relacional durante o processo de mapeamento (ver Cap√≠tulo 9).

forem feitas mudan√ßas em qualquer modelo durante o processo de desenvolvimento. A Figura 10.16 mostra a tabela Funcionario depois de sua convers√£o para uma classe em um modelo de objeto. As diversas abas na janela podem ent√£o ser usadas para inserir/exibir diferentes tipos de informa√ß√£o. Elas incluem opera√ß√µes, atributos e relacionamentos para essa classe.

Convertendo o modelo de dados l√≥gico para o modelo de objeto, e vice-versa. O Rational Rose Data Modeler  tamb√©m  oferece  a  op√ß√£o  de  converter  um projeto l√≥gico de banco de dados (esquema relacional) para um projeto do modelo de objeto (esquema de objeto), e vice-versa. Por exemplo, o modelo l√≥gico de dados mostrado na Figura 10.14 pode ser convertido para um modelo de objeto. Esse tipo de mapeamento permite  um  conhecimento  profundo  dos  relacionamentos entre o modelo conceitual e o modelo de implementa√ß√£o, e ajuda a mant√™-los atualizados quando

Sincronismo entre o projeto conceitual e o banco de dados real. O  Rose Data Modeler permite que o modelo de dados e a implementa√ß√£o do banco de dados se mantenham sincronizados. Ele permite visualizar tanto o modelo de dados quanto o banco de dados e, depois, com base nas diferen√ßas, oferece a op√ß√£o de atualizar o modelo ou alterar o banco de dados.

Suporte de dom√≠nio extensivo. O Rose Data Modeler permite que os projetistas de banco de dados criem um conjunto-padr√£o de tipos de dados definidos pelo usu√°rio (estes s√£o semelhantes aos dom√≠nios

Figura 10.15



Um diagrama gr√°fico do modelo de dados em Rational Rose para o banco de dados EMPRESA.

em SQL; ver Cap√≠tulo 4) e os atribuem a qualquer coluna  no  modelo  de  dados.  As  propriedades  do dom√≠nio  s√£o  ent√£o  propagadas  e  recebem  colunas. Esses  dom√≠nios  podem  ent√£o  ser  mantidos  por  um grupo de padr√µes e implantados a todos os modeladores quando come√ßam a criar modelos usando o framework do Rational Rose.

dados. H√° tamb√©m a op√ß√£o de usar o Rational Rose Web Publisher para permitir que os modelos e os metadados debaixo desses modelos estejam dispon√≠veis a qualquer um na equipe.

## Comunica√ß√£o f√°cil entre as equipes de projeto .

Conforme dissemos, o uso de uma ferramenta comum permite  a  f√°cil  comunica√ß√£o  entre  as  equipes.  No Rose Data Modeler, um desenvolvedor de aplica√ß√£o pode acessar tanto o objeto quanto os modelos de dados e ver como eles s√£o relacionados, para ent√£o poder tomar decis√µes melhores e mais inteligentes a respeito de como montar os m√©todos de acesso aos

O que mostramos aqui √© uma descri√ß√£o parcial das capacidades da ferramenta Rational Rose relacionadas √†s fases de projeto conceitual e l√≥gico da Figura  10.1.  A  faixa  completa  de  diagramas  UML que descrevemos na Se√ß√£o 10.3 pode ser desenvolvida  e  mantida  no  Rose.  Para  obter  mais  detalhes, o leitor deve consultar a documenta√ß√£o do produto. A Figura 10.17 oferece outra vers√£o do diagrama de classes na Figura 7.16, desenhada usando o Rational Rose. A Figura 10.17 difere da Figura 10.15 porque os  atributos  de  chave  estrangeira  n√£o  aparecem  de

Figura 10.16



A classe OM\_EMPLOYEE correspondente √† tabela Funcionario da Figura 10.14.

maneira expl√≠cita. Logo, a Figura 10.17 est√° utilizando as nota√ß√µes apresentadas nos cap√≠tulos 7 e 8. O Rational Rose permite o uso de qualquer uma dessas op√ß√µes, dependendo da prefer√™ncia dos projetistas.

## 10.5 erramentas de projeto F automatizado de banco de dados

A atividade de projeto de banco de dados predominantemente se espalha pela Fase 2 (projeto conceitual), Fase 4 (mapeamento do modelo de dados, ou projeto l√≥gico) e Fase 5 (projeto f√≠sico do banco de dados) no processo que discutimos na Se√ß√£o 10.2. A discuss√£o da Fase 5 fica para o Cap√≠tulo 20, depois que apresentarmos as t√©cnicas de armazenamento e indexa√ß√£o, e a otimiza√ß√£o de consulta. Discutimos as fases 2 e 4 em detalhes com o uso da nota√ß√£o UML na Se√ß√£o 10.3, e indicamos os recursos da ferramenta Rational Rose, que oferece suporte para essas fases, na Se√ß√£o 10.4. Como dissemos, o Rational Rose √© mais do que apenas uma ferramenta de projeto de banco de dados. √â uma ferramenta de desenvolvimento de software e realiza modelagem de banco de dados e projeto de esquema na forma de diagramas de classes como parte de sua metodologia de desenvolvimento de aplica√ß√£o orientada a objeto. Nesta se√ß√£o, vamos resumir os recursos e defici√™ncias do conjunto de ferramentas comerciais que  focalizam  a  automa√ß√£o  do  processo  de  projeto conceitual, l√≥gico e f√≠sico dos bancos de dados.

Figura 10.17



O diagrama de classes do banco de dados EMPRESA (Figura 7.16) desenhado no Rational Rose.

Quando  a  tecnologia  de  banco  de  dados  foi introduzida, a maior parte do projeto de banco de dados  era  executada  manualmente  por  projetistas especializados, que usavam sua experi√™ncia e conhecimento no processo. Por√©m, pelo menos dois fatores indicaram que alguma forma de automa√ß√£o teria de ser utilizada, se poss√≠vel:

- 1. √Ä  medida  que  uma  aplica√ß√£o  envolve  mais e  mais  complexidade  de  dados  em  mat√©ria de relacionamentos e restri√ß√µes, o n√∫mero de op√ß√µes  ou  projetos  diferentes  para  modelar a  mesma  informa√ß√£o  continua  aumentando rapidamente. Torna-se dif√≠cil lidar com essa complexidade e as consequentes alternativas de projeto de maneira manual.
- 2. O grande tamanho de alguns bancos de dados depara com centenas de tipos de entidades e de relacionamentos, tornando a tarefa de gerenciar esses projetos manualmente quase imposs√≠vel. A metainforma√ß√£o relacionada ao processo de projeto, que descrevemos na Se√ß√£o  10.2,  produz  outro  banco  de  dados, que  deve  ser  criado,  mantido  e  consultado como um banco de dados por si s√≥.

Esses fatores deram origem a muitas ferramentas que apareceram sob a categoria geral de ferramenta de engenharia de software auxiliada por computador ( CASE -Computer-Aided  Software  Engineering ) para o projeto de banco de dados. O Rational Rose √©  um bom exemplo de ferramenta CASE moderna. Normalmente, essas ferramentas consistem em uma combina√ß√£o das seguintes facilidades:

- veis  para  modifica√ß√£o,  bem  como  para  gera√ß√£o  de  relat√≥rios,  listagens  de  refer√™ncia cruzada e outros usos.
- 2. Mapeamento  do  modelo. Este  implementa algoritmos de mapeamento semelhantes aos que apresentamos nas se√ß√µes 9.1 e 9.2. O mapeamento √© espec√≠fico do sistema - a maioria  das  ferramentas  gera  esquemas  em  SQL DDL para Oracle, DB2, Informix, Sybase e outros SGBDRs. Essa parte da ferramenta √© mais receptiva √† automa√ß√£o. Se for preciso, o projetista pode editar ainda mais os arquivos DDL produzidos.
- 3. Normaliza√ß√£o  do  projeto. Esta  utiliza  um conjunto de depend√™ncias funcionais que s√£o fornecidas no projeto conceitual ou ap√≥s os esquemas  relacionais  serem  produzidos  durante o projeto l√≥gico. Depois, os algoritmos de  decomposi√ß√£o  de  projeto  (ver  Cap√≠tulo 16) s√£o aplicados para decompor as rela√ß√µes existentes  em  rela√ß√µes  com  forma  normal mais  alta.  Geralmente,  muitas  dessas  ferramentas n√£o possuem o enfoque de gerar projetos  3NF  ou  BCNF  alternativos  (descritos no Cap√≠tulo 15) e permitir que o projetista selecione entre eles com base em alguns crit√©rios, como o n√∫mero m√≠nimo de rela√ß√µes ou a quantidade m√≠nima de armazenamento.
- 1. Diagrama√ß√£o. Esta permite que o projetista desenhe um diagrama de esquema conceitual em alguma nota√ß√£o espec√≠fica da ferramenta.  A  maioria  das  nota√ß√µes  inclui  tipos  de entidade (classes) e tipos de relacionamento (associa√ß√µes) que s√£o mostrados como caixas separadas ou simplesmente como linhas direcionadas ou n√£o, restri√ß√µes de cardinalidade,  mostradas  ao  longo  das  linhas  ou em rela√ß√£o aos diferentes tipos de pontas de seta, ou restri√ß√µes min/max, atributos, chaves, e assim por diante. 10 Algumas ferramentas  exigem  hierarquias  de  heran√ßa  e  usam nota√ß√£o adicional para mostrar a natureza parcialversus -total  e  disjuntaversus -sobreposta  da  especializa√ß√£o/generaliza√ß√£o.  Os diagramas  s√£o  armazenados  internamente como projetos  conceituais  e  est√£o  dispon√≠-

A maioria das ferramentas incorpora alguma forma de projeto f√≠sico, incluindo as escolhas de √≠ndices. H√° uma faixa inteira de ferramentas separadas para monitoramento e medi√ß√£o do desempenho. O problema de ajustar um projeto ou a implementa√ß√£o do banco de dados ainda √© tratado principalmente como uma atividade de tomada de decis√£o humana. Al√©m das fases do projeto descritas neste cap√≠tulo, uma √°rea em que mal existe algum suporte de ferramenta comercial √© a integra√ß√£o de vis√£o (ver Se√ß√£o 10.2.2).

N√£o vamos analisar aqui as ferramentas de projeto  de  banco  de  dados,  mas  apenas  mencionar  as caracter√≠sticas  que  uma  boa  ferramenta  de  projeto deve possuir:

- 1. Uma  interface  f√°cil  de  usar. Isso  √©  essencial, porque permite que os projetistas focalizem a tarefa em m√£os, e n√£o o conhecimento da ferramenta. Interfaces gr√°ficas e do tipo apontar-e-clicar costumam ser usadas. Algumas ferramentas,  como  a  de  projeto  SECSI,  utilizam entrada em linguagem natural. Diferentes interfaces podem ser ajustadas para projetistas iniciantes ou especialistas.

10 Mostramos as nota√ß√µes ER, EER e diagramas de classes UML nos cap√≠tulos 7 e 8. Veja, no Ap√™ndice A, uma ideia dos diferentes tipos de nota√ß√µes diagram√°ticas utilizadas.

- 2. Componentes anal√≠ticos. As ferramentas devem oferecer componentes anal√≠ticos para tarefas que s√£o dif√≠ceis de realizar manualmente, como a avalia√ß√£o das alternativas de projeto f√≠sicas ou a detec√ß√£o das restri√ß√µes de conflito entre as vis√µes. Essa √°rea √© fraca na maioria das ferramentas atuais.
- 3. Componentes  heur√≠sticos. Os  aspectos  do projeto  que  n√£o  podem  ser  quantificados com precis√£o podem ser automatizados pela entrada  de  regras  heur√≠sticas  na  ferramenta para avaliar projeto alternativo.
- 4. An√°lises  de  trade-off. Uma ferramenta deve apresentar ao projetista uma an√°lise comparativa  adequada  sempre  que  apresentar  v√°rias alternativas para escolha. O ideal √© que as  ferramentas  incorporem  uma  an√°lise  de uma mudan√ßa de projeto em n√≠vel conceitual, at√© o projeto f√≠sico. Devido √†s muitas alternativas poss√≠veis para o projeto f√≠sico em determinado sistema, tal an√°lise de trade-off √© dif√≠cil de ser executada, e a maioria das ferramentas atuais a evita.
- 5. Exibi√ß√£o  dos  resultados  do  projeto. Os  resultados do projeto, como os esquemas, com frequ√™ncia s√£o exibidos de forma diagram√°tica. Diagramas esteticamente atraentes e bem dispostos n√£o s√£o f√°ceis de gerar de maneira autom√°tica. Layouts de projeto em m√∫ltiplas p√°ginas, que sejam f√°ceis de ler, s√£o outro desafio. Outros tipos  de  resultados  de  projeto  podem ser  mostrados  como  tabelas,  listas  ou  relat√≥rios, os quais devem ser f√°ceis de interpretar.
- 6. Verifica√ß√£o do projeto. Esse √© um recurso altamente  desej√°vel.  Sua  finalidade  √©  verificar se  o  projeto  resultante  satisfaz  os  requisitos iniciais. A menos que os requisitos sejam capturados e representados internamente de alguma forma que possa ser analisada, n√£o √© poss√≠vel tentar fazer a verifica√ß√£o.

Atualmente,  h√°  cada  vez  mais  consci√™ncia  do valor das ferramentas de projeto, e elas est√£o se tornando essenciais para lidar com grandes problemas de projeto de banco de dados. H√° tamb√©m uma consci√™ncia  crescente  de  que  o  projeto  do  esquema  e  o projeto da aplica√ß√£o devem seguir lado a lado, e a tend√™ncia  atual  entre  as  ferramentas  CASE  √©  focalizar  as  duas  √°reas.  A  popularidade de ferramentas como o Rational Rose deve-se ao fato de que resolve os dois bra√ßos do processo de projeto mostrados na  Figura  10.1  simultaneamente,  aproximando  o projeto do banco de dados e o projeto da aplica√ß√£o como uma atividade unificada. Ap√≥s a aquisi√ß√£o da Rational pela IBM em 2003, o pacote de ferramentas

Rational tem sido melhorado com ferramentas XDE ( eXtended Development Environment , ou ambiente de  desenvolvimento  estendido).  Alguns  vendedores como Platinum (CA) oferecem uma ferramenta para modelagem de dados e projeto de esquema (ERwin) e outra para modelagem de processo e projeto funcional (BPwin). Outras ferramentas (por exemplo, SECSI) utilizam tecnologia de sistema especialista para orientar o processo de projeto, incluindo a habilidade de projeto na forma de regras. A tecnologia de sistema especialista tamb√©m √© √∫til na fase de levantamento e an√°lise de requisitos, que normalmente √© um processo trabalhoso e frustrante. A tend√™ncia √© usar reposit√≥rios de metadados e ferramentas de projeto para obter projetos melhores para bancos de dados complexos. Sem a pretens√£o de ser completa, a Tabela 10.1 lista algumas ferramentas populares de projeto de banco de dados e modelagem de aplica√ß√£o. As empresas da tabela s√£o listadas na ordem alfab√©tica.

## Resumo

Come√ßamos este cap√≠tulo discutindo o papel dos sistemas  de  informa√ß√£o  nas  organiza√ß√µes.  Os  sistemas  de banco de dados s√£o considerados uma parte dos sistemas de informa√ß√£o nas aplica√ß√µes de grande escala. Discutimos como os bancos de dados se encaixam em um sistema de informa√ß√£o para o gerenciamento de recursos de informa√ß√£o em uma organiza√ß√£o e o ciclo de vida pelo qual passam. Depois, discutimos as seis fases do processo de projeto. As tr√™s fases normalmente inclu√≠das como parte do projeto de banco de dados s√£o o projeto conceitual, o projeto l√≥gico (mapeamento do modelo de dados) e o projeto f√≠sico. Tamb√©m discutimos a fase inicial do levantamento e an√°lise de requisitos, que costuma ser considerada uma fase de pr√©-projeto . Al√©m disso, em algum ponto durante o projeto, um pacote de SGBD espec√≠fico precisa ser escolhido. Discutimos alguns dos crit√©rios organizacionais que entram em cena na sele√ß√£o de um SGBD. √Ä medida que s√£o detectados problemas de desempenho, e quando novas aplica√ß√µes s√£o acrescentadas, os projetos precisam ser modificados. A import√¢ncia de projetar o esquema e as  aplica√ß√µes  (ou  transa√ß√µes)  foi  destacada.  Discutimos diferentes t√©cnicas para o projeto do esquema conceitual e a diferen√ßa entre o projeto de esquema centralizado e a t√©cnica de integra√ß√£o de vis√£o.

Introduzimos os diagramas UML como um aux√≠lio para a especifica√ß√£o de modelos e projetos de banco de dados. Apresentamos todos os tipos de diagramas estruturais e comportamentais e depois descrevemos os detalhes de nota√ß√£o sobre os seguintes tipos de diagramas: casos de uso, sequ√™ncia e estados. (Os diagramas de classes j√° haviam sido discutidos nas se√ß√µes 7.8 e 8.6, respectivamente.)  Mostramos  como  alguns  dos  requisitos para o banco de dados UNIVERSIDADE s√£o especificados usando esses diagramas e podem ser utilizados para desenvolver  o  projeto  conceitual  do  banco  de  dados.